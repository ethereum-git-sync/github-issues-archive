{
  "url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
  "repository_url": "https://api.github.com/repos/foundry-rs/foundry",
  "labels_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521/labels{/name}",
  "comments_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521/comments",
  "events_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521/events",
  "html_url": "https://github.com/foundry-rs/foundry/issues/3521",
  "id": 1417094043,
  "node_id": "I_kwDOGBlvNc5UdyOb",
  "number": 3521,
  "title": "feat: deduplicate fuzz inputs",
  "user": {
    "login": "mds1",
    "id": 17163988,
    "node_id": "MDQ6VXNlcjE3MTYzOTg4",
    "avatar_url": "https://avatars.githubusercontent.com/u/17163988?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mds1",
    "html_url": "https://github.com/mds1",
    "followers_url": "https://api.github.com/users/mds1/followers",
    "following_url": "https://api.github.com/users/mds1/following{/other_user}",
    "gists_url": "https://api.github.com/users/mds1/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mds1/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mds1/subscriptions",
    "organizations_url": "https://api.github.com/users/mds1/orgs",
    "repos_url": "https://api.github.com/users/mds1/repos",
    "events_url": "https://api.github.com/users/mds1/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mds1/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3394554570,
      "node_id": "LA_kwDOGBlvNc7KVMrK",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/A-fuzzing",
      "name": "A-fuzzing",
      "color": "FBCA04",
      "default": false,
      "description": "Area: fuzzing"
    },
    {
      "id": 3593644820,
      "node_id": "LA_kwDOGBlvNc7WMqsU",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/T-feature",
      "name": "T-feature",
      "color": "BFD4F2",
      "default": false,
      "description": "Type: feature"
    },
    {
      "id": 3703752787,
      "node_id": "LA_kwDOGBlvNc7cwshT",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/C-forge",
      "name": "C-forge",
      "color": "5319E7",
      "default": false,
      "description": "Command: forge"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "wirew0lf",
    "id": 11537225,
    "node_id": "MDQ6VXNlcjExNTM3MjI1",
    "avatar_url": "https://avatars.githubusercontent.com/u/11537225?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wirew0lf",
    "html_url": "https://github.com/wirew0lf",
    "followers_url": "https://api.github.com/users/wirew0lf/followers",
    "following_url": "https://api.github.com/users/wirew0lf/following{/other_user}",
    "gists_url": "https://api.github.com/users/wirew0lf/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wirew0lf/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wirew0lf/subscriptions",
    "organizations_url": "https://api.github.com/users/wirew0lf/orgs",
    "repos_url": "https://api.github.com/users/wirew0lf/repos",
    "events_url": "https://api.github.com/users/wirew0lf/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wirew0lf/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "wirew0lf",
      "id": 11537225,
      "node_id": "MDQ6VXNlcjExNTM3MjI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11537225?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wirew0lf",
      "html_url": "https://github.com/wirew0lf",
      "followers_url": "https://api.github.com/users/wirew0lf/followers",
      "following_url": "https://api.github.com/users/wirew0lf/following{/other_user}",
      "gists_url": "https://api.github.com/users/wirew0lf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wirew0lf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wirew0lf/subscriptions",
      "organizations_url": "https://api.github.com/users/wirew0lf/orgs",
      "repos_url": "https://api.github.com/users/wirew0lf/repos",
      "events_url": "https://api.github.com/users/wirew0lf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wirew0lf/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2022-10-20T18:45:37Z",
  "updated_at": "2023-05-08T19:21:44Z",
  "closed_at": null,
  "author_association": "COLLABORATOR",
  "active_lock_reason": null,
  "body": "### Component\r\n\r\nForge\r\n\r\n### Describe the feature you would like\r\n\r\nCurrently foundry's fuzz inputs are quite wasteful. Here's a [spreadsheet](https://docs.google.com/spreadsheets/d/17p_8fyyK8fT_UuAU78RRV16N_JrTxfmt-HCEKXivk9E/edit#gid=0) with some data from a new project that simply logs the fuzzer generated values, i.e. dict inputs are minimal so this is a worst case scenario. You can see with uints only 29% of values are unique, and 31% of values are the edge biased values. \r\n\r\nGiven that only 29% of values are unique, this means 71k of the 100k runs were wasted execution.\r\n\r\nFor a fuzz test with `n` inputs, we should consider tracking each unique combination of inputs used to avoid re-using the same inputs. A few consideration:\r\n- If we naively re-generate inputs when finding a duplicate, this might not be any better than just increasing the number of runs (performance-wise)\r\n- A more performant approach may be to modify the strategies. I think each input of a fuzz test is generated independently, so we don't know if we have duplicate inputs until all values are chosen. We may be able to modify the strategies such that all required inputs are generated in the same strategy\r\n\r\n### Additional context\r\n\r\n_No response_",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1445529404",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1445529404",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1445529404,
    "node_id": "IC_kwDOGBlvNc5WKQc8",
    "user": {
      "login": "mds1",
      "id": 17163988,
      "node_id": "MDQ6VXNlcjE3MTYzOTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17163988?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mds1",
      "html_url": "https://github.com/mds1",
      "followers_url": "https://api.github.com/users/mds1/followers",
      "following_url": "https://api.github.com/users/mds1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mds1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mds1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mds1/subscriptions",
      "organizations_url": "https://api.github.com/users/mds1/orgs",
      "repos_url": "https://api.github.com/users/mds1/repos",
      "events_url": "https://api.github.com/users/mds1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mds1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-27T01:03:19Z",
    "updated_at": "2023-02-27T01:03:19Z",
    "author_association": "COLLABORATOR",
    "body": "I think the best solution here is to remove the explicit `edge_weight` strategy used to choose edge values, and instead pre-populate the dict with all edge cases values. Specifically the dict would always be populated with:\r\n- 0 +/-3\r\n- +/-3 around every `type(uintN).max` \r\n- +/-3 around every `type(intN).max`\r\n- +/-3 around every `type(intN).min`\r\n\r\n@wirew0lf I think the telegram you mentioned you may open a PR with a fix for this, should I assign to you?",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1445529404/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1448074470",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1448074470",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1448074470,
    "node_id": "IC_kwDOGBlvNc5WT9zm",
    "user": {
      "login": "wirew0lf",
      "id": 11537225,
      "node_id": "MDQ6VXNlcjExNTM3MjI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11537225?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wirew0lf",
      "html_url": "https://github.com/wirew0lf",
      "followers_url": "https://api.github.com/users/wirew0lf/followers",
      "following_url": "https://api.github.com/users/wirew0lf/following{/other_user}",
      "gists_url": "https://api.github.com/users/wirew0lf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wirew0lf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wirew0lf/subscriptions",
      "organizations_url": "https://api.github.com/users/wirew0lf/orgs",
      "repos_url": "https://api.github.com/users/wirew0lf/repos",
      "events_url": "https://api.github.com/users/wirew0lf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wirew0lf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-28T12:09:42Z",
    "updated_at": "2023-02-28T12:09:42Z",
    "author_association": "NONE",
    "body": "> I think the best solution here is to remove the explicit `edge_weight` strategy used to choose edge values, and instead pre-populate the dict with all edge cases values. Specifically the dict would always be populated with:\r\n> \r\n>     * 0 +/-3\r\n> \r\n>     * +/-3 around every `type(uintN).max`\r\n> \r\n>     * +/-3 around every `type(intN).max`\r\n> \r\n>     * +/-3 around every `type(intN).min`\r\n> \r\n> \r\n> @wirew0lf I think the telegram you mentioned you may open a PR with a fix for this, should I assign to you?\r\n\r\nYeah please, assign it to me.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1448074470/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1448263448",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1448263448",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1448263448,
    "node_id": "IC_kwDOGBlvNc5WUr8Y",
    "user": {
      "login": "mds1",
      "id": 17163988,
      "node_id": "MDQ6VXNlcjE3MTYzOTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17163988?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mds1",
      "html_url": "https://github.com/mds1",
      "followers_url": "https://api.github.com/users/mds1/followers",
      "following_url": "https://api.github.com/users/mds1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mds1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mds1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mds1/subscriptions",
      "organizations_url": "https://api.github.com/users/mds1/orgs",
      "repos_url": "https://api.github.com/users/mds1/repos",
      "events_url": "https://api.github.com/users/mds1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mds1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-28T14:20:25Z",
    "updated_at": "2023-02-28T14:20:25Z",
    "author_association": "COLLABORATOR",
    "body": "Done, thank you!",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1448263448/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1518686492",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1518686492",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1518686492,
    "node_id": "IC_kwDOGBlvNc5ahVEc",
    "user": {
      "login": "wirew0lf",
      "id": 11537225,
      "node_id": "MDQ6VXNlcjExNTM3MjI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11537225?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wirew0lf",
      "html_url": "https://github.com/wirew0lf",
      "followers_url": "https://api.github.com/users/wirew0lf/followers",
      "following_url": "https://api.github.com/users/wirew0lf/following{/other_user}",
      "gists_url": "https://api.github.com/users/wirew0lf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wirew0lf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wirew0lf/subscriptions",
      "organizations_url": "https://api.github.com/users/wirew0lf/orgs",
      "repos_url": "https://api.github.com/users/wirew0lf/repos",
      "events_url": "https://api.github.com/users/wirew0lf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wirew0lf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-22T15:29:13Z",
    "updated_at": "2023-04-22T15:29:13Z",
    "author_association": "NONE",
    "body": "Hey, sorry for not taking care of this earlier, I've had a crazy amount of work. I recently started trying to address this, currently I've got the approach @mds1 mentioned by completely removing the edge_weight strategy which now makes it way more random. Now need to take care of pre-populating the dictionary.\r\n\r\nHowever, I've been looking into other alternatives because I don't find this to be the best possible approach for a fuzzer. I know this has been probably already discussed but features such as re-utilizing the corpus of previous runs as echidna or other binary fuzzers like AFL do, would be something that take the fuzzing/invariant testing to the next level.\r\n\r\nHowever, I don't think this would be possible while the values are generated on each run. Wouldn't a better approach be pre-generating a dictionary with as many runs as configured in the foundry.toml and then just use consequent values from the dict on each run?\r\n\r\nThis would also allow to implement some other cool stuff later on, like bounding values or defining value exceptions like with vm.assume without wasting a run of the fuzzer.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1518686492/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1520497033",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1520497033",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1520497033,
    "node_id": "IC_kwDOGBlvNc5aoPGJ",
    "user": {
      "login": "mds1",
      "id": 17163988,
      "node_id": "MDQ6VXNlcjE3MTYzOTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17163988?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mds1",
      "html_url": "https://github.com/mds1",
      "followers_url": "https://api.github.com/users/mds1/followers",
      "following_url": "https://api.github.com/users/mds1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mds1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mds1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mds1/subscriptions",
      "organizations_url": "https://api.github.com/users/mds1/orgs",
      "repos_url": "https://api.github.com/users/mds1/repos",
      "events_url": "https://api.github.com/users/mds1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mds1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-24T16:38:37Z",
    "updated_at": "2023-04-24T16:38:37Z",
    "author_association": "COLLABORATOR",
    "body": "Sorry can you expand on your suggested features? I'm not sure I totally follow. Right now I believe forge collects PUSH bytes and storage values from runs, adds them to the dictionary, and uses them on subsequent runs",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1520497033/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1538047735",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1538047735",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1538047735,
    "node_id": "IC_kwDOGBlvNc5brL73",
    "user": {
      "login": "wirew0lf",
      "id": 11537225,
      "node_id": "MDQ6VXNlcjExNTM3MjI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11537225?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wirew0lf",
      "html_url": "https://github.com/wirew0lf",
      "followers_url": "https://api.github.com/users/wirew0lf/followers",
      "following_url": "https://api.github.com/users/wirew0lf/following{/other_user}",
      "gists_url": "https://api.github.com/users/wirew0lf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wirew0lf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wirew0lf/subscriptions",
      "organizations_url": "https://api.github.com/users/wirew0lf/orgs",
      "repos_url": "https://api.github.com/users/wirew0lf/repos",
      "events_url": "https://api.github.com/users/wirew0lf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wirew0lf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-08T09:24:22Z",
    "updated_at": "2023-05-08T09:24:22Z",
    "author_association": "NONE",
    "body": "> Sorry can you expand on your suggested features? I'm not sure I totally follow. Right now I believe forge collects PUSH bytes and storage values from runs, adds them to the dictionary, and uses them on subsequent runs\r\n\r\nMost traditional binary fuzzers like AFL or even new smart contract fuzzers like echidna use the corpus from previous runs to fuzz, this is different from using push bytes and storage. The corpus is basically a set of interesting inputs used for fuzzing.\r\n\r\nSo for example, the fuzzer randomly generates a value for a call and this value increases coverage, reaching code that was not reached before by any of the other runs, we want to save this input in the corpus, so we can keep re-using this input in future runs, this has been topic of several research specially in the are of binary fuzzing. I'm by no means an expert in this subject matter but I think using completely random values is not the best approach for fuzzing, even if you include the storage and push bytes. In my opinion, saving and re-using the corpus while measuring coverage after each call on the run to look for new corpus would basically take the invariant testing feature to another whole new level.\r\n\r\nThe problem is, right now we generate the values for the fuzzer and invariant testing based on the strategy for the given type, without knowledge of previous runs. This not only leads to the duplicate input issue, which can be easily solved by moving the edge strategy to the dictionary along with the push and storage values. But also prevents us from developing more advanced features like the one I described above.\r\n\r\nSo what I suggest is coming up with a new architecture for the fuzzer that allows us to keep track of previous runs and log coverage of the run. This would allow us to use the corpus from previous runs or even use a value from the same run that we found increases coverage.\r\n\r\n@mds1 let me know what you think about this, if you find it interesting I can open a separate feature request. I can also push the changes to the integer strategy to get rid of the edge_weight issue on the meanwhile.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1538047735/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1538917130",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1538917130",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3521",
    "id": 1538917130,
    "node_id": "IC_kwDOGBlvNc5bugMK",
    "user": {
      "login": "mds1",
      "id": 17163988,
      "node_id": "MDQ6VXNlcjE3MTYzOTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17163988?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mds1",
      "html_url": "https://github.com/mds1",
      "followers_url": "https://api.github.com/users/mds1/followers",
      "following_url": "https://api.github.com/users/mds1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mds1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mds1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mds1/subscriptions",
      "organizations_url": "https://api.github.com/users/mds1/orgs",
      "repos_url": "https://api.github.com/users/mds1/repos",
      "events_url": "https://api.github.com/users/mds1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mds1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-08T19:21:43Z",
    "updated_at": "2023-05-08T19:21:43Z",
    "author_association": "COLLABORATOR",
    "body": "Ah ok, IIUC you are basically describing coverage guided fuzzing. This is useful and something that would be great to have. However:\r\n1. The added logic/computation for each fuzz run means each individual fuzz runs now takes longer, so you may find more bugs per number of fuzz runs with coverage guidance, but that doesn't mean you find more bugs per unit of time. Therefore it's not always obvious whether the tradeoff of coverage guided fuzzing is worth itâ€”sometimes it may be, other times it may not be\r\n2. Coverage currently doesn't work with the optimizer or via-ir because solc's source maps aren't always correct/useful with those build settings. So currently forge can't rely on exclusively using coverage guided fuzzing anyway\r\n\r\nAs a result I think this feature (https://github.com/foundry-rs/foundry/issues/3521#issuecomment-1445529404) is still worth implementing right now, as it will be a lot less work than coverage guided fuzzing, and should still provide a significant benefit. ",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1538917130/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
