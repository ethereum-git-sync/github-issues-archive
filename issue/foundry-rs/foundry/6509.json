{
  "url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509",
  "repository_url": "https://api.github.com/repos/foundry-rs/foundry",
  "labels_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509/labels{/name}",
  "comments_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509/comments",
  "events_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509/events",
  "html_url": "https://github.com/foundry-rs/foundry/issues/6509",
  "id": 2022750066,
  "node_id": "I_kwDOGBlvNc54kLdy",
  "number": 6509,
  "title": "Forge Extensions",
  "user": {
    "login": "brockelmore",
    "id": 31553173,
    "node_id": "MDQ6VXNlcjMxNTUzMTcz",
    "avatar_url": "https://avatars.githubusercontent.com/u/31553173?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brockelmore",
    "html_url": "https://github.com/brockelmore",
    "followers_url": "https://api.github.com/users/brockelmore/followers",
    "following_url": "https://api.github.com/users/brockelmore/following{/other_user}",
    "gists_url": "https://api.github.com/users/brockelmore/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brockelmore/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brockelmore/subscriptions",
    "organizations_url": "https://api.github.com/users/brockelmore/orgs",
    "repos_url": "https://api.github.com/users/brockelmore/repos",
    "events_url": "https://api.github.com/users/brockelmore/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brockelmore/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3593644820,
      "node_id": "LA_kwDOGBlvNc7WMqsU",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/T-feature",
      "name": "T-feature",
      "color": "BFD4F2",
      "default": false,
      "description": "Type: feature"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2023-12-03T22:48:14Z",
  "updated_at": "2023-12-04T16:36:25Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Component\r\n\r\nForge\r\n\r\n### Describe the feature you would like\r\n\r\n## Rational\r\n`vm.ffi` is an unsafe security hole, bad UX, and slow. Differential testing is too slow to be reasonable. Huff compilation is annoying. \r\n## Scope\r\nInitial scope should be EVM specific replacement/alternative to `vm.ffi`. Longer term, once the initial wasm runtime works well in an EVM context, there may be other places that make sense to allow plugins to tap into (compilation, post-test results, etc).\r\n\r\n## Design Choices\r\nThere are two paths this design could take shape (there are more but these are most realistic):\r\n1. WASM based\r\n2. RPC based\r\n\r\nEach have their pros and cons.\r\n\r\nWASM based extensions are the \"easiest\" for plugin/extension developers - they don't have to implement an RPC server. Users can just write a snippet of code in their language of choice and ship it as either a standalone, shareable repo or even ship it inside their foundry-based project. This path likely leads to fragmentation, experimentation, but ultimately more developers making better use of foundry.\r\n\r\nRPC based extensions are more flexible than WASM based extensions because there is no compilation to WASM (neither at the script or interpreter level). There is more overhead on the developers here, to where there is a centralizing and stabilizing force of extensions (think VSCode extensions - most people don't write custom extensions).\r\n\r\n\r\n### WASM path\r\nUse [wasmer](https://github.com/wasmerio/wasmer) wasm runtime at the core. Ship with [pyodide](https://github.com/pyodide/pyodide) by default to allow python to be ran. If we want to support javascript (I am not inclined to include this), we could ship with [javy](https://github.com/bytecodealliance/javy) to compile JS to WASM on the fly and allow javascript to be ran.\r\n\r\nI lean towards only supporting python extensions natively, and all others must be compiled to WASM by the user. I imagine python & rust will be most common languages for extensions to be built in.\r\n\r\n#### WASM EVM interface\r\nTo satisfy the replacement of `vm.ffi` for *most* use cases, I suggest treating each *extensions* similarly to how we treat `vm`, i.e. as a contract. A sketch of the full implementation:\r\n1. In `foundry.toml` have an `extensions` configuration that points to wasm files. i.e. `extensions = [ { name: \"my_extension\", path: \"./my_local_extension.wasm\", abi: \"my_extension_abi.json\"}]`. Extensions must be uniquely named and the path must be provided*(in theory, we could allow for global extensions in `~/.foundry`). The path could potentially be something like `{ style: \"git\", url: \"https://github.com/...\", wasm: \"path/in/repo\"}` in the future, and could be managed by git submodules akin to libraries.\r\n2. when starting a contract runner, we load up the wasm extensions. We introduce a new cheatcode: `getExtension(string memory name) returns (address)`. Extensions are assigned an address by the contract runner, and upon calling `getExtension`, an address is returned allowing the user to interact with the extension via a normal contract call\r\n3. Under the hood when a call is made, add a line similar to [this](https://github.com/foundry-rs/foundry/blob/d4e6b43ea694f31ef2915e75d81c3308479ef8fd/crates/cheatcodes/src/inspector.rs#L667), but check \r\n```rust \r\nif let Some(ext) = self.addr_to_extensions(addr) {\r\n\tself.call_extension(ext, data)\r\n}\r\n```\r\n4. `call_extension` would determine the function in the extension to call and decode the input using the abi provided in the foundry.toml and call the function via the WASM runtime\r\n5. Load the return data back into the EVM as return data\r\n\r\nPython Example:\r\n```python\r\n# my_extension.py\r\ndef addOne(x):\r\n    return x + 1\r\n```\r\n\r\n```toml\r\n# foundry.toml\r\nextensions = [ {\r\n\tname: \"my_extension\",\r\n\tpath: \"./my_extension.py\",\r\n\tabi: \"my_extension_abi.json\"\r\n}]\r\n```\r\n\r\n```solidity\r\n\r\ninterface MyExtension {\r\n\tfunction addOne(uint256 x) external returns (uint256);\r\n}\r\n\r\ncontract T is Test {\r\n\tMyExtension myPyExt = vm.getExtension(\"my_extension\");\r\n\r\n\tfunction testExt() public {\r\n\t\tuint256 ret = myPyExt.addOne(100);\r\n\t\tassertEq(ret, 101);\r\n\t}\r\n}\r\n```\r\n\r\n\r\nEventually, we could expand this and define specific interfaces for non-evm based calls for compilation & post-test extensions (although arguably, an RPC-based system likely makes more sense for this kind of extension).\r\n\r\n### RPC based\r\nTechnically, this is sort of possible today with the introduction of `vm.rpc`, so I wont go into much more detail. You can in theory define a contract like:\r\n```solidity\r\n\r\ncontract Extension is Test {\r\n\tfunction addOne(uint256 x) public returns (uint256) {\r\n\t\tuint currFork = vm.activeFork();\r\n\t\tvm.selectFork(...);\r\n\t\tuint256 ret = abi.decode(vm.rpc(\"addOne\", abi.encode(x)), (uint256));\r\n\t\tvm.selectFork(currFork);\r\n\t\treturn ret;\r\n\t}\r\n}\r\n```\r\n\r\nA real version of this would likely clean up some of this, maybe automatically creating some of this based on an abi in `foundry.toml`.\r\n\r\nRPC based is more interesting for pre and post-compilation, and pre and post-test as those interfaces are much more strictly defined.\r\n\r\nMy personal preference is towards the WASM path, but it is a not insignificant amount of complexity. The RPC version pushes more complexity on to developers and I think will result in much less usage.\r\n\r\n\r\n\r\n### Additional context\r\n\r\nThis is a request for feedback - I don't claim that either of these are the best path but just paths I have considered",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1837627336",
    "html_url": "https://github.com/foundry-rs/foundry/issues/6509#issuecomment-1837627336",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509",
    "id": 1837627336,
    "node_id": "IC_kwDOGBlvNc5th_fI",
    "user": {
      "login": "brockelmore",
      "id": 31553173,
      "node_id": "MDQ6VXNlcjMxNTUzMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/31553173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brockelmore",
      "html_url": "https://github.com/brockelmore",
      "followers_url": "https://api.github.com/users/brockelmore/followers",
      "following_url": "https://api.github.com/users/brockelmore/following{/other_user}",
      "gists_url": "https://api.github.com/users/brockelmore/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brockelmore/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brockelmore/subscriptions",
      "organizations_url": "https://api.github.com/users/brockelmore/orgs",
      "repos_url": "https://api.github.com/users/brockelmore/repos",
      "events_url": "https://api.github.com/users/brockelmore/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brockelmore/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-03T22:53:06Z",
    "updated_at": "2023-12-03T22:53:06Z",
    "author_association": "MEMBER",
    "body": "related: #706 \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1837627336/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1838246152",
    "html_url": "https://github.com/foundry-rs/foundry/issues/6509#issuecomment-1838246152",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509",
    "id": 1838246152,
    "node_id": "IC_kwDOGBlvNc5tkWkI",
    "user": {
      "login": "onbjerg",
      "id": 8862627,
      "node_id": "MDQ6VXNlcjg4NjI2Mjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8862627?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/onbjerg",
      "html_url": "https://github.com/onbjerg",
      "followers_url": "https://api.github.com/users/onbjerg/followers",
      "following_url": "https://api.github.com/users/onbjerg/following{/other_user}",
      "gists_url": "https://api.github.com/users/onbjerg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/onbjerg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/onbjerg/subscriptions",
      "organizations_url": "https://api.github.com/users/onbjerg/orgs",
      "repos_url": "https://api.github.com/users/onbjerg/repos",
      "events_url": "https://api.github.com/users/onbjerg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/onbjerg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-04T10:23:49Z",
    "updated_at": "2023-12-04T10:24:47Z",
    "author_association": "MEMBER",
    "body": "this would impact a lot of forge and would need more consideration. for example, fuzzing could randomly hit an extension address, potentially triggering the extension. there are 2 camps here, one that says we should automatically remove these from the fuzzer, and others who say we should still include them since any address is an attack vector\r\n\r\nnot sure which i buy into more, but something to think about.\r\n\r\ngenerally, it makes sense to have pluggable precompiles as they fill a gap cli plugins couldn't\r\n\r\nin terms of wasm for post-compilation etc etc, i think we're better off having a cargo-like plugin ecosystem for non-evm things (compilers, static analyzers etc) rather than having hooks that call out to wasm",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1838246152/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1839027340",
    "html_url": "https://github.com/foundry-rs/foundry/issues/6509#issuecomment-1839027340",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6509",
    "id": 1839027340,
    "node_id": "IC_kwDOGBlvNc5tnVSM",
    "user": {
      "login": "brockelmore",
      "id": 31553173,
      "node_id": "MDQ6VXNlcjMxNTUzMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/31553173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brockelmore",
      "html_url": "https://github.com/brockelmore",
      "followers_url": "https://api.github.com/users/brockelmore/followers",
      "following_url": "https://api.github.com/users/brockelmore/following{/other_user}",
      "gists_url": "https://api.github.com/users/brockelmore/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brockelmore/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brockelmore/subscriptions",
      "organizations_url": "https://api.github.com/users/brockelmore/orgs",
      "repos_url": "https://api.github.com/users/brockelmore/repos",
      "events_url": "https://api.github.com/users/brockelmore/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brockelmore/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-04T16:36:24Z",
    "updated_at": "2023-12-04T16:36:24Z",
    "author_association": "MEMBER",
    "body": "> this would impact a lot of forge and would need more consideration.\r\n\r\nFully agree - but this has been talked about literally for over a year and no progress has been made! Really this issue is just to get the ball rolling on what it could actually look like and actually begin the conversation around all the edge cases.\r\n\r\nI do think this would be a major upgrade, if only for the differential fuzzing aspect (and have gotten multiple requests for extensions not just for differentials)",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1839027340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
