{
  "url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652",
  "repository_url": "https://api.github.com/repos/foundry-rs/foundry",
  "labels_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652/labels{/name}",
  "comments_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652/comments",
  "events_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652/events",
  "html_url": "https://github.com/foundry-rs/foundry/issues/6652",
  "id": 2053217616,
  "node_id": "I_kwDOGBlvNc56YZ1Q",
  "number": 6652,
  "title": "Cheat codes not available to contracts deployed during invariant testing",
  "user": {
    "login": "webthethird",
    "id": 6509209,
    "node_id": "MDQ6VXNlcjY1MDkyMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6509209?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/webthethird",
    "html_url": "https://github.com/webthethird",
    "followers_url": "https://api.github.com/users/webthethird/followers",
    "following_url": "https://api.github.com/users/webthethird/following{/other_user}",
    "gists_url": "https://api.github.com/users/webthethird/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/webthethird/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/webthethird/subscriptions",
    "organizations_url": "https://api.github.com/users/webthethird/orgs",
    "repos_url": "https://api.github.com/users/webthethird/repos",
    "events_url": "https://api.github.com/users/webthethird/events{/privacy}",
    "received_events_url": "https://api.github.com/users/webthethird/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3334394228,
      "node_id": "MDU6TGFiZWwzMzM0Mzk0MjI4",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/T-bug",
      "name": "T-bug",
      "color": "d73a4a",
      "default": false,
      "description": "Type: bug"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2023-12-22T00:43:27Z",
  "updated_at": "2023-12-22T00:43:27Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "### Component\n\nForge\n\n### Have you ensured that all of these are up to date?\n\n- [X] Foundry\n- [X] Foundryup\n\n### What version of Foundry are you on?\n\nforge 0.2.0 (1978a03 2023-12-21T09:45:30.854629898Z)\n\n### What command(s) is the bug in?\n\nforge test\n\n### Operating System\n\nLinux\n\n### Describe the bug\n\nWhen testing systems which involve multiple deployments of the same contract, it may be desirable to deploy additional copies during the tests. For invariant testing, if a contract is more complex it is often necessary to wrap it in a handler contract. So if we want to deploy another copy of the contract we must also deploy another handler, which may require access to cheat codes such as `deal`.\r\n\r\nHowever, it appears that cheats are not available to contracts deployed after the `setUp` function. Some copies of the handler, those which are deployed during `setUp`, do have cheat code access, but others deployed later from the same code are prevented from behaving the same way. The expected behavior is that my handler contracts behave the same regardless of when they were deployed, unless deployment time has some bearing on the underlying contract's execution.\r\n\r\nThe only way around this issue that I could find was to pre-deploy additional copies of the handler in question in the `setUp` function, despite not needing them until their underlying contracts are deployed. However, doing so muddles up the `setUp` function, adds additional overhead to the process of adding a new deployment and limits the number of deployments I can have to however many I pre-deployed. The helper function I use for targeting a newly deployed handler goes from this:\r\n\r\n```solidity\r\n    function addStakedToken(\r\n        StakedToken newStakedToken\r\n    ) external onlySafetyModuleHandler {\r\n        IERC20 underlying = newStakedToken.getUnderlyingToken();\r\n        StakedTokenHandler newStakedTokenHandler = new StakedTokenHandler(newStakedToken, stakers);\r\n\r\n        // Add staked token and its handler to lists\r\n        stakedTokens.push(newStakedToken);\r\n        stakedTokenHandlers.push(newStakedTokenHandler);\r\n\r\n        // Register new target and exclude base contracts\r\n        targetContract(address(newStakedTokenHandler));\r\n        excludeContract(address(newStakedToken));\r\n        excludeContract(address(underlying));\r\n    }\r\n```\r\nto this:\r\n```solidity\r\n    function addStakedToken(\r\n        StakedToken newStakedToken\r\n    ) external onlySafetyModuleHandler {\r\n        IERC20 underlying = newStakedToken.getUnderlyingToken();\r\n\r\n        // Use pre-deployed StakedTokenHandler\r\n        // since deploying a new one doesn't give it access to cheats\r\n        StakedTokenHandler newStakedTokenHandler;\r\n        // Two StakedTokenHandlers are already deployed in setUp()\r\n        if (numStakedTokenHandlers == 2)\r\n            newStakedTokenHandler = stakedTokenHandler3;\r\n        else if (numStakedTokenHandlers == 3)\r\n            newStakedTokenHandler = stakedTokenHandler4;\r\n        else if (numStakedTokenHandlers == 4)\r\n            newStakedTokenHandler = stakedTokenHandler5;\r\n        else if (numStakedTokenHandlers == 5)\r\n            newStakedTokenHandler = stakedTokenHandler6;\r\n        else if (numStakedTokenHandlers == 6)\r\n            newStakedTokenHandler = stakedTokenHandler7;\r\n        else if (numStakedTokenHandlers == 7)\r\n            newStakedTokenHandler = stakedTokenHandler8;\r\n        else if (numStakedTokenHandlers == 8)\r\n            newStakedTokenHandler = stakedTokenHandler9;\r\n        else\r\n           revert(\"too many staked token handlers\");\r\n        numStakedTokenHandlers++;\r\n        newStakedTokenHandler.setStakedToken(newStakedToken);\r\n\r\n        // Add staked token and its handler to lists\r\n        stakedTokens.push(newStakedToken);\r\n        stakedTokenHandlers.push(newStakedTokenHandler);\r\n\r\n        // Register new target and exclude base contracts\r\n        targetContract(address(newStakedTokenHandler));\r\n        excludeContract(address(newStakedToken));\r\n        excludeContract(address(underlying));\r\n    }\r\n```\r\nFor additional context, here is the output for the failing test, where `0x1aF7f588A501EA2B5bB3feeFA744892aA2CF00e6` is the address of the new handler contract deployed during `SafetyModuleHandler.addStakingToken` on the fourth line from the bottom:\r\n```\r\n[FAIL. Reason: no cheats available for 0x1aF7f588A501EA2B5bB3feeFA744892aA2CF00e6]\r\n\t[Sequence]\r\n\t\tsender=0xaa9ec8bb61FCa06CF98F1462A29D796C232ed90C addr=[test/invariant/handlers/StakedBPTHandler.sol:StakedBPTHandler]0x15cF58144EF33af1e14b5208015d11F9143E27b9 calldata=transfer(uint256,uint256,uint256) args=[74, 122605228535406998642888989747 [1.226e29], 1]\r\n\t\tsender=0x0000000000000000000000000000000000001442 addr=[test/invariant/handlers/StakedBPTHandler.sol:StakedBPTHandler]0x15cF58144EF33af1e14b5208015d11F9143E27b9 calldata=setStakedToken(address) args=[0x000000000000000000000000000000000000429D]\r\n\t\tsender=0x0000000000000000000000000000000000003677 addr=[test/invariant/handlers/StakedBPTHandler.sol:StakedBPTHandler]0x15cF58144EF33af1e14b5208015d11F9143E27b9 calldata=cooldown(uint256) args=[16598 [1.659e4]]\r\n\t\tsender=0x0000000000000000000000000000000000004FD0 addr=[test/invariant/handlers/StakedTokenHandler.sol:StakedTokenHandler]0xD6BbDE9174b1CdAa358d2Cf4D57D1a9F7178FBfF calldata=redeem(uint256,uint256) args=[12944235812609692675684774955741423858894346459344382611099114779489443672409 [1.294e76], 0]\r\n\t\tsender=0x00000000000000000000000000000000000040f3 addr=[test/invariant/handlers/SMRDHandler.sol:SMRDHandler]0x03A6a84cD762D9707A21605b548aaaB891562aAb calldata=claimRewardsFor(uint256) args=[115792089237316195423570985008687907853269984665640564039457584007913129639933 [1.157e77]]\r\n\t\tsender=0x756666696369656E742062616C616e636520666e addr=[test/invariant/handlers/StakedTokenHandler.sol:StakedTokenHandler]0xD6BbDE9174b1CdAa358d2Cf4D57D1a9F7178FBfF calldata=dealUnderlying(uint256,uint256) args=[963, 7907]\r\n\t\tsender=0x00000000000000000000000000000000691c25e9 addr=[test/invariant/handlers/StakedTokenHandler.sol:StakedTokenHandler]0xD6BbDE9174b1CdAa358d2Cf4D57D1a9F7178FBfF calldata=stake(uint256,uint256) args=[2, 2]\r\n\t\tsender=0x0000000000000000000000000000000000000711 addr=[test/invariant/handlers/SMRDHandler.sol:SMRDHandler]0x03A6a84cD762D9707A21605b548aaaB891562aAb calldata=claimRewardsFor(uint256) args=[12822145867761120285609415092628159210061252848434669764027 [1.282e58]]\r\n\t\tsender=0x0000000000000000000000000000000000001442 addr=[test/invariant/handlers/StakedTokenHandler.sol:StakedTokenHandler]0xD6BbDE9174b1CdAa358d2Cf4D57D1a9F7178FBfF calldata=setStakedToken(address) args=[0x0000000000000000000000000000000000000Fcf]\r\n\t\tsender=0x00000000000000000000000000000000000002D2 addr=[test/invariant/handlers/StakedBPTHandler.sol:StakedBPTHandler]0x15cF58144EF33af1e14b5208015d11F9143E27b9 calldata=setStakedToken(address) args=[0xCCbD087951B520255269D83d499b01084b68236C]\r\n\t\tsender=0x00000000000000000000000000000000000015ED addr=[test/invariant/handlers/SMRDHandler.sol:SMRDHandler]0x03A6a84cD762D9707A21605b548aaaB891562aAb calldata=registerPositions(uint256) args=[23746 [2.374e4]]\r\n\t\tsender=0x00000000000000000000000000000000000077C6 addr=[test/invariant/handlers/SafetyModuleHandler.sol:SafetyModuleHandler]0xA4AD4f68d0b91CFD19687c881e50f3A00242828c calldata=addStakingToken(string,string,uint256,uint256,uint256) args=[\"ê§ôü™ø)\\u{11d31}/·ãï¬•‹ùQ%uñºö*eÔøΩ‡≠á`.\", \"FGg!\\u{1cf1b}`'\", 856770223169212166644023694771404365082446174 [8.567e44], 115792089237316195423570985008687907853269984665640564039457584007913129639933 [1.157e77], 4074004294613378912123582946270 [4.074e30]]\r\n\t\tsender=0xcd7Afc7dd5E122764Df67800943Ff2Cd44B7e8B7 addr=[test/invariant/handlers/SMRDHandler.sol:SMRDHandler]0x03A6a84cD762D9707A21605b548aaaB891562aAb calldata=registerPositions(uint256) args=[963292291715611957590915446518321895136973753255582368229899179331943 [9.632e68]]\r\n\t\tsender=0x0000000000000000000000000000000000000a16 addr=[test/invariant/handlers/StakedTokenHandler.sol:StakedTokenHandler]0x1aF7f588A501EA2B5bB3feeFA744892aA2CF00e6 calldata=transfer(uint256,uint256,uint256) args=[20697 [2.069e4], 1000000 [1e6], 2034]\r\n invariantExchangeRates() (runs: 1, calls: 14, reverts: 1)\r\n\r\n```\r\nNote: looking at the traces from the failed test, I can't tell whether calls to `vm.<cheatcode>` work correctly, such as `vm.startPrank`. In the following trace snippet, which is the last call in the traces and the first call to the newly deployed handler, it appears that `vm.startPrank`, `vm.stopPrank`, `vm.expectRevert` and `vm.assume` executed as usual:\r\n```\r\n  [56150] StakedTokenHandler::transfer(20697 [2.069e4], 1000000 [1e6], 2034)\r\n    ‚îú‚îÄ [0] console::log(\"Bound Result\", 1) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [0] VM::startPrank(0x00000000000000000000000000000000000001c8)\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [0] console::log(\"Bound Result\", 0) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [0] VM::assume(true) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [9847] StakedToken::paused() [staticcall]\r\n    ‚îÇ   ‚îú‚îÄ [2382] SafetyModule::paused() [staticcall]\r\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ ‚Üê false\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê false\r\n    ‚îú‚îÄ [2428] StakedToken::maxStakeAmount() [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 844613378912123578831115 [8.446e23]\r\n    ‚îú‚îÄ [2607] StakedToken::balanceOf(0x000000000000000000000000000000000000007B) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0\r\n    ‚îú‚îÄ [2607] StakedToken::balanceOf(0x00000000000000000000000000000000000001c8) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0\r\n    ‚îú‚îÄ [0] VM::expectRevert(ERC20: transfer amount exceeds balance)\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [6975] StakedToken::transfer(0x000000000000000000000000000000000000007B, 20697 [2.069e4])\r\n    ‚îÇ   ‚îú‚îÄ [382] SafetyModule::paused() [staticcall]\r\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ ‚Üê false\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê revert: ERC20: transfer amount exceeds balance\r\n    ‚îú‚îÄ [0] VM::stopPrank()\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îî‚îÄ ‚Üê ()\r\n```\r\nThe only cheat code used in the handler contract which is not a call to `vm` is `deal(address token, address to, uint256 give)`, which is only used in `StakedTokenHandler.dealUnderlying`. But I still get the same `no cheats available for 0x1aF7f588A501EA2B5bB3feeFA744892aA2CF00e6` error after commenting that line out. And in another failed test with the same reason, and without `deal` commented out, I get the following trace for `dealUnderlying` at the end of the call sequence:\r\n```\r\n  [161282] StakedTokenHandler::dealUnderlying(1342, 10386 [1.038e4])\r\n    ‚îú‚îÄ [0] console::log(\"Bound Result\", 0) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [311] StakedToken::getUnderlyingToken() [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f]\r\n    ‚îú‚îÄ [0] console::log(\"Bound Result\", 999999000000000000001343 [9.999e23]) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [2561] ERC20::balanceOf(0x000000000000000000000000000000000000007B) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0\r\n    ‚îú‚îÄ [0] VM::record()\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îú‚îÄ [561] ERC20::balanceOf(0x000000000000000000000000000000000000007B) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0\r\n    ‚îú‚îÄ [0] VM::accesses(ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f])\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê [0xde31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332], []\r\n    ‚îú‚îÄ [0] VM::load(ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f], 0xde31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    ‚îú‚îÄ emit WARNING_UninitedSlot(who: ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f], slot: 100501195172664535830925975091664947533607165983939194257793843064591798272818 [1.005e77])\r\n    ‚îú‚îÄ emit SlotFound(who: ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f], fsig: 0x70a0823100000000000000000000000000000000000000000000000000000000, keysHash: 0xde31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332, slot: 100501195172664535830925975091664947533607165983939194257793843064591798272818 [1.005e77])\r\n    ‚îú‚îÄ [561] ERC20::balanceOf(0x000000000000000000000000000000000000007B) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0\r\n    ‚îú‚îÄ [0] VM::load(ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f], 0xde31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332) [staticcall]\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    ‚îú‚îÄ [0] VM::store(ERC20: [0x3381cD18e2Fb4dB236BF0525938AB6E43Db0440f], 0xde31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332, 0x00000000000000000000000000000000000000000000d3c20dee1639f99c053f)\r\n    ‚îÇ   ‚îî‚îÄ ‚Üê ()\r\n    ‚îî‚îÄ ‚Üê ()\r\n```\r\nWith these traces, it is unclear which cheat code was unavailable.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/foundry-rs/foundry/issues/6652/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
