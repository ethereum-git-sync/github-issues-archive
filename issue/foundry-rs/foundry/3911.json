{
  "url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
  "repository_url": "https://api.github.com/repos/foundry-rs/foundry",
  "labels_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911/labels{/name}",
  "comments_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911/comments",
  "events_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911/events",
  "html_url": "https://github.com/foundry-rs/foundry/issues/3911",
  "id": 1503316778,
  "node_id": "I_kwDOGBlvNc5Zmssq",
  "number": 3911,
  "title": "`forge deploy` feature wishlist",
  "user": {
    "login": "tynes",
    "id": 6626818,
    "node_id": "MDQ6VXNlcjY2MjY4MTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6626818?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tynes",
    "html_url": "https://github.com/tynes",
    "followers_url": "https://api.github.com/users/tynes/followers",
    "following_url": "https://api.github.com/users/tynes/following{/other_user}",
    "gists_url": "https://api.github.com/users/tynes/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tynes/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tynes/subscriptions",
    "organizations_url": "https://api.github.com/users/tynes/orgs",
    "repos_url": "https://api.github.com/users/tynes/repos",
    "events_url": "https://api.github.com/users/tynes/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tynes/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3593644820,
      "node_id": "LA_kwDOGBlvNc7WMqsU",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/T-feature",
      "name": "T-feature",
      "color": "BFD4F2",
      "default": false,
      "description": "Type: feature"
    },
    {
      "id": 3703752787,
      "node_id": "LA_kwDOGBlvNc7cwshT",
      "url": "https://api.github.com/repos/foundry-rs/foundry/labels/C-forge",
      "name": "C-forge",
      "color": "5319E7",
      "default": false,
      "description": "Command: forge"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2022-12-19T17:32:30Z",
  "updated_at": "2023-05-02T17:29:14Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "### Component\r\n\r\nForge\r\n\r\n### Describe the feature you would like\r\n\r\nIt would be nice to have a higher level command on top of `forge script` that is specifically designed to facilitate the management and deployment of complex smart contract systems. [hardhat-deploy](https://github.com/wighawag/hardhat-deploy) has over 20k repos that are using it on Github but it only receives a few commits per month and is missing certain features that would make it much easier to use.\r\n\r\nThe main feature that `forge script` is missing that would make it ideal for using for deployments is the way that the deployment artifacts are maintained\r\n\r\nDesired features:\r\n- There is a single artifact file per deployed contract\r\n- This file contains all of the information required to interact with the contract as well as verify it\r\n- Any language could have a library to read in the artifact and build a `Contract` object/struct, so that its easy to interact with the contracts, including `forge script`\r\n- `hardhat deploy` does not work well with hardware wallets, forcing insane hacks at deploy time to get it to work. Should be able to use hardware wallets at any derivation path\r\n- Idempotency, don't redeploy things if the code in the local workspace matches the code referenced in the deploy artifact (allows easy resumes of deployments)\r\n- Be able to reference deployment artifacts in remote locations (filesystem, URI), to be able to interact with those contracts (could be done via cheatcode)\r\n- The artifacts should be namespaced by network, something like `deployments/{mainnet,goerli}`\r\n- Automatically use chain id to know which network's artifacts to use\r\n- If the namespacing is canonical, then a network of deployment artifacts will make it really easy to interact with different contracts from different projects across chains\r\n- A way to manage a contract dependency graph at deploy time\r\n### Additional context\r\n\r\n_No response_",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911/reactions",
    "total_count": 6,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1358084396",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1358084396",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1358084396,
    "node_id": "IC_kwDOGBlvNc5Q8rks",
    "user": {
      "login": "hexonaut",
      "id": 588921,
      "node_id": "MDQ6VXNlcjU4ODkyMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/588921?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hexonaut",
      "html_url": "https://github.com/hexonaut",
      "followers_url": "https://api.github.com/users/hexonaut/followers",
      "following_url": "https://api.github.com/users/hexonaut/following{/other_user}",
      "gists_url": "https://api.github.com/users/hexonaut/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hexonaut/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hexonaut/subscriptions",
      "organizations_url": "https://api.github.com/users/hexonaut/orgs",
      "repos_url": "https://api.github.com/users/hexonaut/repos",
      "events_url": "https://api.github.com/users/hexonaut/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hexonaut/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-19T18:39:12Z",
    "updated_at": "2022-12-19T18:40:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "+1 for some sort of higher level structure. I'm currently using bash scripts to orchestrate multiple `forge script` runs. My main issue is there is no easy way to persist contracts through the deploy. For example if I have 2 dependencies that need to be deployed first I need to run each of them individually, use `jq` to pull contract info from the `broadcast` dir then set environment variables for the subsequent scripts. This is a bit clunky, and I would prefer some more standardized framework to orchestrate this.\r\n\r\nI'm not familiar with hardhat-deploy, but I need something along the lines of:\r\n\r\n`vm.export(\"MY_CONTRACT_LABEL\", contractAddress)`\r\n\r\nWhich can be imported in a subsequent script by:\r\n\r\n`vm.import(\"MY_CONTRACT_LABEL\")`",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1358084396/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1369962540",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1369962540",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1369962540,
    "node_id": "IC_kwDOGBlvNc5Rp_gs",
    "user": {
      "login": "hexonaut",
      "id": 588921,
      "node_id": "MDQ6VXNlcjU4ODkyMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/588921?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hexonaut",
      "html_url": "https://github.com/hexonaut",
      "followers_url": "https://api.github.com/users/hexonaut/followers",
      "following_url": "https://api.github.com/users/hexonaut/following{/other_user}",
      "gists_url": "https://api.github.com/users/hexonaut/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hexonaut/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hexonaut/subscriptions",
      "organizations_url": "https://api.github.com/users/hexonaut/orgs",
      "repos_url": "https://api.github.com/users/hexonaut/repos",
      "events_url": "https://api.github.com/users/hexonaut/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hexonaut/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T16:20:26Z",
    "updated_at": "2023-01-03T16:29:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "This list looks good to support mostly everything we need at Maker, but I would add two more points:\r\n\r\n * There should be a standard way to pass arbitrary configuration parameters from the `deploy` context to the `script` context. I think the structure of having some global configuration json file which can then be easily modified and passed into the child `script` contexts would be ideal. Perhaps env vars are sufficient for the translation between `deploy` and `script`, but just wanted to make sure this point is considered in the structure.\r\n  * Scripts should be able to export arbitrary data to the parent deploy process similar to the previous post I made. It's possible there are multiple deploys of the same contract, and I would like a way to specify which is which with a friendly label.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1369962540/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1370101228",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1370101228",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1370101228,
    "node_id": "IC_kwDOGBlvNc5RqhXs",
    "user": {
      "login": "tynes",
      "id": 6626818,
      "node_id": "MDQ6VXNlcjY2MjY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6626818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tynes",
      "html_url": "https://github.com/tynes",
      "followers_url": "https://api.github.com/users/tynes/followers",
      "following_url": "https://api.github.com/users/tynes/following{/other_user}",
      "gists_url": "https://api.github.com/users/tynes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tynes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tynes/subscriptions",
      "organizations_url": "https://api.github.com/users/tynes/orgs",
      "repos_url": "https://api.github.com/users/tynes/repos",
      "events_url": "https://api.github.com/users/tynes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tynes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T18:37:33Z",
    "updated_at": "2023-01-03T18:37:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "> There should be a standard way to pass arbitrary configuration parameters\r\n\r\nI definitely agree with this, hardhat handles this with scripts by allowing you to define arbitrary CLI params. There is not a way to do this with `hardhat deploy` so we created a [hardhat plugin](https://github.com/ethereum-optimism/optimism/tree/develop/packages/hardhat-deploy-config) for managing dynamic deploy config. This plugin allows you to define a JSON file that includes the dynamic deploy config and then the values can be accessed during deployment execution",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1370101228/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1399464017",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1399464017",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1399464017,
    "node_id": "IC_kwDOGBlvNc5TaiBR",
    "user": {
      "login": "adhusson",
      "id": 2977,
      "node_id": "MDQ6VXNlcjI5Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2977?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adhusson",
      "html_url": "https://github.com/adhusson",
      "followers_url": "https://api.github.com/users/adhusson/followers",
      "following_url": "https://api.github.com/users/adhusson/following{/other_user}",
      "gists_url": "https://api.github.com/users/adhusson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adhusson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adhusson/subscriptions",
      "organizations_url": "https://api.github.com/users/adhusson/orgs",
      "repos_url": "https://api.github.com/users/adhusson/repos",
      "events_url": "https://api.github.com/users/adhusson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adhusson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-22T11:54:31Z",
    "updated_at": "2023-01-22T19:32:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "FYI, here's how we do it at Mangrove. It's still hackish and in need of cleanup but can provide ideas. There's no idempotency and so far it has not been a problem. The flow is:\r\n\r\n1. You call `forge script --fork-url myNetwork MyDeployment`\r\n2. During script execution, all current deployments on `myNetwork` are accessible by name through `fork.get(name)`\r\n3. You register any new/replacement deploy with `fork.set(name,address)`\r\n4. A JSON file with all known deployments is written to disk. If `WRITE_DEPLOY` was true, the old JSON file is replaced. Otherwise you have both files available.\r\n\r\nSome more details:\r\n\r\nThere's a [Toy ENS](https://github.com/mangrovedao/mangrove-core/blob/master/lib/ToyENS.sol) contract that maintains a name=>address mapping. Scripts inherit the [Deployer](https://github.com/mangrovedao/mangrove-core/blob/master/script/lib/Deployer.sol) contract which [detects the current fork](https://github.com/mangrovedao/mangrove-core/blob/master/script/lib/Deployer.sol#L48) and [loads addresses from a network-dependent JSON file](https://github.com/mangrovedao/mangrove-core/blob/master/test/lib/forks/Generic.sol#L141) into the ToyENS (if the remote node [has its own ToyENS at `0xdecaf0...`](https://github.com/mangrovedao/mangrove-core/blob/master/test/lib/forks/Generic.sol#L152) those mappings prioritized)). Scripts call `fork.set(name,address)` to [register any newly deployed contract](https://github.com/mangrovedao/mangrove-core/blob/master/script/MangroveDeployer.s.sol#L35), then end with a call to their [`outputDeployment()`](https://github.com/mangrovedao/mangrove-core/blob/master/script/lib/Deployer.sol#L119) method, which [dumps all the Toy ENS mappings to a JSON file](https://github.com/mangrovedao/mangrove-core/blob/master/script/lib/Deployer.sol#L119). By default, a timestamped JSON file is created. If `WRITE_DEPLOY` is true, the \"latest\" file is updated. All those files are keyed to the [current network](https://github.com/mangrovedao/mangrove-core/blob/master/test/lib/forks/Generic.sol#L73).\r\n\r\nMisc additional stuff:\r\n* There are 2 Toy ENS contracts. There's \"context\", which cannot be written to, and \"deployed\" which can. That's so scripts can't overwrite e.g. uniswap's address by mistake, but can fetch it by name.\r\n* Scripting discipline requires:\r\n    1. `run()` ends with `outputDeployment()`\r\n    2. Deploys are followed by `fork.set(name,address)`\r\n    3. There's an `innerRun` function called by `run()` so that scripts can call each other through `innerRun()` and `run()` can [read environment variables to get its arguments](https://github.com/mangrovedao/mangrove-core/blob/master/script/MangroveDeployer.s.sol#L21). That's way more convenient that giving a function signature as argument to `forge script`.\r\n* There's extra broadcaster-selection logic to handle the \"I want to simulate as if calling from a contract\". In that case we use `--skip-simulation`.\r\n\r\nPending improvements:\r\n* The code contains additional complexity because we often don't want to deploy but just _generate deployment calldata_ to pass to a contract.\r\n* The fork-selection logic should be updated to use mappings instead of an if-then-else.\r\n* writeJson should be used instead of manual string-wrangling to write the JSON files.\r\n* Add local overrides for mappings using either a local JSON file or environment vars e.g. `OVERRIDE_UNISWAP=...`.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1399464017/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1399506797",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1399506797",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1399506797,
    "node_id": "IC_kwDOGBlvNc5Tasdt",
    "user": {
      "login": "hexonaut",
      "id": 588921,
      "node_id": "MDQ6VXNlcjU4ODkyMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/588921?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hexonaut",
      "html_url": "https://github.com/hexonaut",
      "followers_url": "https://api.github.com/users/hexonaut/followers",
      "following_url": "https://api.github.com/users/hexonaut/following{/other_user}",
      "gists_url": "https://api.github.com/users/hexonaut/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hexonaut/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hexonaut/subscriptions",
      "organizations_url": "https://api.github.com/users/hexonaut/orgs",
      "repos_url": "https://api.github.com/users/hexonaut/repos",
      "events_url": "https://api.github.com/users/hexonaut/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hexonaut/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-22T14:38:48Z",
    "updated_at": "2023-01-22T15:18:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "This looks great @adhusson .",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1399506797/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1406588724",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1406588724",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1406588724,
    "node_id": "IC_kwDOGBlvNc5T1tc0",
    "user": {
      "login": "hexonaut",
      "id": 588921,
      "node_id": "MDQ6VXNlcjU4ODkyMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/588921?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hexonaut",
      "html_url": "https://github.com/hexonaut",
      "followers_url": "https://api.github.com/users/hexonaut/followers",
      "following_url": "https://api.github.com/users/hexonaut/following{/other_user}",
      "gists_url": "https://api.github.com/users/hexonaut/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hexonaut/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hexonaut/subscriptions",
      "organizations_url": "https://api.github.com/users/hexonaut/orgs",
      "repos_url": "https://api.github.com/users/hexonaut/repos",
      "events_url": "https://api.github.com/users/hexonaut/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hexonaut/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-27T14:36:12Z",
    "updated_at": "2023-01-27T14:51:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Following up here from Discord:\r\n\r\nI'll run over our current structure and say why we chose this path and where the pain points are. This is the PR this is being implemented for Maker: https://github.com/makerdao/dss-direct-deposit/pull/92\r\n\r\n1. We define json configuration files in `script/input/<CHAINID>` such as here: https://github.com/makerdao/dss-direct-deposit/tree/deploy-scripts/script/input/1\r\n2. Scripts are run which will read in the configuration json and output with user-defined labels to `https://github.com/makerdao/dss-direct-deposit/tree/deploy-scripts/script/output/1`. Please note we cannot use the broadcast json files because it may be that a contract was not deployed from an EOA, is behind a proxy, etc. We need to label these ourselves in the script. Example [#1](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/deploy-core.sh) and [#2](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/deploy.sh) of deploy scripts in this repo. Examples of [loadConfig](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/script/D3MCoreDeploy.s.sol#L43) and [exportContract](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/script/D3MCoreDeploy.s.sol#L56).\r\n3. In Maker we need to deploy contracts and then execute them in a separate operation (by the administrative spell instead of the deployer EOA). For the \"core deploy\" example above we have a dependency loading function [here](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/script/D3MCoreInit.s.sol#L44).\r\n\r\nThe pain points:\r\n\r\n1. The overall structure above is cumbersome to pass json files in and out. The only way to read files is from pre-defined folders that have read-write access allowed in foundry.toml. This is problematic if for example I am installing `dss-direct-deposit` as a library in some parent deploy repository. In that case I want to be able to build inside the `lib/dss-direct-deposit` directory, but pass in a file from outside. Currently the only way to do this (that I know of) is to put the json inside an environment variable which is kind of unintuitive. It would be nice to be able to pass in a configuration here by CLI arg such as `forge script .... --user-arg-config /path/to/my/config.json` which would automatically allow that file to be read.\r\n2. Dependency management is non-existent, and we don't really want to roll our own. Currently we are just combining previously generated json output files into an environment vars such as [here](https://github.com/makerdao/dss-direct-deposit/blob/deploy-scripts/init.sh#L47). This is messy, and I would like not have to do manual json manipulation in bash scripts. :)\r\n\r\nProposed solution:\r\n\r\nI think what I would like to see is the higher level `forge deploy` command as suggested in OP that would take a json configuration file that glues all of this together.\r\n\r\nAn example of what this could look like (feel free to maybe move the `cmd` stuff into a json root object or something):\r\n\r\n```\r\n{\r\n\t\"core\": {\r\n\t\t\"cmd\": \"forge script script/D3MCoreDeploy.s.sol:D3MCoreDeployScript --use solc:0.8.14 --rpc-url $ETH_RPC_URL --sender $ETH_FROM --broadcast --verify\",\r\n\t\t\"config\": \"./script/input/$FOUNDRY_CHAINID/core.json\",\r\n\t\t\"outputDir\": \"./script/output/$FOUNDRY_CHAINID/\",\r\n\t\t\"outputName\": \"core\"\r\n\t},\r\n\t\"core-init\": {\r\n\t\t\"dependencies\": [\"core\"],\r\n\t\t\"cmd\": \"forge script script/D3MCoreInit.s.sol:D3MCoreInitScript --use solc:0.8.14 --rpc-url \"$ETH_RPC_URL\" --broadcast --unlocked --sender $MCD_PAUSE_PROXY\",\r\n\t\t\"config\": \"./script/input/$FOUNDRY_CHAINID/core.json\"\r\n\t},\r\n\t\"aave\": {\r\n\t\t\"dependencies\": [\"core\"],\r\n\t\t\"cmd\": \"forge script script/D3MDeploy.s.sol:D3MDeployScript --use solc:0.8.14 --rpc-url $ETH_RPC_URL --sender $ETH_FROM --broadcast --verify\",\r\n\t\t\"config\": \"./script/input/$FOUNDRY_CHAINID/aave.json\",\r\n\t\t\"outputDir\": \"./script/output/$FOUNDRY_CHAINID/\",\r\n\t\t\"outputName\": \"aave\"\r\n\t},\r\n\t\"aave-init\": {\r\n\t\t\"dependencies\": [\"core\", \"d3m:aave\"],\r\n\t\t\"cmd\": \"forge script script/D3MInit.s.sol:D3MInitScript --use solc:0.8.14 --rpc-url $ETH_RPC_URL --broadcast --unlocked --sender $MCD_PAUSE_PROXY\",\r\n\t\t\"config\": \"./script/input/$FOUNDRY_CHAINID/aave.json\"\r\n\t}\r\n}\r\n```\r\n\r\nRunning this would then be as simple as `forge deploy aave` which would check if the `core` output exists, if it does it skips that step and if it doesn't would run that step. After `core` step is complete it would move to `aave` and run that.\r\n\r\nScripts could access dependencies by using `vm.readDependency(\"XYZ\")` or similar. In the \"aave-init\" example above `d3m:aave` remaps the aave target into a dependency labelled \"d3m\". This is so the D3Minit script can call `vm.readDependency(\"d3m\")` and it will fill in either aave or compound or whatever the higher level script determines.\r\n\r\nThe config should also be able to specify a dependency inside a `forge install ...` directory added to `lib/XYZ/...` so that higher level deploy coordination repos can orchestrate amongst a bunch of smaller repos.\r\n\r\nHow does that look to everyone? More should be added, but this is the biggest piece that is missing for us imo.",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1406588724/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1474512062",
    "html_url": "https://github.com/foundry-rs/foundry/issues/3911#issuecomment-1474512062",
    "issue_url": "https://api.github.com/repos/foundry-rs/foundry/issues/3911",
    "id": 1474512062,
    "node_id": "IC_kwDOGBlvNc5X40S-",
    "user": {
      "login": "PierrickGT",
      "id": 2401738,
      "node_id": "MDQ6VXNlcjI0MDE3Mzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2401738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PierrickGT",
      "html_url": "https://github.com/PierrickGT",
      "followers_url": "https://api.github.com/users/PierrickGT/followers",
      "following_url": "https://api.github.com/users/PierrickGT/following{/other_user}",
      "gists_url": "https://api.github.com/users/PierrickGT/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PierrickGT/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PierrickGT/subscriptions",
      "organizations_url": "https://api.github.com/users/PierrickGT/orgs",
      "repos_url": "https://api.github.com/users/PierrickGT/repos",
      "events_url": "https://api.github.com/users/PierrickGT/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PierrickGT/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-17T23:30:39Z",
    "updated_at": "2023-03-17T23:30:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "> +1 for some sort of higher level structure. I'm currently using bash scripts to orchestrate multiple `forge script` runs. My main issue is there is no easy way to persist contracts through the deploy. For example if I have 2 dependencies that need to be deployed first I need to run each of them individually, use `jq` to pull contract info from the `broadcast` dir then set environment variables for the subsequent scripts. This is a bit clunky, and I would prefer some more standardized framework to orchestrate this.\r\n\r\nYour use case is probably different but you can use [StdJson](https://github.com/foundry-rs/forge-std/blob/master/src/StdJson.sol) to parse JSON files in Solidity.\r\nThat's what I've used for the ERC-5164 bridge interface: https://github.com/pooltogether/ERC5164/blob/main/script/helpers/DeployedContracts.sol\r\n\r\nBasically, I deploy the contracts on both chains and then use the script to retrieve the deployed contracts and interact with them: https://github.com/pooltogether/ERC5164/blob/main/script/deploy/DeployToOptimism.s.sol#L39\r\nOf course, it requires a lot of forge commands but with the use of NPM, you can easily create one single command that handles the deployment: https://github.com/pooltogether/ERC5164/blob/main/package.json",
    "reactions": {
      "url": "https://api.github.com/repos/foundry-rs/foundry/issues/comments/1474512062/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
