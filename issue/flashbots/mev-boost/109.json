{
  "url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
  "repository_url": "https://api.github.com/repos/flashbots/mev-boost",
  "labels_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109/labels{/name}",
  "comments_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109/comments",
  "events_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109/events",
  "html_url": "https://github.com/flashbots/mev-boost/issues/109",
  "id": 1218609580,
  "node_id": "I_kwDOGZSKs85IooGs",
  "number": 109,
  "title": "mev-boost with unconditional payments",
  "user": {
    "login": "obadiaa",
    "id": 19510814,
    "node_id": "MDQ6VXNlcjE5NTEwODE0",
    "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/obadiaa",
    "html_url": "https://github.com/obadiaa",
    "followers_url": "https://api.github.com/users/obadiaa/followers",
    "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
    "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
    "organizations_url": "https://api.github.com/users/obadiaa/orgs",
    "repos_url": "https://api.github.com/users/obadiaa/repos",
    "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/obadiaa/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4082529928,
      "node_id": "LA_kwDOGZSKs87zVnaI",
      "url": "https://api.github.com/repos/flashbots/mev-boost/labels/research%20%F0%9F%92%A1",
      "name": "research ðŸ’¡",
      "color": "0052cc",
      "default": false,
      "description": "Research topic"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 13,
  "created_at": "2022-04-28T11:45:09Z",
  "updated_at": "2022-07-18T15:47:32Z",
  "closed_at": null,
  "author_association": "COLLABORATOR",
  "active_lock_reason": null,
  "body": "TLDR: We'd like to consider whether it would make sense for builders to bid unconditionally for their header to be selected by the proposer. This would imply the proposer gets paid regardless of whether the body gets revealed. We care about this because it maps onto the current spec of in-protocol PBS more closely (further helping test PBS with MEV-Boost), because it is more favorable to proposers, and because it places less trust on _relays_.\r\n\r\n**Context**\r\nIn the current version of MEV-Boost:\r\n- *searchers* submit bundles to *builders*\r\n- *builders* build blocks with these bundles and public mempool transactions\r\n- *builders* send their blocks and bids `(body, header, bid)` to *relays*\r\n- *relays* check the validity of and store builder blocks, get pinged by the *proposer* and share **only** the headers of all the valid blocks they have alongside their respective bids `(header,bid)`\r\n- the *proposer* selects the header with the highest bid and signs on it within the beacon block they propose\r\n- once the *relay* knows the *proposer* has signed on this header, the block body of the associated header is revealed by the *relay*. The payment is contained within the body.\r\n\r\n> Note: \r\n> This commit-reveal scheme was chosen in order to ensure there is no trust assumption placed on validators, making accessing MEV revenue via MEV-Boost completely permissionless. This is the 'trusted relay' model in this document: https://hackmd.io/8cUfu-HKQuyYjWk-f9DVuw. This Github issue doesn't discuss in detail why this solution was chosen. Please refer to a presentation given at EthStaker for more detail for why ensuring all validators have access to MEV revenue is especially important in PoS Ethereum: https://youtu.be/GJwS7VF40wk?t=23292.\r\n\r\n**Unconditional payments**\r\nIn the current model, the proposer only gets paid if the block body whose header they've signed on is revealed by the relay. This means the proposer is at the mercy of the relay. If the relay doesn't reveal the body, then the proposer ~~gets slashed from proposing an empty execution block~~ loses protocol rewards they would've gotten from proposing a block as well as the MEV rewards (incl. transaction tips) that are in the block body. (edit: correcting previous statement that proposer gets slashed from proposing an empty block).\r\n\r\nThe relay is therefore trusted by 1) the builders who submit their blocks to it, 2) the validators who sign on one of the headers they receive from the relays.\r\n\r\nWe would like to consider an alternative system where builders pay unconditionally for their bid. In this system:\r\n- *searchers* submit bundles to *builders*\r\n- *builders* build blocks with these bundles and public mempool transactions\r\n- *builders* send their `(header,bid)` pairs to *relays*\r\n- *relays* store builder's `(header,bid)` pairs as well the money needed to fullfill the bid\r\n- *relays* get pinged by the *proposer* and release each `(header,bids)` pairs it has for the current slot.\r\n- the *proposer* selects the header with the highest bid and signs on it within the beacon block they propose\r\n- as soon as the *relay* sees the header, it releases the payment to the proposer, unconditionally of the body being revealed.\r\n- the block body of the associated header is revealed by the *builder* who is now incentivized to do so since they've already paid for it.\r\n\r\nHow does this differ from the current system?\r\n- The relay now essentially acts as a payment escrow.\r\n- The relay cannot see the block bodies and does not check for the validity of the bodies. This reduces the trust builders and proposers need to have in the relay. \r\n- The proposer now gets paid regardless of whether the body gets revealed. \r\n- The builders are now responsible to reveal their header's body, and they are incentivized to do so since they've already paid for it. Similarly, they are incentivized to make sure their body is valid.\r\n- This shifts the attack vector to builders, who can now be griefed by proposers who can pick a header late enough such that a builder doesn't have time to reveal the body before the appropriate time window but a relay has enough time to see it and release the payment.\r\n\r\nA document outlining this alternative was written by @thegostep here:  https://hackmd.io/@flashbots/Skc0vuyCt\r\n\r\n\r\n**Outstanding questions**\r\n1) How does unconditional payment work with multiple relays? In other words, who does the builder send money to if it sends its `header,bid` pair to two relays? (h/t @lightclient for asking this question)\r\n2) Does this system put a prohibitively higher capital requirements on builders who now need to put up money upfront?\r\n3) Is a griefing vector from proposers acceptable? \r\n4) Which solution is better between the current design and unconditional payments? Do we fully understand the trade-off space? \r\n\r\nWe open this up for discussion and look forward to your questions and comments ðŸ¤—",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/109/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1113175225",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1113175225",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1113175225,
    "node_id": "IC_kwDOGZSKs85CWbS5",
    "user": {
      "login": "thegostep",
      "id": 15959632,
      "node_id": "MDQ6VXNlcjE1OTU5NjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15959632?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thegostep",
      "html_url": "https://github.com/thegostep",
      "followers_url": "https://api.github.com/users/thegostep/followers",
      "following_url": "https://api.github.com/users/thegostep/following{/other_user}",
      "gists_url": "https://api.github.com/users/thegostep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thegostep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thegostep/subscriptions",
      "organizations_url": "https://api.github.com/users/thegostep/orgs",
      "repos_url": "https://api.github.com/users/thegostep/repos",
      "events_url": "https://api.github.com/users/thegostep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thegostep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-04-29T11:00:42Z",
    "updated_at": "2022-04-29T11:03:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think the model can be refined slightly: builders would send to the relays the header + a signed payment. The relay sends the header to the validator and escrows the payment until it receives the signed header back. It then publishes the payment to the transaction pool.\n\nThis assumes that only the relay has the ability to censor a payment and it is possible for all parties to identify if they do. This can be achieved through each relay having an independent escrow contract.\n\nThe capital requirements is that builders must maintain an account balance with each relay they send payloads to.\n\n---\n```solidity\n\ncontract Escrow {\n\n    event Payment(address builder, address feeRecipient, uint256 amount, uint256 nonce, uint256 expiry, bytes32 blockhash);\n\n    struct Account {\n        uint256 timelock;\n        uint256 balance;\n        uint256 nonce;\n    }\n\n    mapping[address => Account] accounts;\n    \n    address immutable admin;\n    uint256 immutable timelockDuration;\n\n    constructor(address a, uint256 t) {\n        admin = a;\n        timelockDuration = t;\n    }\n\n    // builder deposits eth into their account\n    receive() public payable {\n        accounts[msg.sender].balance += msg.value;\n    }\n\n    // escrow executes payment\n    function pay(address feeRecipient, uint256 amount, uint256 nonce, uint256 expiry, bytes32 blockhash, bytes memory permission) public {\n        require(msg.sender == admin);\n        require(block.number <= expiry);\n        bytes memory msg = keccak256(abi.encodePacked(feeRecipient, amount, nonce, expiry, blockhash));\n        address builder = ecrecover(msg, permission);\n        require(nonce >= accounts[builder].nonce);\n        accounts[builder].nonce = nonce + 1;\n        accounts[builder].balance -= amount;\n        payable(feeRecipient).transfer(amount);\n        emit Payment(builder, feeRecipient, amount, nonce, expiry, blockhash);\n    }\n\n    // builder requests exit\n    function requestExit() public {\n        require(accounts[msg.sender].timelock == 0);\n        accounts[msg.sender].timelock = block.number + timelockDuration;\n    }\n\n    // builder confirms exit\n    function confirmExit() public {\n        Account memory account = accounts[msg.sender];\n        require(account.timelock != 0 && block.number >= account.timelock);\n        delete accounts[msg.sender];\n        payable(msg.sender).transfer(account.balance);\n    }\n\n}\n```",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1113175225/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1114250628",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1114250628",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1114250628,
    "node_id": "IC_kwDOGZSKs85Cah2E",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-01T14:16:27Z",
    "updated_at": "2022-05-01T14:16:27Z",
    "author_association": "COLLABORATOR",
    "body": "Ty @thegostep this is what I meant to describe above! \r\n\r\nQ for you: what if a builder sends their header to multiple relays?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1114250628/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1114251939",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1114251939",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1114251939,
    "node_id": "IC_kwDOGZSKs85CaiKj",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-01T14:22:51Z",
    "updated_at": "2022-05-01T14:29:07Z",
    "author_association": "COLLABORATOR",
    "body": "On Q3 `Is a griefing vector from proposers acceptable?`:\r\n\r\nI'd like to understand the griefing attack better. In broad terms, the attack would be the proposer securing the money from the builder's bid but ensuring the body doesn't get revealed. The incentive for them to do so would be 'MEV-stealing'.\r\n\r\nIf relays are required to release the payment when they see the signed header on the p2p network, then the chances of relays but not the builder seeing the header in time could be small enough that the griefing risk is ok?\r\n\r\nCould the risk also be mitigated by a time window the header has to be committed by that accounts for p2p network latency?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1114251939/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1115931753",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1115931753",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1115931753,
    "node_id": "IC_kwDOGZSKs85Cg8Rp",
    "user": {
      "login": "fradamt",
      "id": 104826920,
      "node_id": "U_kgDOBj-IKA",
      "avatar_url": "https://avatars.githubusercontent.com/u/104826920?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fradamt",
      "html_url": "https://github.com/fradamt",
      "followers_url": "https://api.github.com/users/fradamt/followers",
      "following_url": "https://api.github.com/users/fradamt/following{/other_user}",
      "gists_url": "https://api.github.com/users/fradamt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fradamt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fradamt/subscriptions",
      "organizations_url": "https://api.github.com/users/fradamt/orgs",
      "repos_url": "https://api.github.com/users/fradamt/repos",
      "events_url": "https://api.github.com/users/fradamt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fradamt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-03T10:04:33Z",
    "updated_at": "2022-05-12T14:05:26Z",
    "author_association": "NONE",
    "body": "Some comments:\r\n\r\n> If the relay doesn't reveal the body, then the proposer gets slashed from proposing an empty execution block\r\n\r\nThe proposer would lose income but they don't get slashed for not proposing. \r\n\r\n> This means the proposer is at the mercy of the relay.\r\n\r\nThe proposer is anyway at the mercy of the relay, even with \"unconditional\" payment. They still need to sign a header in order to obtain the payment (at which point the proposer can't do anything else without getting slashed for double signing), and the relay can withhold the payment just like they can withhold the block in the current scheme. \r\n\r\nNot only that, but relay withholding is not a more attributable fault in this scheme than in the current one. Currently, if a relay withholds a block *for a few seconds*, chances are the block won't become canonical and the proposer doesn't get paid, but detecting the (probably) malicious behavior of the relay requires being online, and anyway it's indistinguishable from just temporarily degraded network conditions, or the relay getting DDoS'ed etc... The only way to tell if a relay is malicious is to observe their behavior for a long period of time and have some metrics, and even then it's hard to be sure. With this other scheme, a relay can withhold a payment just the same, but they are forced to withhold it forever (or anyway until the funds are not available anymore), which is a  very clearly detectable behavior. Nonetheless, the fault is still not clearly attributable, because the relay *is supposed to withhold the payment* if the proposer sends them a signed header too late for the builder to release the block, and so one anyway one would have to monitor when messages are being received to try to determine who's at fault. \r\n\r\n\r\n> The shifts the attack vector to builders, who can now be griefed by proposers who can pick a header late enough such that a builder doesn't have time to reveal the body before the appropriate time window but a relay has enough time to see it and release the payment.\r\n\r\nImho, this is much worse than what a malicious relay can do to proposers in the current scheme (possible worse even for proposers themselves, because this attack vector existing and being hard to mitigate means builders might want to bid less, at least for untrusted proposers). A single relay can withhold a block, but a proposer can avoid ever finding themselves in a situation where they depend on a single relay, by only signing headers which have been suggested by multiple relays (which should be the case for most headers, since builders are incentivized to send them to all relay they deem trustworthy). To accept a header, a proposer would send it over p2p, so all relays which have suggested that header (even ones which the proposer doesn't trust but the builder trusted!) are able to release the body. It's basically a 1 of N trust model for the proposer, where N is all relays which have received the corresponding body, a subset of which the proposer explicitly trusts. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1115931753/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116027545",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1116027545",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1116027545,
    "node_id": "IC_kwDOGZSKs85ChTqZ",
    "user": {
      "login": "thegostep",
      "id": 15959632,
      "node_id": "MDQ6VXNlcjE1OTU5NjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15959632?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thegostep",
      "html_url": "https://github.com/thegostep",
      "followers_url": "https://api.github.com/users/thegostep/followers",
      "following_url": "https://api.github.com/users/thegostep/following{/other_user}",
      "gists_url": "https://api.github.com/users/thegostep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thegostep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thegostep/subscriptions",
      "organizations_url": "https://api.github.com/users/thegostep/orgs",
      "repos_url": "https://api.github.com/users/thegostep/repos",
      "events_url": "https://api.github.com/users/thegostep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thegostep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-03T12:11:48Z",
    "updated_at": "2022-05-03T12:11:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Nonetheless, the fault is still not clearly attributable, because the relay is supposed to withhold the payment if the proposer sends them a signed header too late for the builder to release the block, and so one anyway one would have to monitor when messages are being received to try to determine who's at fault.\r\n\r\nI agree, this is the main concern with this approach and seems to be a show stopper.\r\n\r\n> It's basically a 1 of N trust model for the proposer, where N is all relays which have received the corresponding body, a subset of which the proposer explicitly trusts.\r\n\r\nSomething which has been brought up in the past is that relays should gossip builder payloads amongst eachother to improve data availability. This seems dangerous to me as it creates a set of colluding relays who all see the transaction content of a builder without the builders explicitly approving it.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116027545/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116035557",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1116035557",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1116035557,
    "node_id": "IC_kwDOGZSKs85ChVnl",
    "user": {
      "login": "fradamt",
      "id": 104826920,
      "node_id": "U_kgDOBj-IKA",
      "avatar_url": "https://avatars.githubusercontent.com/u/104826920?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fradamt",
      "html_url": "https://github.com/fradamt",
      "followers_url": "https://api.github.com/users/fradamt/followers",
      "following_url": "https://api.github.com/users/fradamt/following{/other_user}",
      "gists_url": "https://api.github.com/users/fradamt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fradamt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fradamt/subscriptions",
      "organizations_url": "https://api.github.com/users/fradamt/orgs",
      "repos_url": "https://api.github.com/users/fradamt/repos",
      "events_url": "https://api.github.com/users/fradamt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fradamt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-03T12:20:48Z",
    "updated_at": "2022-05-03T12:23:46Z",
    "author_association": "NONE",
    "body": "> Something which has been brought up in the past is that relays should gossip builder payloads amongst eachother to improve data availability. This seems dangerous to me as it creates a set of colluding relays who all see the transaction content of a builder without the builders explicitly approving it.\r\n\r\nPersonally, I think they shouldn't, and it should be considered as a violation of the principles of their relationship with builders. Nonetheless, a builder can (and likely will) share payloads with multiple relays, and I think that this \"natural\" redundancy should be enough to give very good guarantees in most slots",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116035557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116721122",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1116721122",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1116721122,
    "node_id": "IC_kwDOGZSKs85Cj8_i",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-03T22:29:09Z",
    "updated_at": "2022-05-03T22:29:09Z",
    "author_association": "COLLABORATOR",
    "body": "Assuming both relay and builder don't have access to the block gossip layer. One minor downside is this will require an extra hop before gossiping the full block. I'm not sure what that looks like latency-wise. \r\n\r\nStatus duo at the start of the slot:\r\n1. **proposer** --`get_header`--> **relay**\r\n2. **relay** --`header`--> **proposer**\r\n3. _proposer signs header_\r\n4. **proposer** --`get_payload`--> **relay**\r\n5. **relay** --`payload`--> **proposer**\r\n6. _proposer validates payload_\r\n7. _proposer gossips the block_\r\n\r\nWith unconditional payment:\r\n1. **proposer** --`get_header`--> **relay**\r\n2. **relay** --`header`--> **proposer**\r\n3. _proposer signs header_\r\n4. **proposer** --`get_payload`--> **relay**\r\n5. **relay** --`get_payload`--> **builder**\r\n6. **builder** --`payload`--> **relay**\r\n7. **relay** --`payload`--> **proposer**\r\n8. _proposer validates payload_\r\n9. _proposer gossips the block_\r\n\r\nThe additional 5 and 6 may introduce additional latencies to delay 9\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1116721122/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124045088",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1124045088",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1124045088,
    "node_id": "IC_kwDOGZSKs85C_5Eg",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-11T17:22:44Z",
    "updated_at": "2022-05-11T18:19:25Z",
    "author_association": "COLLABORATOR",
    "body": "Hey @fradamt @thegostep @terencechain, thanks for your replies! I'll address each individually.\r\n\r\n@fradamt: \r\n\r\n> With this other scheme, a relay can withhold a payment just the same, but they are forced to withhold it forever (or anyway until the funds are not available anymore), which is a very clearly detectable behavior.\r\n\r\nWhat's the intuition for why the relay needs to withhold the payment forever and that it's a detectable behavior? Is that an argument in favor of the 'unconditional payment' model?\r\n\r\nTrying to summarize your point:\r\n1) the 'unconditional payment' model still requires a relay (otherwise proposers can seriously attack builders which would likely lead to builders only working with trusted proposers).\r\n2) because it does still require a relay, proposers are still subject to withholding attacks from relays but, as opposed to block-body-withholding this payment-withholding attack is more detectable.\r\n3) the current system has a 1/n trust model for proposers accepting bids from relays. more specifically, a proposer can select a bid it has seen from n relays, and then would just need 1 out of n relays to reveal the body. in the 'unconditional payment' model, this 1/n property stops existing.\r\n\r\nFor 3: \r\n- i understand the 1/n argument but question the assumption builders will share their payloads with lots of relays. are builders really incentivized to do so? the more relays they share their blocks with, the more they are subject to potential adverse behaviour and the harder it is for them to know who the malicious party is. I think this is outside the scope of this issue and have created a new issue for it here #122 ðŸ¤ \r\n\r\n- suppose we're in the unconditional payment model and a proposer selects a bid seen by multiple relays, then either a) all relays have the money for the payment which is capital inefficient but means we preserve the 1/n property, or b) there is some way for relays to split payments but then we lose the 1/n property. does that sound accurate to you?\r\n\r\nLastly: afaik in-protocol PBS has unconditional payments. does that mean its design should be re-thought?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124045088/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124057753",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1124057753",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1124057753,
    "node_id": "IC_kwDOGZSKs85C_8KZ",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-11T17:35:35Z",
    "updated_at": "2022-06-01T18:23:29Z",
    "author_association": "COLLABORATOR",
    "body": "@terencechain :\r\ngreat point! however in my mind the builder had access to the block gossip layer, why do you assume they don't?\r\n\r\nif they did, i imagine a participating builder would essentially monitor the network for a signed header from the proposer and verify if it matches their own. in case it does, they would then gossip the body. Going something like:\r\n\r\n1.  **proposer**Â --`get_header`-->Â **relay**\r\n2.  **relay**Â --`header`-->Â **proposer**\r\n3.  _proposer signs header_\r\n4.  **proposer**Â --`get_payload`-->Â (p2p network)\r\n5. **builder**Â --`payload`-->Â (p2p network)\r\n7. _proposer validates payload_\r\n8.  _proposer gossips the block_",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124057753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124070649",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1124070649",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1124070649,
    "node_id": "IC_kwDOGZSKs85C__T5",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-11T17:40:52Z",
    "updated_at": "2022-05-11T18:17:31Z",
    "author_association": "COLLABORATOR",
    "body": "@thegostep :\r\n\r\n> Something which has been brought up in the past is that relays should gossip builder payloads amongst each other to improve data availability. This seems dangerous to me as it creates a set of colluding relays who all see the transaction content of a builder without the builders explicitly approving it.\r\n\r\nI've opened a new issue for this #122. It's clear relays shouldn't violate the preferences of builders but I think even if builders explicitly approve it - I'm not sure they'd be fully aware of what it would take to distinguish misbehavior.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1124070649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1125088767",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1125088767",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1125088767,
    "node_id": "IC_kwDOGZSKs85DD33_",
    "user": {
      "login": "fradamt",
      "id": 104826920,
      "node_id": "U_kgDOBj-IKA",
      "avatar_url": "https://avatars.githubusercontent.com/u/104826920?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fradamt",
      "html_url": "https://github.com/fradamt",
      "followers_url": "https://api.github.com/users/fradamt/followers",
      "following_url": "https://api.github.com/users/fradamt/following{/other_user}",
      "gists_url": "https://api.github.com/users/fradamt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fradamt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fradamt/subscriptions",
      "organizations_url": "https://api.github.com/users/fradamt/orgs",
      "repos_url": "https://api.github.com/users/fradamt/repos",
      "events_url": "https://api.github.com/users/fradamt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fradamt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-12T14:48:24Z",
    "updated_at": "2022-06-03T07:39:05Z",
    "author_association": "NONE",
    "body": "> What's the intuition for why the relay needs to withhold the payment forever and that it's a detectable behavior? Is that an argument in favor of the 'unconditional payment' model?\r\nNot forever, but at least for a while, depending on how things are set up. If they don't, the proposer gets their payment, albeit maybe a bit later than they should have. Compare this to the current model, in which the block *is* the payment, and the proposer only gets paid if it is released in time for it to become canonical \r\n\r\nAs far as detectability, I think I was a bit unclear. If the relay withholds a payment, it is very easy to detect that they did, because they have to withhold it for a long time, rather than for just a few seconds in the current scheme, but this does not mean that we can easily detect *why* they withheld it, which is crucial to determining who's at fault, from an outside perspective. This is because the relay is entrusted by builders with not releasing payments for signed headers which are received late, so them withholding it can be malicious but can also just be prescribed behavior caused by a late proposer. \r\nAll of this to say that even with unconditional payments it does not become significantly easier (or at all, I think?) to monitor relays for malicious behavior\r\n\r\nI guess the issue really comes from the fact that payments can't be (and aren't) unconditional. The condition is that the proposer sends a signed header in time, and someone has to enforce it. In PBS, that would be a committee, and here it has to be relays\r\n\r\n> Trying to summarize your point:\r\n> \r\n> 1. the 'unconditional payment' model still requires a relay (otherwise proposers can seriously attack builders which would likely lead to builders only working with trusted proposers).\r\n> 2. because it does still require a relay, proposers are still subject to withholding attacks from relays but, as opposed to block-body-withholding this payment-withholding attack is more detectable.\r\n> 3. the current system has a 1/n trust model for proposers accepting bids from relays. more specifically, a proposer can select a bid it has seen from n relays, and then would just need 1 out of n relays to reveal the body. in the 'unconditional payment' model, this 1/n property stops existing.\r\n\r\n1. If you didn't have a relay, either builders act as their own relays (as in, the proposer still don't get to see the payload and instead sign a header), in which case proposers can only work with trusted builders, or proposers receive full payloads and we have the problem you mentioned. Basically one of the two sides has to be trusted, and we only get to choose which one, unless we put a bilaterally trusted entity in the middle.\r\n2. As mentioned above, unfortunately it doesn't really help that it is detectable, because it's not necessarily malicious behavior, and detecting whether it is is still hard.\r\n3. I guess that whether the 1/n property keeps existing or not would depend on the implementation, one could still do this in a way where the same payment is given to multiple relays (but can only be executed once), so proposers have the same kind of guarantee. Not really better ones though, which would be the point of \"unconditional\" payments! They still need to trust that at least one relay is honest, and the signed header still needs to reach relays quickly enough for them to be ok with releasing the payment. The only situation in which they are a bit more protected is if relays are very slow at releasing what they have, which would be ok if it's the payment but not ok if it's the payload. So we don't gain much for the proposers, but make it much less builder-friendly.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1125088767/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1144334016",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1144334016",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1144334016,
    "node_id": "IC_kwDOGZSKs85ENSbA",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-06-02T01:52:45Z",
    "updated_at": "2022-06-02T01:52:45Z",
    "author_association": "COLLABORATOR",
    "body": "\r\n\r\n\r\n> @terencechain : great point! however in my mind the builder had access to the block gossip layer, why do you assume they don't?\r\n> \r\n> if they did, i imagine a participating builder would essentially monitor the network for a signed header from the proposer and verify if it matches their own. in case it does, they would then gossip the body. Going something like:\r\n> \r\n> 1. **proposer**Â --`get_header`-->Â **relay**\r\n> 2. **relay**Â --`header`-->Â **proposer**\r\n> 3. _proposer signs header_\r\n> 4. **proposer**Â --`get_payload`-->Â (p2p network)\r\n> 5. **builder**Â --`payload`-->Â (p2p network)\r\n> 6. _proposer validates payload_\r\n> 7. _proposer gossips the block_\r\n\r\nApology, I meant builder or relay don't have gossip implemented today, but they do plan to have it one day? The above interaction will work if they have gossip layers. There are also a few options.\r\n\r\nThe proposer and builder need to implement a payload header and payload gossip protocol in this option. We don't have this today. One pro is proposer gets to validate the payload with local EE before gossiping out the block although this endures extra latency for everyone else to receive the block\r\n```\r\nproposer --get_payload--> (p2p network)\r\nbuilder --payload--> (p2p network)\r\nproposer validates payload\r\nproposer gossips the block\r\n```\r\n\r\nIn this option, the proposer will gossip out the signed blinded block, and when the builder sees it, the builder will gossip the signed full block. It's faster and doesn't require additional gossip implementations for payload. The trade-off is proposer will not be able to validate the block using local EE before gossip\r\n```\r\nproposer --signed_blinded_block--> (p2p network)\r\nbuilder --signed_block--> (p2p network)\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1144334016/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1166713854",
    "html_url": "https://github.com/flashbots/mev-boost/issues/109#issuecomment-1166713854",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/109",
    "id": 1166713854,
    "node_id": "IC_kwDOGZSKs85FiqP-",
    "user": {
      "login": "obadiaa",
      "id": 19510814,
      "node_id": "MDQ6VXNlcjE5NTEwODE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19510814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/obadiaa",
      "html_url": "https://github.com/obadiaa",
      "followers_url": "https://api.github.com/users/obadiaa/followers",
      "following_url": "https://api.github.com/users/obadiaa/following{/other_user}",
      "gists_url": "https://api.github.com/users/obadiaa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/obadiaa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/obadiaa/subscriptions",
      "organizations_url": "https://api.github.com/users/obadiaa/orgs",
      "repos_url": "https://api.github.com/users/obadiaa/repos",
      "events_url": "https://api.github.com/users/obadiaa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/obadiaa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-06-27T01:16:21Z",
    "updated_at": "2022-06-27T01:16:21Z",
    "author_association": "COLLABORATOR",
    "body": "Hey! Thank you all for your comments and the several conversations on and offline on this topic.\r\n\r\nMy conclusion on this issue is the following: 'unconditional payments' is unlikely to be a good alternative because:\r\n- it has higher capital requirements on builders, not only from the need to escrow payments but also in order to preserve the same neat 1/n security property we have in the current system for proposers to mitigate against body-withdrawal issues (malicious or not). In particular, a builder would have to send payments to each relay it sends it body to. (thanks @fradamt !)\r\n- it likely has additional communication overhead or potential trouble linking up communication pipes appropriately. such problems could rear their head in p2p network delays, generally overhead from additional message passing between different entities or induced latency in other parts of the pbs workflow. (thanks @terencechain !)\r\n\r\non the plus side, such a design would\r\n- provide better privacy guarantees for builders since they wouldn't have to reveal block bodies to relays.\r\n- make byzantine behavior of relays more easily detectable because payments have to be withheld for longer, although it would still be difficult to determine whether it is a malicious relay, a relay performance issue, or a malicious proposer/proposer performance issue.\r\n\r\nIt's also worth noting:\r\n- the proposers would not directly benefit from this system. they could potentially indirectly benefit from it if it incentivizes builders to submit bodies they wouldn't have submitted otherwise, or if it helps mitigate against builder-relay integrations for privacy reasons.\r\n- the griefing attack vector on the builders still exists. \r\n- the payments in in-protocol PBS aren't unconditional, they still rely on a committee which replaces the relay. this is a mistake I made in the initial statement of the problem.\r\n\r\nOne potential avenue to explore is that this system could still exist in the proposer-builder abstraction, and it could be a service offered by relays to attract builders who are privacy-sensitive although it would add technical complexity to the system that would need to be understood better (payments, additional message passing, impact on the pbs workflow).\r\n\r\nI consider this issue closed for now but will keep it open for any additional comments from y'all, thanks again!",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1166713854/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  }
]
