{
  "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176",
  "repository_url": "https://api.github.com/repos/NomicFoundation/hardhat",
  "labels_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176/labels{/name}",
  "comments_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176/comments",
  "events_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176/events",
  "html_url": "https://github.com/NomicFoundation/hardhat/issues/2176",
  "id": 1084302459,
  "node_id": "I_kwDOB7jojM5AoSR7",
  "number": 2176,
  "title": "How to link library before deploying the contract in hardhat?",
  "user": {
    "login": "akachi1409",
    "id": 86838625,
    "node_id": "MDQ6VXNlcjg2ODM4NjI1",
    "avatar_url": "https://avatars.githubusercontent.com/u/86838625?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/akachi1409",
    "html_url": "https://github.com/akachi1409",
    "followers_url": "https://api.github.com/users/akachi1409/followers",
    "following_url": "https://api.github.com/users/akachi1409/following{/other_user}",
    "gists_url": "https://api.github.com/users/akachi1409/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/akachi1409/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/akachi1409/subscriptions",
    "organizations_url": "https://api.github.com/users/akachi1409/orgs",
    "repos_url": "https://api.github.com/users/akachi1409/repos",
    "events_url": "https://api.github.com/users/akachi1409/events{/privacy}",
    "received_events_url": "https://api.github.com/users/akachi1409/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": true,
  "assignee": {
    "login": "fvictorio",
    "id": 417134,
    "node_id": "MDQ6VXNlcjQxNzEzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/417134?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fvictorio",
    "html_url": "https://github.com/fvictorio",
    "followers_url": "https://api.github.com/users/fvictorio/followers",
    "following_url": "https://api.github.com/users/fvictorio/following{/other_user}",
    "gists_url": "https://api.github.com/users/fvictorio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fvictorio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fvictorio/subscriptions",
    "organizations_url": "https://api.github.com/users/fvictorio/orgs",
    "repos_url": "https://api.github.com/users/fvictorio/repos",
    "events_url": "https://api.github.com/users/fvictorio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fvictorio/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "fvictorio",
      "id": 417134,
      "node_id": "MDQ6VXNlcjQxNzEzNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417134?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fvictorio",
      "html_url": "https://github.com/fvictorio",
      "followers_url": "https://api.github.com/users/fvictorio/followers",
      "following_url": "https://api.github.com/users/fvictorio/following{/other_user}",
      "gists_url": "https://api.github.com/users/fvictorio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fvictorio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fvictorio/subscriptions",
      "organizations_url": "https://api.github.com/users/fvictorio/orgs",
      "repos_url": "https://api.github.com/users/fvictorio/repos",
      "events_url": "https://api.github.com/users/fvictorio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fvictorio/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2021-12-20T03:02:33Z",
  "updated_at": "2022-11-18T00:17:32Z",
  "closed_at": "2021-12-21T20:49:01Z",
  "author_association": "NONE",
  "active_lock_reason": "resolved",
  "body": "I am deploying the contract using Hardhat, and I get the link error below.\r\n\r\n![Screenshot_1](https://user-images.githubusercontent.com/86838625/146705596-f0e5a626-f453-417b-bd46-0a844fd2f4e2.png)\r\nAs you can check, IterableMapping library is not linked, though I have that library in the project.\r\n\r\nMaybe this is not the issue of Hardhat (because I failed to deploy it in Remix), but please help me how to link the library in Hardhat.\r\n\r\n```\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary IterableMapping {\r\n    // Iterable mapping from address to uint;\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address => uint256) values;\r\n        mapping(address => uint256) indexOf;\r\n        mapping(address => bool) inserted;\r\n    }\r\n\r\n    function get(Map storage map, address key) public view returns (uint256) {\r\n        return map.values[key];\r\n    }    \r\n    function getIndexOfKey(Map storage map, address key)public view returns (int256)\r\n    {\r\n        if (!map.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int256(map.indexOf[key]);\r\n    }    \r\n    function getKeyAtIndex(Map storage map, uint256 index) public view returns (address)\r\n    {\r\n        return map.keys[index];\r\n    }    \r\n    function size(Map storage map) public view returns (uint256) {\r\n        return map.keys.length;\r\n    }   \r\n    function set(\r\n        Map storage map,\r\n        address key,\r\n        uint256 val\r\n    ) public {\r\n        if (map.inserted[key]) {\r\n            map.values[key] = val;\r\n        } else {\r\n            map.inserted[key] = true;\r\n            map.values[key] = val;\r\n            map.indexOf[key] = map.keys.length;\r\n            map.keys.push(key);\r\n        }\r\n    }    \r\n    function remove(Map storage map, address key) public {\r\n        if (!map.inserted[key]) {\r\n            return;\r\n        }  \r\n        delete map.inserted[key];\r\n        delete map.values[key];\r\n        uint256 index = map.indexOf[key];\r\n        uint256 lastIndex = map.keys.length - 1;\r\n        address lastKey = map.keys[lastIndex];  \r\n        map.indexOf[lastKey] = index;\r\n        delete map.indexOf[key];    \r\n        map.keys[index] = lastKey;\r\n        map.keys.pop();\r\n    }\r\n}\r\n\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport './SafeMath.sol';\r\nimport './IterableMapping.sol';\r\n\r\ncontract NODERewardManagement {\r\n    using SafeMath for uint256;\r\n    using IterableMapping for IterableMapping.Map;\r\n\r\n    struct NodeEntity {string name;uint256 creationTime;uint256 lastClaimTime;uint256 rewardAvailable;}\r\n\r\n    IterableMapping.Map private nodeOwners;\r\n    mapping(address => NodeEntity[]) private _nodesOfUser;\r\n\r\n    uint256 public nodePrice;\r\n    uint256 public rewardPerNode;\r\n    uint256 public claimTime;\r\n    address public gateKeeper;\r\n    address public token;\r\n\r\n    bool public autoDistri = true;\r\n    bool public distribution = false;\r\n    uint256 public gasForDistribution = 300000;\r\n    uint256 public lastDistributionCount = 0;\r\n    uint256 public lastIndexProcessed = 0;\r\n    uint256 public totalNodesCreated = 0;\r\n    uint256 public totalRewardStaked = 0;\r\n\r\n    constructor(uint256 _nodePrice,uint256 _rewardPerNode,uint256 _claimTime) {\r\n        nodePrice = _nodePrice;\r\n        rewardPerNode = _rewardPerNode;\r\n        claimTime = _claimTime;\r\n        gateKeeper = msg.sender;\r\n    }\r\n\r\n    modifier onlySentry() {\r\n        require(msg.sender == token || msg.sender == gateKeeper, \"Fuck off\");\r\n        _;\r\n    }\r\n\r\n    function setToken (address token_) external onlySentry {\r\n        token = token_;\r\n    }\r\n\r\n    function distributeRewards(uint256 gas, uint256 rewardNode)private returns (uint256,uint256,uint256)\r\n    {\r\n        distribution = true;\r\n        uint256 numberOfnodeOwners = nodeOwners.keys.length;\r\n        require(numberOfnodeOwners > 0, \"DISTRI REWARDS: NO NODE OWNERS\");\r\n        if (numberOfnodeOwners == 0) {\r\n            return (0, 0, lastIndexProcessed);\r\n        }\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 newGasLeft;\r\n        uint256 localLastIndex = lastIndexProcessed;\r\n        uint256 iterations = 0;\r\n        uint256 newClaimTime = block.timestamp;\r\n        uint256 nodesCount;\r\n        uint256 claims = 0;\r\n        NodeEntity[] storage nodes;\r\n        NodeEntity storage _node;\r\n\r\n        while (gasUsed < gas && iterations < numberOfnodeOwners) {\r\n            localLastIndex++;\r\n            if (localLastIndex >= nodeOwners.keys.length) {\r\n                localLastIndex = 0;\r\n            }\r\n            nodes = _nodesOfUser[nodeOwners.keys[localLastIndex]];\r\n            nodesCount = nodes.length;\r\n            for (uint256 i = 0; i < nodesCount; i++) {\r\n                _node = nodes[i];\r\n                if (claimable(_node)) {\r\n                    _node.rewardAvailable += rewardNode;\r\n                    _node.lastClaimTime = newClaimTime;\r\n                    totalRewardStaked += rewardNode;\r\n                    claims++;\r\n                }\r\n            }\r\n            iterations++;\r\n            newGasLeft = gasleft();\r\n\r\n            if (gasLeft > newGasLeft) {\r\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n            }\r\n\r\n            gasLeft = newGasLeft;\r\n        }\r\n        lastIndexProcessed = localLastIndex;\r\n        distribution = false;\r\n        return (iterations, claims, lastIndexProcessed);\r\n    }\r\n\r\n    function createNode(address account, string memory nodeName) external onlySentry {\r\n        require(isNameAvailable(account, nodeName),\"CREATE NODE: Name not available\");\r\n        _nodesOfUser[account].push(NodeEntity({\r\n            name: nodeName,creationTime: block.timestamp,lastClaimTime: block.timestamp,rewardAvailable: rewardPerNode\r\n        }));\r\n        nodeOwners.set(account, _nodesOfUser[account].length);\r\n        totalNodesCreated++;\r\n        if (autoDistri && !distribution) {\r\n            distributeRewards(gasForDistribution, rewardPerNode);\r\n        }\r\n    }\r\n\r\n    function isNameAvailable(address account, string memory nodeName)private view returns (bool)\r\n    {\r\n        NodeEntity[] memory nodes = _nodesOfUser[account];\r\n        for (uint256 i = 0; i < nodes.length; i++) {\r\n            if (keccak256(bytes(nodes[i].name)) == keccak256(bytes(nodeName))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _burn(uint256 index) internal {\r\n        require(index < nodeOwners.size());\r\n        nodeOwners.remove(nodeOwners.getKeyAtIndex(index));\r\n    }\r\n\r\n    function _getNodeWithCreatime( NodeEntity[] storage nodes,uint256 _creationTime) private view returns (NodeEntity storage) {\r\n        uint256 numberOfNodes = nodes.length;\r\n        require(numberOfNodes > 0,\"CASHOUT ERROR: You don't have nodes to cash-out\");\r\n        bool found = false;\r\n        int256 index = binary_search(nodes, 0, numberOfNodes, _creationTime);\r\n        uint256 validIndex;\r\n        if (index >= 0) {\r\n            found = true;\r\n            validIndex = uint256(index);\r\n        }\r\n        require(found, \"NODE SEARCH: No NODE Found with this blocktime\");\r\n        return nodes[validIndex];\r\n    }\r\n\r\n    function binary_search(NodeEntity[] memory arr,uint256 low,uint256 high,uint256 x) private view returns (int256) {\r\n        if (high >= low) {\r\n            uint256 mid = (high + low).div(2);\r\n            if (arr[mid].creationTime == x) {\r\n                return int256(mid);\r\n            } else if (arr[mid].creationTime > x) {\r\n                return binary_search(arr, low, mid - 1, x);\r\n            } else {\r\n                return binary_search(arr, mid + 1, high, x);\r\n            }\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function _cashoutNodeReward(address account, uint256 _creationTime)external onlySentry returns (uint256)\r\n    {\r\n        require(_creationTime > 0, \"NODE: CREATIME must be higher than zero\");\r\n        NodeEntity[] storage nodes = _nodesOfUser[account];\r\n        uint256 numberOfNodes = nodes.length;\r\n        require(numberOfNodes > 0,\"CASHOUT ERROR: You don't have nodes to cash-out\");\r\n        NodeEntity storage node = _getNodeWithCreatime(nodes, _creationTime);\r\n        uint256 rewardNode = node.rewardAvailable;\r\n        node.rewardAvailable = 0;\r\n        return rewardNode;\r\n    }\r\n\r\n    function _cashoutAllNodesReward(address account)external onlySentry returns (uint256)\r\n    {\r\n        NodeEntity[] storage nodes = _nodesOfUser[account];\r\n        uint256 nodesCount = nodes.length;\r\n        require(nodesCount > 0, \"NODE: CREATIME must be higher than zero\");\r\n        NodeEntity storage _node;\r\n        uint256 rewardsTotal = 0;\r\n        for (uint256 i = 0; i < nodesCount; i++) {\r\n            _node = nodes[i];\r\n            rewardsTotal += _node.rewardAvailable;\r\n            _node.rewardAvailable = 0;\r\n        }\r\n        return rewardsTotal;\r\n    }\r\n\r\n    function claimable(NodeEntity memory node) private view returns (bool) {\r\n        return node.lastClaimTime + claimTime <= block.timestamp;\r\n    }\r\n\r\n    function _getRewardAmountOf(address account)external view returns (uint256)\r\n    {\r\n        require(isNodeOwner(account), \"GET REWARD OF: NO NODE OWNER\");\r\n        uint256 nodesCount;\r\n        uint256 rewardCount = 0;\r\n\r\n        NodeEntity[] storage nodes = _nodesOfUser[account];\r\n        nodesCount = nodes.length;\r\n        for (uint256 i = 0; i < nodesCount; i++) {\r\n            rewardCount += nodes[i].rewardAvailable;\r\n        }\r\n\r\n        return rewardCount;\r\n    }\r\n\r\n    function _getRewardAmountOf(address account, uint256 _creationTime)external view returns (uint256)\r\n    {\r\n        require(isNodeOwner(account), \"GET REWARD OF: NO NODE OWNER\");\r\n\r\n        require(_creationTime > 0, \"NODE: CREATIME must be higher than zero\");\r\n        NodeEntity[] storage nodes = _nodesOfUser[account];\r\n        uint256 numberOfNodes = nodes.length;\r\n        require(numberOfNodes > 0,\"CASHOUT ERROR: You don't have nodes to cash-out\");\r\n        NodeEntity storage node = _getNodeWithCreatime(nodes, _creationTime);\r\n        uint256 rewardNode = node.rewardAvailable;\r\n        return rewardNode;\r\n    }\r\n\r\n    function _getNodeRewardAmountOf(address account, uint256 creationTime)external view returns (uint256)\r\n    {\r\n        return _getNodeWithCreatime(_nodesOfUser[account], creationTime).rewardAvailable;\r\n    }\r\n\r\n    function _getNodesNames(address account)external view returns (string memory)\r\n    {\r\n        require(isNodeOwner(account), \"GET NAMES: NO NODE OWNER\");\r\n        NodeEntity[] memory nodes = _nodesOfUser[account];\r\n        uint256 nodesCount = nodes.length;\r\n        NodeEntity memory _node;\r\n        string memory names = nodes[0].name;\r\n        string memory separator = \"#\";\r\n        for (uint256 i = 1; i < nodesCount; i++) {\r\n            _node = nodes[i];\r\n            names = string(abi.encodePacked(names, separator, _node.name));\r\n        }\r\n        return names;\r\n    }\r\n\r\n    function _getNodesCreationTime(address account) external view returns (string memory)\r\n    {\r\n        require(isNodeOwner(account), \"GET CREATIME: NO NODE OWNER\");\r\n        NodeEntity[] memory nodes = _nodesOfUser[account];\r\n        uint256 nodesCount = nodes.length;\r\n        NodeEntity memory _node;\r\n        string memory _creationTimes = uint2str(nodes[0].creationTime);\r\n        string memory separator = \"#\";\r\n\r\n        for (uint256 i = 1; i < nodesCount; i++) {\r\n            _node = nodes[i];\r\n            _creationTimes = string(abi.encodePacked(_creationTimes,separator,uint2str(_node.creationTime)));\r\n        }\r\n        return _creationTimes;\r\n    }\r\n\r\n    function _getNodesRewardAvailable(address account)external view returns (string memory)\r\n    {\r\n        require(isNodeOwner(account), \"GET REWARD: NO NODE OWNER\");\r\n        NodeEntity[] memory nodes = _nodesOfUser[account];\r\n        uint256 nodesCount = nodes.length;\r\n        NodeEntity memory _node;\r\n        string memory _rewardsAvailable = uint2str(nodes[0].rewardAvailable);\r\n        string memory separator = \"#\";\r\n\r\n        for (uint256 i = 1; i < nodesCount; i++) {\r\n            _node = nodes[i];\r\n\r\n            _rewardsAvailable = string(abi.encodePacked(_rewardsAvailable, separator,uint2str(_node.rewardAvailable)));\r\n        }\r\n        return _rewardsAvailable;\r\n    }\r\n\r\n    function _getNodesLastClaimTime(address account)external view returns (string memory)\r\n    {\r\n        require(isNodeOwner(account), \"LAST CLAIME TIME: NO NODE OWNER\");\r\n        NodeEntity[] memory nodes = _nodesOfUser[account];\r\n        uint256 nodesCount = nodes.length;\r\n        NodeEntity memory _node;\r\n        string memory _lastClaimTimes = uint2str(nodes[0].lastClaimTime);\r\n        string memory separator = \"#\";\r\n\r\n        for (uint256 i = 1; i < nodesCount; i++) {\r\n            _node = nodes[i];\r\n            _lastClaimTimes = string(abi.encodePacked(_lastClaimTimes,separator,uint2str(_node.lastClaimTime)));\r\n        }\r\n        return _lastClaimTimes;\r\n    }\r\n\r\n    function uint2str(uint256 _i)internal pure returns (string memory _uintAsString)\r\n    {\r\n        if (_i == 0) {return \"0\";}\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) { len++;j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (_i != 0) { k = k - 1;\r\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1; _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function _changeNodePrice(uint256 newNodePrice) external onlySentry {\r\n        nodePrice = newNodePrice;\r\n    }\r\n\r\n    function _changeRewardPerNode(uint256 newPrice) external onlySentry {\r\n        rewardPerNode = newPrice;\r\n    }\r\n\r\n    function _changeClaimTime(uint256 newTime) external onlySentry {\r\n        claimTime = newTime;\r\n    }\r\n\r\n    function _changeAutoDistri(bool newMode) external onlySentry {\r\n        autoDistri = newMode;\r\n    }\r\n\r\n    function _changeGasDistri(uint256 newGasDistri) external onlySentry {\r\n        gasForDistribution = newGasDistri;\r\n    }\r\n\r\n    function _getNodeNumberOf(address account) public view returns (uint256) {\r\n        return nodeOwners.get(account);\r\n    }\r\n\r\n    function isNodeOwner(address account) private view returns (bool) {\r\n        return nodeOwners.get(account) > 0;\r\n    }\r\n\r\n    function _isNodeOwner(address account) external view returns (bool) {\r\n        return isNodeOwner(account);\r\n    }\r\n\r\n    function _distributeRewards() external  onlySentry returns (uint256, uint256,uint256)\r\n    {\r\n        return distributeRewards(gasForDistribution, rewardPerNode);\r\n    }\r\n}\r\n\r\n\r\n```\r\nThanks.",
  "closed_by": {
    "login": "fvictorio",
    "id": 417134,
    "node_id": "MDQ6VXNlcjQxNzEzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/417134?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fvictorio",
    "html_url": "https://github.com/fvictorio",
    "followers_url": "https://api.github.com/users/fvictorio/followers",
    "following_url": "https://api.github.com/users/fvictorio/following{/other_user}",
    "gists_url": "https://api.github.com/users/fvictorio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fvictorio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fvictorio/subscriptions",
    "organizations_url": "https://api.github.com/users/fvictorio/orgs",
    "repos_url": "https://api.github.com/users/fvictorio/repos",
    "events_url": "https://api.github.com/users/fvictorio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fvictorio/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/comments/999084568",
    "html_url": "https://github.com/NomicFoundation/hardhat/issues/2176#issuecomment-999084568",
    "issue_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176",
    "id": 999084568,
    "node_id": "IC_kwDOB7jojM47jNIY",
    "user": {
      "login": "fvictorio",
      "id": 417134,
      "node_id": "MDQ6VXNlcjQxNzEzNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417134?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fvictorio",
      "html_url": "https://github.com/fvictorio",
      "followers_url": "https://api.github.com/users/fvictorio/followers",
      "following_url": "https://api.github.com/users/fvictorio/following{/other_user}",
      "gists_url": "https://api.github.com/users/fvictorio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fvictorio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fvictorio/subscriptions",
      "organizations_url": "https://api.github.com/users/fvictorio/orgs",
      "repos_url": "https://api.github.com/users/fvictorio/repos",
      "events_url": "https://api.github.com/users/fvictorio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fvictorio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-21T20:49:01Z",
    "updated_at": "2021-12-21T20:49:01Z",
    "author_association": "MEMBER",
    "body": "Check this: https://hardhat.org/plugins/nomiclabs-hardhat-ethers.html#library-linking\r\n\r\nThis issue tracker is not a support channel. Please use [our Discord server](https://hardhat.org/discord) if you have more questions.",
    "reactions": {
      "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/comments/999084568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/comments/1166891958",
    "html_url": "https://github.com/NomicFoundation/hardhat/issues/2176#issuecomment-1166891958",
    "issue_url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/2176",
    "id": 1166891958,
    "node_id": "IC_kwDOB7jojM5FjVu2",
    "user": {
      "login": "webdev0305",
      "id": 65252823,
      "node_id": "MDQ6VXNlcjY1MjUyODIz",
      "avatar_url": "https://avatars.githubusercontent.com/u/65252823?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/webdev0305",
      "html_url": "https://github.com/webdev0305",
      "followers_url": "https://api.github.com/users/webdev0305/followers",
      "following_url": "https://api.github.com/users/webdev0305/following{/other_user}",
      "gists_url": "https://api.github.com/users/webdev0305/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/webdev0305/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/webdev0305/subscriptions",
      "organizations_url": "https://api.github.com/users/webdev0305/orgs",
      "repos_url": "https://api.github.com/users/webdev0305/repos",
      "events_url": "https://api.github.com/users/webdev0305/events{/privacy}",
      "received_events_url": "https://api.github.com/users/webdev0305/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-06-27T05:35:41Z",
    "updated_at": "2022-06-27T05:35:41Z",
    "author_association": "NONE",
    "body": "There is no solution?\r\nI have the same issue",
    "reactions": {
      "url": "https://api.github.com/repos/NomicFoundation/hardhat/issues/comments/1166891958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
