{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/4666",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/4666",
  "id": 1100613711,
  "node_id": "I_kwDOAq426M5BmghP",
  "number": 4666,
  "title": "ERC: Non-tradable Token Standard",
  "user": {
    "login": "omaraflak",
    "id": 6695348,
    "node_id": "MDQ6VXNlcjY2OTUzNDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6695348?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/omaraflak",
    "html_url": "https://github.com/omaraflak",
    "followers_url": "https://api.github.com/users/omaraflak/followers",
    "following_url": "https://api.github.com/users/omaraflak/following{/other_user}",
    "gists_url": "https://api.github.com/users/omaraflak/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/omaraflak/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/omaraflak/subscriptions",
    "organizations_url": "https://api.github.com/users/omaraflak/orgs",
    "repos_url": "https://api.github.com/users/omaraflak/repos",
    "events_url": "https://api.github.com/users/omaraflak/events{/privacy}",
    "received_events_url": "https://api.github.com/users/omaraflak/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2022-01-12T17:35:45Z",
  "updated_at": "2022-07-18T18:09:44Z",
  "closed_at": "2022-01-13T04:54:29Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "# Non-Tradable Token Standard\r\n\r\n| <!-- -->       | <!-- -->                                                                                                                        |\r\n|----------------|---------------------------------------------------------------------------------------------------------------------------------|\r\n| Title          | Non-Tradable Tokens                                                                                                             |\r\n| Description    | A standard interface for non-tradable tokens.                                                                                   |\r\n| EIP            | 4666                                                                                                                            |\r\n| Author         | [Omar Aflak](https://github.com/omaraflak)                                                                                      |\r\n| Contributors   | [Pol-Malo Le Bris](https://www.linkedin.com/in/pol-malo-le-bris-a251801a2/), [Marvin Martin](https://github.com/MarvinMartin24) |\r\n| Discussions-To | https://github.com/ethereum/eips/issues/4666                                                                                    |\r\n| Status         | Draft                                                                                                                           |\r\n| Type           | Standards Track                                                                                                                 |\r\n| Category       | ERC                                                                                                                             |\r\n| Created        | 2022-01-12                                                                                                                      |\r\n| Requires       | [165](https://eips.ethereum.org/EIPS/eip-165)                                                                                   |\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (TOC) -->\r\n- [Simple Summary](#simple-summary)\r\n- [Abstract](#abstract)\r\n- [Motivation](#motivation)\r\n- [Specification](#specification)\r\n  - [Extensions](#extensions)\r\n    - [Metadata](#metadata)\r\n    - [Delegation](#delegation)\r\n- [Rationale](#rationale)\r\n  - [On-chain vs Off-chain](#on-chain-vs-off-chain)\r\n- [Implementation](#implementation)\r\n  - [NTT](#ntt)\r\n  - [NTTDelegate](#nttdelegate)\r\n- [NTT for EIP ?](#ntt-for-eip-)\r\n- [Copyright](#copyright)\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n## Simple Summary\r\n\r\nA standard interface for <u>**non-tradable tokens**</u>, aka <u>**NTT**</u>s.\r\n\r\n## Abstract\r\n\r\nNTTs represent inherently personal possessions (material or immaterial), such as university diplomas, online training certificates, government issued documents (national id, driving licence, visa, wedding, etc.), badges, labels, and so on.\r\n\r\nAs the name implies, NTTs are not made to be traded or sold. They don't have monetary value. They only serve as a **proof of possession**.\r\n\r\n## Motivation\r\n\r\nUS, 2017, MIT published 111 diplomas on a blockchain. France, 2018, Carrefour multinational retail corporation used blockchain technology to certify the provenance of its chickens. South Korea, 2019, the state published 1 million driving licences on a blockchain-powered platform.\r\n\r\nEach of them made their own smart contracts, with different implementations. We think diplomas, food labels, or driving licences are just a subset of a more general type of tokens: **non-tradable tokens**. Tokens that represent certificates or labels that were granted to you by some authority.\r\n\r\nBy providing a common interface for this type of tokens, we allow more applications to be developed and we position blockchain technology as a standard gateway for verification of personal possessions.\r\n\r\n## Specification\r\n\r\nA single NTT contract, is seen as representing one type of badge by one authority. For instance, one NTT contract for MIT diplomas, one NTT contract for the state driving licences, and so on...\r\n\r\n* An address might possess multiple tokens, which are indexed.\r\n* An authority who delivers a certificate should be in position to invalidate it. Think of driving licences or weddings. However, it cannot delete your token.\r\n* The issuer of a token might be someone else than the contract creator.\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (CODE:syntax=solidity&src=./contracts/INTT.sol) -->\r\n<!-- The below code snippet is automatically added from ./contracts/INTT.sol -->\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\ninterface INTT is IERC165 {\r\n    /// @notice Count all tokens assigned to an owner\r\n    /// @param owner Address for whom to query the balance\r\n    /// @return Number of tokens owned by `owner`\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /// @notice Check if a token hasn't been invalidated\r\n    /// @param owner Address for whom to check the token validity\r\n    /// @param index Index of the token\r\n    /// @return True if the token is valid, False otherwise\r\n    function isValid(address owner, uint256 index) external view returns (bool);\r\n\r\n    /// @notice Get the issuer of a token\r\n    /// @param owner Address for whom to check the token issuer\r\n    /// @param owner Index of the token\r\n    /// @return Address of the issuer\r\n    function issuerOf(address owner, uint256 index) external view returns (address);\r\n}\r\n```\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n### Extensions\r\n\r\n#### Metadata\r\n\r\nAn interface allowing to add metadata linked to each token, as in ERC721.\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (CODE:syntax=solidity&src=./contracts/INTTMetadata.sol) -->\r\n<!-- The below code snippet is automatically added from ./contracts/INTTMetadata.sol -->\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface INTTMetadata {\r\n    /// @return Descriptive name of the tokens in this contract\r\n    function name() external view returns (string memory);\r\n\r\n    /// @return An abbreviated name of the tokens in this contract\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice URI to query to get the token's metadata\r\n    /// @param owner Address of the token's owner\r\n    /// @param index Index of the token\r\n    /// @return URI for the token\r\n    function tokenURI(address owner, uint256 index) external view returns (string memory);\r\n}\r\n```\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n#### Delegation\r\n\r\nAn interface to standardize delegation rights of token minting.\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (CODE:syntax=solidity&src=./contracts/INTTDelegate.sol) -->\r\n<!-- The below code snippet is automatically added from ./contracts/INTTDelegate.sol -->\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface INTTDelegate {\r\n    /// @notice Grant one-time minting right to `operator` for `owner`\r\n    /// An allowed operator can call the function to transfer rights.\r\n    /// @param operator Address allowed to mint a token\r\n    /// @param owner Address for whom `operator` is allowed to mint a token\r\n    function delegate(address operator, address owner) external;\r\n\r\n    /// @notice Grant one-time minting right to a list of `operators` for a corresponding list of `owners`\r\n    /// An allowed operator can call the function to transfer rights.\r\n    /// @param operators Addresses allowed to mint\r\n    /// @param owners Addresses for whom `operators` are allowed to mint a token\r\n    function delegateBatch(address[] memory operators, address[] memory owners) external;\r\n\r\n    /// @notice Mint a token. Caller must have the right to mint for the owner.\r\n    /// @param owner Address for whom the token is minted\r\n    function mint(address owner) external;\r\n\r\n    /// @notice Mint tokens to multiple addresses. Caller must have the right to mint for all owners.\r\n    /// @param owners Addresses for whom the tokens are minted\r\n    function mintBatch(address[] memory owners) external;\r\n}\r\n```\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n## Rationale\r\n\r\n### On-chain vs Off-chain\r\n\r\nA decision was made to keep the data off-chain (via `tokenURI()`) for two main reasons: \r\n* Non-Tradable Tokens represent personal possessions. Therefore, there might be cases where the data should be encrypted. The standard should not outline decisions about encryption because there are just so many ways this could be done, and every possibility is specific to the use-case.\r\n* Non-Tradable Tokens must stay generic. There could have been a possibility to make a `MetadataStore` holding the data of NTTs in an elegant way, unfortunately we would have needed a support for generics in solidity (or struct inheritance), which is not available today.\r\n\r\n## Implementation\r\n\r\n### NTT\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (CODE:syntax=solidity&src=./contracts/NTT.sol) -->\r\n<!-- The below code snippet is automatically added from ./contracts/NTT.sol -->\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nimport \"./INTT.sol\";\r\nimport \"./INTTMetadata.sol\";\r\n\r\nabstract contract NTT is INTT, INTTMetadata, ERC165 {\r\n    // Token data\r\n    struct Token {\r\n        address issuer;\r\n        bool valid;\r\n    }\r\n\r\n    // Mapping from owner to tokens\r\n    mapping (address => Token[]) private _balances;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Contract creator\r\n    address private _creator;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _creator = msg.sender;\r\n    }\r\n\r\n    /// @notice Count all tokens assigned to an owner\r\n    /// @param owner Address for whom to query the balance\r\n    /// @return Number of tokens owned by `owner`\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"balance query for the zero address\");\r\n        return _balances[owner].length;\r\n    }\r\n\r\n    /// @notice Check if a token is hasn't been invalidated\r\n    /// @param owner Address for whom to check the token validity\r\n    /// @return True if the token is valid, false otherwise\r\n    function isValid(address owner, uint256 index) public view virtual override returns (bool) {\r\n        return _getTokenOrRevert(owner, index).valid;\r\n    }\r\n\r\n    /// @notice Get the issuer of a token\r\n    /// @param owner Address for whom to check the token issuer\r\n    /// @param owner Index of the token\r\n    /// @return Address of the issuer\r\n    function issuerOf(address owner, uint256 index) public view virtual override returns (address) {\r\n        return _getTokenOrRevert(owner, index).issuer;\r\n    }\r\n\r\n    /// @notice Get all the tokens of an account\r\n    /// @param owner Address for whom to get the tokens\r\n    /// @return Array of tokens\r\n    function tokensOf(address owner) public view virtual returns (Token[] memory) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /// @return Descriptive name of the tokens in this contract\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /// @return An abbreviated name of the tokens in this contract\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /// @notice URI to query to get the token's metadata\r\n    /// @param owner Address of the token's owner\r\n    /// @param index Index of the token\r\n    /// @return URI for the token\r\n    function tokenURI(address owner, uint256 index) public view virtual override returns (string memory) {\r\n        _getTokenOrRevert(owner, index);\r\n        bytes memory baseURI = bytes(_baseURI());\r\n        if (baseURI.length > 0) {\r\n            return string(abi.encodePacked(baseURI, tokenId(owner, index)));\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /// @param owner Address of the token's owner\r\n    /// @param index Index of the token\r\n    /// @return A unique identifier for that token\r\n    function tokenId(address owner, uint256 index) public pure virtual returns (string memory) {\r\n        return string(abi.encodePacked(\r\n            Strings.toHexString(uint256(uint160(owner)), 20),\r\n            Strings.toHexString(index, 32)\r\n        ));\r\n    }\r\n\r\n    /// @notice Check if a given address owns a valid token\r\n    /// @param owner Address for whom to check\r\n    /// @return True if `owner` has a valid token, false otherwise\r\n    function hasValidToken(address owner) external view virtual returns (bool) {\r\n        Token[] storage tokens = _balances[owner];\r\n        for (uint i=0; i<tokens.length; i++) {\r\n            if (tokens[i].valid) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return \r\n            interfaceId == type(INTT).interfaceId ||\r\n            interfaceId == type(INTTMetadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @notice Prefix for all calls to tokenURI\r\n    /// @return Common base URI for all token\r\n    function _baseURI() internal pure virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @notice Mark the token as invalidated\r\n    /// @param owner Address for whom to invalidate the token\r\n    function _invalidate(address owner, uint256 index) internal virtual {\r\n        Token storage token = _getTokenOrRevert(owner, index);\r\n        token.valid = false;\r\n    }\r\n\r\n    /// @notice Mint a new token\r\n    /// @param owner Address for whom to assign the token\r\n    function _mint(address owner) internal virtual {\r\n        Token[] storage tokens = _balances[owner];\r\n        tokens.push(Token(msg.sender, true));\r\n    }\r\n\r\n    /// @return True if the caller is the contract's creator, false otherwise\r\n    function _isCreator() internal view virtual returns (bool) {\r\n        return msg.sender == _creator;\r\n    }\r\n\r\n    /// @notice Retrieve a Token or revert if it does not exist\r\n    /// @param owner Address of the token's owner\r\n    /// @param index Index of the token\r\n    /// @return The Token struct\r\n    function _getTokenOrRevert(address owner, uint256 index) private view returns (Token storage) {\r\n        Token[] storage tokens = _balances[owner];\r\n        require(index < tokens.length, \"NTT does not exist\");\r\n        return tokens[index];\r\n    }\r\n}\r\n```\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n### NTTDelegate\r\n\r\n<!-- AUTO-GENERATED-CONTENT:START (CODE:syntax=solidity&src=./contracts/NTTDelegate.sol) -->\r\n<!-- The below code snippet is automatically added from ./contracts/NTTDelegate.sol -->\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./INTTDelegate.sol\";\r\nimport \"./NTT.sol\";\r\n\r\nabstract contract NTTDelegate is NTT, INTTDelegate {\r\n    // Mapping from operator to list of owners\r\n    mapping (address => mapping(address => bool)) _allowed;\r\n\r\n    /// @notice Grant one-time minting right to `operator` for `owner`\r\n    /// An allowed operator can call the function to transfer rights.\r\n    /// @param operator Address allowed to mint a token\r\n    /// @param owner Address for whom `operator` is allowed to mint a token\r\n    function delegate(address operator, address owner) public virtual override {\r\n        _delegateAsDelegateOrCreator(operator, owner, _isCreator());\r\n    }\r\n\r\n    /// @notice Grant one-time minting right to a list of `operators` for a corresponding list of `owners`\r\n    /// An allowed operator can call the function to transfer rights.\r\n    /// @param operators Addresses allowed to mint a token\r\n    /// @param owners Addresses for whom `operators` are allowed to mint a token\r\n    function delegateBatch(address[] memory operators, address[] memory owners) public virtual override {\r\n        require(operators.length == owners.length, \"operators and owners must have the same length\");\r\n        bool isCreator = _isCreator();\r\n        for (uint i=0; i<operators.length; i++) {\r\n            _delegateAsDelegateOrCreator(operators[i], owners[i], isCreator);\r\n        }\r\n    }\r\n\r\n    /// @notice Mint a token. Caller must have the right to mint for the owner.\r\n    /// @param owner Address for whom the token is minted\r\n    function mint(address owner) public virtual override {\r\n        _mintAsDelegateOrCreator(owner, _isCreator());\r\n    }\r\n\r\n    /// @notice Mint tokens to multiple addresses. Caller must have the right to mint for all owners.\r\n    /// @param owners Addresses for whom the tokens are minted\r\n    function mintBatch(address[] memory owners) public virtual override {\r\n        bool isCreator = _isCreator();\r\n        for (uint i=0 ; i<owners.length; i++) {\r\n            _mintAsDelegateOrCreator(owners[i], isCreator);\r\n        }\r\n    }\r\n\r\n    /// @notice Check if an operator is a delegate for a given address\r\n    /// @param operator Address of the operator\r\n    /// @param owner Address of the token's owner\r\n    /// @return True if the `operator` is a delegate for `owner`, false otherwise\r\n    function isDelegate(address operator, address owner) public view returns (bool) {\r\n        return _allowed[operator][owner];\r\n    }\r\n\r\n    /// @notice Check if you are a delegate for a given address\r\n    /// @param owner Address of the token's owner\r\n    /// @return True if the caller is a delegate for `owner`, false otherwise\r\n    function isDelegateOf(address owner) public view returns (bool) {\r\n        return isDelegate(msg.sender, owner);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(NTT) returns (bool) {\r\n        return \r\n            interfaceId == type(INTTDelegate).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _delegateAsDelegateOrCreator(address operator, address owner, bool isCreator) private {\r\n        require(\r\n            isCreator || _allowed[msg.sender][owner],\r\n            \"Only contract creator or allowed operator can delegate\"\r\n        );\r\n        if (!isCreator) {\r\n            _allowed[msg.sender][owner] = false;\r\n        }\r\n        _allowed[operator][owner] = true;\r\n    }\r\n\r\n    function _mintAsDelegateOrCreator(address owner, bool isCreator) private {\r\n        require(\r\n            isCreator || _allowed[msg.sender][owner],\r\n            \"Only contract creator or allowed operator can mint\"\r\n        );\r\n        if (!isCreator) {\r\n            _allowed[msg.sender][owner] = false;\r\n        }\r\n        _mint(owner);\r\n    }\r\n}\r\n```\r\n<!-- AUTO-GENERATED-CONTENT:END -->\r\n\r\n## NTT for EIP ?\r\n\r\nAs a first NTT, why not create the **EIP Creator Badge** ? An NTT created by the Ethereum foundation, and attributed to EIP-standard creators ? 🙂\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./NTT.sol\";\r\n\r\ncontract EIPCreatorBadge is NTT {\r\n    constructor() NTT(\"EIP Creator Badge\", \"EIP\") {}\r\n\r\n    function giveThatManABadge(address owner) external {\r\n        require(_isCreator(), \"You must be the contract creator\");\r\n        _mint(owner);\r\n    }\r\n\r\n    function _baseURI() internal pure override returns (string memory) {\r\n        return \"https://eips.ethereum.org/ntt/\";\r\n    }\r\n}\r\n```\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/4666/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1011795620",
    "html_url": "https://github.com/ethereum/EIPs/issues/4666#issuecomment-1011795620",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666",
    "id": 1011795620,
    "node_id": "IC_kwDOAq426M48Tsak",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-13T04:54:29Z",
    "updated_at": "2022-01-13T04:54:29Z",
    "author_association": "MEMBER",
    "body": "Per the bot comment, this should either be moved to the Magicians forum for discussion, or a draft EIP should be created in this repository.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1011795620/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1011919562",
    "html_url": "https://github.com/ethereum/EIPs/issues/4666#issuecomment-1011919562",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/4666",
    "id": 1011919562,
    "node_id": "IC_kwDOAq426M48UKrK",
    "user": {
      "login": "omaraflak",
      "id": 6695348,
      "node_id": "MDQ6VXNlcjY2OTUzNDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6695348?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/omaraflak",
      "html_url": "https://github.com/omaraflak",
      "followers_url": "https://api.github.com/users/omaraflak/followers",
      "following_url": "https://api.github.com/users/omaraflak/following{/other_user}",
      "gists_url": "https://api.github.com/users/omaraflak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/omaraflak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/omaraflak/subscriptions",
      "organizations_url": "https://api.github.com/users/omaraflak/orgs",
      "repos_url": "https://api.github.com/users/omaraflak/repos",
      "events_url": "https://api.github.com/users/omaraflak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/omaraflak/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-13T08:45:41Z",
    "updated_at": "2022-01-13T11:05:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "# **Discussion:** https://ethereum-magicians.org/t/eip-4671-non-tradable-token/7976?u=omaraflak\r\n# **Pull Request:** https://github.com/ethereum/EIPs/pull/4671",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1011919562/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
