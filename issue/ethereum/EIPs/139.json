{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/139/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/139/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/139/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/139",
  "id": 172200821,
  "node_id": "MDU6SXNzdWUxNzIyMDA4MjE=",
  "number": 139,
  "title": "EIP new opcode \"codehash\"",
  "user": {
    "login": "wanderer",
    "id": 158211,
    "node_id": "MDQ6VXNlcjE1ODIxMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wanderer",
    "html_url": "https://github.com/wanderer",
    "followers_url": "https://api.github.com/users/wanderer/followers",
    "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
    "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
    "organizations_url": "https://api.github.com/users/wanderer/orgs",
    "repos_url": "https://api.github.com/users/wanderer/repos",
    "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wanderer/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 32,
  "created_at": "2016-08-19T19:14:50Z",
  "updated_at": "2016-09-09T14:35:46Z",
  "closed_at": "2016-09-02T15:22:12Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Overview\n\nAdds a new opcode `CODEHASH`. This opcode returns the codeHash of an account given its address.\n# Specification\n\nThe proposed value for this opcode is  `0xa5`.\n\nThis opcode pushes the hash of an account  to the stack, given the account's address. The account's address is pop from the stack. If the account doesn't exist then it push `0` to the stack  pops a single item from the stack.\n# Rationale\n\nThis helps complete the set of getter operation for accounts. The other getter operations are\n`EXTCODECOPY`, `EXTCODESIZE`, `BALANCE`.\n\nThe usecase for this opcode is for typechecking on the contract level. For example if you wanted to build a subcurrency that didn't have a central register account. The contract would need to know that it was sending units to an contract of a valid type.\n\nConsider the following pseudocode.  This contract has to function `spend` and `receive`. The `spend` function need to check that it is \"talking\" to a contract of the same type. \n\n```\nconst validType = \"0xsomehash\"\n\nfunction spend (to, amount) {\n    if(CODEHASH(to) === validType) {\n         storage['balance'] -= amount\n         to.receive(amount)\n    }\n} \n\nfunction receive (amount) {\n    if(CODEHASH(from) === validType) {\n      storage['balance'] += amount\n    }\n} \n```\n\nThis should enable us to build shard proof subcurrencies since it would allow contracts that interact with a limited subtree of the state independently of the global knowledge of the contract. This would be useful in light client's applications as well as. \n",
  "closed_by": {
    "login": "wanderer",
    "id": 158211,
    "node_id": "MDQ6VXNlcjE1ODIxMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wanderer",
    "html_url": "https://github.com/wanderer",
    "followers_url": "https://api.github.com/users/wanderer/followers",
    "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
    "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
    "organizations_url": "https://api.github.com/users/wanderer/orgs",
    "repos_url": "https://api.github.com/users/wanderer/repos",
    "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wanderer/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/139/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/139/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241119397",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241119397",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241119397,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTExOTM5Nw==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-19T19:57:28Z",
    "updated_at": "2016-08-19T20:28:17Z",
    "author_association": "MEMBER",
    "body": "I was writing a similar contract snippet to calculate code hash with `EXTCODECOPY` + `SHA3` as part of a pre-call verification of the recipient.\n\nSince there's no streaming `SHA3` in that case the memory equalling to `EXTCODESIZE` needs to be allocated. It can be too expensive paying for per-word memory expansion, per-word codecopy fee and per-word hashing fees.\n\nOne more use case: when linking with libraries (which are executed via `DELEGATECALL`) the call could ensure there's no mismatch between the required and the actually used library.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241119397/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241171854",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241171854",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241171854,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTE3MTg1NA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T01:57:05Z",
    "updated_at": "2016-08-20T01:57:05Z",
    "author_association": "MEMBER",
    "body": "It would be great if we could also get information about the contract init code, that would actually allow proper reasoning or type checking of contracts, because we often do not only need the functionality of a contract but also its current or at least initial state. Luckily, with metropolis, we might be able to achieve that: The address of a contracts is the hash of its init code. Still, we are not 100% there, because the init code also contains the constructor parameters and we might want to allow some variability there.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241171854/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241185085",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241185085",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241185085,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTE4NTA4NQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T07:32:33Z",
    "updated_at": "2016-08-20T07:32:33Z",
    "author_association": "MEMBER",
    "body": "While I've got no particular objection to the opcode being added, I don't see the use-case as compelling. Requiring a specific code hash severely restricts interoperability, while not proving anything about the contract's state, so in many cases it's still insufficient. In cases where you absolutely must trust the code you're calling, proof-of-ancestry seems more useful.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241185085/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241201021",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241201021",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241201021,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwMTAyMQ==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T13:46:40Z",
    "updated_at": "2016-08-20T13:47:08Z",
    "author_association": "MEMBER",
    "body": "@Arachnid \n\n> while not proving anything about the contract's state\n\nyep. There is a difference between the contract's code and the are state of a contract. And I think they should be different opcodes. Also getting stateroots is harder to do from an implementation perspective.\n\n>  I don't see the use-case as compelling. \n\nWhat prompted this EIP was thinking about sub-currencies that shard proof. Which I would argue is a good use case. If you build naive subcurrency contract  you would create a single contract that simply creates a ledge in its Storage.  If this was on shard `A` but you lived on shard `B` then you wouldn't want to talk to shard `A` every time you moved around  the subcurrency.  \n\nAnother way at looking at this is thinking about it in terms of UTXOs.  This would allow you to build contracts, where every individual instance of the contract was like an UTXO.  \n\nThere are several ways of solving these problem. But I think this is an elegant way of doing it and minimally invasive to implementations since implementation would be exactly the same as `BALANCE` except we are now getting the 4th item from RLP account array, instead of the first.\n\n> Requiring a specific code hash severely restricts interoperability\n\nyou could check multiple hashes. valid hash types could be set by the parent contract. There are multiple ways to make this reactive.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241201021/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241203396",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241203396",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241203396,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwMzM5Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T14:33:52Z",
    "updated_at": "2016-08-20T14:33:52Z",
    "author_association": "MEMBER",
    "body": "> What prompted this EIP was thinking about sub-currencies that shard proof. Which I would argue is a good use case. If you build naive subcurrency contract you would create a single contract that simply creates a ledge in its Storage. If this was on shard A but you lived on shard B then you wouldn't want to talk to shard A every time you moved around the subcurrency.\n\nI think you're going to have to elaborate a bit on how being able to determine the code hash helps with that - I don't follow at all.\n\n> you could check multiple hashes. valid hash types could be set by the parent contract. There are multiple ways to make this reactive.\n\nOnly interacting with certain code makes for an extremely inflexible system, though; much of the value of Ethereum, and the Internet as a whole, comes from permissionless innovation, which this completely shuts down.\n\nIf your security model absolutely requires you to trust the code you're interacting with, there are alternatives that don't require any EVM modifications; the simplest is proof-of-ancestry. Given a factory contract that creates instances of the contract you care about, you can trivially verify that a contract is descended from it by hashing the factory's address with the creation nonce of the child contract, and verifying it matches the contract's address. Unlike checking the code hash, this also lets you make assertions about the entire state of the target contract.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241203396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241204772",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241204772",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241204772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNDc3Mg==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:00:05Z",
    "updated_at": "2016-08-20T15:02:39Z",
    "author_association": "MEMBER",
    "body": "> Given a factory contract \n\nIf there are shards, then there would be a different  factory contract on each contract. Furthermore let's say a new instance of the contract is created everytime its used in which case generating the address from the factory's address could be 10,000 of hashes. But for simplicity just assume there are no factory contracts\n\n> alternatives that don't require any EVM modifications;\n\nLets say we have subcurrency contract like the initial example. It has a simple `send`, `receive`. How does instance `A` send some units to instance  `B` without breaking the integrity of the overall contract?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241204772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241204977",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241204977",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241204977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNDk3Nw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:03:31Z",
    "updated_at": "2016-08-20T15:03:31Z",
    "author_association": "MEMBER",
    "body": "> If there are shards, then there would be a different factory contract on each contract.\n\nYes, but as you already pointed out, it's no problem to check several addresses.\n\n> Furthermore let's say a new instance of the contract is created everytime its used in which case generating the address from the factory's address could be 10,000 of hashes.\n\nYou only need one hash, if the factory contract keeps track of how many contracts it's created, and provides the nonce to the created contract for use in proofs.\n\n> Now lets say we have subcurrency contract like the initial example. It has a simple send, receive. How does instance A send some units to instance B without breaking the integrity of the overall contract?\n\nI don't know, how? That's exactly what I was asking for an explanation of.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241204977/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241205613",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241205613",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241205613,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNTYxMw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:15:28Z",
    "updated_at": "2016-08-20T15:15:28Z",
    "author_association": "MEMBER",
    "body": "> You only need one hash, if the factory contract keeps track of how many contracts it's created, and provides the nonce to the created contract for use in proofs.\n\nok contract `A` creates `B`, `B` creates `C`, `D` creates `F` and so on, and to `Z` How does `Z`. how does `A` generate `Z`s address?\n\n> I don't know, how? That's exactly what I was asking for an explanation of.\n\nwell one way  is if you had `codeHash`. `A` would check if `B` is running the correct code. \n\n```\nfunction spend (to, amount) {\n    if(CODEHASH(to) === validType) {\n         storage['balance'] -= amount\n         to.receive(amount)\n    }\n} \n```\n\nThis would prevent units being added or subtracted to contract (which is compose of many instances) by any third party contract.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241205613/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207021",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241207021",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241207021,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNzAyMQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:42:52Z",
    "updated_at": "2016-08-20T15:42:52Z",
    "author_association": "MEMBER",
    "body": "> ok contract A creates B, B creates C, D creates F and so on, and to Z How does Z. how does A generate Zs address?\n\nIt doesn't - A generates all the contracts, and B through Z call it for new instances.\n\n> This would prevent units being added or subtracted to contract (which is compose of many instances) by any third party contract.\n\nIf you're checking only the codehash, then the contract needs to be written so that no set of stored data can \"sway it from its appointed course\" - for instance, I could create a contract that gives me a massive preloaded balance, then use it to call contracts on other shards to hand over their tokens. From this perspective, checking code hash is simultaneously too restrictive, since it prohibits innovation, and too lax.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207021/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207516",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241207516",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241207516,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNzUxNg==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:51:30Z",
    "updated_at": "2016-08-20T15:53:27Z",
    "author_association": "MEMBER",
    "body": "> If you're checking only the codehash, then the contract needs to be written so that no set of stored data can \"sway it from its appointed course\" - for instance, I could create a contract that gives me a massive preloaded balance, then use it to call contracts on other shards to hand over their tokens\n\nyep as @chriseth pointed out.  One way around is to have the contract check its parent's codeHash. There maybe some other hacky ways around this But it would be nice to get more guarantees about the starting state.  \n\n> checking code hash is simultaneously too restrictive, since it prohibits innovation, and too lax.\n\nwhat is a counter proposal/idea then? \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207516/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207665",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241207665",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241207665,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwNzY2NQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T15:54:17Z",
    "updated_at": "2016-08-20T15:54:17Z",
    "author_association": "MEMBER",
    "body": "> Provide a counter proposal then\n\nI just did exactly that - factory contracts, and the ability to prove a contract was generated by a factory. But I think the real solution is, wherever possible, authoring contracts so that they don't have to rely on knowing what code another contract is running - as I stated earlier, all the best innovation is permissionless.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241207665/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241208165",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241208165",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241208165,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwODE2NQ==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T16:03:33Z",
    "updated_at": "2016-08-20T16:07:10Z",
    "author_association": "MEMBER",
    "body": "> factory contracts, \n\nRight, the whole point is that we are trying NOT to use single factory contracts. \n\n> all the best innovation is permissionless.\n\nok. I'll just take your word on that. Is checking signatures to spend funds permissionless? If that is permissionless then why would checking signatures and checking a codeHash to spend funds not be permissionless?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241208165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241208494",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241208494",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241208494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwODQ5NA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T16:09:51Z",
    "updated_at": "2016-08-20T16:09:51Z",
    "author_association": "MEMBER",
    "body": "> Right, the whole point is that we are trying NOT to use single factory contracts.\n\nWhy not?\n\n> ok. I'll just take your word on that. Is checking signatures to spend funds permissionless? If that is permissionless then why would checking signatures and checking a codeHash to spend funds not be permissionless?\n\nBy \"permissionless\" I mean \"permissionless innovation\" - you don't need to ask someone else in order to build on top of their stack. Open APIs such as HTTP, OAUTH, and the standardized token contract are examples of that. Requiring someone to add the code hash for your contract to a whitelist is an example of the opposite.\n\nIf you need to seek permission before doing something new, it becomes enormously harder to do new and interesting things.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241208494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241209756",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241209756",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241209756,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIwOTc1Ng==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T16:33:58Z",
    "updated_at": "2016-08-20T16:47:23Z",
    "author_association": "MEMBER",
    "body": "> Why not?\n\n1) Shards. Since contracts don't have to phone home to the factory contract. \n2) ephemeral contracts that emulate UTXO  \n\n>  permissionless innovation\n\nIm defining the \"contract\" as a Set of contracts that are all running the same code. Each instance stands for one account. To transfer funds between accounts you need to check codeHash. But to trigger a unit transfer or to interact with a contract in other ways could be done via an permissionless API or an interface the contract provides. Only internal operations need to check. Let me  update the example so that it has an external permissionless API as well as the the internal interface\n\nAlso I made a mistake in the original example that might be causing confusion\n\n```\nconst validType = \"0xsomehash\"\n\nfunction spend (to, amount) {\n     if(msg.caller == storage['owner'] &&  storage['balance'] > amount){\n        storage['balance'] -= amount\n        this.internal_spend(to, amount)\n     }\n} \n\nfunction internal_spend(to, amount) {\n    if(CODEHASH(to) === validType) {\n         storage['balance'] -= amount\n         to.internal_receive(amount)\n    }\n} \n\nfunction internal_receive (amount) {\n    if(CODEHASH(from) === validType) {\n      storage['balance'] += amount\n    }\n} \n```\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241209756/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241213215",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241213215",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241213215,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTIxMzIxNQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-20T17:35:11Z",
    "updated_at": "2016-08-20T17:35:11Z",
    "author_association": "MEMBER",
    "body": "> 1) Shards. Since contracts don't have to phone home to the factory contract. \n\nWith proof-of-ancestry with hashing, that's not necessary even with sharding. It might require having one factory address per shard, though it seems likely that whatever mechanism is used to generate addresses on different shards will be deterministic, and thus still permit the same approach with a single parent hash.\n\n> 2) ephemeral contracts that emulate UTXO\n\nThis seems entirely practical with a factory contract too, although it's not clear to me why you'd need to prove the code of such a contract, rather than its ancestry.\n\n> Im defining the \"contract\" as a Set of contracts that are all running the same code. Each instance stands for one account. \n\nOkay; fair enough.\n\n> To transfer funds between accounts you need to check codeHash. \n\nProving ancestry still seems like a better option to me, since it lets you make assertions about the contract's state as well as its code.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241213215/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241412415",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-241412415",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 241412415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTQxMjQxNQ==",
    "user": {
      "login": "nmushegian",
      "id": 924397,
      "node_id": "MDQ6VXNlcjkyNDM5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/924397?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nmushegian",
      "html_url": "https://github.com/nmushegian",
      "followers_url": "https://api.github.com/users/nmushegian/followers",
      "following_url": "https://api.github.com/users/nmushegian/following{/other_user}",
      "gists_url": "https://api.github.com/users/nmushegian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nmushegian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nmushegian/subscriptions",
      "organizations_url": "https://api.github.com/users/nmushegian/orgs",
      "repos_url": "https://api.github.com/users/nmushegian/repos",
      "events_url": "https://api.github.com/users/nmushegian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nmushegian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-22T13:29:23Z",
    "updated_at": "2016-08-22T13:29:55Z",
    "author_association": "NONE",
    "body": "CODEHASH would let you do \"short-circuits\" in the \"what is the type of this address\" proof for some cases, which is interesting, but I agree that it's not really enough on its own and IMO people shouldn't use it as a shortcut for having a whole type-factory model\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/241412415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244329702",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244329702",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244329702,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDMyOTcwMg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T09:36:03Z",
    "updated_at": "2016-09-02T09:36:03Z",
    "author_association": "MEMBER",
    "body": "While this might have limited applications, it can be still very useful in certain cases and given it is already available to the state, it would make sense making it available to EVM.\n\nProof of ancestry might become more complicated when contract address calculation changes (Serenity?) because multiple ways (the current and the new) of calculating an address must be checked.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244329702/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244330701",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244330701",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244330701,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDMzMDcwMQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T09:40:56Z",
    "updated_at": "2016-09-02T09:40:56Z",
    "author_association": "MEMBER",
    "body": "> While this might have limited applications, it can be still very useful in certain cases and given it is already available to the state, it would make sense making it available to EVM.\n\nWhile I still haven't heard a truly compelling use-case, I agree that it's probably worth adding because it's easily available in the state, and may prove useful.\n\n> Proof of ancestry might become more complicated when contract address calculation changes (Serenity?) because multiple ways (the current and the new) of calculating an address must be checked.\n\nIf you get to handwave away checking initial state, I get to handwave away address calculations maybe changing. ;)\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244330701/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244334212",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244334212",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244334212,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDMzNDIxMg==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T09:56:42Z",
    "updated_at": "2016-09-02T09:56:42Z",
    "author_association": "MEMBER",
    "body": "`CODEHASH` will also allow to check if an account exits. Gas cost of `CALL` depends on it.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244334212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244339142",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244339142",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244339142,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDMzOTE0Mg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T10:21:20Z",
    "updated_at": "2016-09-02T10:21:20Z",
    "author_association": "MEMBER",
    "body": "> CODEHASH will also allow to check if an account exits. Gas cost of CALL depends on it.\n\n`EXTCODESIZE` could already be used for that.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244339142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244344465",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244344465",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244344465,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0NDQ2NQ==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T10:50:19Z",
    "updated_at": "2016-09-02T10:50:46Z",
    "author_association": "MEMBER",
    "body": "@axic Actually not, because an account can be in any of 5 states:\n- not exists, no executable code, code size 0\n- exists, no executable code, code size 0\n- exists, executable code, size > 0\n- not exists, executable code, code size 0\n- exists, executable code, code size 0.\n\nAs you can see \"code size\" property does not match \"exists\" property.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244344465/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244344677",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244344677",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244344677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0NDY3Nw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T10:51:27Z",
    "updated_at": "2016-09-02T10:51:27Z",
    "author_association": "MEMBER",
    "body": "But all accounts with code size 0 will have the same hash, so how is `CODEHASH` an improvement?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244344677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244346773",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244346773",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244346773,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0Njc3Mw==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:03:34Z",
    "updated_at": "2016-09-02T11:03:34Z",
    "author_association": "MEMBER",
    "body": "As I understand this `CODEHASH` of an existing account with empty code is Keccak(\"\") and `CODEHASH` of non-existing account is 0. Right?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244346773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244347076",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244347076",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244347076,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0NzA3Ng==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:05:17Z",
    "updated_at": "2016-09-02T11:05:17Z",
    "author_association": "MEMBER",
    "body": "> As I understand this CODEHASH of an existing account with empty code is Keccak(\"\") and CODEHASH of non-existing account is 0. Right?\n\nYes, it should be `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470` for empty and `0` for non-existent.\n\nSo it is definitely an improvement.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244347076/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244347537",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244347537",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244347537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0NzUzNw==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:08:08Z",
    "updated_at": "2016-09-02T11:08:08Z",
    "author_association": "MEMBER",
    "body": "The mess is always around precompiled contracts (last 2 states) as we allowed them to be non-existing but still usable.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244347537/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244348550",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244348550",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244348550,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0ODU1MA==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:14:12Z",
    "updated_at": "2016-09-02T11:14:12Z",
    "author_association": "MEMBER",
    "body": "Aren't they existing just with codesize 0? Otherwise the empty account call fee would be charged every time.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244348550/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349000",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244349000",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244349000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0OTAwMA==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:16:53Z",
    "updated_at": "2016-09-02T11:16:53Z",
    "author_association": "MEMBER",
    "body": "Empty account call fee is charged the first time called (globally). Unless you create them in the genesis block.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349000/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349359",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244349359",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244349359,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0OTM1OQ==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:19:03Z",
    "updated_at": "2016-09-02T11:19:03Z",
    "author_association": "MEMBER",
    "body": "Yes, but that is an edge case as part of the network creation users are instructed to do this. In ethereumjs-vm it is done every time so for example browser-solidity  gas costs won't be confusing.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349359/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349806",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244349806",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244349806,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM0OTgwNg==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:21:44Z",
    "updated_at": "2016-09-02T11:21:44Z",
    "author_association": "MEMBER",
    "body": "It is edge case, but VM implementations have to handle edge cases.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244349806/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244350924",
    "html_url": "https://github.com/ethereum/EIPs/issues/139#issuecomment-244350924",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/139",
    "id": 244350924,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NDM1MDkyNA==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-02T11:29:00Z",
    "updated_at": "2016-09-02T11:29:00Z",
    "author_association": "MEMBER",
    "body": "> It is edge case, but VM implementations have to handle edge cases.\n\nI don't think it affects the VM, only contracts. Before precompiles are included in the state, `codehash` will return `0`, otherwise `c5d246...`. It is only a problem to contracts, but they already face that with the higher fee they might not be expecting.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/244350924/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
