{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/225/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/225/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/225/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/225",
  "id": 212094213,
  "node_id": "MDU6SXNzdWUyMTIwOTQyMTM=",
  "number": 225,
  "title": "Clique PoA protocol & Rinkeby PoA testnet",
  "user": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3539577331,
      "node_id": "LA_kwDOAq426M7S-anz",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/discussions-to",
      "name": "discussions-to",
      "color": "20DFB1",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": true,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 123,
  "created_at": "2017-03-06T11:24:17Z",
  "updated_at": "2023-02-24T18:41:59Z",
  "closed_at": "2022-06-10T08:32:27Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Changelog:\r\n\r\n * **Apr 4, 2017**:\r\n   * Mention the cascading proposal-execution corner case and its avoidance.\r\n * **Mar 14, 2017**:\r\n   * Expanded the Clique block authorization section, added a strategy proposal.\r\n   * Expanded the Clique signer voting section, added a strategy proposal.\r\n * **Mar 13, 2017**:\r\n   * Polished up the constants in the Clique consensus protocol spec.\r\n   * Added the two difficulty values and described in-turn/out-of-turn signing.\r\n * **Mar 11, 2017**:\r\n   * Added initial technical specs for the Clique PoA consensus protocol.\r\n   * Added checkpointing to reset votes and embed the list of signers into epoch headers.\r\n   * Reintroduced authorized signer vanity extra-data as a fixed 32 byte allowance.\r\n * **Mar 6, 2017**\r\n   * First proposal of the Rinkeby testnet and its PoA implementation ideas.\r\n\r\n# Clique proof-of-authority consensus protocol\r\n\r\n*Note, for the background and rationale behind the proposed proof-of-authority consensus protocol, please read the sections after this technical specification. I've placed this on top to have an easy to find reference for implementers without having to dig through the discussions.*\r\n\r\nWe define the following constants:\r\n\r\n * **`EPOCH_LENGTH`**: Number of blocks after which to checkpoint and reset the pending votes.\r\n   * Suggested `30000` for the testnet to remain analogous to the mainnet `ethash` epoch.\r\n * **`BLOCK_PERIOD`**: Minimum difference between two consecutive block's timestamps.\r\n   * Suggested `15s` for the testnet to remain analogous to the mainnet `ethash` target.\r\n * **`EXTRA_VANITY`**: Fixed number of extra-data prefix bytes reserved for signer *vanity*.\r\n   * Suggested `32 bytes` to retain the current extra-data allowance and/or use.\r\n * **`EXTRA_SEAL`**: Fixed number of extra-data suffix bytes reserved for signer seal.\r\n   * `65 bytes` fixed as signatures are based on the standard `secp256k1` curve.\r\n * **`NONCE_AUTH`**: Magic nonce number `0xffffffffffffffff` to vote on adding a new signer.\r\n * **`NONCE_DROP`**: Magic nonce number `0x0000000000000000` to vote on removing a signer.\r\n * **`UNCLE_HASH`**: Always `Keccak256(RLP([]))` as uncles are meaningless outside of PoW.\r\n * **`DIFF_NOTURN`**: Block score (difficulty) for blocks containing out-of-turn signatures.\r\n   * Suggested `1` since it just needs to be an arbitrary baseline constant.\r\n * **`DIFF_INTURN`**: Block score (difficulty) for blocks containing in-turn signatures.\r\n   * Suggested `2` to show a slight preference over out-of-turn signatures.\r\n\r\nWe also define the following per-block constants:\r\n\r\n * **`BLOCK_NUMBER`**: Block height in the chain, where the height of the genesis is block `0`.\r\n * **`SIGNER_COUNT`**: Number of authorized signers valid at a particular instance in the chain.\r\n * **`SIGNER_INDEX`**: Index of the block signer in the sorted list of current authorized signers.\r\n * **`SIGNER_LIMIT`**: Number of consecutive blocks out of which a signer may only sign one.\r\n   * Must be `floor(SIGNER_COUNT / 2) + 1` to enforce majority consensus on a chain.\r\n\r\nWe repurpose the `ethash` header fields as follows:\r\n\r\n * **`beneficiary`**: Address to propose modifying the list of authorized signers with.\r\n   * Should be filled with zeroes normally, modified only while voting.\r\n   * Arbitrary values are permitted nonetheless (even meaningless ones such as voting out non signers) to avoid extra complexity in implementations around voting mechanics.\r\n   * **Must** be filled with zeroes on checkpoint (i.e. epoch transition) blocks.\r\n * **`nonce`**: Signer proposal regarding the account defined by the `beneficiary` field.\r\n   * Should be **`NONCE_DROP`** to propose deauthorizing `beneficiary` as a existing signer.\r\n   * Should be **`NONCE_AUTH`** to propose authorizing `beneficiary` as a new signer.\r\n   * **Must** be filled with zeroes on checkpoint (i.e. epoch transition) blocks.\r\n   * **Must** not take up any other value apart from the two above (for now).\r\n * **`extraData`**: Combined field for signer vanity, checkpointing and signer signatures.\r\n   * First **`EXTRA_VANITY`** bytes (fixed) may contain arbitrary signer vanity data.\r\n   * Last **`EXTRA_SEAL`** bytes (fixed) is the signer's signature sealing the header.\r\n   * Checkpoint blocks **must** contain a list of signers (`N*20 bytes`) in between, **omitted** otherwise.\r\n   * The list of signers in checkpoint block extra-data sections **must** be sorted in ascending order.\r\n * **`mixHash`**: Reserved for fork protection logic, similar to the extra-data during the DAO.\r\n   * **Must** be filled with zeroes during normal operation.\r\n * **`ommersHash`**: **Must** be **`UNCLE_HASH`** as uncles are meaningless outside of PoW.\r\n * **`timestamp`**: **Must** be at least the parent timestamp + **`BLOCK_PERIOD`**.\r\n * **`difficulty`**: Contains the standalone score of the block to derive the quality of a chain.\r\n   * **Must** be **`DIFF_NOTURN`** if `BLOCK_NUMBER % SIGNER_COUNT != SIGNER_INDEX`\r\n   * **Must** be **`DIFF_INTURN`** if `BLOCK_NUMBER % SIGNER_COUNT == SIGNER_INDEX`\r\n\r\n## Authorizing a block\r\n\r\nTo authorize a block for the network, the signer needs to sign the block's hash containing **everything except the signature itself**. The means that the hash contains every field of the header (`nonce` and `mixDigest` included), and also the  `extraData` with the exception of the 65 byte signature suffix. The fields are hashed in the order of their definition in the yellow paper.\r\n\r\nThis hash is signed using the standard `secp256k1` curve, and the resulting 65 byte signature (`R`, `S`, `V`, where `V` is `0` or `1`) is embedded into the `extraData` as the trailing 65 byte suffix.\r\n\r\nTo ensure malicious signers (loss of signing key) cannot wreck havoc in the network, each singer is allowed to sign **maximum one** out of **`SIGNER_LIMIT`** consecutive blocks. The order is not fixed, but in-turn signing weighs more (**`DIFF_INTURN`**) than out of turn one (**`DIFF_NOTURN`**).\r\n\r\n### Authorization strategies\r\n\r\nAs long as signers conform to the above specs, they can authorize and distribute blocks as they see fit. The following suggested strategy will however reduce network traffic and small forks, so it's a suggested feature:\r\n\r\n * If a signer is allowed to sign a block (is on the authorized list and didn't sign recently).\r\n   * Calculate the optimal signing time of the next block (parent + **`BLOCK_PERIOD`**).\r\n   * If the signer is in-turn, wait for the exact time to arrive, sign and broadcast immediately.\r\n   * If the signer is out-of-turn, delay signing by `rand(SIGNER_COUNT * 500ms)`.\r\n\r\nThis small strategy will ensure that the in-turn signer (who's block weighs more) has a slight advantage to sign and propagate versus the out-of-turn signers. Also the scheme allows a bit of scale with the increase of the number of signers.\r\n\r\n## Voting on signers\r\n\r\nEvery epoch transition (genesis block included) acts as a stateless checkpoint, from which capable clients should be able to sync without requiring any previous state. This means epoch headers **must not** contain votes, all non settled votes are discarded, and tallying starts from scratch.\r\n\r\nFor all non-epoch transition blocks:\r\n\r\n * Signers may cast one vote per own block to propose a change to the authorization list.\r\n * Only the latest proposal per target beneficiary is kept from a single signer.\r\n * Votes are tallied live as the chain progresses (concurrent proposals allowed).\r\n * Proposals reaching majority consensus **`SIGNER_LIMIT`** come into effect immediately.\r\n * Invalid proposals are **not** to be penalized for client implementation simplicity.\r\n\r\n**A proposal coming into effect entails discarding all pending votes for that proposal (both for and against) and starting with a clean slate.**\r\n\r\n### Cascading votes\r\n\r\nA complex corner case may arise during signer deauthorization. When a previously authorized signer is dropped, the number of signers required to approve a proposal might decrease by one. This might cause one or more pending proposals to reach majority consensus, the execution of which might further cascade into new proposals passing.\r\n\r\nHandling this scenario is non obvious when multiple conflicting proposals pass simultaneously (e.g. add a new signer vs. drop an existing one), where the evaluation order might drastically change the outcome of the final authorization list. Since signers may invert their own votes in every block they mint, it's not so obvious which proposal would be \"first\".\r\n\r\nTo avoid the pitfalls cascading executions would entail, the Clique proposal explicitly forbids cascading effects. In other words: **Only the `beneficiary` of the current header/vote may be added to/dropped from the authorization list. If that causes other proposals to reach consensus, those will be executed when their respective beneficiaries are \"touched\" again (given that majority consensus still holds at that point).**\r\n\r\n### Voting strategies\r\n\r\nSince the blockchain can have small reorgs, a naive voting mechanism of \"cast-and-forget\" may not be optimal, since a block containing a singleton vote may not end up on the final chain.\r\n\r\nA simplistic but working strategy is to allow users to configure \"proposals\" on the signers (e.g. \"add 0x...\", \"drop 0x...\"). The signing code can then pick a random proposal for every block it signs and inject it. This ensures that multiple concurrent proposals as well as reorgs get eventually noted on the chain.\r\n\r\nThis list may be expired after a certain number of blocks / epochs, but it's important to realize that \"seeing\" a proposal pass doesn't mean it won't get reorged, so it should not be immediately dropped when the proposal passes.\r\n\r\n# Background\r\n\r\nEthereum's first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot.\r\n\r\nRopsten was thus born, clearing out all the junk and starting with a clean slate. This ran well until the end of February 2017, when malicious actors decided to abuse the low PoW and gradually inflate the block gas limits to 9 billion (from the normal 4.7 million), at which point sending in gigantic transactions crippling the entire network. Even before that, attackers attempted multiple extremely long reorgs, causing network splits between different clients, and even different versions.\r\n\r\nThe root cause of these attacks is that a PoW network is only as secure as the computing capacity placed behind it. Restarting a new testnet from zero wouldn't solve anything, since the attacker can mount the same attack over and over again. The Parity team decided to go with an emergency solution of rolling back a significant number of blocks, and enacting a soft-fork rule that disallows gas limits above a certain threshold.\r\n\r\nWhile this solution may work in the short term:\r\n\r\n * It's not elegant: Ethereum supposed to have dynamic block limits\r\n * It's not portable: other clients need to implement new fork logic themselves\r\n * It's not compatible with sync modes: fast and light clients are both out of luck\r\n * It's just prolonging the attacks: junk can still be steadily pushed in ad infinitum\r\n \r\nParity's solution although not perfect, is nonetheless workable. I'd like to propose a longer term alternative solution, which is more involved, yet should be simple enough to allow rolling out in a reasonable amount of time.\r\n\r\n# Standardized proof-of-authority\r\n\r\nAs reasoned above, proof-of-work cannot work securely in a network with no value. Ethereum has its long term goal of proof-of-stake based on Casper, but that is heavy research so we cannot rely on that any time soon to fix today's problems. One solution however is easy enough to implement, yet effective enough to fix the testnet properly, namely a proof-of-authority scheme.\r\n\r\n*Note, Parity does have an [implementation of PoA](https://github.com/ethcore/parity/wiki/Consensus-Engines#authority-round), though it seems more complex than needed and without much documentation on the protocol, it's hard to see how it could play along with other clients. I welcome feedback from them on this proposal from their experience.*\r\n\r\nThe main design goals of the PoA protocol described here is that it should be very simple to implement and embed into any existing Ethereum client, while at the same time allow using existing sync technologies (fast, light, warp) without needing client developers to add custom logic to critical software.\r\n\r\n## Proof-of-authority 101\r\n\r\nFor those not aware of how PoA works, it's a very simplistic protocol, where instead of miners racing to find a solution to a difficult problem, authorized signers can at any time at their own discretion create new blocks.\r\n\r\nThe challenges revolve around how to control minting frequency, how to distribute minting load (and opportunity) between the various signers and how to dynamically adapt the list of signers. The next section defines a proposed protocol to handle all these scenarios.\r\n\r\n## Rinkeby proof-of-authority\r\n\r\nThere are two approaches to syncing a blockchain in general:\r\n\r\n * The classical approach is to take the genesis block and crunch through all the transactions one by one. This is tried and proven, but in Ethereum complexity networks quickly turns out to be very costly computationally.\r\n * The other is to only download the chain of block headers and verify their validity, after which point an arbitrary recent state may be downloaded from the network and checked against recent headers.\r\n \r\nA PoA scheme is based on the idea that blocks may only be minted by trusted signers. As such, every block (or header) that a client sees can be matched against the list of trusted signers. The challenge here is how to maintain a list of authorized signers that can change in time? The obvious answer (store it in an Ethereum contract) is also the wrong answer: fast, light and warp sync don't have access to the state during syncing.\r\n\r\n**The protocol of maintaining the list of authorized signers must be fully contained in the block headers.**\r\n\r\nThe next obvious idea would be to change the structure of the block headers so it drops the notions of PoW, and introduces new fields to cater for voting mechanisms. This is also the wrong answer: changing such a core data structure in multiple implementations would be a nightmare development, maintenance and security wise.\r\n\r\n**The protocol of maintaining the list of authorized signers must fit fully into the current data models.**\r\n\r\nSo, according to the above, we can't use the EVM for voting, rather have to resort to headers. And we can't change header fields, rather have to resort to the currently available ones. Not much wiggle room.\r\n\r\n### Repurposing header fields for signing and voting\r\n\r\nThe most obvious field that currently is used solely as *fun metadata* is the 32 byte **extra-data** section in block headers. Miners usually place their client and version in there, but some fill it with alternative \"messages\". The protocol would extend this field ~~to~~ with 65 bytes with the purpose of a secp256k1 miner signature. This would allow anyone obtaining a block to verify it against a list of authorized signers. It also makes the **miner** section in block headers obsolete (since the address can be derived from the signature).\r\n\r\n*Note, changing the length of a header field is a non invasive operation as all code (such as RLP encoding, hashing) is agnostic to that, so clients wouldn't need custom logic.*\r\n\r\nThe above is enough to validate a chain, but how can we update a dynamic list of signers. The answer is that we can repurpose the newly obsoleted **miner** field and the PoA obsoleted **nonce** field to create a voting protocol:\r\n\r\n * During regular blocks, both of these fields would be set to zero.\r\n * If a signer wishes to enact a change to the list of authorized signers, it will:\r\n   * Set the **miner** to the signer it wishes to vote about\r\n   * Set the **nonce** to `0` or `0xff...f` to vote in favor of adding or kicking out\r\n   \r\nAny clients syncing the chain can \"tally\" up the votes during block processing, and maintain a dynamically changing list of authorized signers by popular vote. ~~The initial set of signers can be given as genesis chain parameters (to avoid the complexity of deploying an \"initial voters list\" contract in the genesis state).~~\r\n\r\nTo avoid having an infinite window to tally up votes in, and also to allow periodically flushing stale proposals, we can reuse the concept of an epoch from ethash, where every epoch transition flushes all pending votes. Furthermore, these epoch transitions can also act as stateless checkpoints containing the list of current authorized signers within the header extra-data. This permits clients to sync up based only on a checkpoint hash without having to replay all the voting that was done on the chain up to that point. It also allows the genesis header to fully define the chain, containing the list of initial signers.\r\n\r\n### Attack vector: Malicious signer\r\n\r\nIt may happen that a malicious user gets added to the list of signers, or that a signer key/machine is compromised. In such a scenario the protocol needs to be able to defend itself against reorganizations and spamming. The proposed solution is that given a list of N authorized signers, any signer may only mint 1 block out of every K. This ensures that damage is limited, and the remainder of the miners can vote out the malicious user.\r\n\r\n### Attack vector: Censoring signer\r\n\r\nAnother interesting attack vector is if a signer (or group of signers) attempts to censor out blocks that vote on removing them from the authorization list. To work around this, we restrict the allowed minting frequency of signers to 1 out of N/2. This ensures that malicious signers need to control at least 51% of signing accounts, at which case it's game over anyway.\r\n\r\n### Attack vector: Spamming signer\r\n\r\nA final small attack vector is that of malicious signers injecting new vote proposals inside every block they mint. Since nodes need to tally up all votes to create the actual list of authorized signers, they need to track all votes through time. Without placing a limit on the vote window, this could grow slowly, yet unbounded. The solution is to place a ~~moving~~ window of W blocks after which votes are considered stale. ~~A sane window might be 1-2 epochs.~~ We'll call this an epoch.\r\n\r\n### Attack vector: Concurrent blocks\r\n\r\nIf the number of authorized signers are N, and we allow each signer to mint 1 block out of K, then at any point in time N-K+1 miners are allowed to mint. To avoid these racing for blocks, every signer would add a small random \"offset\" to the time it releases a new block. This ensures that small forks are rare, but occasionally still happen (as on the main net). If a signer is caught abusing it's authority and causing chaos, it can be voted out.\r\n\r\n# Notes\r\n\r\n**Does this suggest we use a *censored* testnet?**\r\n\r\nSo and so. The proposal suggests that given the malicious nature of certain actors and given the weakness of the PoW scheme in a \"monopoly money\" network, it is better to have a network with a bit of spam filtering enabled that developers can rely on to test their programs vs. to have a wild wild west chain that dies due to its uselessness.\r\n\r\n**Why standardize proof-of-authority?**\r\n\r\nDifferent clients are better at different scenarios. Go may be awesome in capable server side environments, but CPP may be better suited to run on an RPI Zero. Having a possibility to mix clients in private environments too would be a net win for the ecosystem, as well as being able to participate in a single spamless testnet would be a win for everyone at large.\r\n\r\n**Doesn't manual voting get messy?**\r\n\r\nThis is an implementation detail, but signers may implement contract based voting strategy leveraging the full capabilities of the EVM, only pushing the results into the headers for average nodes to verify.\r\n\r\n# Clarifications and feedback\r\n\r\n  * This proposal does not rule out clients running a PoW based testnet side by side, whether Ropsten or a new one based on it. The ideal scenario would be that clients provide a way to attach to both PoW as well as PoA based test networks (https://github.com/ethereum/EIPs/issues/225#issuecomment-284378473).\r\n * The protocol parameters although can be made configurable at client implementers' discression, the Rinkeby network should be as close to the main network as possible. That includes dynamic gas limits, variable block times around 15 seconds, gas prices and such (https://github.com/ethereum/EIPs/issues/225#issuecomment-284380575).\r\n * The scheme requires that at least K signers are online at any time, since that is the minimum number required to ensure \"minting\" diversity. This means that if more than K drop off, the network stalls. This should be solved by ensuring the signers are high-uptime machines and failing ones should be voted out in a timely fashion before too many failures occur (https://github.com/ethereum/EIPs/issues/225#issuecomment-284413381).\r\n * The proposal does not address \"legitimate\" spam, as in an attacker validly spending testnet ether to create junk, however without PoW mining, an attacker may not be able to obtain infinite ether to mount the attack in the first place. One possibility would be to have a faucet giving out ether based on GitHub (or whatever else) accounts in a limited fashion (e.g. 10 / day) (https://github.com/ethereum/EIPs/issues/225#issuecomment-284436932).\r\n * A suggestion was made to create checkpoint blocks for every epoch that contains a list of authorized signers at that point in time. This would allow light clients at a later point to say \"sync from here\" without needing to start from the genesis. This could be added to the extradata field as a prefix before the signature (https://github.com/ethereum/EIPs/issues/225#issuecomment-284725467).",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/225/reactions",
    "total_count": 81,
    "+1": 70,
    "-1": 0,
    "laugh": 0,
    "hooray": 5,
    "confused": 0,
    "heart": 6,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/225/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284378473",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284378473",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284378473,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDM3ODQ3Mw==",
    "user": {
      "login": "miohtama",
      "id": 49922,
      "node_id": "MDQ6VXNlcjQ5OTIy",
      "avatar_url": "https://avatars.githubusercontent.com/u/49922?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/miohtama",
      "html_url": "https://github.com/miohtama",
      "followers_url": "https://api.github.com/users/miohtama/followers",
      "following_url": "https://api.github.com/users/miohtama/following{/other_user}",
      "gists_url": "https://api.github.com/users/miohtama/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/miohtama/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/miohtama/subscriptions",
      "organizations_url": "https://api.github.com/users/miohtama/orgs",
      "repos_url": "https://api.github.com/users/miohtama/repos",
      "events_url": "https://api.github.com/users/miohtama/events{/privacy}",
      "received_events_url": "https://api.github.com/users/miohtama/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T12:04:05Z",
    "updated_at": "2017-03-06T12:04:31Z",
    "author_association": "NONE",
    "body": "As the word _censored_ is in cursive, I'd like to point out that while this proposal proposes a new public testnet with less decentralized characteristics, it's possible for anyone to run their own PoW testnet. Then you bear the infrastructure cost of doing so and the proposal does not limit your ability for this any way. This has been true from Ethereum day zero, as Ethereum clients have been very user friendly for running your private testnet.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284378473/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284379186",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284379186",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284379186,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDM3OTE4Ng==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T12:07:51Z",
    "updated_at": "2017-03-06T12:07:51Z",
    "author_association": "MEMBER",
    "body": "Just to add on that, the proposal also does not restrict clients to run this exclusively. The proposal can run side-by-side with the current testnet, so users would be free to chose between the PoW Ropsten or the PoA Rinkeby.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284379186/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284380575",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284380575",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284380575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDM4MDU3NQ==",
    "user": {
      "login": "christoph2806",
      "id": 431015,
      "node_id": "MDQ6VXNlcjQzMTAxNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/431015?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christoph2806",
      "html_url": "https://github.com/christoph2806",
      "followers_url": "https://api.github.com/users/christoph2806/followers",
      "following_url": "https://api.github.com/users/christoph2806/following{/other_user}",
      "gists_url": "https://api.github.com/users/christoph2806/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christoph2806/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christoph2806/subscriptions",
      "organizations_url": "https://api.github.com/users/christoph2806/orgs",
      "repos_url": "https://api.github.com/users/christoph2806/repos",
      "events_url": "https://api.github.com/users/christoph2806/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christoph2806/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T12:15:02Z",
    "updated_at": "2017-03-06T12:15:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "We greatly support this approach! As a DApp Developer, we urgently need a *public* safe and reliable testnet, which obviously cannot be secured by PoW. DApps are beginning to interact heavily - only to mention status.im, metamask, uport, or other wallets - and only on a broadly accepted public testnet all projects will be present and able to test dependencies to others. For similar reasons, the new testnet should be as similar as possible to the mainnet - only then it can serve as a valid reference for developement. I'd prefer:\r\n- similar gas limit\r\n- similar block time\r\n- similar gas price \r\n- and for each parameter, a similar statistical distribution\r\nonly then you can consider an application which runs on testnet as \"tested\". \r\nI appreciate the parity solution with kovan, because it gives some relief for short term, but I would like to encourage all involved parties to work together on a shared solution.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284380575/reactions",
      "total_count": 19,
      "+1": 19,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284382299",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284382299",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284382299,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDM4MjI5OQ==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T12:24:32Z",
    "updated_at": "2017-03-06T12:24:32Z",
    "author_association": "MEMBER",
    "body": "@christoph2806 Definitely, added to the proposal's clarification section.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284382299/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284413381",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284413381",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284413381,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQxMzM4MQ==",
    "user": {
      "login": "Nashatyrev",
      "id": 8173857,
      "node_id": "MDQ6VXNlcjgxNzM4NTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8173857?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Nashatyrev",
      "html_url": "https://github.com/Nashatyrev",
      "followers_url": "https://api.github.com/users/Nashatyrev/followers",
      "following_url": "https://api.github.com/users/Nashatyrev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Nashatyrev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Nashatyrev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Nashatyrev/subscriptions",
      "organizations_url": "https://api.github.com/users/Nashatyrev/orgs",
      "repos_url": "https://api.github.com/users/Nashatyrev/repos",
      "events_url": "https://api.github.com/users/Nashatyrev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Nashatyrev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T14:37:44Z",
    "updated_at": "2017-03-06T14:37:44Z",
    "author_association": "MEMBER",
    "body": "With time some signers can go offline. Couldn't it be the case when at some block all of (N-K) signers who can mint the next block are stale and the network stuck?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284413381/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284419556",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284419556",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284419556,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQxOTU1Ng==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T14:59:25Z",
    "updated_at": "2017-03-06T14:59:25Z",
    "author_association": "MEMBER",
    "body": "For my proposal the network operators should ensure that stale signers are removed/replaced in a timely fashion. For testnet purposes this would probably be only a handful of signers that we can guarantee uptime.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284419556/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284436932",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284436932",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284436932,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQzNjkzMg==",
    "user": {
      "login": "hrishikeshio",
      "id": 1659870,
      "node_id": "MDQ6VXNlcjE2NTk4NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1659870?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hrishikeshio",
      "html_url": "https://github.com/hrishikeshio",
      "followers_url": "https://api.github.com/users/hrishikeshio/followers",
      "following_url": "https://api.github.com/users/hrishikeshio/following{/other_user}",
      "gists_url": "https://api.github.com/users/hrishikeshio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hrishikeshio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hrishikeshio/subscriptions",
      "organizations_url": "https://api.github.com/users/hrishikeshio/orgs",
      "repos_url": "https://api.github.com/users/hrishikeshio/repos",
      "events_url": "https://api.github.com/users/hrishikeshio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hrishikeshio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T15:51:34Z",
    "updated_at": "2017-03-06T15:51:34Z",
    "author_association": "NONE",
    "body": "How will the ether be distributed? It is important since spammer can try to get as much ether as possible from various sources and then use it to spam the network.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284436932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284445216",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284445216",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284445216,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ0NTIxNg==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T16:15:25Z",
    "updated_at": "2017-03-06T16:15:25Z",
    "author_association": "MEMBER",
    "body": "@hrishikeshio The issue with Ropsten was that the attacker minted tens of thousands of blocks, producing huge reorgs and pushing the gas limit up to 9B. These two scenarios could be avoided since only signers can mint blocks, so they could also retain some sanity limits.\r\n\r\nThe proposal does not specify any means for spam filtering for individual transactions as that is a new can of worms. I'll have to think a bit how best to solve that issue (around miner strategies), but limiting ether availability on a testnet is imho a bad idea. We want to be as inclusive as possible.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284445216/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284449211",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284449211",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284449211,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ0OTIxMQ==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T16:26:53Z",
    "updated_at": "2017-03-06T16:26:53Z",
    "author_association": "MEMBER",
    "body": "One possible solution would be to have a faucet that grants X ether / Y time (e.g 10 / day) but is bound to some OAuth protocol that has proper protection against mass account creation (e.g. github accout, email address, etc).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284449211/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284451357",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284451357",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284451357,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ1MTM1Nw==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T16:32:57Z",
    "updated_at": "2017-03-12T05:17:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "Snippet to claim a github user ownership to an ethereum address\r\n\r\n```solidity\r\ncontract GitHubOracle is  usingOraclize {\r\n    //constant for oraclize commits callbacks\r\n    uint8 constant CLAIM_USER = 0;\r\n    //temporary storage enumerating oraclize calls\r\n    mapping (bytes32 => uint8) claimType;\r\n    //temporary storage for oraclize user register queries\r\n    mapping (bytes32 => UserClaim) userClaim;\r\n    //permanent storage of sha3(login) of github users\r\n    mapping (bytes32 => address) users;\r\n    //events\r\n    event UserSet(string githubLogin, address account);\r\n    //stores temporary data for oraclize user register request\r\n    struct UserClaim {\r\n        address sender;\r\n        bytes32 githubid;\r\n        string login;\r\n    }\r\n\r\n    //register or change a github user ethereum address\r\n    function register(string _github_user, string _gistid)\r\n     payable {\r\n        bytes32 ocid = oraclize_query(\"URL\", strConcat(\"https://gist.githubusercontent.com/\",_github_user,\"/\",_gistid,\"/raw/\"));\r\n        claimType[ocid] = CLAIM_USER;\r\n        userClaim[ocid] = UserClaim({sender: msg.sender, githubid: sha3(_github_user), login: _github_user});\r\n    }\r\n  //oraclize response callback\r\n    function __callback(bytes32 _ocid, string _result) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        uint8 callback_type = claimType[_ocid];\r\n        if(callback_type==CLAIM_USER){\r\n            if(strCompare(_result,\"404: Not Found\") != 0){    \r\n                address githubowner = parseAddr(_result);\r\n                if(userClaim[_ocid].sender == githubowner){\r\n                    _register(userClaim[_ocid].githubid,userClaim[_ocid].login,githubowner);\r\n                }\r\n            }\r\n            delete userClaim[_ocid]; //should always be deleted\r\n        }\r\n        delete claimType[_ocid]; //should always be deleted\r\n    }\r\n    function _register(bytes32 githubid, string login, address githubowner) \r\n     internal {\r\n        users[githubid] = githubowner;\r\n        UserSet(login, githubowner);\r\n    }\r\n}\r\n```\r\nUser create a gist with his public address and call register passing `_github_user` + `_gistid`\r\n\r\nFrom https://github.com/ethereans/github-token/blob/master/contracts/GitHubToken.sol\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284451357/reactions",
      "total_count": 12,
      "+1": 12,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284488849",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284488849",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284488849,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ4ODg0OQ==",
    "user": {
      "login": "mightypenguin",
      "id": 1100099,
      "node_id": "MDQ6VXNlcjExMDAwOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1100099?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mightypenguin",
      "html_url": "https://github.com/mightypenguin",
      "followers_url": "https://api.github.com/users/mightypenguin/followers",
      "following_url": "https://api.github.com/users/mightypenguin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mightypenguin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mightypenguin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mightypenguin/subscriptions",
      "organizations_url": "https://api.github.com/users/mightypenguin/orgs",
      "repos_url": "https://api.github.com/users/mightypenguin/repos",
      "events_url": "https://api.github.com/users/mightypenguin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mightypenguin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T18:36:34Z",
    "updated_at": "2017-03-06T18:36:34Z",
    "author_association": "NONE",
    "body": "There could be a light quick proof of stake system where (like the github oraclize above) people need 5ETH locked to a live net contract address that then allows them to be on the testnet. Misbehave, and the ethereum foundation (or who ever runs it) confiscates your eth.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284488849/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284491825",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284491825",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284491825,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ5MTgyNQ==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T18:46:36Z",
    "updated_at": "2017-03-06T18:46:36Z",
    "author_association": "MEMBER",
    "body": "Yeah, side chains are an interesting idea but those are a whole new can of worms :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284491825/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284535274",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284535274",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284535274,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDUzNTI3NA==",
    "user": {
      "login": "maurycyp",
      "id": 1296842,
      "node_id": "MDQ6VXNlcjEyOTY4NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1296842?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maurycyp",
      "html_url": "https://github.com/maurycyp",
      "followers_url": "https://api.github.com/users/maurycyp/followers",
      "following_url": "https://api.github.com/users/maurycyp/following{/other_user}",
      "gists_url": "https://api.github.com/users/maurycyp/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maurycyp/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maurycyp/subscriptions",
      "organizations_url": "https://api.github.com/users/maurycyp/orgs",
      "repos_url": "https://api.github.com/users/maurycyp/repos",
      "events_url": "https://api.github.com/users/maurycyp/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maurycyp/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T21:17:13Z",
    "updated_at": "2017-03-06T21:20:00Z",
    "author_association": "NONE",
    "body": "Two thoughts:\r\n\r\nLast week, INFURA launched a (private but publicly available) chain called INFURAnet (with INFURA running all the authorities) to provide a usable test network in the face of the Ropsten issues. It was obviously based on Parity but we would feel better if PoA was a standard and compatible feature across all clients. Therefore, we support this EIP.\r\n\r\nAdditionally, if Ropsten is replaced with a PoA network, we would be happy to run one of the authorities.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284535274/reactions",
      "total_count": 23,
      "+1": 16,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 7,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284563886",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284563886",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284563886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDU2Mzg4Ng==",
    "user": {
      "login": "AlexeyAkhunov",
      "id": 13686139,
      "node_id": "MDQ6VXNlcjEzNjg2MTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13686139?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AlexeyAkhunov",
      "html_url": "https://github.com/AlexeyAkhunov",
      "followers_url": "https://api.github.com/users/AlexeyAkhunov/followers",
      "following_url": "https://api.github.com/users/AlexeyAkhunov/following{/other_user}",
      "gists_url": "https://api.github.com/users/AlexeyAkhunov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AlexeyAkhunov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AlexeyAkhunov/subscriptions",
      "organizations_url": "https://api.github.com/users/AlexeyAkhunov/orgs",
      "repos_url": "https://api.github.com/users/AlexeyAkhunov/repos",
      "events_url": "https://api.github.com/users/AlexeyAkhunov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AlexeyAkhunov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T23:04:49Z",
    "updated_at": "2017-03-06T23:37:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "What about still using PoW on the testnet, but with slightly modified parameters:\r\n\r\n1) Block Reward = 0\r\n2) Gas price is fixed to certain value\r\n3) There is a hard cap on the gas limit in a block \r\n4) Faucet gives testnet Ether only to accounts that have Ether in the same account on the main net, and that Ether is at least 24 hours old. Each account only receives test Ether once. Or some other limitation of this sort, which will allow faucet to be automatic, but will limit sybil attacks.\r\n\r\nHopefully, implementation could be much easier than Proof Of Authority\r\n\r\nEDIT: Another idea - can Block Reward be negative? Meaning that mining actually cost Test Ether. That allows implementing sort of \"Proof Of Authority\" trivially, by simply distributing large amounts of test Ether. It also means that if Test Ether is dished out periodically, the maintainers of the test net can disallow abusive miners by not giving them the next tranche of test Ether",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284563886/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284573734",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284573734",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284573734,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDU3MzczNA==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T23:52:31Z",
    "updated_at": "2017-03-06T23:52:31Z",
    "author_association": "MEMBER",
    "body": "The issue with your modified PoW scheme is that it still permits creating huge reorgs by mining lots of blocks, even if without reward.\r\n\r\nThe second proposal doesn't solve this issue either as a malicious user might accumulate a lot of ether first, then create many many parallel chains. All will be valid since he does have the funds, and there's no way to take it away. Arguably more stable than the first proposal, but doing negative rewards might break clients unexpectedly as I don't think most codebases catered for this possibility.\r\n\r\nBtw, the zero block reward is a nice idea for PoA too, as it prevents a rogue signer / leaked key from ruining the chain with accumulated funds.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284573734/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284574692",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284574692",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284574692,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDU3NDY5Mg==",
    "user": {
      "login": "AlexeyAkhunov",
      "id": 13686139,
      "node_id": "MDQ6VXNlcjEzNjg2MTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13686139?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AlexeyAkhunov",
      "html_url": "https://github.com/AlexeyAkhunov",
      "followers_url": "https://api.github.com/users/AlexeyAkhunov/followers",
      "following_url": "https://api.github.com/users/AlexeyAkhunov/following{/other_user}",
      "gists_url": "https://api.github.com/users/AlexeyAkhunov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AlexeyAkhunov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AlexeyAkhunov/subscriptions",
      "organizations_url": "https://api.github.com/users/AlexeyAkhunov/orgs",
      "repos_url": "https://api.github.com/users/AlexeyAkhunov/repos",
      "events_url": "https://api.github.com/users/AlexeyAkhunov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AlexeyAkhunov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-06T23:57:18Z",
    "updated_at": "2017-03-06T23:57:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "@karalabe Thanks! What I meant with the negative rewards - the maintainer of the network gives out enough Test Eth to current miner authorities to mine, lets say, for a week. After the week, the maintainer looks who needs a top-up, and only gives a top up to miners who behaved well. For those who did not behave well, the payouts simply stop.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284574692/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284575348",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284575348",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284575348,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDU3NTM0OA==",
    "user": {
      "login": "AlexeyAkhunov",
      "id": 13686139,
      "node_id": "MDQ6VXNlcjEzNjg2MTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13686139?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AlexeyAkhunov",
      "html_url": "https://github.com/AlexeyAkhunov",
      "followers_url": "https://api.github.com/users/AlexeyAkhunov/followers",
      "following_url": "https://api.github.com/users/AlexeyAkhunov/following{/other_user}",
      "gists_url": "https://api.github.com/users/AlexeyAkhunov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AlexeyAkhunov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AlexeyAkhunov/subscriptions",
      "organizations_url": "https://api.github.com/users/AlexeyAkhunov/orgs",
      "repos_url": "https://api.github.com/users/AlexeyAkhunov/repos",
      "events_url": "https://api.github.com/users/AlexeyAkhunov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AlexeyAkhunov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-07T00:00:19Z",
    "updated_at": "2017-03-07T00:00:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "@karalabe Ah, I got your point about the parallel chains now. In that case, there needs to be some kind of regular expiration of Test Eth :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284575348/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284606567",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284606567",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284606567,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDYwNjU2Nw==",
    "user": {
      "login": "jaekwon",
      "id": 53785,
      "node_id": "MDQ6VXNlcjUzNzg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/53785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jaekwon",
      "html_url": "https://github.com/jaekwon",
      "followers_url": "https://api.github.com/users/jaekwon/followers",
      "following_url": "https://api.github.com/users/jaekwon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jaekwon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jaekwon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jaekwon/subscriptions",
      "organizations_url": "https://api.github.com/users/jaekwon/orgs",
      "repos_url": "https://api.github.com/users/jaekwon/repos",
      "events_url": "https://api.github.com/users/jaekwon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jaekwon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-07T02:56:50Z",
    "updated_at": "2017-03-07T02:56:50Z",
    "author_association": "NONE",
    "body": "Here's GoEthereum on Tendermint.\r\n\r\nhttps://github.com/tendermint/ethermint\r\n\r\nThe goal is to make as much of GoEthereum as compatible as possible.\r\n\r\nCome to #ethermint on the Tendermint slack for discussions.\r\n\r\nWe have some upstream patches that would make Ethermint much cleaner.  See the bottom of https://github.com/tendermint/ethermint/pull/42/files",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284606567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284606663",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284606663",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284606663,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDYwNjY2Mw==",
    "user": {
      "login": "jaekwon",
      "id": 53785,
      "node_id": "MDQ6VXNlcjUzNzg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/53785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jaekwon",
      "html_url": "https://github.com/jaekwon",
      "followers_url": "https://api.github.com/users/jaekwon/followers",
      "following_url": "https://api.github.com/users/jaekwon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jaekwon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jaekwon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jaekwon/subscriptions",
      "organizations_url": "https://api.github.com/users/jaekwon/orgs",
      "repos_url": "https://api.github.com/users/jaekwon/repos",
      "events_url": "https://api.github.com/users/jaekwon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jaekwon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-07T02:57:30Z",
    "updated_at": "2017-03-07T02:57:30Z",
    "author_association": "NONE",
    "body": "We're pushing GoEthereum to high tx limits and uncovering some issues.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284606663/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284725467",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284725467",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284725467,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDcyNTQ2Nw==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-07T13:47:43Z",
    "updated_at": "2017-03-07T13:47:43Z",
    "author_association": "MEMBER",
    "body": "Just to mention a proposal by @frozeman and @fjl of adding the set of signers to the extra-data field of every X block to act as a checkpoint. This wouldn't be useful now, but it would permit anyone trivially adding a logic to \"sync form H(X)\" where `H(X)` is the hash of a checkpoint block.\r\n\r\nThe added benefit is that this would allow the genesis block to store the initial set of signers and we wouldn't need extra chain configuration parameters.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284725467/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284979660",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-284979660",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 284979660,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDk3OTY2MA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-08T08:34:55Z",
    "updated_at": "2017-03-08T08:34:55Z",
    "author_association": "MEMBER",
    "body": "Here's a suggested protocol change: https://gist.github.com/holiman/5e021b24a7bfec95c8cc84b97e44e45a\r\n\r\nIt was a bit too long for fitting in a comment. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/284979660/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285315240",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285315240",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285315240,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTMxNTI0MA==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T10:31:45Z",
    "updated_at": "2017-03-09T10:31:45Z",
    "author_association": "MEMBER",
    "body": "@holiman To react a bit to the proposal here too, I see one problem that's easy-ish to solve, another that's hard:\r\n\r\nYour scheme must also ensure that blocks cannot be minted like crazy, otherwise the difficulty becomes irrelevant. This can be done with the same \"min 15 seconds apart\" guarantee that the original proposal had.\r\n\r\nThe harder part is that with no guarantee on signer ordering/frequency (only relying on the difficulty for chain quality/validation), malicious signers can mine very long chains that aren't difficult enough to beat the canonical, however the nodes cannot know this before processing them. And since creating these chains is mostly free in a PoA world, malicious signers can keep spamming with little effort.\r\n\r\nThe original proposal had a guarantee that the majority of the signers agreed at some point that a chain is valid (even if it was reorged afterwards), so minority malicious miners can only feed made up chains of  N/2 blocks.\r\n\r\nThe difficulty idea is elegant btw, just not sure how yet to make use of it :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285315240/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285860920",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285860920",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285860920,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg2MDkyMA==",
    "user": {
      "login": "keorn",
      "id": 7750981,
      "node_id": "MDQ6VXNlcjc3NTA5ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7750981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/keorn",
      "html_url": "https://github.com/keorn",
      "followers_url": "https://api.github.com/users/keorn/followers",
      "following_url": "https://api.github.com/users/keorn/following{/other_user}",
      "gists_url": "https://api.github.com/users/keorn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/keorn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/keorn/subscriptions",
      "organizations_url": "https://api.github.com/users/keorn/orgs",
      "repos_url": "https://api.github.com/users/keorn/repos",
      "events_url": "https://api.github.com/users/keorn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/keorn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T11:26:28Z",
    "updated_at": "2017-03-12T22:09:56Z",
    "author_association": "NONE",
    "body": "If you do not mind somewhat relying on UNIX time and longer block times when validators are down, then Aura (in Parity) uses something like that:\r\n- time is divided into steps, the current step is `t / step_duration`\r\n- the primary for `step` is `step % length(validators)`\r\n- the header seal is a list of two values: `step` and signature (`step` is redundant and can be removed in a future version)\r\n- the total difficulty or as we refer to it \"chain score\" is set to be (using appropriate differencing to obtain block difficulty): `U128_max * height - step`\r\n\r\nValidation: block at a given `step` can be only signed by the primary, only first block for a given `step` is accepted (if a second is received, a vote to remove the authority should be issued), block can arrive at most 1 step ahead.\r\n\r\nValidator set can be altered in the way @karalabe proposed.\r\n\r\nEither way we will attempt to implement whichever solution is elected.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285860920/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285861300",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285861300",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285861300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg2MTMwMA==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T11:36:13Z",
    "updated_at": "2017-03-11T11:36:13Z",
    "author_association": "MEMBER",
    "body": "I'm not too fond of relying on time. Using @holiman 's proposal of calculating \"your turn\" based only on block height seems a bit better in respect as nodes don't have to be synced.\r\n\r\nAny particular reason for having the chain difficulty calculated like that instead of just the height of the chain for example? What does this more complex formula gain you?\r\n\r\nThe issue I see with Aura's turn based scheme is that if a few signers drop off (which can be only natural in an internet scale system), then the chain dynamics would become quite irregular, with \"gaps\" in the minting time; versus my proposal where multiple signers can fill in for those that dropped.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285861300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285861822",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285861822",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285861822,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg2MTgyMg==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T11:47:29Z",
    "updated_at": "2017-03-11T11:47:29Z",
    "author_association": "MEMBER",
    "body": "If I understand correctly, the idea in the difficulty algorithm is to score those chains higher that have the most signers signing at the correct turn. So chains that skip blocks are scored less vs. those that include all signers.\r\n\r\nWhat happens in scenarios where blocks are minted in step, but propagated later after the step ends? Or if some signers receive the next block in time, while some signers receive it a bit later after the step ended?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285861822/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285870421",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285870421",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285870421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg3MDQyMQ==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T14:35:55Z",
    "updated_at": "2017-03-11T14:35:55Z",
    "author_association": "MEMBER",
    "body": "I've updated the proposal with a tech spec section describing the proposed PoA protocol itself. It's still missing a few details around signing (notably the 1-out-of-K block constraint), and I've yet to figure out the difficulty calculation.\r\n\r\nAlso I split off the PoA protocol from the testnet itself naming wise as I'd like to keep the two concepts separated to avoid confusion. Using metro station names for the testnets is fine, but for a reusable PoA scheme I wanted something a bit more \"mundane\" and/or obvious.\r\n\r\nThe names are still up for finalization. The `Clique` name for the PoA scheme (best until now) was suggested by @holiman .",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285870421/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285872847",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285872847",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285872847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg3Mjg0Nw==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T15:17:32Z",
    "updated_at": "2017-03-11T15:17:32Z",
    "author_association": "MEMBER",
    "body": "Id recommend using the Ethermint or Eris DB permissioning native contract or both. They've both been tested extensively and both would not require reinventing the wheel. Furthermore we're all friends here and have done the heavy leg work here so...why not? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285872847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285875274",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285875274",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285875274,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg3NTI3NA==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T15:30:40Z",
    "updated_at": "2017-03-11T15:30:40Z",
    "author_association": "MEMBER",
    "body": "It's hard to evaluate such a proposal without any details. I personally am not familiar with either how the work, so I cannot comment on their feasibility.\r\n\r\nMy main design goals here are to be easy to add to any client and support current techs (fast, light, warp sync) without invasive changes.\r\n\r\nCan those consensus engines be plugged into all clients? Can they run on mobile and embedded devices? Are they fully self contained without external dependencies? Can they achieve consensus header only? Are they compatible licensing wise with all clients? These all are essential requirements I've tried to meet.\r\n\r\nI'm happy to consider them, but you need to provide a lot more detail to evaluate based upon.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285875274/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285883011",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285883011",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285883011,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTg4MzAxMQ==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-11T17:34:50Z",
    "updated_at": "2017-03-11T17:34:50Z",
    "author_association": "MEMBER",
    "body": "Absolutely. \r\n\r\nSo both use a tendermint consensus Proof of Stake, that is detailed here: \r\n\r\nhttps://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm\r\n\r\nAs for the pluggability of the algorithm, it's been proven to be quite doable, in fact, Parity has already done it: \r\n\r\nhttps://github.com/ethcore/parity/blob/ade5a13f5bad745b4200ececde42aa219ad768ae/json/src/spec/engine.rs\r\n\r\nAnd ethermint already implements this through geth in a way (I wouldn't be the one to give the details, that would be something for @jaekwon or @ebuchman to explain)\r\n\r\nhttps://github.com/tendermint/ethermint\r\n\r\nAs for Eris-DB and your attempt at permissioning by way of Proof Of Authority, we simply utilize the above BFT consensus algorithm and on top of that utilize a native contract (not dissimilar to the current cryptographic addresses such as SHA256, RIPEMD-160, etc.) to implement a permissioning scheme amongst the validators. \r\n\r\nWhile we have our own version of the EVM that is much more stripped down than Geth, I don't think it would be something difficult to make a modular go package for ease of implementation (CC @silasdavis ): \r\n\r\nhttps://github.com/eris-ltd/eris-db/blob/master/manager/eris-mint/evm/snative.go#L73\r\n\r\nThe above ^^^ could be implemented in a way through geth via some tinkering with this function in geth:\r\n\r\nhttps://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L33\r\n\r\nBoth solutions are written in Golang so there is surely a way to make them somewhat compatible. Again. Trying to find a way to work together so ya'll can keep your focus ;) \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285883011/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285959415",
    "html_url": "https://github.com/ethereum/EIPs/issues/225#issuecomment-285959415",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/225",
    "id": 285959415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTk1OTQxNQ==",
    "user": {
      "login": "yaronvel",
      "id": 19823963,
      "node_id": "MDQ6VXNlcjE5ODIzOTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/19823963?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yaronvel",
      "html_url": "https://github.com/yaronvel",
      "followers_url": "https://api.github.com/users/yaronvel/followers",
      "following_url": "https://api.github.com/users/yaronvel/following{/other_user}",
      "gists_url": "https://api.github.com/users/yaronvel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yaronvel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yaronvel/subscriptions",
      "organizations_url": "https://api.github.com/users/yaronvel/orgs",
      "repos_url": "https://api.github.com/users/yaronvel/repos",
      "events_url": "https://api.github.com/users/yaronvel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yaronvel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-12T17:22:21Z",
    "updated_at": "2017-03-12T17:22:21Z",
    "author_association": "NONE",
    "body": "Maybe instead of all these fancy ideas just ask Bitcoin how they are able to have functional PoW testnet?\r\nHint: block size (i.e., gas limit) is bounded.\r\n\r\nBut off-course we cannot allow testnet to have different behavior than mainnet.\r\nSo let's us PoA instead. Exactly as in mainnet.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/285959415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
