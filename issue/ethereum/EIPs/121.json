{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/121",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/121/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/121/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/121/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/121",
  "id": 161823332,
  "node_id": "MDU6SXNzdWUxNjE4MjMzMzI=",
  "number": 121,
  "title": "ERC: Proxy standard",
  "user": {
    "login": "SilentCicero",
    "id": 9806174,
    "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/SilentCicero",
    "html_url": "https://github.com/SilentCicero",
    "followers_url": "https://api.github.com/users/SilentCicero/followers",
    "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
    "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
    "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
    "repos_url": "https://api.github.com/users/SilentCicero/repos",
    "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
    "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 30,
  "created_at": "2016-06-23T01:47:37Z",
  "updated_at": "2022-01-30T02:24:10Z",
  "closed_at": "2022-01-30T02:24:10Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "```\nERC\nTitle: Proxy standard\nStatus: Draft\nType: Informational\nCreated: 22.06.2016\nResolution: https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n```\n## Abstract\n\nThe following describes standard functions a proxy contract can implement.\n## Motivation\n\nMany Ethereum users and smart-contracts hold and manage digital assets. A unified way to hold, acquire and transfer digital assets could greatly simplify and unify the designs of many contractual services making them more inter-operable with each other, while also gaining from the design benefits of standardization. Many contractual services also require a single persistent account at which to transact within the ecosystem. These services could also greatly benefit from a single unified contractual design enabling this practice to happen in a predictable and consistent way.\n## Rational\n\nThis allows Ethereum users/services to store, transfer and manage multiple kinds of digital assets in a single simple vetted standardized smart-contract. By doing so, we simplify digital asset acquisition, storage and management. A proxy standard also simplifies and/or unified contractual design of governance, identity or financial services on Ethereum. While there is always the potential that the implementer contract of a Proxy could be compromised or poorly design and all assets exposed to attack or freezing, we can expect at the very least the proxy contract implementer to be able to transfer its proxy's ownership (and the digital assets contained therein).\n## Specification\n1. A single contract with two methods (i.e. `transfer_implementer`, and `forward_transaction`) and one  variable (i.e. `implementer`).\n2. The `transfer_implementer` method is solely responsible for changing ownership from the stored implementer to a new implementer and is access restricted to the implementer and the contract itself.\n3. The forwarding method `forward_transaction` has three inputs: `address _destination`, `uint _value`, `bytes _bytecode`.\n4. The `forward_transaction` method is access restricted to the `implementer` only.\n5. The `forward_transaction` forwards transactions to the destination address as the ProxyContract address.\n6. The `StandardProxy` contract implements the `Proxy` interface contract containing the `forward_transaction` and `transfer_ownership` methods.\n### Code for `Proxy` contract interface\n\n```\ncontract Proxy {\n    function forward_transaction (address _destination, uint _value, bytes _bytecode) {}\n    function transfer_implementer (address _implementer) {}\n}\n```\n### Code for the `StandardProxy` contract\n\n```\nimport \"Proxy.sol\";\n\ncontract StandardProxy is Proxy {\n\n    function forward_transaction (address _destination, uint _value, bytes _bytecode) {\n        if(msg.sender == implementer) {\n            if(!_destination.call.value(_value)(_bytecode)) {\n                throw;\n            }\n        }\n    }\n\n    function transfer_implementer (address _implementer) {\n        if(msg.sender == implementer || msg.sender == address(this)) {\n            implementer = _implementer;\n        }\n    }\n\n    address implementer;\n}\n```\n### `StandardProxy` contract in use with a factory contract\n\n```\nimport \"StandardProxy.sol\";\n\ncontract ImplementedStandardProxy is StandardProxy {\n    function ImplementedStandardProxy(address _implementer) {\n        implementer = _implementer;\n    }\n\n    function getImplementer() constant returns (address) {\n       return implementer;\n    }\n}\n\ncontract ImplementedStandardProxyFactory {\n    function createStandardProxy(address _implementer) returns (address standardProxyAddress) {\n        standardProxyAddress = new ImplementedStandardProxy(_implementer);\n    }\n}\n```\n### Potential Attack Vectors/Pitfalls\n- rare use of self access restriction: this is a very uncommon use of contract access restriction and is potentially vulnerable because of this fact (just an odd use of access restriction).\n- re-entry: outward call contract re-entry is a worry in the `forward_transaction` method.\n- compromised implementer contract/user account: if the implementer contract is compromised by an attacker all digital assets held by the proxy are potentially exposed to attack and theft. The proxy is not suppose to solve this. It is merely suppose to provide a contractual base on which to bond digital assets too.\n- poorly designed implementer contracts: an implementer contract may end up being poorly design or broken, potentially locking the digital assets in the proxy forever. If a contract supports the use of proxy contracts we can then as contract architects expect them to, at the very least, be able to transfer ownership of the proxy.  Thus simplifying our base expectations and concerns for contracts that manage digital assets.\n- transaction forwarding/routing costs: if implementer systems use a proxy to manage digital assets and to represent an identity of that system, there is the additional cost incurred by forwarding transactions through the abstracted implementer, into the proxy and out into the ecosystem. This adds additional gas costs that need to be considered.\n- empty/invalid bytecode inputs: there may be potential issues with forwarding transactions that have no bytecode (I cant think of any, but it does seem like it could present issues in the future -- this is merely my intuition here, nothing else).\n### Examples of proxy contract designs\n- Nikolai Mushegian (nexusdev/dapple) `DSBaseActor` -- https://github.com/nexusdev/dappsys/blob/develop/contracts/actor/base.sol\n- Christian Lundkvist/Joel Torstensson (consensys/uport-proxy) `Proxy` -- https://github.com/ConsenSys/uport-proxy/blob/master/contracts/Proxy.sol\n### Notes\n- re-entry must be addressed in the `forward_transaction` method.\n- proxies should be kept, simple, robust, reusable and stupid (they are meant to be used by other contract interfaces)\n- use the \"owner\" contract instead of \"implementer\" term/concept (in defense of the `implementer` term/concept: \"ownership\" is certainly a valid term/concept here, however, implementer does seem more metaphysically accurate, as the term \"owner\" only implies ownership, where as implementer implies that which can implement state change within and as the contract -- this is to be debated however and perhaps it just has too much overlap with the \"owner\" contract infrastructure).\n- perhaps \"proxy\" is not the right term here, the dappsys ecosystem uses the term \"BaseActor\", which also seems appropriate and accurate. However, in conversation and in deep mediation, I believe \"proxy\" to be a better descriptive term here.\n- proxy contracts (1) simplify, unify and standardize digital asset acquisition and management while also providing (2) a persistent account identity at which services and users can transact with the ecosystem, although I do believe there to be more benefits\n- proxy contracts also help us manage expectations of contracts that hold digital assets or need a persistent account within the ecosystem\n\nA special thanks and credit goes to Christian Lundkvist, Nikolai Mushegian, Simon de la Rouviere, Niran Babalola, and Peter Borah for furthering the design of proxy and proxy like smart-contracts on Ethereum.\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/121/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/121/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
{
  "message": "API rate limit exceeded for user ID 93719879.",
  "documentation_url": "https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting"
}
