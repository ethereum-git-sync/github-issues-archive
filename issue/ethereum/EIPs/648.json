{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/648/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/648/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/648/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/648",
  "id": 236654417,
  "node_id": "MDU6SXNzdWUyMzY2NTQ0MTc=",
  "number": 648,
  "title": "Easy parallelizability",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 49,
  "created_at": "2017-06-17T11:06:46Z",
  "updated_at": "2022-01-16T00:44:11Z",
  "closed_at": "2022-01-16T00:44:11Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Parameters\r\n\r\n* `MAX_THREADS`: 8\r\n\r\n### Specification\r\n\r\nIntroduce a new type of transaction (following same general format as #232):\r\n\r\n    [2, network_id, startgas, to, data, ranges]\r\n\r\nWhere `ranges` is an RLP list, where each value in the list is an address prefix, representing the range of all addresses with that prefix. That is, for example:\r\n\r\n* `\\x01` refers to the set of addresses from 0x0100000000000000000000000000000000000000 to 0x01ffffffffffffffffffffffffffffffffffffff\r\n* `\\x02\\x48\\xab` refers to the set of addresses from 0x0248ab0000000000000000000000000000000000 to 0x0248abffffffffffffffffffffffffffffffffff\r\n* `'l#\\xfa\\xce\\x01O \\xb3\\xeb\\xb6Z\\xe9m\\r\\x7f\\xf3*\\xb9L\\x17'` refers to the one-element set containing only the address 0x6c23face014f20b3ebb65ae96d0d7ff32ab94c17\r\n* The empty string refers to the set of all addresses\r\n\r\nPrefixes longer than 20 bytes are illegal (ie. transactions containing such prefixes are invalid). We call the \"range of a transaction\" the union of all ranges specified in that transaction if the transaction is of this new type, and the set of all addresses otherwise. For example, if a transaction's `ranges` field is of the form `[\\x01, \\x02\\x03, \\xff\\x8c\\x45]`, its range is the set of all addresses that start with either 0x01, or 0x0203, or 0xff8c45.\r\n\r\nWe keep track of a `starting_gas_height` and `finishing_gas_height` for each transaction. We define the `starting_gas_height` of a transaction T to be the maximum of all `finishing_gas_height`s of all transactions T' before T such that either (i) T' is more than MAX_THREADS behind T (ie.  `txindex_of(T) - txindex_of(T') > MAX_THREADS`) or (ii) the ranges of T and T' intersect. We define the `finishing_gas_height` of T to be the `starting_gas_height` of T plus the amount of gas consumed while executing T.\r\n\r\nThe current rule that a transaction is invalid if its `start_gas` plus the current `total_gas_used` exceeds the block `gas_limit` is removed, and replaced with a rule that a transaction T is invalid if: `T.starting_gas_height + T.start_gas > gas_limit`. Notice that in the case where all transactions use the entire address space as their range, this is exactly equivalent to the current status quo, but in the case where transactions use disjoint ranges, this increases capacity.\r\n\r\nAny CALL, CREATE, CALLCODE, DELEGATECALL or STATICCALL that attempts to access an account outside a transaction's range fails; any EXTCODESIZE, EXTCODECOPY, BALANCE or SELFDESTRUCT that attempts to access an account outside a transaction's range immediately throws an exception. Addresses 0...127 have one exception: any account can STATICCALL them. We add a binding norm on protocol development that no address may be introduced into that range which has logic such that it may return a differing value depending on transactions that take place within a block (though changes _between_ blocks are acceptable).\r\n\r\n### Rationale\r\n\r\nThis allows transactions in the EVM to be processed in parallel much more easily, by specifying statically what addresses they can access; it also appropriately incentivizes making transactions that are easy to parallelize. It does this in a maximally backwards-compatible and non-intrusive way where old-style transactions can continue to work.\r\n\r\nThe exception for addresses 0...127 is introduced to allow access to precompiles and to system contracts like BLOCKHASH.\r\n\r\nNote that this EIP does change the role of the block gas limit from being a limit on total gas consumed to being a limit on gas height. This means that the theoretical max capacity of the blockchain would increase by a factor of NUM_THREADS, though if we want to avoid increasing uncle rates it does require the assumption that miners are running on hardware that has NUM_THREADS CPU cores. For clarity, it may be a good idea to rename the block `gas_limit` to `gas_height_limit`.\r\n\r\n### Client implementation\r\n\r\nA client can follow the following algorithm:\r\n\r\n1. Let `TXINDEX = 0`\r\n2. Initialize `txgrab` as an empty list.\r\n3. WHILE (i) the transaction in the block at index `TXINDEX` does not intersect with any transaction in `txgrab`, (ii) `len(txgrab) < NUM_THREADS` and (iii) `TXINDEX < len(block.transactions)`, add the transaction in the block at index `TXINDEX` to `txgrab` and set `TXINDEX += 1`.\r\n4. Execute all transactions in `txgrab` in parallel.\r\n5. If `TXINDEX == len(block.transactions)`, exit. Otherwise, go back to step 2.\r\n\r\n### Specification, v2\r\n\r\nModify the new transaction type to be as follows:\r\n\r\n    [2, network_id, startgas, to, data, read_ranges, write_ranges]\r\n\r\nThe **read range** of a transaction is the union of all `read_ranges`, and the **write range** of a transaction is the union of all `write_ranges`. Replace \"the ranges of T and T' intersect\" above with \"the read or write range of T intersects with the write range of T' \" (where T is the current transaction and T' is a previous transaction). Read-only operations are allowed to access the read or write ranges, write-only operations are allowed to access the write range only.\r\n\r\nThis adds a further optimization where if two transactions' read ranges intersect at data that is not written to, then they can still be processed in parallel.\r\n\r\nThe exception for addresses 0...127 can be removed, as any contracts that wish to use the precompiles can simply include the addresses in their read range, and even if all transactions include those addresses in their read range parallelizability will not be significantly impacted as almost no one wants to write to those addresses.\r\n\r\n#### Proposed amendment 1 (thanks @Arachnid for suggestion)\r\n\r\nInstead of each range being an RLP list, it is simply a byte array, where each byte represents a byte prefix (eg. the byte array `\\x03\\x35\\xfe` means \"the set of all addresses starting with 0x03, 0x35 or 0xfe\"). An empty byte array represents the set of all addresses. This simplifies implementation at some cost to granularity, though the value of that level of granularity is arguably low.",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/648/reactions",
    "total_count": 63,
    "+1": 30,
    "-1": 0,
    "laugh": 1,
    "hooray": 24,
    "confused": 0,
    "heart": 8,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/648/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309269697",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309269697",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309269697,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTI2OTY5Nw==",
    "user": {
      "login": "mattdf",
      "id": 11067114,
      "node_id": "MDQ6VXNlcjExMDY3MTE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/11067114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mattdf",
      "html_url": "https://github.com/mattdf",
      "followers_url": "https://api.github.com/users/mattdf/followers",
      "following_url": "https://api.github.com/users/mattdf/following{/other_user}",
      "gists_url": "https://api.github.com/users/mattdf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mattdf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mattdf/subscriptions",
      "organizations_url": "https://api.github.com/users/mattdf/orgs",
      "repos_url": "https://api.github.com/users/mattdf/repos",
      "events_url": "https://api.github.com/users/mattdf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mattdf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-18T10:44:41Z",
    "updated_at": "2017-06-18T10:47:25Z",
    "author_association": "MEMBER",
    "body": "I don't entirely understand the calculation for `starting_gas_height` and `finishing_gas_height`, what's the point of that above just computing `startgas*len(tx_set)` for each `tx_set` in rangeset R?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309269697/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309291268",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309291268",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309291268,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTI5MTI2OA==",
    "user": {
      "login": "chrisfranko",
      "id": 3543217,
      "node_id": "MDQ6VXNlcjM1NDMyMTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3543217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chrisfranko",
      "html_url": "https://github.com/chrisfranko",
      "followers_url": "https://api.github.com/users/chrisfranko/followers",
      "following_url": "https://api.github.com/users/chrisfranko/following{/other_user}",
      "gists_url": "https://api.github.com/users/chrisfranko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chrisfranko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chrisfranko/subscriptions",
      "organizations_url": "https://api.github.com/users/chrisfranko/orgs",
      "repos_url": "https://api.github.com/users/chrisfranko/repos",
      "events_url": "https://api.github.com/users/chrisfranko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chrisfranko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-18T17:34:01Z",
    "updated_at": "2017-06-18T17:34:01Z",
    "author_association": "NONE",
    "body": "interesting. Can you give an example of when this would be best taken advantage of?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309291268/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309336572",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309336572",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309336572,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTMzNjU3Mg==",
    "user": {
      "login": "VictorTaelin",
      "id": 13090166,
      "node_id": "MDQ6VXNlcjEzMDkwMTY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/13090166?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VictorTaelin",
      "html_url": "https://github.com/VictorTaelin",
      "followers_url": "https://api.github.com/users/VictorTaelin/followers",
      "following_url": "https://api.github.com/users/VictorTaelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/VictorTaelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VictorTaelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VictorTaelin/subscriptions",
      "organizations_url": "https://api.github.com/users/VictorTaelin/orgs",
      "repos_url": "https://api.github.com/users/VictorTaelin/repos",
      "events_url": "https://api.github.com/users/VictorTaelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VictorTaelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T04:35:29Z",
    "updated_at": "2017-06-19T04:35:40Z",
    "author_association": "MEMBER",
    "body": "Wondering why this is at transaction level, not contract level. If a contract could specify what other contracts it can communicate with, then all transactions sent to it would be computed in parallel, and as a bonus the blockchain itself could eventually be.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309336572/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309475618",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309475618",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309475618,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTQ3NTYxOA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T15:28:19Z",
    "updated_at": "2017-06-19T15:28:19Z",
    "author_association": "MEMBER",
    "body": "Given addresses are randomly distributed throughout the address space, I'm not sure how useful a prefix-based scheme is likely to be - how often will contracts you wish to interact with be conveniently clustered under a common prefix?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309475618/reactions",
      "total_count": 17,
      "+1": 17,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309475734",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309475734",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309475734,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTQ3NTczNA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T15:28:39Z",
    "updated_at": "2017-06-19T15:28:39Z",
    "author_association": "MEMBER",
    "body": "@MaiaVictor What if the contract can communicate with other contracts specified at runtime?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309475734/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309696425",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-309696425",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 309696425,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTY5NjQyNQ==",
    "user": {
      "login": "heikoheiko",
      "id": 2804689,
      "node_id": "MDQ6VXNlcjI4MDQ2ODk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2804689?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/heikoheiko",
      "html_url": "https://github.com/heikoheiko",
      "followers_url": "https://api.github.com/users/heikoheiko/followers",
      "following_url": "https://api.github.com/users/heikoheiko/following{/other_user}",
      "gists_url": "https://api.github.com/users/heikoheiko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/heikoheiko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/heikoheiko/subscriptions",
      "organizations_url": "https://api.github.com/users/heikoheiko/orgs",
      "repos_url": "https://api.github.com/users/heikoheiko/repos",
      "events_url": "https://api.github.com/users/heikoheiko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/heikoheiko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T09:23:20Z",
    "updated_at": "2017-06-20T09:23:20Z",
    "author_association": "MEMBER",
    "body": "Once we have #98 clients can also implement **optimistic concurrent** processing of txs. The assumption here would be, that most txs in a block don't share any state, except for `block.coinbase`. So we'd need a different mechanism to collect fees for the miner, but otherwise this can be done without any further protocol updates (a hint on parallelizable group of txs in the transaction list, might be helpful though). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309696425/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310147808",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310147808",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310147808,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDE0NzgwOA==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-21T17:22:44Z",
    "updated_at": "2017-06-21T17:22:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid From my understanding, you could _maybe_ have 10 contracts for a given Token (e.g. SNT) where each SNT contract only has access to 1/10 of the address space, with the ability to do cross-token-contract swaps as well. If this is possible, then you could make SNT transactions parrelizable to some extent.\r\n\r\nThat's the best example I could come up with, but I am sure there are more sensible ones. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310147808/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310203316",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310203316",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310203316,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDIwMzMxNg==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-21T20:58:19Z",
    "updated_at": "2017-06-21T20:58:19Z",
    "author_association": "NONE",
    "body": "I would rather that DELEGATECALL (and for the sake of symmetry, CALLCODE) worked out-of-range. Blindly deploying a contract with libraries is unlikely to group them in the same range. Technically, one could brute-force them into doing so by grinding away at addresses and nonces, but this would be incredibly user-unfriendly. It is also backwards-incompatible.\r\n\r\nI do realize that a DELEGATECALL could fail if the targeted contract selfdestructed. One possible solution would be that a DELEGATECALL uses the code of a contract at the _beginning_ of a block, and ignore selfdestructs for this one purpose. That adds a wart, but it also improves the life of the average user.\r\n\r\nAll that said, I agree with @Arachnid. In a way, this penalizes non-address-grinded multi-contract dapps, For that matter, if address grinding ever became a significant factor in dapp design, users will inevitably want to cluster themselves around popular ranges, leading to pseudo-shards. Elegant and emergent in its own bizarre way, but I don't think it would be desirable compared to an actual first-class sharding system.\r\n\r\n@heikoheiko: I'm curious why sharing `block.coinbase` is a problem. Unless that one address is involved with the transaction, there should be no difference whenever it receives rewards. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310203316/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310634423",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310634423",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310634423,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDYzNDQyMw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T10:44:57Z",
    "updated_at": "2017-06-23T10:44:57Z",
    "author_association": "MEMBER",
    "body": "> Once we have #98 clients can also implement optimistic concurrent processing of txs. The assumption here would be, that most txs in a block don't share any state, except for block.coinbase. So we'd need a different mechanism to collect fees for the miner, but otherwise this can be done without any further protocol updates (a hint on parallelizable group of txs in the transaction list, might be helpful though).\r\n\r\nAgree. However, there is currently no gas incentive to make nicely parallelizable txs, and furthermore the worst case still has zero parallelization, and client devs would still have to design for the worst case. This EIP increases the gas limit for \"normal usage\" by up to 8x but does NOT worsen the worst case at all, and it also introduces an up to 8x subsidy for parallelizable txs.\r\n\r\n> Given addresses are randomly distributed throughout the address space, I'm not sure how useful a prefix-based scheme is likely to be - how often will contracts you wish to interact with be conveniently clustered under a common prefix?\r\n\r\nMost transactions only need to interact with one contract; with EIP86 maybe two. To give one trivial example, any transactions that use two distinct ERC20 tokens will usually have independent read/write ranges.\r\n\r\n> If a contract could specify what other contracts it can communicate with, then all transactions sent to it would be computed in parallel, and as a bonus the blockchain itself could eventually be.\r\n\r\nConsider things this way:\r\n\r\n1. (a) There exist contracts that only need to interact with a few other contracts. (b) There also exist contracts that could theoretically interact with anything.\r\n2. (a) There exist transactions that only need to interact with a few known contracts. (b) There also exist transactions that could theoretically interact with any address.\r\n\r\nIdeally, we want to retain support for 1b and 2b, but recognize and subsidize 1a and 2a. If we recognize 1a in protocol, then we _don't_ recognize all of 2a, because there are cases where a _contract_ could theoretically interact with anything (quick example: decentralized exchange), but the _transaction_ can be more static (one particular order in the DEX with a known counterparty). However, any instance of 1a is also an instance of 2a, as if a given contract C only affects D1, D2 and D3 then any transaction sending to C can only affect C, D1, 2 and D3. Hence, 1a is a subset of 2a, and so 2a is the more general thing to recognize and subsidize in protocol.\r\n\r\n> interesting. Can you give an example of when this would be best taken advantage of?\r\n\r\nSome quick examples:\r\n\r\n1. Transactions going to an ICO can happen in parallel to almost everything else, so the ICO would not interfere with normal traffic the same way. In fact, Status-style network congestion would not be possible unless there were 8 ICOs happening at the same time.\r\n2. ERC20 tokens can be parallelized (ie. transactions sending MKR and transactions sending REP can be totally separated)\r\n\r\nI would even go so far as to say that nearly all activity on the current ETH chain would be parallelizable.\r\n\r\n> I would rather that DELEGATECALL (and for the sake of symmetry, CALLCODE) worked out-of-range. \r\n\r\nThis is what specification v2 is for. Libraries are generally read-only, and v2 allows for intersecting read ranges, so it should cover all of these use cases.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310634423/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310634641",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310634641",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310634641,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDYzNDY0MQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T10:46:02Z",
    "updated_at": "2017-06-23T10:55:25Z",
    "author_association": "MEMBER",
    "body": "> how often will contracts you wish to interact with be conveniently clustered under a common prefix?\r\n\r\nI think you might have misunderstood. My scheme does not require you to choose a single prefix. You can set the read or write range for a transaction as the union of multiple prefixes. So address grinding should not be necessary or particularly helpful.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310634641/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310635749",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310635749",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310635749,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDYzNTc0OQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T10:52:39Z",
    "updated_at": "2017-06-23T10:52:39Z",
    "author_association": "MEMBER",
    "body": "> I don't entirely understand the calculation for starting_gas_height and finishing_gas_height, what's the point of that above just computing startgas*len(tx_set) for each tx_set in rangeset R?\r\n\r\nNot sure I understand your proposal. The intuition behind my proposal is that the finishing_gas_height of a transaction can be thought of as an upper bound on the computational \"depth\" of the transcation - that is, the number of clock cycles of time needed to execute that transaction and all of its dependencies that can't be parallelized.\r\n\r\nI'll give an example. Suppose you have four transactions, and suppose that the full address range is the letters ABCDEFGHIJ for simplicity. The first tx has 25000 gas and read/write ranges ABCD. The second tx has 50000 gas and read ranges EFGHIJ and write ranges EFG. The third tx has 65000 gas and read ranges EFGHIJ and write ranges HIJ. All three of those txs can be executed in parallel. Now, suppose the fourth tx has 20000 gas and has read/write ranges CDEF. Executing this tx requires having already executed the first and the second, though not the third (as the third does not write anything that the fourth reads or writes); hence its finishing_gas_height is max(25000, 50000) + 20000 = 70000. A computer with 8 threads would be able to finish processing all four transactions in 70000 cycles (assuming 1 cycle = 1 gas); hence these 4 transactions could fit into a block with a 70000 gas limit.\r\n\r\nHope that makes some sense.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310635749/reactions",
      "total_count": 18,
      "+1": 17,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310655663",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310655663",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310655663,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY1NTY2Mw==",
    "user": {
      "login": "aakilfernandes",
      "id": 1577353,
      "node_id": "MDQ6VXNlcjE1NzczNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aakilfernandes",
      "html_url": "https://github.com/aakilfernandes",
      "followers_url": "https://api.github.com/users/aakilfernandes/followers",
      "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
      "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
      "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
      "repos_url": "https://api.github.com/users/aakilfernandes/repos",
      "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T12:43:45Z",
    "updated_at": "2017-06-23T12:43:45Z",
    "author_association": "NONE",
    "body": "I like this proposal a lot. Given that developers usually opt towards \"pull\" rather than \"push\" transactions, most transactions should be able to take advantage of this.\r\n\r\nIf the subsidy is removed, could this be implemented as a soft fork? Client devs may struggle with multi-threaded implementations and I don't see a pressing need for non-miners to implement this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310655663/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310689693",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310689693",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310689693,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY4OTY5Mw==",
    "user": {
      "login": "LefterisJP",
      "id": 1658405,
      "node_id": "MDQ6VXNlcjE2NTg0MDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1658405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LefterisJP",
      "html_url": "https://github.com/LefterisJP",
      "followers_url": "https://api.github.com/users/LefterisJP/followers",
      "following_url": "https://api.github.com/users/LefterisJP/following{/other_user}",
      "gists_url": "https://api.github.com/users/LefterisJP/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LefterisJP/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LefterisJP/subscriptions",
      "organizations_url": "https://api.github.com/users/LefterisJP/orgs",
      "repos_url": "https://api.github.com/users/LefterisJP/repos",
      "events_url": "https://api.github.com/users/LefterisJP/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LefterisJP/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:02:58Z",
    "updated_at": "2017-06-23T15:02:58Z",
    "author_association": "MEMBER",
    "body": "@vbuterin I have a question on `finishing_gas_height` which you described as the computational depth of the transaction.\r\n\r\nIn your example 4 transactions you calculate: `finishing_gas_height(T3) = max(25000, 50000) + 20000 = 70000`\r\n\r\nThe number `70000` is the maximum gas needed to execute that transaction and all of its dependencies that can't be parallelized. Correct?\r\n\r\nBut then you mention that: \r\n>  these 4 transactions could fit into a block with a 70000 gas limit\r\n\r\nUnless I am missing something, the block's max gas limit required shouldn't change due to the way you process the transactions .Shouldn't it be `160000`, basically the sum of all transactions of the block?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310689693/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310690345",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310690345",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310690345,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5MDM0NQ==",
    "user": {
      "login": "LefterisJP",
      "id": 1658405,
      "node_id": "MDQ6VXNlcjE2NTg0MDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1658405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LefterisJP",
      "html_url": "https://github.com/LefterisJP",
      "followers_url": "https://api.github.com/users/LefterisJP/followers",
      "following_url": "https://api.github.com/users/LefterisJP/following{/other_user}",
      "gists_url": "https://api.github.com/users/LefterisJP/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LefterisJP/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LefterisJP/subscriptions",
      "organizations_url": "https://api.github.com/users/LefterisJP/orgs",
      "repos_url": "https://api.github.com/users/LefterisJP/repos",
      "events_url": "https://api.github.com/users/LefterisJP/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LefterisJP/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:05:24Z",
    "updated_at": "2017-06-23T15:05:24Z",
    "author_association": "MEMBER",
    "body": "Some additional comments on the actual spec:\r\n\r\nI really like the idea and believe it will really help relieve the network pressure in Status-like ICO situations.\r\n\r\nEven though I suppose it would be a bit more work, I think that `spec V2` where you specifically specify both read and write ranges of the transaction is far superior since it will allow for more efficient parallelization.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310690345/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310694031",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310694031",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310694031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5NDAzMQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:19:09Z",
    "updated_at": "2017-06-23T15:19:56Z",
    "author_association": "MEMBER",
    "body": "> Unless I am missing something, the block's max gas limit required shouldn't change due to the way you process the transactions .Shouldn't it be 160000, basically the sum of all transactions of the block?\r\n\r\nThis EIP will change the role of the block gas limit. So a 4.7m gas limit would be not just 4.7m gas worth of computation, but rather 4.7m gas worth of time on an 8-core machine. Perhaps renaming it to `gas_height_limit` would make that clearer?\r\n\r\n> Even though I suppose it would be a bit more work, I think that spec V2 where you specifically specify both read and write ranges of the transaction is far superior since it will allow for more efficient parallelization.\r\n\r\nAgree. I definitely believe v2 is superior.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310694031/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310695339",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310695339",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310695339,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5NTMzOQ==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:24:03Z",
    "updated_at": "2017-06-23T15:24:44Z",
    "author_association": "MEMBER",
    "body": "One thing that should be noted here is that the CPU-intensive workload should scale linearly with the number of cores, but what does not scale that well is the size of memory and database access. It could be that this change will effectively make state reads 8 times cheaper in gas, depending on the database.\r\n\r\nOn the other hand, if the transaction gives an explicit list of addresses (i.e. not only prefixes) it will read from, we might already load these accounts into the memory of the core processing this transaction before we start processing it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310695339/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310695506",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310695506",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310695506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5NTUwNg==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:24:35Z",
    "updated_at": "2017-06-23T15:25:04Z",
    "author_association": "NONE",
    "body": "Extremely in favor of this proposal. In addition to the immediate scaling gains, I have a strong hunch that defining and incentivizing parallelism will open up very useful design space for us in the future.\r\n\r\nIf we do this, let's do v2 if at all possible. A lot of current design patterns heavily use `delegatecall` for efficiency reasons, and it would be unfortunate to disincentivize that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310695506/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310696456",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310696456",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310696456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5NjQ1Ng==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:27:57Z",
    "updated_at": "2017-06-23T15:28:31Z",
    "author_association": "MEMBER",
    "body": "> but what does not scale that well is the size of memory and database access. It could be that this change will effectively make state reads 8 times cheaper, depending on the database.\r\n\r\nGood point. Question: are SSD reads parallelizable? If not, then state reading opcodes would definitely need to be increased in price.\r\n\r\n> we might already load these accounts into the memory of the core processing this transaction before we start processing it.\r\n\r\nOne problem with this is that accounts can have arbitrarily large storage trees, and we can't load _that_ into memory.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310696456/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310698654",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310698654",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310698654,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDY5ODY1NA==",
    "user": {
      "login": "LefterisJP",
      "id": 1658405,
      "node_id": "MDQ6VXNlcjE2NTg0MDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1658405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LefterisJP",
      "html_url": "https://github.com/LefterisJP",
      "followers_url": "https://api.github.com/users/LefterisJP/followers",
      "following_url": "https://api.github.com/users/LefterisJP/following{/other_user}",
      "gists_url": "https://api.github.com/users/LefterisJP/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LefterisJP/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LefterisJP/subscriptions",
      "organizations_url": "https://api.github.com/users/LefterisJP/orgs",
      "repos_url": "https://api.github.com/users/LefterisJP/repos",
      "events_url": "https://api.github.com/users/LefterisJP/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LefterisJP/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:36:19Z",
    "updated_at": "2017-06-23T15:36:19Z",
    "author_association": "MEMBER",
    "body": "@vbuterin \r\n\r\n> So a 4.7m gas limit would be not just 4.7m gas worth of computation, but rather 4.7m gas worth of time on an 8-core machine. \r\n\r\nI see. That makes sense.\r\n\r\n> Perhaps renaming it to `gas_height_limit` would make that clearer?\r\n\r\nYes I think this sounds like a bit more accurate description for this field. So a block would have a `gas_height_limit` and the `gas_used` in the block can still be greater than that with a maximum theoretical limit (in the case of full parallelization) of `8 * gas_height_limit`.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310698654/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310701906",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310701906",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310701906,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcwMTkwNg==",
    "user": {
      "login": "VictorTaelin",
      "id": 13090166,
      "node_id": "MDQ6VXNlcjEzMDkwMTY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/13090166?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VictorTaelin",
      "html_url": "https://github.com/VictorTaelin",
      "followers_url": "https://api.github.com/users/VictorTaelin/followers",
      "following_url": "https://api.github.com/users/VictorTaelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/VictorTaelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VictorTaelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VictorTaelin/subscriptions",
      "organizations_url": "https://api.github.com/users/VictorTaelin/orgs",
      "repos_url": "https://api.github.com/users/VictorTaelin/repos",
      "events_url": "https://api.github.com/users/VictorTaelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VictorTaelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:48:19Z",
    "updated_at": "2017-06-23T15:48:19Z",
    "author_association": "MEMBER",
    "body": "> Ideally, we want to retain support for 1b and 2b, but recognize and subsidize 1a and 2a. If we recognize 1a in protocol, then we don't recognize all of 2a, because there are cases where a contract could theoretically interact with anything\r\n\r\nMakes sense. I didn't put a lot of thought on this, so that was just speculation, but let me explain what I had in mind: if a contract pre-determined a set of contracts it can interact to, then, in situations of stress, there could (guessing) be an automated way to fork the contract from the rest of network, letting it run on its own cluster for a day or two. It would be a separate, merge-mined network for that time. Eventually, it could be re-merged. Assuming splitting and merging was a costly operation, that would only be possible if we had a guarantee the contract won't receive a transaction that interacted with contracts on the other network. That is why the restriction couldn't be on transaction level, as any transaction could trigger a re-merge. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310701906/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310703199",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310703199",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310703199,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcwMzE5OQ==",
    "user": {
      "login": "VictorTaelin",
      "id": 13090166,
      "node_id": "MDQ6VXNlcjEzMDkwMTY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/13090166?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VictorTaelin",
      "html_url": "https://github.com/VictorTaelin",
      "followers_url": "https://api.github.com/users/VictorTaelin/followers",
      "following_url": "https://api.github.com/users/VictorTaelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/VictorTaelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VictorTaelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VictorTaelin/subscriptions",
      "organizations_url": "https://api.github.com/users/VictorTaelin/orgs",
      "repos_url": "https://api.github.com/users/VictorTaelin/repos",
      "events_url": "https://api.github.com/users/VictorTaelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VictorTaelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:53:21Z",
    "updated_at": "2017-06-23T15:56:35Z",
    "author_association": "MEMBER",
    "body": "> @MaiaVictor What if the contract can communicate with other contracts specified at runtime?\r\n\r\nThen it wouldn't be parallelizable, I guess. Except if we had `add_friend` and `remove_friend` opcodes to modify the set of contracts a contract can interact with? Both would take a few days to concretize, in order to give the networks time to split/merge, under my speculative and possibly wrong dynamic-forking scheme.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310703199/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310704569",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310704569",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310704569,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcwNDU2OQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T15:58:39Z",
    "updated_at": "2017-06-23T15:58:39Z",
    "author_association": "MEMBER",
    "body": "> if a contract pre-determined a set of contracts it can interact to, then, in situations of stress, there could (guessing) be an automated way to fork the contract from the rest of network, letting it run on its own cluster for a day or two\r\n\r\nSure. But this is not at all compatible with the goal of \"easy parallelizability\" :)\r\n\r\nNetworks splitting and merging is the sort of thing we're considering for later stages of the sharding roadmap, whereas this proposal is intended to be more here-and-now.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310704569/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310708536",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310708536",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310708536,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcwODUzNg==",
    "user": {
      "login": "rphmeier",
      "id": 10121380,
      "node_id": "MDQ6VXNlcjEwMTIxMzgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/10121380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rphmeier",
      "html_url": "https://github.com/rphmeier",
      "followers_url": "https://api.github.com/users/rphmeier/followers",
      "following_url": "https://api.github.com/users/rphmeier/following{/other_user}",
      "gists_url": "https://api.github.com/users/rphmeier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rphmeier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rphmeier/subscriptions",
      "organizations_url": "https://api.github.com/users/rphmeier/orgs",
      "repos_url": "https://api.github.com/users/rphmeier/repos",
      "events_url": "https://api.github.com/users/rphmeier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rphmeier/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T16:14:45Z",
    "updated_at": "2017-06-23T16:14:45Z",
    "author_association": "NONE",
    "body": "@chriseth Given that the state trie is keyed by `sha3(address)` and not `address`, although this proposal allows good parallelization of compute-intensive transactions, it likely won't lead to a reduction in disk reads as trie lookups will still have to traverse completely from the root and state lookups won't be any cheaper. \r\n\r\nOnly lookups of fully pre-determined addresses would benefit, although we'd have to charge for \"pre-loading\" gas ahead of time in case the transaction never actually inspects those accounts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310708536/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310709453",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310709453",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310709453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcwOTQ1Mw==",
    "user": {
      "login": "rphmeier",
      "id": 10121380,
      "node_id": "MDQ6VXNlcjEwMTIxMzgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/10121380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rphmeier",
      "html_url": "https://github.com/rphmeier",
      "followers_url": "https://api.github.com/users/rphmeier/followers",
      "following_url": "https://api.github.com/users/rphmeier/following{/other_user}",
      "gists_url": "https://api.github.com/users/rphmeier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rphmeier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rphmeier/subscriptions",
      "organizations_url": "https://api.github.com/users/rphmeier/orgs",
      "repos_url": "https://api.github.com/users/rphmeier/repos",
      "events_url": "https://api.github.com/users/rphmeier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rphmeier/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T16:18:36Z",
    "updated_at": "2017-06-23T16:18:36Z",
    "author_association": "NONE",
    "body": "@vbuterin \r\n\r\n> A computer with 8 threads would be able to finish processing all four transactions in 70000 cycles (assuming 1 cycle = 1 gas); hence these 4 transactions could fit into a block with a 70000 gas limit.\r\n\r\nThis assumes that disk/memory operations are parallelizable, when in fact we usually find these to be some of the largest bottlenecks while optimizing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310709453/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310714084",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310714084",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310714084,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDcxNDA4NA==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T16:37:26Z",
    "updated_at": "2017-06-23T17:22:32Z",
    "author_association": "NONE",
    "body": "Can we cement this with a simple example?\r\n\r\nSuppose I call a contract with 150,000 gas in thread A, which moves tokens in thread B (utilizing 50,000 gas). Given that there are 8 threads, how much gas does this transaction consume?\r\n\r\nEdit: I think I'm confused about the gas consumption ramifications. Is this proposing individual transactions spend only some fraction of gas commensurate with the subset of the state space they update? Or is it proposing a way to pack more gas spending into a block with a fixed gas limit?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310714084/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310780152",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310780152",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310780152,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDc4MDE1Mg==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T21:45:17Z",
    "updated_at": "2017-06-23T21:45:17Z",
    "author_association": "MEMBER",
    "body": "Question: What are the tools that need to be made available for handling interdependent state changes of contracts within the read and writing range? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310780152/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310780250",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310780250",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310780250,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDc4MDI1MA==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T21:45:50Z",
    "updated_at": "2017-06-23T21:45:50Z",
    "author_association": "MEMBER",
    "body": "Or is this proposal simply proposing to handle only the independent ones? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310780250/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310790093",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310790093",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310790093,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDc5MDA5Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T22:53:44Z",
    "updated_at": "2017-06-23T22:53:44Z",
    "author_association": "MEMBER",
    "body": "> Is this proposing individual transactions spend only some fraction of gas commensurate with the subset of the state space they update? Or is it proposing a way to pack more gas spending into a block with a fixed gas limit?\r\n\r\nThe latter.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310790093/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310790361",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310790361",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310790361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDc5MDM2MQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T22:55:52Z",
    "updated_at": "2017-06-23T22:55:52Z",
    "author_association": "MEMBER",
    "body": "> This assumes that disk/memory operations are parallelizable, when in fact we usually find these to be some of the largest bottlenecks while optimizing.\r\n\r\nSomething can be a bottleneck and be parallelizable at the same time. Currently, the problem is that each individual database op may be dependent on the result of the previous, whereas with this scheme you could be fetching several storage keys at the same time.\r\n\r\nI'd definitely be very interested in getting more data on parallelization and SSD reads.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310790361/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310795862",
    "html_url": "https://github.com/ethereum/EIPs/issues/648#issuecomment-310795862",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/648",
    "id": 310795862,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDc5NTg2Mg==",
    "user": {
      "login": "veox",
      "id": 3036030,
      "node_id": "MDQ6VXNlcjMwMzYwMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3036030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/veox",
      "html_url": "https://github.com/veox",
      "followers_url": "https://api.github.com/users/veox/followers",
      "following_url": "https://api.github.com/users/veox/following{/other_user}",
      "gists_url": "https://api.github.com/users/veox/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/veox/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/veox/subscriptions",
      "organizations_url": "https://api.github.com/users/veox/orgs",
      "repos_url": "https://api.github.com/users/veox/repos",
      "events_url": "https://api.github.com/users/veox/events{/privacy}",
      "received_events_url": "https://api.github.com/users/veox/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-23T23:42:48Z",
    "updated_at": "2017-06-23T23:53:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "**TL;DR**: Is it a known fact that the bottleneck is transaction processing, and not network latency (or something else altogether)?\r\n\r\nAs much as I like the proposal in general, got to highlight: it does not immediately follow that introducing parallelisation like this will result in a `gas_limit` increase (as in its current meaning).\r\n\r\nImagine a newly-received block being validated by a node. Say for example that:\r\n\r\n* 1/4 of the txs are \"batches of `MAX_THREADS`\", which can be processed in parallel;\r\n* 1/4 are \"batches of [2; `MAX_THREADS`)\";\r\n* 1/4 are new-style \"batches of 1\" - calls to contracts with a `CREATE` operation, and therefore accesses to an address that can only be determined at execution time;\r\n* 1/4 are \"old-style unbatched\".\r\n\r\nA miner pool's node is likely to be capable of many more concurrent threads than the largest batch here, yet even they have to process the latter two categories one tx at a time. Slower miners that can't provide such concurrency are likely to vote the gas limit down, if their uncle probability increases.\r\n\r\nMany more miners may come to be seen as \"slow\" if the bottleneck turns out to be not validation time, but block propagation time (i.e. _time in transit_). This parameter is likely to increase, since for the same new `gas_height_limit` as the old `gas_limit`, a block may be up to `MAX_THREADS` bigger byte-wise.\r\n\r\nSure, slow miners would eventually be forced off the market by their own inefficiency. But that may take a while - at least 'till unprofitability of such behaviour becomes apparent to their operators. The time period, I'd make a guess, is months, if not years.\r\n\r\nIMO it's still worth diverting mindshare towards this goal from other development (probably because it's not my own mindshare being diverted q:D).\r\n\r\nJust something to keep in mind - this proposal is about activating processing power that's currently underused, to put market pressure on those that are grossly under-performing. It may back-fire, though, by using an unexpected criteria to determine who it is that's \"under-performing\". If ~~that's~~ the criteria turns out to be network latency, then the answer may be \"everybody\".\r\n\r\n-----\r\n\r\nAlso, if implemented, this will likely introduce \"fee levels\" for various categories of transactions, where a \"batch of 1\" (or \"old-style unbatched\") would need to have gas price at least `MAX_THREADS` higher than the most efficiently parallelisable one.\r\n\r\nNot calling this part \"bad\", only that such an outcome would be a rational market response.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310795862/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
