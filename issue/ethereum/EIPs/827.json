{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/827/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/827/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/827/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/827",
  "id": 287804142,
  "node_id": "MDU6SXNzdWUyODc4MDQxNDI=",
  "number": 827,
  "title": "ERC827 Token Standard (ERC20 Extension)",
  "user": {
    "login": "AugustoL",
    "id": 7763867,
    "node_id": "MDQ6VXNlcjc3NjM4Njc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AugustoL",
    "html_url": "https://github.com/AugustoL",
    "followers_url": "https://api.github.com/users/AugustoL/followers",
    "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
    "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
    "organizations_url": "https://api.github.com/users/AugustoL/orgs",
    "repos_url": "https://api.github.com/users/AugustoL/repos",
    "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AugustoL/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 123,
  "created_at": "2018-01-11T14:26:49Z",
  "updated_at": "2022-05-28T05:04:28Z",
  "closed_at": "2022-05-28T05:04:27Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "```\r\nEIP: 827\r\nTitle: ERC827 Token Standard (ERC20 Extension)\r\nAuthor: Augusto Lemble <me@augustol.com>\r\nType: Token Standard\r\nStatus: Draft\r\nCategory: ERC\r\nCreated: 2018-01-11\r\nUpdated: 2019-05-21\r\n```\r\n\r\n## This standard is still a draft and is proven to be unsafe to be used\r\n\r\n## Simple Summary\r\n\r\nA extension of the standard interface ERC20 for tokens with methods that allows the execution of calls inside transfer and approvals.\r\n\r\n\r\n## Abstract\r\n\r\nThis standard provides basic functionality to transfer tokens, as well as allow tokens to be approved so they can be spent by another on-chain third party. Also it allows to execute calls on transfers and approvals.\r\n\r\n\r\n## Motivation\r\n\r\nThis extension of the ERC20 interface allows the token to execute a function in the receiver contract contract after the approval or transfer happens. The function is executed by the token proxy, a simple proxy which goal is to mask the msg.sender to prevent the token contract to execute the function calls itself.\r\nThe ERC20 token standard is widely accepted but it only allows the transfer of value, ethereum users are available to transfer value and data on transactions, with these extension of the ERC20 token standard they will be able to do the same with ERC20 tokens.\r\n\r\nI saw a lot of new standards being proposed in the community and I think the way to improve the current ERC20 standard is with an extension that is fully compatible with the original standard and also add new methods, but keeping it simple at the same time, the code to be added to the ERC20 standard is near 150 lines of code.\r\n\r\n**When to use each function**\r\n\r\n- approveAndCall: Probably the one that you will need, maybe the only one since it only allows the receiver contract to use approved balance. The best practice is to check the allowance of the sender and then do your stuff using the transferFromAndCall method.\r\n\r\n- transferAndCall: There is no way to check that the balance that will be transferred is the correct one, this function is useful when a function dont need to check any transfer of value.\r\n\r\n- transferFromAndCall: Same as transferAndCall, only useful when there is no need to check the transfered amount of tokens and want to spend approved balance.\r\n\r\n\r\n## Specification\r\n\r\n## Token\r\n### Methods\r\n\r\n**NOTE**: Callers MUST handle `false` from `returns (bool success)`.  Callers MUST NOT assume that `false` is never returned!\r\n\r\n\r\n#### name - ERC20\r\n\r\nReturns the name of the token - e.g. `\"MyToken\"`.\r\n\r\nOPTIONAL - This method can be used to improve usability,\r\nbut interfaces and other contracts MUST NOT expect these values to be present.\r\n\r\n\r\n``` js\r\nfunction name() constant returns (string name)\r\n```\r\n\r\n\r\n#### symbol - ERC20\r\n\r\nReturns the symbol of the token. E.g. \"HIX\".\r\n\r\nOPTIONAL - This method can be used to improve usability,\r\nbut interfaces and other contracts MUST NOT expect these values to be present.\r\n\r\n``` js\r\nfunction symbol() constant returns (string symbol)\r\n```\r\n\r\n\r\n\r\n#### decimals - ERC20\r\n\r\nReturns the number of decimals the token uses - e.g. `8`, means to divide the token amount by `100000000` to get its user representation.\r\n\r\nOPTIONAL - This method can be used to improve usability,\r\nbut interfaces and other contracts MUST NOT expect these values to be present.\r\n\r\n``` js\r\nfunction decimals() constant returns (uint8 decimals)\r\n```\r\n\r\n\r\n#### totalSupply - ERC20\r\n\r\nReturns the total token supply.\r\n\r\n``` js\r\nfunction totalSupply() constant returns (uint256 totalSupply)\r\n```\r\n\r\n\r\n\r\n#### balanceOf - ERC20\r\n\r\nReturns the account balance of another account with address `_owner`.\r\n\r\n``` js\r\nfunction balanceOf(address _owner) constant returns (uint256 balance)\r\n```\r\n\r\n\r\n\r\n#### transfer - ERC20\r\n\r\nTransfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.\r\nThe function SHOULD `revert` if the `_from` account balance does not have enough tokens to spend.\r\n\r\nA token contract which creates new tokens SHOULD trigger a Transfer event with the `_from` address set to `0x0` when tokens are created.\r\n\r\n*Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.\r\n\r\n``` js\r\nfunction transfer(address _to, uint256 _value) returns (bool success)\r\n```\r\n\r\n\r\n\r\n#### transferFrom - ERC20\r\n\r\nTransfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.\r\n\r\nThe `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.\r\nThis can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.\r\nThe function SHOULD `revert` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.\r\n\r\n*Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.\r\n\r\n``` js\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success)\r\n```\r\n\r\n\r\n\r\n#### approve - ERC20\r\n\r\nAllows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.\r\n\r\nUsers SHOULD make sure to create user interfaces in such a way that they set the allowance first to `0` before setting it to another value for the same spender.\r\nTHOUGH The contract itself shouldn't enforce it, to allow backwards compatibility with contracts deployed before\r\n\r\n``` js\r\nfunction approve(address _spender, uint256 _value) returns (bool success)\r\n```\r\n\r\n\r\n\r\n#### allowance - ERC20\r\n\r\nReturns the amount which `_spender` is still allowed to withdraw from `_owner`.\r\n\r\n``` js\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining)\r\n```\r\n\r\n### ERC827 Proxy\r\n\r\nA very simple proxy contract used to forward the calls form the token contract.\r\n- The proxy is deployed and assigned on the ERC827 token on the ERC827 constructor.\r\n- The proxy can only execute calls coming form the token contract.\r\n\r\nThere is a public variable called proxy in the ERC827 token, this can be used to check if the call is coming from the ERC827 token since the proxy can only forward calls from the token contract.\r\n\r\n```\r\ncontract ERC827Proxy {\r\n\r\n  address public token;\r\n  bytes4 public callContractFunctionSignature = bytes4(\r\n    keccak256(\"callContract(address,bytes)\")\r\n  );\r\n\r\n  constructor() public {\r\n    token = address(msg.sender);\r\n  }\r\n\r\n  function callContract(\r\n    address _target, bytes memory _data\r\n  ) public payable returns (bool) {\r\n    require(\r\n      msg.sender == address(token),\r\n      \"Proxy cant execute calls to the token contract\"\r\n    );\r\n    (bool success, bytes memory data) = _target.call.value(msg.value)(_data);\r\n    require(success, \"Proxy call failed\");\r\n    return true;\r\n  }\r\n\r\n}\r\n```\r\n\r\n### ERC827 methods\r\n\r\n#### transferAndCall - ERC827\r\n\r\nExecute a function on `_to` with the `_data` parameter, if the function ends successfully execute the transfer of `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.\r\n\r\nThis method is `payable`, which means that ethers can be sent when calling it, but the transfer of ether needs to be handled in the call is executed after transfer since the one who receives the ether is the token contract and not the token receiver.\r\n\r\nThe function SHOULD `revert` if the call to `_to` address fails or if `_from` account balance does not have enough tokens to spend.\r\nThe ERC20 `transfer` method is called before the `_call(_to, _data)`.\r\n\r\n*Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.\r\n\r\n**Important Note** Do not use this method with fallback functions that receive the value transferred as parameter, there is not way to verify how much value was transferred on the fallback function.\r\n\r\n``` js\r\n  function transferAndCall(\r\n    address _to, uint256 _value, bytes memory _data\r\n  ) public payable returns (bool) {\r\n    super.transfer(_to, _value);\r\n    _call(_to, _data);\r\n    return true;\r\n  }\r\n```\r\n\r\n#### transferFromAndCall - ERC827\r\n\r\nExecute a function on `_to` with the `_data` parameter, if the function ends successfully execute the transfer of `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.\r\n\r\nThis method is `payable`, which means that ethers can be sent when calling it, but the transfer of ether needs to be handled in the call is executed after transfer since the one who receives the ether is the token contract and not the token receiver.\r\n\r\nThe `transferFromAndCall` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf before executing a function.\r\nThe ERC20 `transferFrom` method is called before the `_call(_to, _data)`.\r\nThis can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.\r\nThe function SHOULD `revert` if the call to `_to` address fails or if the `_from` approved balance by `_from` to `msg.sender` is not enough to execute the transfer.\r\n\r\n*Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.\r\n\r\n**Important Note** Do not use this method with fallback functions that receive the value transferred as parameter, there is not way to verify how much value was transferred on the fallback function.\r\n\r\n``` js\r\n  function transferFromAndCall(\r\n    address _from, address _to, uint256 _value, bytes memory _data\r\n  ) public payable returns (bool) {\r\n    super.transferFrom(_from, _to, _value);\r\n    _call(_to, _data);\r\n    return true;\r\n  }\r\n```\r\n\r\n#### approveAndCall - ERC827\r\n\r\nExecute a function on `_spender` with the `_data` parameter, if the function ends successfully allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.\r\n\r\nThis method is `payable`, which means that ethers can be sent when calling it, but the transfer of ether needs to be handled in the call is executed after transfer since the one who receives the ether is the token contract and not the token receiver.\r\n\r\nClients SHOULD make sure to create user interfaces in such a way that they set the allowance first to `0` before setting it to another value for the same spender.\r\nThe ERC20 `approve` method is called before the ` _call(_spender, _data)`.\r\nThe function SHOULD `revert` if the call to `_spender` address fails.\r\nTHOUGH The contract itself shouldn't enforce it, to allow backwards compatibility with contracts deployed before\r\n\r\n\r\n``` js\r\n  function approveAndCall(\r\n    address _spender, uint256 _value, bytes memory _data\r\n  ) public payable returns (bool) {\r\n    super.approve(_spender, _value);\r\n    _call(_spender, _data);\r\n    return true;\r\n  }\r\n```\r\n\r\n\r\n### Events\r\n\r\n\r\n#### Transfer - ERC20\r\n\r\nMUST trigger when tokens are transferred, including zero value transfers.\r\n\r\n``` js\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value)\r\n```\r\n\r\n\r\n\r\n#### Approval - ERC20\r\n\r\nMUST trigger on any successful call to `approve(address _spender, uint256 _value)`.\r\n\r\n``` js\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value)\r\n```\r\n\r\n## Past Issues\r\n\r\nThe main issue that has been recognized by the community is that the standard does not follow the assumption about executing calls in behalf of a token contract, every smart contract that handle token balances assume the token contract will execute only the common methods and maybe a callback that is implemented by the token itself. This standard break that rule and allow the execution of arbitrary calls making it hard to integrate in current solutions. \r\n**UPDATE**\r\nThis was solved by adding a simple proxy to the token and forwarding the calls coming from the token contract, the proxy ensure that the calls come only from the token contract and allows this to be verified on chain, this prevents the token address to be used as `msg.sender` allowing the integration with current solutions.\r\n\r\n### Discussion channel\r\n\r\nhttps://gitter.im/ERC827\r\n\r\n## Revisions\r\n\r\n- 2019/02/19: Simple proxy integrated in token contract to forward calls to any other contract.\r\n- 2018/06/28: Changed implementation link in zeppelin-solidity for windingtree/erc827 repository.\r\n- 2018/06/27: Added warning, current issued of the standard and public channel link.\r\n- 2018/04/17: Rename of functions to avoid function overloading and added payable modifier to ERC827 functions.\r\n- 2018/02/13: Added CC0 copyright\r\n- 2018/02/13: Added complete function code and notes abouts usage of each function\r\n- 2018/01/11: Initial Draft \r\n\r\n## Implementation\r\n\r\n[ERC827 Interface in Winding Tree](https://github.com/windingtree/erc827/blob/master/contracts/ERC827/IERC827.sol)\r\n\r\n[ERC827 Standard Token implementation in Winding Tree](https://github.com/windingtree/erc827/blob/master/contracts/ERC827/ERC827.sol\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/)",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/827/reactions",
    "total_count": 51,
    "+1": 31,
    "-1": 2,
    "laugh": 0,
    "hooray": 8,
    "confused": 2,
    "heart": 8,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/827/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356955626",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-356955626",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 356955626,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk1NTYyNg==",
    "user": {
      "login": "spalladino",
      "id": 429604,
      "node_id": "MDQ6VXNlcjQyOTYwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/429604?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/spalladino",
      "html_url": "https://github.com/spalladino",
      "followers_url": "https://api.github.com/users/spalladino/followers",
      "following_url": "https://api.github.com/users/spalladino/following{/other_user}",
      "gists_url": "https://api.github.com/users/spalladino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/spalladino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/spalladino/subscriptions",
      "organizations_url": "https://api.github.com/users/spalladino/orgs",
      "repos_url": "https://api.github.com/users/spalladino/repos",
      "events_url": "https://api.github.com/users/spalladino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/spalladino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T14:47:55Z",
    "updated_at": "2018-01-11T14:48:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "I really like the fact that it remains fully ERC20 compatible, and does not force receivers of the token to implement a certain function to signal that they accept them.\r\n\r\nOne question though: what is the rationale behind making the external call _before_ the transfer or approval? I would have expected the call to occur afterwards, so the receiver of the tokens can check the transferred/approved balance and act upon it on that same call. And by `throw`ing if the call goes wrong, the transfer gets rolled back all the same.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356955626/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356960230",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-356960230",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 356960230,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk2MDIzMA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T15:02:41Z",
    "updated_at": "2018-01-11T15:02:41Z",
    "author_association": "NONE",
    "body": "@spalladino In the `approveData` method the call is executed after the `approve` and in the transfer methods the call is executed before the transfer. At first all calls were executed before the ERC20 methods, but I changed the order in the `approveData` because I think the next call to be executed after an approve will want to have the amount to be transfered already approved, doing this you can execute a `transferFrom` inside the call and if all the things you wanted to do and check went fine you claim the tokens.\r\n\r\nI think the order of the function call in `approveData` is not explained correctly in the issue, Im going to update it.\r\n\r\nYou are right that if the call fails the `transfer` and `transferFrom` will be reverted, the order can be changed and it will have the same effect I guess.\r\n\r\nI have no problem on changing the order :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356960230/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356963634",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-356963634",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 356963634,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk2MzYzNA==",
    "user": {
      "login": "spalladino",
      "id": 429604,
      "node_id": "MDQ6VXNlcjQyOTYwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/429604?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/spalladino",
      "html_url": "https://github.com/spalladino",
      "followers_url": "https://api.github.com/users/spalladino/followers",
      "following_url": "https://api.github.com/users/spalladino/following{/other_user}",
      "gists_url": "https://api.github.com/users/spalladino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/spalladino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/spalladino/subscriptions",
      "organizations_url": "https://api.github.com/users/spalladino/orgs",
      "repos_url": "https://api.github.com/users/spalladino/repos",
      "events_url": "https://api.github.com/users/spalladino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/spalladino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T15:14:03Z",
    "updated_at": "2018-01-11T15:14:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "Oops sorry, I misunderstood the order in `approveData`. As for the order in `transferData` and `transferDataFrom`, I'd follow the same approach of transfer-then-call as in approve, for the same reasons you mention. WDYT?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356963634/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356966165",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-356966165",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 356966165,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk2NjE2NQ==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T15:42:32Z",
    "updated_at": "2018-01-11T15:42:32Z",
    "author_association": "NONE",
    "body": "I agree, im going to change the description in the issue.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356966165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356979109",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-356979109",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 356979109,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk3OTEwOQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T16:19:43Z",
    "updated_at": "2018-01-11T16:19:43Z",
    "author_association": "NONE",
    "body": "I like this. Where do you envision this standard relative to ERCs 20, 223, and 777? It seems like 827 is a _fantastic_ stopgap that's 20-compatible that should be adopted relatively quickly before the community gets around to ratifying 223 or 777.\r\n\r\nThoughts?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/356979109/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357011532",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357011532",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357011532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAxMTUzMg==",
    "user": {
      "login": "facuspagnuolo",
      "id": 6967192,
      "node_id": "MDQ6VXNlcjY5NjcxOTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6967192?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/facuspagnuolo",
      "html_url": "https://github.com/facuspagnuolo",
      "followers_url": "https://api.github.com/users/facuspagnuolo/followers",
      "following_url": "https://api.github.com/users/facuspagnuolo/following{/other_user}",
      "gists_url": "https://api.github.com/users/facuspagnuolo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/facuspagnuolo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/facuspagnuolo/subscriptions",
      "organizations_url": "https://api.github.com/users/facuspagnuolo/orgs",
      "repos_url": "https://api.github.com/users/facuspagnuolo/repos",
      "events_url": "https://api.github.com/users/facuspagnuolo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/facuspagnuolo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T18:05:30Z",
    "updated_at": "2018-01-11T18:05:30Z",
    "author_association": "NONE",
    "body": "I really like this, thanks a lot! What do you think about overloading `transfer`, `approve` and `transferFrom` functions considering the new `bytes _data` argument?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357011532/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357014184",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357014184",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357014184,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAxNDE4NA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T18:14:49Z",
    "updated_at": "2018-01-11T18:14:49Z",
    "author_association": "NONE",
    "body": "@Shrugs yes I agree, less code is safer and easier to test, and I think this new methods fulfill the needs that the rest of the standards are trying to cover.\r\n\r\n@facuspagnuolo but if we do that we will change the ERC20 function signatures and it wont be ERC20 compatible anymore, right? I think we cant have functions with the same name and different arguments, or we can? :thinking: ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357014184/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357018374",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357018374",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357018374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAxODM3NA==",
    "user": {
      "login": "facuspagnuolo",
      "id": 6967192,
      "node_id": "MDQ6VXNlcjY5NjcxOTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6967192?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/facuspagnuolo",
      "html_url": "https://github.com/facuspagnuolo",
      "followers_url": "https://api.github.com/users/facuspagnuolo/followers",
      "following_url": "https://api.github.com/users/facuspagnuolo/following{/other_user}",
      "gists_url": "https://api.github.com/users/facuspagnuolo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/facuspagnuolo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/facuspagnuolo/subscriptions",
      "organizations_url": "https://api.github.com/users/facuspagnuolo/orgs",
      "repos_url": "https://api.github.com/users/facuspagnuolo/repos",
      "events_url": "https://api.github.com/users/facuspagnuolo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/facuspagnuolo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T18:29:26Z",
    "updated_at": "2018-01-11T18:37:56Z",
    "author_association": "NONE",
    "body": "@AugustoL as far as I know, if we provide an overloaded function changing the amount of parameters, I think it won't change the signature of the ERC20 functions, for example:\r\n- ERC20 `transfer` function will keep being: `keccak256(\"transfer(address,uint256)\")`\r\n- ERC827 `transfer` function will be: `keccak256(\"transfer(address,uint256,bytes)\")`\r\n\r\nam I right?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357018374/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357018654",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357018654",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357018654,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAxODY1NA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T18:30:24Z",
    "updated_at": "2018-01-11T18:30:24Z",
    "author_association": "NONE",
    "body": "@facuspagnuolo I think you are, let me do a quick test! :eyes: ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357018654/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357021278",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357021278",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357021278,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAyMTI3OA==",
    "user": {
      "login": "facuspagnuolo",
      "id": 6967192,
      "node_id": "MDQ6VXNlcjY5NjcxOTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6967192?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/facuspagnuolo",
      "html_url": "https://github.com/facuspagnuolo",
      "followers_url": "https://api.github.com/users/facuspagnuolo/followers",
      "following_url": "https://api.github.com/users/facuspagnuolo/following{/other_user}",
      "gists_url": "https://api.github.com/users/facuspagnuolo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/facuspagnuolo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/facuspagnuolo/subscriptions",
      "organizations_url": "https://api.github.com/users/facuspagnuolo/orgs",
      "repos_url": "https://api.github.com/users/facuspagnuolo/repos",
      "events_url": "https://api.github.com/users/facuspagnuolo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/facuspagnuolo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T18:39:29Z",
    "updated_at": "2018-01-11T18:45:52Z",
    "author_association": "NONE",
    "body": "Another quick thing, we might want to distinguish between `throw` and `revert` in the spec",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357021278/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357038769",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-357038769",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 357038769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzAzODc2OQ==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-11T19:41:30Z",
    "updated_at": "2018-01-11T19:41:30Z",
    "author_association": "NONE",
    "body": "@facuspagnuolo I changed the method names to be the same as ERC20 but with the data argument and the signature is different so there is not issue on having the same name but with the `_data` argument.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357038769/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359119507",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-359119507",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 359119507,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTExOTUwNw==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-19T23:37:16Z",
    "updated_at": "2018-01-19T23:37:33Z",
    "author_association": "NONE",
    "body": "I think that allowing the token contract to call any function at any address is much less useful than calling some sort of `tokensReceived` method on the receiving contract (as in ERC223/777). Receiving contracts have no way of knowing that the calling address is a token contract, so they can't really do anything useful with the passed in data.\r\n\r\nA big part of this is that `msg.sender` will always be the token address, where a `tokensReceived` method knows the intended sender from the passed in arguments. There is also no explicit way to link the token transfer to the function call, which really limits the possibilities.\r\n\r\nIt also seems like it could have unintended consequences to allow a token to call any arbitrary data. For example, if tokenA is accidentally transferred to an ERC827 token contract, anyone would be able to claim these tokens by simply calling `tokenA.transfer(self, value)` from the ERC827 token.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359119507/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359123772",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-359123772",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 359123772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTEyMzc3Mg==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-20T00:05:41Z",
    "updated_at": "2018-01-20T00:05:41Z",
    "author_association": "NONE",
    "body": "@abandeali1 thanks for the feedback! But I think this is more useful because you dont need to have any specific method in the receiver contract to call it, but if the contract has it you can still use it, so you can call any other contract and make use of the `tokenFallback` function. In fact I think we can say that this token is also ERC223-Receiver compatible ?\r\n\r\nThere is way to know who executed the transaction, you can send a signature of the `msg.sata` as a parameter and verify the signer in the contract that is receiving the call form the token. you can also use `tx.origin` but I understand that is not recommended.\r\n\r\nAnd if there is tokens transfered to this contract they can be claimed by anyone, I dont see any problem there, at least they are not stuck there, which I think is the main problem, having tokens that are not able to being used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359123772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359137498",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-359137498",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 359137498,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTEzNzQ5OA==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-20T02:18:02Z",
    "updated_at": "2018-01-20T02:18:02Z",
    "author_association": "NONE",
    "body": "@AugustoL this is partially true. The major difference is that in ERC223/777, `from` and `value` are always passed to the `tokensReceived` callback, so receiving contacts can rely on those arguments with the assumption that the token conforms to the standard. With ERC827, what is preventing me from telling the receiving contract that I transferred 10000000 tokens when I actually only transferred 1?\r\n\r\nTo the second point, this particular case might not be that bad. But this is just a single example of unintended consequences, and I can't confidently say that there aren't other cases out there that would lead to a worse outcome.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359137498/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360226262",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-360226262",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 360226262,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDIyNjI2Mg==",
    "user": {
      "login": "strotter",
      "id": 94086,
      "node_id": "MDQ6VXNlcjk0MDg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/94086?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/strotter",
      "html_url": "https://github.com/strotter",
      "followers_url": "https://api.github.com/users/strotter/followers",
      "following_url": "https://api.github.com/users/strotter/following{/other_user}",
      "gists_url": "https://api.github.com/users/strotter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/strotter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/strotter/subscriptions",
      "organizations_url": "https://api.github.com/users/strotter/orgs",
      "repos_url": "https://api.github.com/users/strotter/repos",
      "events_url": "https://api.github.com/users/strotter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/strotter/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-24T18:20:34Z",
    "updated_at": "2018-01-24T18:20:34Z",
    "author_association": "NONE",
    "body": "As of yesterday's release of zeppelin, those links in the above post no longer work because the contract code has been migrated into separate directories:\r\n\r\nhttps://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC827/ERC827Token.sol",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360226262/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360264170",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-360264170",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 360264170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDI2NDE3MA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-24T20:32:31Z",
    "updated_at": "2018-01-24T20:32:31Z",
    "author_association": "NONE",
    "body": "Thanks @strotter ! fixed :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360264170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360676156",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-360676156",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 360676156,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY3NjE1Ng==",
    "user": {
      "login": "SergioDemianLerner",
      "id": 1752347,
      "node_id": "MDQ6VXNlcjE3NTIzNDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1752347?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SergioDemianLerner",
      "html_url": "https://github.com/SergioDemianLerner",
      "followers_url": "https://api.github.com/users/SergioDemianLerner/followers",
      "following_url": "https://api.github.com/users/SergioDemianLerner/following{/other_user}",
      "gists_url": "https://api.github.com/users/SergioDemianLerner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SergioDemianLerner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SergioDemianLerner/subscriptions",
      "organizations_url": "https://api.github.com/users/SergioDemianLerner/orgs",
      "repos_url": "https://api.github.com/users/SergioDemianLerner/repos",
      "events_url": "https://api.github.com/users/SergioDemianLerner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SergioDemianLerner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T03:41:12Z",
    "updated_at": "2018-01-26T03:44:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "I find one important problem with this standard. The call to the receiver's contract is not authenticated. The receiver's contract cannot tell if the data received comes in fact from the sender or anyone else. I see people will start using it in this way:\r\n\r\ntoken.transfer(receiver,amount, abiEncodingOf(received(sender ,amount))\r\nThe receiver contract would have a method received(address sender, uint amount).\r\nThe security of this pattern is obviously completely broken.\r\n\r\nIt would be much much useful if the receiver would receive the arguments token, sender and amount right from the token contract, and not from the supposedly sender.\r\n\r\nThe pattern that uses approve/transferFrom can also lead to common mistakes if a honest sender uses token.transferFrom(receiver,amount), and then a malicious user uses token.transfer(receiver,0,simData) just to simulate the previous transferFrom() has a data argument.\r\n\r\nAlso this standard will break any other future standard that tries to fix this problem and try to notify a receiver with authenticated source/amount information. Once you allow the token to emit any message, you cannot authenticate anything later.\r\n\r\nStill another problem is that you can use the token to send messages to itself. If the token contract is owner of tokens, then you can use this to steal the tokens from the token contract.\r\n\r\nVery bad standard IMHO.\r\n\r\nNow that I read the previous comments, I note that ALL that I said has been already said in a previous comment by @abandeali1",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360676156/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360789100",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-360789100",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 360789100,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDc4OTEwMA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T13:48:54Z",
    "updated_at": "2018-01-26T13:48:54Z",
    "author_association": "NONE",
    "body": "@SergioDemianLerner Thanks for your feedback!\r\n\r\nWe require that the the `_spender` and `_to` cant be the token address itself but I didnt had any note about that in the spec.\r\n\r\nIf the contract have any other tokens or assets they are open for grabs, I dont see a problem there since the contract in my opinion in only responsible of handling the internal balances.\r\n\r\nAuthentication is something that I think it can be done from the other contract too, without requiring the contract to be called to have a function to receive tokens.\r\n\r\nHow do you see message signing/verification being used in the receiver contract for authentication? If you need to authenticate a user it can send a signature of a hash generated inside the function and verify the real sender there.\r\n\r\nI use a lot more `transferFrom` (with _data param) and `approval` to check the availability of the value that the sender is willing to transfer, and claiming it afterwards. The use of `transfer` (with _data param) can be useful for some cases, but I see much more utility in transferFrom & approve strategy for transferring value.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360789100/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361295597",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-361295597",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 361295597,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTI5NTU5Nw==",
    "user": {
      "login": "dadeg",
      "id": 4580642,
      "node_id": "MDQ6VXNlcjQ1ODA2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4580642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dadeg",
      "html_url": "https://github.com/dadeg",
      "followers_url": "https://api.github.com/users/dadeg/followers",
      "following_url": "https://api.github.com/users/dadeg/following{/other_user}",
      "gists_url": "https://api.github.com/users/dadeg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dadeg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dadeg/subscriptions",
      "organizations_url": "https://api.github.com/users/dadeg/orgs",
      "repos_url": "https://api.github.com/users/dadeg/repos",
      "events_url": "https://api.github.com/users/dadeg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dadeg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-29T16:10:22Z",
    "updated_at": "2018-01-29T16:10:22Z",
    "author_association": "NONE",
    "body": "@AugustoL To be clear, \r\n\r\n> I use a lot more transferFrom (with _data param) and approval to check the availability of the value that the sender is willing to transfer, and claiming it afterwards. The use of transfer (with _data param) can be useful for some cases, but I see much more utility in transferFrom & approve strategy for transferring value.\r\n\r\nYou are talking about a pattern like this? \r\n\r\n```\r\ntoken.approve(receiver, value, keccak256(\"canRecieve(sender)\");\r\n\r\nContract Receiver {\r\n  function canReceive(address sender) public {\r\n    uint256 allowedValue = tokenContract.allowance(sender, self);\r\n    tokenContract.transferFrom(sender, self, allowedValue);\r\n    doBusinessLogic();\r\n  }\r\n\r\n  function doBusinessLogic() { ... }\r\n}\r\n```\r\n\r\nThis would require the receiving contract be aware of the token contract address. It would be nice if the sender and value were passed as arguments so we would not need to do the approval-allowance-transferFrom dance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361295597/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361302210",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-361302210",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 361302210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTMwMjIxMA==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-29T16:29:21Z",
    "updated_at": "2018-01-29T16:29:21Z",
    "author_association": "NONE",
    "body": "@dadeg Something like that, yes! Keep in mind that you can send the value in the call data and you also can instantiate a ERC20 token using the msg.sender address.\r\n```\r\ntoken.approve(receiver, value, keccak256(\"canRecieve(sender, value)\");\r\n\r\nContract Receiver {\r\n  function canReceive(address sender, uint256 value) public {\r\n    ERC20 tokenContract = ERC20(msg.sender);\r\n    uint256 allowedValue = tokenContract.allowance(sender, value);\r\n    tokenContract.transferFrom(sender, value, allowedValue);\r\n    doBusinessLogic();\r\n  }\r\n\r\n  function doBusinessLogic() { ... }\r\n}\r\n```\r\nAlthough I would recommend to have some way to specify the token address in the contract itself, if not it can be called from any ERC827 token.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361302210/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361307145",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-361307145",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 361307145,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTMwNzE0NQ==",
    "user": {
      "login": "dadeg",
      "id": 4580642,
      "node_id": "MDQ6VXNlcjQ1ODA2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4580642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dadeg",
      "html_url": "https://github.com/dadeg",
      "followers_url": "https://api.github.com/users/dadeg/followers",
      "following_url": "https://api.github.com/users/dadeg/following{/other_user}",
      "gists_url": "https://api.github.com/users/dadeg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dadeg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dadeg/subscriptions",
      "organizations_url": "https://api.github.com/users/dadeg/orgs",
      "repos_url": "https://api.github.com/users/dadeg/repos",
      "events_url": "https://api.github.com/users/dadeg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dadeg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-29T16:44:13Z",
    "updated_at": "2018-01-29T16:51:11Z",
    "author_association": "NONE",
    "body": "Thanks! I am unsure if sending value is a wise idea, considering there is no guarantee that the value mentioned in the `_data` argument matches the `value` argument in the original `approve` call: `token.approve(receiver, 10, keccak256(\"canReceive(sender, 1000)\"))`\r\n\r\nAs long as the receiving contract knows the address of the token contract, this `approve-allowance-transferFrom `pattern seems like a strong guarantee that nothing bad will happen. Even if the user initially screws up the approve() call, like typo-ing the `_data` string, `token.approve(receiver, 10, keccak256(\"someTypoFunction(sender, 1000)\"))`, they can recover by simply calling `canReceive` directly themselves, or calling `approve` again with the correct data signature. And the rest of the pattern is hardcoded in a single transaction to limit the UI/UX complications.\r\n\r\nEdit: To add on to this, There is no risk of a malicious actor calling `receiver.canReceive` because the method is hardcoded to just check the token for the allowance from any arbitrary user. The assumption being that a user wouldn't call approve previously unless they actually intended on having the receiver take ownership of all the tokens immediately.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/361307145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362721480",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-362721480",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 362721480,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjcyMTQ4MA==",
    "user": {
      "login": "yarrumretep",
      "id": 725179,
      "node_id": "MDQ6VXNlcjcyNTE3OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/725179?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yarrumretep",
      "html_url": "https://github.com/yarrumretep",
      "followers_url": "https://api.github.com/users/yarrumretep/followers",
      "following_url": "https://api.github.com/users/yarrumretep/following{/other_user}",
      "gists_url": "https://api.github.com/users/yarrumretep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yarrumretep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yarrumretep/subscriptions",
      "organizations_url": "https://api.github.com/users/yarrumretep/orgs",
      "repos_url": "https://api.github.com/users/yarrumretep/repos",
      "events_url": "https://api.github.com/users/yarrumretep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yarrumretep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-02T22:06:11Z",
    "updated_at": "2018-02-02T22:19:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "Please correct me if I'm wrong, but doesn't this standard mean that the resulting 827 tokens will not be compatible with most (all?) ERC223 #223  receiver contracts (to the extent they exist)?  ERC223 requires that the receiving contract accept tokenFallback from pre-approved sending contract addresses to validate that the second argument 'value' represents a guaranteed transfer to the receiver. In this case, however, the invocation of tokenFallback will be composed by the caller of the transfer(with bytes) function.  You can't know that they are not nefarious and crediting themselves with more tokens than they are indeed transferring.\r\n\r\nThis is essentially the same argument that @SergioDemianLerner and @abandeali1 made - and I concur.  For the \"transfer\" function, this is at least useless and quite possibly dangerous.  For the \"approve\", it works because the receiver then has to call transferFrom and can inspect the implementation of transferFrom to ensure they are satisfied with its behavior.\r\n\r\nWhat happened to the old \"approveAndCall\" pattern? OpenZeppelin/zeppelin-solidity#346",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362721480/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364696730",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364696730",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364696730,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDY5NjczMA==",
    "user": {
      "login": "ptrwtts",
      "id": 497330,
      "node_id": "MDQ6VXNlcjQ5NzMzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/497330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ptrwtts",
      "html_url": "https://github.com/ptrwtts",
      "followers_url": "https://api.github.com/users/ptrwtts/followers",
      "following_url": "https://api.github.com/users/ptrwtts/following{/other_user}",
      "gists_url": "https://api.github.com/users/ptrwtts/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ptrwtts/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ptrwtts/subscriptions",
      "organizations_url": "https://api.github.com/users/ptrwtts/orgs",
      "repos_url": "https://api.github.com/users/ptrwtts/repos",
      "events_url": "https://api.github.com/users/ptrwtts/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ptrwtts/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-10T21:47:21Z",
    "updated_at": "2018-02-10T21:47:21Z",
    "author_association": "NONE",
    "body": "@yarrumretep as far as I can tell, the current implementation of microraiden, which is a #223 receiver contract, is susceptible to this attack:\r\n\r\nhttps://github.com/raiden-network/microraiden/blob/master/contracts/contracts/RaidenMicroTransferChannels.sol#L149\r\n\r\nBut I wonder if this an issue with ERC827, or with #223 receivers (and #777 receivers for that matter). They probably shouldn't trust that tokens have been transferred. Otherwise they need to implement a white/black list to be safe.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364696730/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364701183",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364701183",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364701183,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcwMTE4Mw==",
    "user": {
      "login": "LefterisJP",
      "id": 1658405,
      "node_id": "MDQ6VXNlcjE2NTg0MDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1658405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LefterisJP",
      "html_url": "https://github.com/LefterisJP",
      "followers_url": "https://api.github.com/users/LefterisJP/followers",
      "following_url": "https://api.github.com/users/LefterisJP/following{/other_user}",
      "gists_url": "https://api.github.com/users/LefterisJP/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LefterisJP/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LefterisJP/subscriptions",
      "organizations_url": "https://api.github.com/users/LefterisJP/orgs",
      "repos_url": "https://api.github.com/users/LefterisJP/repos",
      "events_url": "https://api.github.com/users/LefterisJP/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LefterisJP/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-10T22:33:26Z",
    "updated_at": "2018-02-10T22:33:26Z",
    "author_association": "MEMBER",
    "body": "Since when is it a good idea to execute arbitrary calls to contracts? Let alone make that part of a token standard?\r\n\r\nJust popping in since I heard \"microraiden\".\r\n\r\nBasically re-iterating what @abandeali1, @SergioDemianLerner and @yarrumretep mentioned.\r\n\r\nIn the spec you have this function:\r\n\r\n```solidity\r\nfunction transfer(address _to, uint256 _value, bytes _data) returns (bool success)\r\n```\r\n\r\nYou describe it as:\r\n\r\n> Execute a function on _to with the _data parameter, if the function ends successfully execute the \r\n> transfer of _value amount of tokens to address _to, and MUST fire the Transfer event.\r\n>\r\n> The function SHOULD revert if the call to _to address fails or if _from account balance does not have enough tokens to spend.\r\n> The ERC20 transfer method is called before the _to.call(_data).\r\n\r\n\r\nSo essentialy I can do an ERC20 transfer of 1 token to contract `_to` but in the data I provide to it say I sent it 1 million tokens.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364701183/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364717460",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364717460",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364717460,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcxNzQ2MA==",
    "user": {
      "login": "dadeg",
      "id": 4580642,
      "node_id": "MDQ6VXNlcjQ1ODA2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4580642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dadeg",
      "html_url": "https://github.com/dadeg",
      "followers_url": "https://api.github.com/users/dadeg/followers",
      "following_url": "https://api.github.com/users/dadeg/following{/other_user}",
      "gists_url": "https://api.github.com/users/dadeg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dadeg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dadeg/subscriptions",
      "organizations_url": "https://api.github.com/users/dadeg/orgs",
      "repos_url": "https://api.github.com/users/dadeg/repos",
      "events_url": "https://api.github.com/users/dadeg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dadeg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-11T03:38:36Z",
    "updated_at": "2018-02-11T03:38:36Z",
    "author_association": "NONE",
    "body": "@LefterisJP i think your example highlights a weakness in the target contract, not in this token standard.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364717460/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364720008",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364720008",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364720008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcyMDAwOA==",
    "user": {
      "login": "yarrumretep",
      "id": 725179,
      "node_id": "MDQ6VXNlcjcyNTE3OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/725179?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yarrumretep",
      "html_url": "https://github.com/yarrumretep",
      "followers_url": "https://api.github.com/users/yarrumretep/followers",
      "following_url": "https://api.github.com/users/yarrumretep/following{/other_user}",
      "gists_url": "https://api.github.com/users/yarrumretep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yarrumretep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yarrumretep/subscriptions",
      "organizations_url": "https://api.github.com/users/yarrumretep/orgs",
      "repos_url": "https://api.github.com/users/yarrumretep/repos",
      "events_url": "https://api.github.com/users/yarrumretep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yarrumretep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-11T04:24:32Z",
    "updated_at": "2018-02-11T04:24:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "@dadeg As a 'receiving' contract under this standard as described above all I effectively get is a ping that my balance may change in the future by some unspecified amount.  Because the standard does not mandate anything about the contents of the _data (nor could it really control that without a significant on-chain burden), the receiver isn't guaranteed anything in particular about the arguments passed therein and their relation to the 827 token contract's actual anticipated transfer.  Receiver can't even keep his old balance and compare to verify because the actual transfer is not completed until after his call.\r\n\r\nAny contract expecting to receive ERC223 tokens (with some kind of tokenFallback function) would not be able to receive tokens that implemented this function without specific precautions to prevent callers invoking tokenFallback in the _data parameter.  tokenFallback value parameter can be trusted with sending contract source inspection.  _data cannot be trusted to report the quantity of the transfer.\r\n\r\nAlso, couldn't this pattern of calling out prior to making data changes open this function to reentrancy issues?\r\n\r\nThe approveAndCall variant above, on the other hand, seems more reasonable and useful to me.  There is no incentive to 'lie' about the amount being approved in the _data invocation - because the amount is either approved or not in the sending contract.  Although it takes more gas than the 223 method, the only trust that must be verified before accepting calls from a sending token is that the tranferFrom function functions as advertised (and the rest of the token behaves in an ERC20 way).  This is, in essence, a way to chain 2 calls together (approve and then doSomethingWithThisApproval).  Existing ERC20 handlers expecting the approve/doSomething pattern might even be usable directly without modification (if they have a doSomething variant that doesn't depend on msg.sender).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364720008/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364720821",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364720821",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364720821,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcyMDgyMQ==",
    "user": {
      "login": "dadeg",
      "id": 4580642,
      "node_id": "MDQ6VXNlcjQ1ODA2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4580642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dadeg",
      "html_url": "https://github.com/dadeg",
      "followers_url": "https://api.github.com/users/dadeg/followers",
      "following_url": "https://api.github.com/users/dadeg/following{/other_user}",
      "gists_url": "https://api.github.com/users/dadeg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dadeg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dadeg/subscriptions",
      "organizations_url": "https://api.github.com/users/dadeg/orgs",
      "repos_url": "https://api.github.com/users/dadeg/repos",
      "events_url": "https://api.github.com/users/dadeg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dadeg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-11T04:38:23Z",
    "updated_at": "2018-02-11T04:38:23Z",
    "author_association": "NONE",
    "body": "@yarrumretep \"Receiver can't even keep his old balance and compare to verify because the actual transfer is not completed until after his call.\" \r\n\r\nThis is interesting. If a user called approve, would the receiving contract be able to inspect the allowed amount (by calling allowance on the token) within the same transaction, or would it fail (or return 0) because the approve call does not finish until the receiving contract returns?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364720821/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364721153",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364721153",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364721153,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcyMTE1Mw==",
    "user": {
      "login": "yarrumretep",
      "id": 725179,
      "node_id": "MDQ6VXNlcjcyNTE3OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/725179?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yarrumretep",
      "html_url": "https://github.com/yarrumretep",
      "followers_url": "https://api.github.com/users/yarrumretep/followers",
      "following_url": "https://api.github.com/users/yarrumretep/following{/other_user}",
      "gists_url": "https://api.github.com/users/yarrumretep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yarrumretep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yarrumretep/subscriptions",
      "organizations_url": "https://api.github.com/users/yarrumretep/orgs",
      "repos_url": "https://api.github.com/users/yarrumretep/repos",
      "events_url": "https://api.github.com/users/yarrumretep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yarrumretep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-11T04:44:40Z",
    "updated_at": "2018-02-11T04:44:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "@dadeg not only inspect, but modify.  Receiver can consume the allowance in the call directly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364721153/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364721851",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364721851",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364721851,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDcyMTg1MQ==",
    "user": {
      "login": "dadeg",
      "id": 4580642,
      "node_id": "MDQ6VXNlcjQ1ODA2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4580642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dadeg",
      "html_url": "https://github.com/dadeg",
      "followers_url": "https://api.github.com/users/dadeg/followers",
      "following_url": "https://api.github.com/users/dadeg/following{/other_user}",
      "gists_url": "https://api.github.com/users/dadeg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dadeg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dadeg/subscriptions",
      "organizations_url": "https://api.github.com/users/dadeg/orgs",
      "repos_url": "https://api.github.com/users/dadeg/repos",
      "events_url": "https://api.github.com/users/dadeg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dadeg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-11T05:00:31Z",
    "updated_at": "2018-02-11T05:00:31Z",
    "author_association": "NONE",
    "body": "@yarrumretep ok, that seems like a good thing. Would a receiving contract be able to do the same sort of inspection on a transfer call? Seems so. But there would be no way to guarantee the _data had the correct sender address. Transfer seems useless like you said. \r\n\r\nAlthough a 223 tokenFallback receiver would have the same issue. There is no guarantee that tokenFallback is being called by a trustworthy 223 token contract. Even inspecting the source code of the caller would be problematic.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364721851/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364810796",
    "html_url": "https://github.com/ethereum/EIPs/issues/827#issuecomment-364810796",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/827",
    "id": 364810796,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDgxMDc5Ng==",
    "user": {
      "login": "AugustoL",
      "id": 7763867,
      "node_id": "MDQ6VXNlcjc3NjM4Njc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7763867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AugustoL",
      "html_url": "https://github.com/AugustoL",
      "followers_url": "https://api.github.com/users/AugustoL/followers",
      "following_url": "https://api.github.com/users/AugustoL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AugustoL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AugustoL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AugustoL/subscriptions",
      "organizations_url": "https://api.github.com/users/AugustoL/orgs",
      "repos_url": "https://api.github.com/users/AugustoL/repos",
      "events_url": "https://api.github.com/users/AugustoL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AugustoL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-12T01:34:16Z",
    "updated_at": "2018-02-12T01:34:16Z",
    "author_association": "NONE",
    "body": "@yarrumretep @dadeg @LefterisJP @ptrwtts Thanks for the discussion and your feedback!\r\n\r\nA quick summary of each function and their capabilities:\r\n\r\n- **approve**: Probably the one that you will need, maybe the only one since it allows the receiver contract to use \"authenticated\" balance. No issues here.\r\n- **transfer**: There is no way to check that the balance that will be transfered is the correct one, this function executed after the token transfer is useful when a function dont need to check any transfer of value.\r\n- **transferFrom**: Same as transfer, only useful when there is no need to check the transfered amount of tokens and want to spend approved balance.\r\n\r\nTo work with this standard a developer must understand all capabilities of each function and the big problems of using a wrong function can bring.\r\n\r\nI think it would be enough to add a section in the proposal with this information.\r\n\r\nWhat do you think? am I missing something? you would add something else?\r\n\r\nI also though in removing the functions, but there are use cases for them and if they are used correctly it wont bring any issues. It should also be a decision of the developer which functions of this standard he needs and if he wants to add only `approve` he can do it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364810796/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
