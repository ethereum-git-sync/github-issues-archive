{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1723",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1723",
  "id": 403296899,
  "node_id": "MDU6SXNzdWU0MDMyOTY4OTk=",
  "number": 1723,
  "title": "ERC: Cryptography Engine Standard",
  "user": {
    "login": "zac-williamson",
    "id": 1476668,
    "node_id": "MDQ6VXNlcjE0NzY2Njg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1476668?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/zac-williamson",
    "html_url": "https://github.com/zac-williamson",
    "followers_url": "https://api.github.com/users/zac-williamson/followers",
    "following_url": "https://api.github.com/users/zac-williamson/following{/other_user}",
    "gists_url": "https://api.github.com/users/zac-williamson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/zac-williamson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/zac-williamson/subscriptions",
    "organizations_url": "https://api.github.com/users/zac-williamson/orgs",
    "repos_url": "https://api.github.com/users/zac-williamson/repos",
    "events_url": "https://api.github.com/users/zac-williamson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/zac-williamson/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2019-01-25T19:15:32Z",
  "updated_at": "2021-12-04T20:13:13Z",
  "closed_at": "2021-12-04T20:13:13Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "```\r\neip: 1723\r\ntitle: Cryptography Engine\r\nauthor: AZTEC\r\ndiscussions-to: https://github.com/ethereum/EIPs/issues/1723\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2019-01-25\r\n```\r\n\r\n<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->\r\n# Cryptography Engine Standard\r\n\r\n## Simple Summary\r\n<!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the EIP.-->\r\n\r\nThis EIP defines the interface and behaviours of a zero-knowledge proof validation engine, supporting multiple compatible types of zero-knowledge proof. The Cryptography Engine enables developers to construct customized transaction semantics for confidential digital digital assets.\r\n\r\n## Abstract\r\n\r\n<!--A short (~200 word) description of the technical issue being addressed.-->\r\n\r\nThis standard defines a mechanism by which multiple confidential digital assets and confidential DApps can efficiently communicate with one another, whilst enabling developers to customize the transaction semantics of their confidential smart contract.  \r\n\r\nThe Cryptography Engine acts as a validator for a set of mutually compatible zero-knowledge proofs that conform to the AZTEC protocol. These proofs can be used by digital asset builders to construct confidential transaction semantics for digital assets and dApps. By subscribing to the same Cryptography Engine, smart contracts can efficiently communicate with one another while preserving confidentiality.\r\n\r\n## Motivation\r\n\r\nConfidential transactions, where the values inside a transaction are encrypted, are made possible through zero-knowledge proofs. Currently, existing zero-knowledge proofs define *unilateral* transactions - transfers of value of one asset type only, issued by a single user.  \r\n  \r\nWhile useful, there is a significant shortfall between the functionality of current confidential digital assets and public assets. Specifically, when comparing confidential digital assets with the ERC20 token standard, the following functionality is missing:\r\n\r\n1. Smart contracts cannot easily issue confidential transactions on behalf of users (as opposed to external accounts controlled by humans).\r\n2. Confidential assets cannot efficiently communicate with one another confidentially. For example, a confidential decentralized exchange which enacts trades between confidential assets, where observers cannot identify the values inside the trade.\r\n\r\n### Bridging the Gap with the Cryptography Engine\r\n\r\nThe AZTEC protocol enables confidential transactions on Ethereum and the construction of confidential digital assets. At the core of the protocol is the AZTEC commitment function - a method of encrypting data that enables the highly efficient construction and verification of range proofs.  \r\n\r\nThis in turn enables highly efficient **Sigma protocols** - simple zero-knowledge proofs that validate relationships between encrypted numbers via homomorphic arithmetic.  \r\n\r\nThe AZTEC protocol's \"join-split\" transaction enables basic unilateral confidential transfers of value. If a digital asset builder wishes to define more advanced confidential transaction semantics, these can be expressed as a Sigma protocol layered on top of a \"join-split\" transaction.  \r\n\r\nThe Cryptography Engine defines a set of these Sigma protocols, that developers can use in a modular fashion to construct complex confidential transaction semantics.\r\n\r\n### Cross-Asset Interoperability  \r\n\r\nConfidential **settlement**, where an exchange of value between different assets occurs confidentially, is necessary for a wide degree of financial applications. However this is, traditionally, a computationally expensive endeavour: every smart contract in a transaction sequence must validate its own zero-knowledge proof in order to prevent double spending. However this results in redundant computation - the proof statements that these smart contracts are validating will overlap significantly.\r\n\r\nThis problem is solved by using a single verification engine. A confidential AZTEC transaction must satisfy a *balancing relationship* - the transaction inputs must be equal to the transaction outputs. If multiple smart contracts require the *same* balancing relationship to be satisfied, the Cryptography Engine can identify this and prevent redundant computation from being performed. To summarise:\r\n\r\n1. The Cryptography Engine validates AZTEC zero-knowledge proofs.\r\n2. If a proof satisfies one or more balancing relationships, these are recorded by the engine.\r\n3. The Cryptography Engine can use these recorded proofs to validate whether a transfer instruction satisfies a balancing relationship.\r\n\r\nFor example consider a confidential decentralized exchange dApp\r\n\r\n> When the DeX processes an order, it validates a **bilateral swap** zero-knowledge proof via the Cryptography Engine  \r\n>  \r\n> Once validated, the Cryptography Engine converts the proof into **transfer instructions** and returns these to the DeX  \r\n>  \r\n> The DeX forwards the **transfer instructions** to two confidential digital assets  \r\n>  \r\n> Each asset **queries** the Cryptography Engine with the transfer instruction  \r\n>  \r\n> The Cryptography Engine can validate the mathematical legitimacy of the transfer instruction, **without performing additional proof verification**  \r\n\r\nIn the above example, the **bilateral swap** zero-knowledge proof costs approximately 500,000 gas to verify. If each confidential asset also required their own zero-knowledge proof, this would add over **1,000,000** gas to the transaction's gas cost.  \r\n\r\n### Security and Trust  \r\n\r\nThe Cryptography Engine's AZTEC proofs all utilize **the same common reference string**. As a consequence, all confidential smart contracts that use the Cryptography Engine can share the same single trusted setup - a trusted setup is **not** required per dApp, and all dApps can share the same security assumptions.\r\n\r\n## Example Set of Zero-Knowledge Proofs  \r\n\r\nThe following is an initial set of AZTEC protocol proofs that an MVP Cryptography Engine can support. As more use-cases and requirements become apparent, Sigma protocols can be developed that satisfy these use-cases and then added to the Cryptography Engine.\r\n\r\nname | description | # of balancing relationships satisfied | gas costs |\r\n---- | ----------- | -------------------------------------- | --------- |\r\n`join-split` | enables unilateral confidential value transfer | 1 | ~800,000 |\r\n`bilateral-swap` | enables a trade between two confidential assets | 2 | ~500,000 |\r\n`dividend` | verifies an AZTEC note is a public percentage of another AZTEC note. Used for interest and dividend payments | 0 | ~700,000 |\r\n`public-range` | verifies an AZTEC note is greater than/less than a public integer | 0 | ~300,000 |\r\n`private-range` | verifies an AZTEC note is greater than/less than a secret integer | 0 | ~700,000 |\r\n\r\nNote: the gas costs above do NOT include the costs associated with sending the transaction or paying for the input data.\r\n  \r\n## Specification  \r\n  \r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).\r\n\r\nEvery ERC-1723 compliant contract MUST implement the following interface:\r\n\r\n```solidity\r\n/**\r\n * @title The Cryptography Engine\r\n * @dev See https://github.com/ethereum/EIPs/issues/1723\r\n **/\r\ninterface CryptographyEngine {\r\n\r\n    /// @dev emitted when the Cryptography Engine adds or modifies a proof\r\n    event LogSetProof(uint16 _proofType, address _validatorAddress, bool _isBalanced);\r\n\r\n    /// @dev emitted when the Cryptography Engine changes the common reference string\r\n    event LogSetCommonReferenceString(bytes32[6] _commonReferenceString);\r\n\r\n    /// @dev Get the common reference string\r\n    function getCommonReferenceString() external view returns (bytes32[6] _commonReferenceString);\r\n\r\n    /// @dev Get whether a proof satisfies a balancing relationship\r\n    function getIsProofBalanced(uint16 _proofType) external view returns (bool _balanced);\r\n\r\n    /// @dev Get the validator address of a given _proofType\r\n    function getValidatorAddress(uint16 _proofType) external view returns (address _validator);\r\n\r\n    /// @dev Query the engine for a previously validated proof.\r\n    ///      _sender is the address of the entity that originally validated the proof\r\n    function validateProofByHash(bytes32 _proofHash, uint16 _proofType, address _sender) external view returns (bool _valid);\r\n\r\n    /// @dev Set the Cryptography Engine's common reference string. Will change if a new\r\n    ///      trusted setup ceremony is performed\r\n    function setCommonReferenceString(bytes32[6] _commonReferenceString) public;\r\n\r\n    /// @dev Set an AZTEC zero-knowledge proof validator contract against a _proofType.\r\n    ///      _isBalanced defines whether a balancing relationship is satisfied by the proof\r\n    function setProof(uint16 _proofType, address _proofValidatorAddress, bool _isBalanced) public;\r\n\r\n    /// @dev Validate an AZTEC zero-knowledge proof according to _proofType.\r\n    ///      and return transfer instructions to sender\r\n    function validateProof(uint16 _proofType, address _sender, bytes _proofData) external returns (bytes _proofOutputs);\r\n\r\n    /// @dev Clear storage variables set when validating proofs.\r\n    ///      Will only work if sent by address that validated the proofs\r\n    function clearProofByHashes(uint16 _proofType, bytes32[] _proofHashes) external;\r\n}\r\n```  \r\n\r\nThe token contract MUST implement the above interface to be compatible with the standard. The implementation MUST follow the specifications described below.\r\n\r\n### Methods\r\n\r\n#### validateProofByHash\r\n\r\n```solidity\r\nfunction validateProofByHash(bytes32 _proofHash, uint16 _proofType, address _sender) view returns (bool _valid);\r\n```\r\n\r\nAfter a dApp calls `validateProof`, it may issue `confidentialTransferFrom` instructions to one or more confidential digital assets, supplying a `bytes proofOutput` object as a transfer instruction.  \r\n\r\nThis digital asset can then compute the `keccak256` hash of `bytes proofOutput` and query whether this instruction satisfies a balancing relationship by calling `validateProofByHash`.  \r\n\r\nIf `bytes32 _proofHash` comes from a satisfying balancing relationship from a proof sent by `address _sender`, with type `_proofType`, the Cryptography Engine MUST return true.\r\nIf `bytes32 _proofHash` does *not* come from a satisfying balancing relationship, the Cryptography Engine MUST return `false`.\r\n\r\n#### setCommonReferenceString\r\n\r\n```solidity\r\nfunction setCommonReferenceString(bytes32[6] _commonReferenceString) public;\r\n```\r\n\r\nChanges the Cryptography Engine's AZTEC common reference string. This string is generated via a trusted setup ceremony, and can be created via a multiparty computation protocol. The same restrictions that apply to `setProof` should apply to `setCommonReferenceString`.\r\n\r\n#### setProof\r\n\r\n```solidity\r\nfunction setProof(uint16 _proofType, address _proofValidatorAddress, bool _isBalanced) public;\r\n```\r\n\r\nMaps a given `_proofType` to the address of a validator smart contract. This is a privileged action, as providing faulty validator smart contracts fatally undermines the security of the Cryptography Engine. Ideally this method is restricted by a consensus mechanism, where the protocol's stakeholders decide the proof types and validator smart contracts supported by the Cryptography Engine.\r\n\r\n#### validateProof\r\n\r\n```solidity\r\nfunction validateProof(uint16 _proofType, address _sender, bytes _proofData) returns (bytes _proofOutputs)\r\n```\r\n\r\nValidate an AZTEC zero-knowledge proof according to the proof's `_proofType`, proof's `_proofData` and the message `_sender`.  \r\nIf the proof is not valid, this method MUST throw an error.  \r\nIf the proof is valid, `bytes proofOutputs` MUST be formatted according to the Cryptography Engine's [ABI specification](#abi-encoding-of-proofoutputs).  \r\n\r\nThe field `address _sender` corresponds to the address of the entity issuing the original transaction - it is the responsibility of the contract calling the Cryptography Engine to correctly supply this variable. To do otherwise does not affect the security of the Cryptography Engine or its zero-knowledge proofs, however it makes the contract calling `validateProof` vulnerable to front-running attacks.  \r\n\r\nThe Cryptography Engine then MUST record the correctness of `bytes proofOutput` and the `_proofType` against a unique combination of the following components:\r\n\r\n1. The `keccak256` hash of `bytes proofOutput`  \r\n2. The `_proofType`\r\n3. The message sender `msg.sender` (**not** `_sender`)\r\n\r\n#### clearProofByHashes\r\n\r\n```solidity\r\nfunction clearProofByHashes(uint16 _proofType, bytes32[] _proofHashes)\r\n```\r\n\r\nFunction is designed to utilize [EIP-1283](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1283.md) to reduce gas costs. It is highly likely that any storage variables set by `validateProof` are only required for the duration of a single transaction.  \r\n\r\nE.g. a decentralized exchange validating a swap proof and sending transfer instructions to two confidential assets.  \r\n\r\nThis method allows the calling smart contract to recover most of the gas spent by setting `validatedProofs`, by clearing any set state variables before the transaction terminates.\r\n\r\n### Motivation and Rationale for `uint16 _proofType`  \r\n\r\nThe `uint16 _proofType` variable defines which zero-knowledge proof to verify. It functions in a similar way to a function signature, where IDs are represented by 16-bit integers instead of 4-bytes of a keccak256 hash.  \r\n\r\nThe rationale behind this is to provide digital asset builders with an efficient method to define the set of zero-knowledge proofs that their asset subscribes to, without having to set a storage variable for every proof. For the `uint16` type one can use a bit-filter to completely define the set of proofs the asset listens to.  \r\n\r\nThe potential downside is being limited to 65535 proofs. Every proof supported by the crypto-engine must be extensively vetted before being integrated into the engine, with a formal soundness proof - a single insecure proof renders the entire cryptosystem insecure. As a result, a maximum cap of 65535 proofs seems reasonable, as one would question the security of such a broad cryptography engine.\r\n\r\n### ABI Encoding of `proofOutputs`\r\n\r\nDue to the nature of zero-knowledge cryptography, the data structure of a zero-knowledge proof is relatively complex. To abstract this away from users and developers, AZTEC zero-knowledge proofs supplied to the Cryptography Engine are encoded as a `bytes` argument.  \r\n\r\nIt falls to the Cryptography Engine to process this `bytes` argument and present, as an output to a valid proof, transfer instructions to the sender via: `bytes proofOutput`. A transfer instruction involves the following:  \r\n\r\n* What are the AZTEC notes that are inputs to this transaction? (to be destroyed)\r\n* What are the AZTEC output notes? (to be created)  \r\n* If public ERC20 tokens are being converted to/from AZTEC note form, who is the owner?\r\n* If owner !== address(0), how many tokens are being converted? Is this a conversion of public tokens to AZTEC notes, or the opposite?\r\n\r\nThese transfer instructions are not simple. The natural instinct is to encode this data as a struct, however ABI encoding for structs is still experimental and should not be included in a standard.  \r\n  \r\nTo this end, `bytes` types are used to define the structure of `proofOutputs` and its constituent components. A JSON schema of how these types are encoded is provided below. The two key custom types used are an encoding for an AZTEC note, `aztecNote`, as well as the encoding for a `proofOutput`. Encoded data is NOT packed.\r\n\r\nAny implementation of the Cryptography Engine spec MUST format its output according to this specification.  \r\n\r\nIn order to allow developers to easily manipulate `proofOutputs` and its child components, [utilities libraries](#cryptography-engine-utilities) are provided to convert this data into its constituent Solidity types.\r\n\r\n### JSON Schemas\r\n\r\n#### aztecNote\r\n\r\n```js\r\n{\r\n    \"name\": \"aztecNote\",\r\n    \"type\": \"bytes\",\r\n    \"description\": \"a formatted AZTEC note\",\r\n    \"components\": [\r\n        {\r\n            \"name\": \"owner\",\r\n            \"type\": \"address\",\r\n            \"description\": \"owner of the note\"\r\n        },\r\n        {\r\n            \"name\": \"noteHash\",\r\n            \"type\": \"bytes32\",\r\n            \"description\": \"keccak256 hash of uncompressed Note coordinates\"\r\n        },\r\n        {\r\n            \"name\": \"noteData\",\r\n            \"type\": \"bytes\",\r\n            \"description\": \"compressed AZTEC note data. Used when emitting events\",\r\n            \"components\": [\r\n                {\r\n                    \"name\": \"gamma\",\r\n                    \"type\": \"bytes32\",\r\n                    \"description\": \"compressed AZTEC group element 'gamma'. y-coordinate represented by a bit in the 255th bit position\"\r\n                },\r\n                {\r\n                    \"name\": \"sigma\",\r\n                    \"type\": \"bytes32\",\r\n                    \"description\": \"compressed AZTEC group element 'sigma'. y-coordinate represented by a bit in the 255th bit position\"\r\n                },\r\n                {\r\n                    \"name\": \"metadata\",\r\n                    \"type\": \"bytes\",\r\n                    \"description\": \"metadata required by note owner to decrypt note. Usually a compressed secp256k1 group element but can have additional data\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n#### proofOutput\r\n\r\n```js\r\n{\r\n    \"name\": \"proofOutput\",\r\n    \"type\": \"bytes\",\r\n    \"description\": \"a transfer instruction generated from an AZTEC zero-knowledge proof\",\r\n    \"components\": [\r\n        {\r\n            \"name\": \"inputNotes\",\r\n            \"type\": \"bytes\",\r\n            \"description\": \"AZTEC input notes. Formatted as a `bytes` type that contains a dynamic array of `aztecNote` objects\"\r\n        },\r\n        {\r\n            \"name\": \"outputNotes\",\r\n            \"type\": \"bytes\",\r\n            \"description\": \"AZTEC output notes. Formatted as a `bytes` type that contains a dynamic array of `aztecNote` objects\"\r\n        },\r\n        {\r\n            \"name\": \"publicOwner\",\r\n            \"type\": \"address\",\r\n            \"description\": \"if public tokens are being transferred into/from AZTEC note form, this is the owner of the tokens. Otherwise is 0\"\r\n        },\r\n        {\r\n            \"name\": \"publicValue\",\r\n            \"type\": \"int256\",\r\n            \"description\": \"quantity of tokens being transferred into AZTEC note form. Negative value signifies withdrawal from AZTEC notes into token form\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n### Cryptography Engine Utilities\r\n\r\n```solidity\r\npragma solidity 0.4.24;\r\n\r\nlibrary ProofOutputs {\r\n    function length(bytes memory _proofOutputs) internal pure returns (\r\n        uint _numProofOutputs\r\n    ) {\r\n        assembly {\r\n            _numProofOutputs := mload(add(_proofOutputs, 0x20))\r\n        }\r\n    }\r\n\r\n    function getProofOutput(bytes memory _proofOutputs, uint _i) internal pure returns (\r\n        bytes _proofOutput\r\n    ) {\r\n        assembly {\r\n            _proofOutput := add(_proofOutputs, mload(add(add(_proofOutputs, 0x40), mul(_i, 0x20))))\r\n        }\r\n    }\r\n\r\n    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\r\n        bytes memory _inputNotes,\r\n        bytes memory _outputNotes,\r\n        address _publicOwner,\r\n        int256 _publicValue\r\n    ) {\r\n        assembly {\r\n            _inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\r\n            _outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\r\n            _publicOwner := mload(add(_proofOutput, 0x60))\r\n            _publicValue := mload(add(_proofOutput, 0x80))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Notes {\r\n    function length(bytes memory _notes) internal pure returns (\r\n        uint _numNotes\r\n    ) {\r\n        assembly {\r\n            _numNotes := mload(add(_notes, 0x20))\r\n        }\r\n    }\r\n\r\n    function getNote(bytes memory _notes, uint i) internal pure returns (\r\n        bytes _note\r\n    ) {\r\n        assembly {\r\n            _note := add(_notes, mload(add(add(_notes, 0x40), mul(i, 0x20))))\r\n        }\r\n    }\r\n\r\n    function extractNote(bytes memory _note) internal pure returns (\r\n            address _owner,\r\n            bytes32 _noteHash,\r\n            bytes memory _metadata\r\n        ) {\r\n        assembly {\r\n            _owner := mload(add(_note, 0x20))\r\n            _noteHash := mload(add(_note, 0x40))\r\n            _metadata := add(_note, mload(add(_note, 0x60)))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Implementation\r\n<!--The implementations must be completed before any EIP is given status \"Final\", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \"rough consensus and running code\" is still useful when it comes to resolving many discussions of API details.-->\r\n\r\nSee the following resources for a work in progress implementation:\r\n\r\n- [AZTEC Cryptography Engine PoC](https://github.com/AztecProtocol/AZTEC/blob/master/packages/contracts/contracts/ACE/ACE.sol)\r\n- [Join-Split Transaction Validator](https://github.com/AztecProtocol/AZTEC/blob/master/packages/contracts/contracts/ACE/validators/AZTECJoinSplit/AZTECJoinSplit.sol)\r\n\r\nTo see more code, head to [the AZTEC monorepo](https://github.com/AztecProtocol/AZTEC). Many thanks to @PaulRBerg, @thomas-waite, @ArnSch and the @AztecProtocol team for their contributions to this document.\r\n\r\n## Copyright\r\nWork released under [LGPL-3.0](https://www.gnu.org/licenses/lgpl-3.0.en.html).",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1723/reactions",
    "total_count": 13,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 7,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/458928370",
    "html_url": "https://github.com/ethereum/EIPs/issues/1723#issuecomment-458928370",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723",
    "id": 458928370,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODkyODM3MA==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-30T12:35:51Z",
    "updated_at": "2019-01-30T12:35:51Z",
    "author_association": "NONE",
    "body": "Great to see you standardising this and making great progress in the corresponding Aztec protocol!\r\n\r\nCouple of thoughts / questions:\r\n\r\n1. If `_proofType` always maps to whether or not a `_proofType` is of a balancing relationship(s) or not, I’m wondering why this needs to be stored on chain (i.e. the mapping from `_proofType` to `_isBalanced`)? Did you have a use-case for this in mind (i.e. where a caller would not know the details of the `_proofType` it was using, but would need to know whether the specific `_proofType` satisfied a balancing relationship)?\r\n\r\n2. Should a call to `setProof` and `setCommonReferenceString` clear existing proofs (for the specific type in the first case, and all types in the second case)? Otherwise a caller to `validateProofByHash` would not have any guarantees about the terms under which the outputs which it is validating were proven.\r\n\r\n3. You mention that the reason `validateProof` needs to take in a `_sender` address is to avoid a possible front-running attack - could you elaborate a bit on this with an example?\r\n\r\n4. The links under the `Implementation` section are out of date although the contracts can be easily found in your repo.\r\n\r\n5. With `clearProofByHashes` do you foresee the `validateProof` and `validateProofByHash` always happening inside a single transaction (and hence no one can call this function in-between to grief the caller of `validateProofByHash`)? If that is the case, and in both instances it is smart contracts calling out to the `Cryptography Engine` then I guess `validateProofByHash` would only be needed if the smart contract calling this function didn't trust the smart contract that was asserting the `proofOutput` which seems unusual unless this contract could be upgraded or otherwise tampered with.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/458928370/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/461372332",
    "html_url": "https://github.com/ethereum/EIPs/issues/1723#issuecomment-461372332",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723",
    "id": 461372332,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTM3MjMzMg==",
    "user": {
      "login": "zac-williamson",
      "id": 1476668,
      "node_id": "MDQ6VXNlcjE0NzY2Njg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1476668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zac-williamson",
      "html_url": "https://github.com/zac-williamson",
      "followers_url": "https://api.github.com/users/zac-williamson/followers",
      "following_url": "https://api.github.com/users/zac-williamson/following{/other_user}",
      "gists_url": "https://api.github.com/users/zac-williamson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zac-williamson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zac-williamson/subscriptions",
      "organizations_url": "https://api.github.com/users/zac-williamson/orgs",
      "repos_url": "https://api.github.com/users/zac-williamson/repos",
      "events_url": "https://api.github.com/users/zac-williamson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zac-williamson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T10:51:12Z",
    "updated_at": "2019-02-07T10:51:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Great to see you standardising this and making great progress in the corresponding Aztec protocol!\r\n> \r\n> Couple of thoughts / questions:\r\n> \r\n> 1. If `_proofType` always maps to whether or not a `_proofType` is of a balancing relationship(s) or not, I’m wondering why this needs to be stored on chain (i.e. the mapping from `_proofType` to `_isBalanced`)? Did you have a use-case for this in mind (i.e. where a caller would not know the details of the `_proofType` it was using, but would need to know whether the specific `_proofType` satisfied a balancing relationship)?\r\n> 2. Should a call to `setProof` and `setCommonReferenceString` clear existing proofs (for the specific type in the first case, and all types in the second case)? Otherwise a caller to `validateProofByHash` would not have any guarantees about the terms under which the outputs which it is validating were proven.\r\n> 3. You mention that the reason `validateProof` needs to take in a `_sender` address is to avoid a possible front-running attack - could you elaborate a bit on this with an example?\r\n> 4. The links under the `Implementation` section are out of date although the contracts can be easily found in your repo.\r\n> 5. With `clearProofByHashes` do you foresee the `validateProof` and `validateProofByHash` always happening inside a single transaction (and hence no one can call this function in-between to grief the caller of `validateProofByHash`)? If that is the case, and in both instances it is smart contracts calling out to the `Cryptography Engine` then I guess `validateProofByHash` would only be needed if the smart contract calling this function didn't trust the smart contract that was asserting the `proofOutput` which seems unusual unless this contract could be upgraded or otherwise tampered with.\r\n\r\nHeya! Sorry for the slow reply.  \r\n\r\n1. any smart contract that intends to manipulate a registry of AZTEC notes based on proofs from the Cryptography Engine (e.g. ERC1724) will need to know whether a given proof type satisfies a balancing relationship. `isBalanced` enables a contract to validate this, without having to have foreknowledge about the proofs supported by the Cryptography Engine  \r\n\r\n2. Thanks for bringing that up. That issue might get resolved because we're thinking of changing `setProof` so that existing proofs cannot be modified, so that developers can have surety over a given proof if they intend to use it in their smart contract. You're correct that we'll need to invalidate previous proofs if the CRS gets updated. I'll update the EIP to reflect this.  \r\n\r\n3. If I construct a valid zero-knowledge proof and then broadcast it to the network, theoretically an attacker could grab my proof out of the mining pool and broadcast it themselves, and use it for their own purposes. By integrating `_sender` into the zero-knowledge proof, the proof is only valid when broadcast from a single account.  \r\n\r\n4. Thanks for identifying that, I'll update the links  \r\n\r\n5. This is correct. If I'm building a zero-knowledge Dapp that interacts with confidential assets, these assets cannot assume any instructions sent to them from my Dapp are legitimate, and must validate the instructions with the Cryptography Engine.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/461372332/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705535",
    "html_url": "https://github.com/ethereum/EIPs/issues/1723#issuecomment-974705535",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723",
    "id": 974705535,
    "node_id": "IC_kwDOAq426M46GNN_",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-20T20:12:45Z",
    "updated_at": "2021-11-20T20:12:45Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705535/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086471",
    "html_url": "https://github.com/ethereum/EIPs/issues/1723#issuecomment-986086471",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1723",
    "id": 986086471,
    "node_id": "IC_kwDOAq426M46xnxH",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-04T20:13:12Z",
    "updated_at": "2021-12-04T20:13:12Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
