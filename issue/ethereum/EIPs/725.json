{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/725/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/725/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/725/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/725",
  "id": 262184482,
  "node_id": "MDU6SXNzdWUyNjIxODQ0ODI=",
  "number": 725,
  "title": "ERC: Proxy Account",
  "user": {
    "login": "frozeman",
    "id": 232662,
    "node_id": "MDQ6VXNlcjIzMjY2Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/frozeman",
    "html_url": "https://github.com/frozeman",
    "followers_url": "https://api.github.com/users/frozeman/followers",
    "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
    "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
    "organizations_url": "https://api.github.com/users/frozeman/orgs",
    "repos_url": "https://api.github.com/users/frozeman/repos",
    "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
    "received_events_url": "https://api.github.com/users/frozeman/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 274,
  "created_at": "2017-10-02T18:41:46Z",
  "updated_at": "2022-03-19T11:03:05Z",
  "closed_at": "2022-03-19T11:03:05Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "```\r\neip: <to be assigned>\r\ntitle: ERC-725 Smart Contract Based Account\r\nauthor: Fabian Vogelsteller <fabian@lukso.network>, Tyler Yasaka (@tyleryasaka)\r\ndiscussions-to: https://github.com/ethereum/EIPs/issues/725\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\nrequires: ERC165, ERC173, ERC1271 (optional)\r\ncreated: 2017-10-02\r\nupdated: 2020-07-02\r\n```\r\n\r\n**This is the new 725 v2 standard, that is radically different from [ERC 725 v1](https://github.com/ethereum/EIPs/blob/ede8c26a77eb1ac8fa2d01d8743a8cf259d8d45b/EIPS/eip-725.md). ERC 725 v1 is be moved to #734 as a new key manager standard.**\r\n--------\r\n\r\n## Simple Summary\r\nA standard interface for a smart contract based account with attachable key value store.\r\n\r\n## Abstract\r\n\r\nThe following describes standard functions for a unique smart contract based account that can be used by humans,\r\ngroups, organisations, objects and machines.\r\n\r\nThe standard is divided into two sub standards:\r\n\r\n`ERC725X`:\r\nCan execute arbitrary smart contracts using and deploy other smart contracts.\r\n\r\n`ERC725Y`:\r\nCan hold arbitrary data through a generic key/value store.\r\n\r\n## Motivation\r\n\r\nStandardizing a minimal interface for a smart contract based account allows any interface to operate through these account types.\r\nSmart contact based accounts following this standard have the following advantages:\r\n\r\n- can hold any asset (native token, e.g. ERC20 like tokens)\r\n- can execute any smart contract and deploy smart contracts\r\n- have upgradeable security (through owner change, e.g. to a gnosis safe)\r\n- are basic enough to work for for a long time\r\n- are extensible though additional standardisation of the key/value data.\r\n- can function as an owner/controller or proxy of other smart contracts\r\n\r\n\r\n## Specification\r\n\r\n### ERC725X \r\n\r\nERC165 identifier: `0x44c028fe`\r\n\r\n#### execute\r\n\r\nExecutes a call on any other smart contracts, transfers the blockchains native token, or deploys a new smart contract.\r\nMUST only be called by the current owner of the contract.\r\n\r\n```js\r\nfunction execute(uint256 operationType, address to, uint256 value, bytes data)\r\n```\r\n\r\nThe `operationType` can execute the following operations:\r\n- `0` for `call`\r\n- `1` for `delegatecall`\r\n- `2` for `create2`\r\n- `3` for `create`\r\n\r\nOthers may be added in the future.\r\n\r\n**Triggers Event:** [ContractCreated](#contractcreated) if a contract was created\r\n\r\n### Events\r\n\r\n#### ContractCreated\r\n\r\nMUST be triggered when `execute` creates a new contract using the `_operationType` `1`.\r\n\r\n```js\r\nevent ContractCreated(address indexed contractAddress)\r\n```\r\n\r\n### ERC725Y\r\n\r\nERC165 identifier: `0x2bd57b73`\r\n\r\n#### getData\r\n\r\nReturns the data at the specified key.\r\n\r\n```js\r\nfunction getData(bytes32 key) external view returns(bytes value)\r\n```\r\n\r\n#### setData\r\n\r\nSets the data at a specific key. MUST only be called by the current owner of the contract.\r\n\r\n**Triggers Event:** [DataChanged](#datachanged)\r\n\r\n```js\r\nfunction setData(bytes32 _key, bytes memory _value) external\r\n```\r\n\r\n### Events\r\n\r\n#### DataChanged\r\n\r\nMUST be triggered when `setData` was successfully called.\r\n\r\n```js\r\nevent DataChanged(bytes32 indexed key, bytes value)\r\n```\r\n\r\n\r\n### Ownership\r\n\r\nThis contract is controlled by an owner. The owner can be a smart contract or an external account.\r\nThis standard requires [ERC173](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md) and should implement the functions:\r\n\r\n- `owner() view`\r\n- `transferOwnership(address newOwner)`\r\n- and the Event `event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)`\r\n\r\n### Data keys\r\n\r\nData keys, should be the keccak256 hash of a type name.\r\ne.g. `keccak256('ERCXXXMyNewKeyType')` is `0x6935a24ea384927f250ee0b954ed498cd9203fc5d2bf95c735e52e6ca675e047`\r\n\r\n#### Multiple keys of the same type\r\n\r\nIf you require multiple keys of the same key type they MUST be defined as follows:\r\n\r\n- The keytype name MUST have a `[]` add and then hashed\r\n- The key hash MUST contain the number of all elements, and is required to be updated when a new key element is added.\r\n\r\nFor all other elements:\r\n- The first 16 bytes are the first 16 bytes of the key hash\r\n- The second 16 bytes is a `uint128` of the number of the element\r\n- Elements start at number `0`\r\n\r\n##### Example\r\nThis would looks as follows for `ERCXXXMyNewKeyType[]` (keccak256: `0x4f876465dbe22c8495f4e4f823d846957ddb8ce6006afe66ddc5bac4f0626767`): \r\n- element number: key: `0x4f876465dbe22c8495f4e4f823d846957ddb8ce6006afe66ddc5bac4f0626767`, value: `0x0000000000000000000000000000000000000000000000000000000000000002` (2 elements)\r\n- element 1: key: `0x4f876465dbe22c8495f4e4f823d8469500000000000000000000000000000000`, value: `0x123...` (element 0)\r\n- element 2: key: `0x4f876465dbe22c8495f4e4f823d8469500000000000000000000000000000001`, value: `0x321...` (element 1)\r\n...\r\n\r\n#### Default key values\r\n\r\nERC725 key standards need to be defined within new standards, we suggest the following defaults:\r\n\r\n| Name | Description | Key | value |\r\n| --- | --- | --- | --- |\r\n| SupportedStandards | Allows to determine standards supported by this contract | `0xeafec4d89fa9619884b6b89135626455000000000000000000000000xxxxxxxx`, where `xxxxxxxx` is the 4 bytes identifier of the standard supported | Value can be defined by the standard, by default it should be the 4 bytes identifier  e.g. `0x7a30e6fc` |\r\n| SupportedStandards > ERC725Account | Allows to determine standards supported by this contract | `0xeafec4d89fa9619884b6b89135626455000000000000000000000000afdeb5d6`, where `afdeb5d6` is the 4 bytes part of the hash of `keccak256('ERC725Account')` | Value is the 4 bytes identifier `0xafdeb5d6` |\r\n\r\n\r\n##### ERC725Account\r\n\r\nAn ERC725Account is an ERC725 smart contract based account for storing of assets and execution of other smart contracts.\r\n\r\n- `ERC173` to be controllable by an owner, that could be am external account, or smart contract\r\n- `ERC725X` to interact with other smart contracts\r\n- `ERC725Y` to attach data to the account for future extensibility\r\n- COULD have `ERC1271` to be able to verify signatures from owners.\r\n- Should fire the `event ValueReceived(address indexed sender, uint256 indexed value)` if ETH is received.\r\n\r\nA full implementation of an `ERC725Account` can be found [found here](https://github.com/ERC725Alliance/ERC725/tree/master/implementations/contracts).\r\n\r\n## Rationale\r\n\r\nThe purpose of an smart contract account is to allow an entity to exist as a first-class citizen with the ability to execute arbitrary contract calls.\r\n\r\n## Implementation\r\n\r\n- [Latest implementation](https://github.com/ERC725Alliance/ERC725/tree/master/implementations/contracts)\r\n\r\n\r\n### Solidity Interfaces\r\n```solidity\r\n// SPDX-License-Identifier: CC0-1.0\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n//ERC165 identifier: `0x44c028fe`\r\ninterface IERC725X  /* is ERC165, ERC173 */ {\r\n    event ContractCreated(address indexed contractAddress);\r\n    event Executed(uint256 indexed operation, address indexed to, uint256 indexed  value, bytes data);\r\n\r\n    function execute(uint256 operationType, address to, uint256 value, bytes memory data) external;\r\n}\r\n\r\n//ERC165 identifier: `0x2bd57b73`\r\ninterface IERC725Y /* is ERC165, ERC173 */ {\r\n    event DataChanged(bytes32 indexed key, bytes value);\r\n\r\n    function getData(bytes32 key) external view returns (bytes memory value);\r\n    function setData(bytes32 key, bytes memory value) external;\r\n}\r\n\r\ninterface IERC725 /* is IERC725X, IERC725Y */ {\r\n\r\n}\r\n\r\ninterface IERC725Account /* is IERC725, IERC725Y, IERC1271 */ {\r\n    event ValueReceived(address indexed sender, uint256 indexed value);\r\n}\r\n```\r\n\r\n## Flow chart\r\n\r\n![ERC725v2-flow](https://user-images.githubusercontent.com/232662/57334038-996a8b00-70ec-11e9-9179-4dda3f30e09d.PNG)\r\n\r\n## Additional References\r\n\r\n- [Slides of the ERC Identity presentation](https://www.slideshare.net/FabianVogelsteller/erc-725-identity)\r\n- [In-contract claim VS claim registry](https://github.com/ethereum/wiki/wiki/ERC-735:-Claim-Holder-Registry-vs.-in-contract)\r\n- [Identity related reports](https://www.weboftrust.info/specs.html)\r\n- [W3C Verifiable Claims Use Cases](https://w3c.github.io/vc-use-cases/)\r\n- [Decentralised Identity Foundation](https://identity.foundation)\r\n- [Sovrin Foundation Self Sovereign Identity](https://sovrin.org/wp-content/uploads/2017/06/The-Inevitable-Rise-of-Self-Sovereign-Identity.pdf)\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/725/reactions",
    "total_count": 166,
    "+1": 106,
    "-1": 2,
    "laugh": 0,
    "hooray": 23,
    "confused": 7,
    "heart": 28,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/725/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333634991",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333634991",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333634991,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzYzNDk5MQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T19:12:07Z",
    "updated_at": "2017-10-02T19:37:50Z",
    "author_association": "NONE",
    "body": "This is a very useful ERC. I would remove all the Must and Should comments regarding types of keys as it should really be left up to the implementation of the contract. \r\n\r\nSome contract types might want to have the admin functions, like `claim` or `addKey` be made by some types of admin keys, some might want to make those available to different types of keys, some might want to make the process to addKeys to go through the same process as any `execute` call will go to. This actually doesn't add much complexity: if you want a contract like that, just make so that only the contract itself can call some functions, and then make functions like `addKey` be actually just a proxy that creates a proper request to execute them, via whatever mechanism `execute` needs to go.\r\n\r\n---\r\n\r\n```\r\nfunction approve(uint256 _id) returns (bool success)\r\n```\r\n\r\nyou should either add a second boolean parameter to say either you approve or not, or add a second function called `reject`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333634991/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333641540",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333641540",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333641540,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY0MTU0MA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T19:37:27Z",
    "updated_at": "2017-10-02T19:38:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "I added the `bool` to the approve, just forgot that. \r\n\r\nConcerning the flexibility of key addition/removals, i added:\r\n\"MUST only be done by keys of type `1`, or the identity itself. If its the identity itself, the approval process will determine its approval.\"\r\n\r\nWhich includes either using key type 1, or the identity itself, e.g. then only the identity contract itself can call those function, and they always go through the approval process.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333641540/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333642505",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333642505",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333642505,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY0MjUwNQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T19:41:12Z",
    "updated_at": "2017-10-02T19:41:12Z",
    "author_association": "NONE",
    "body": "It's just that I don't believe defining key types should be in the scope of this ERC. For some cases, like a democracy, the strings can represent different types of agents: voters, election officials, ID validators, those who can propose new stuff, etc. For a more hierarchical organization, type can be a number representing their rank: for some smaller is more important, for others, bigger is more important.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333642505/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333644194",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333644194",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333644194,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY0NDE5NA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T19:47:44Z",
    "updated_at": "2017-10-02T19:48:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "The reason to add key types, is to prevent people from running around with keys, which can overtake their identity, but rather only use they action keys on a daily basis. Those wont have the ability to remove or change keys, which reduces the risk to loose your identity all together.\r\n\r\nThe other advantage is that it allows to define purposes to keys, which other entities or contracts can then use to derive the purpose of a user action on their system. E.g. if key type `23` means award collector, then a game interface knows which one to assign awards to.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333644194/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333647309",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333647309",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333647309,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY0NzMwOQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T19:59:07Z",
    "updated_at": "2017-10-02T19:59:07Z",
    "author_association": "MEMBER",
    "body": "I would like to see some details/arguments as to why this benefits from being a standard.  In what ways do we gain interoperability benefits from having this standardized?  What types of general purpose tooling are we expecting people to build that will need to work with unknown future implementations of this?\r\n\r\nLooking over the methods, it seems like a large number of them would qualify as \"implementation details\" and are not relevant to creating an generic identity management standard.  For example, how a particular identity provider does key management is not something that needs to work with many tools, it just needs to work with the identity provider's tool suite.  Even some contract that supports 10 identity providers and wants to interface with them all presumably needs to trust those providers in advance, meaning they don't need to build their contract to support arbitrary future providers.\r\n\r\nGiven the current motivation section, I would recommend that this not be a standard and instead just be a contract/dApp that anyone can write and deploy.  😄 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333647309/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333661328",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333661328",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333661328,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY2MTMyOA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T20:51:45Z",
    "updated_at": "2017-10-02T20:51:45Z",
    "author_association": "NONE",
    "body": "@MicahZoltu I disagree there.  If I'd like to be able to use an identity in Mist, it means that I want to create an account, allow that account do things on behalf of others. What I mostly need to be standardized is the addKey, execute and approve. We can use our own private contract, but I think it's nice to try to work together with others.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333661328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333667944",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333667944",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333667944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY2Nzk0NA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T21:17:14Z",
    "updated_at": "2017-10-02T21:50:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "This needs to be standardized so that other contracts can interact with real world identities, automatically check and verify them. It’s not mainly necessary for interfaces alone. Also this contract represents ONE identity. The addition of claims need to be standardized, so that other identities can issue claims about each other. \r\n\r\nVerifying an identity  would happen in the following ways:\r\n- either The calling contract knows the claimtype (are not defined yet, but would be things like address, biometric data etc) and  issuer it trusts. Then he simply needs to retrieve that claim and verify that it’s signature contains the address of the identity and the claim number. And checks that this signing address belongs to the issuers identity. \r\n- or he will retrieve claim by type and then goes and checks the issuers identity claims. This can be done down as many ways as necessary to end up at an trusted claim. \r\n\r\nBut I assume over time known and trusted issuers will appear so only one check needs to be done. \r\n\r\nI might write an extra document to explain all the ways of how one can interact with this contract. But I would like to keep that apart from the ERC itself to keep it easy to read. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333667944/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333696869",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333696869",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333696869,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzY5Njg2OQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T23:45:25Z",
    "updated_at": "2017-10-02T23:46:30Z",
    "author_association": "MEMBER",
    "body": "In order for there to be value in a _standard_ there needs to be interoperability concerns that are being addressed.  We don't need a standard for prediction markets, or a standard for exchanges or a standard for gambling games unless there is a compelling argument as to how one of these things would be better if they were interoperable.  There isn't significant value in making it so all gambling games have the same interface, since users will interact with each gambling game via a dApp custom built for that gambling game.\r\n\r\nA good example of useful standardization is token contracts.  There is value in standardizing tokens so that an application (e.g., Wallet, exchange, etc.) can interact with any token the user provides without needing to know about it in advance or write custom integrations for each token.  However, there is little to no value in standardizing how tokens come into existence because there isn't a strong need for a general purpose UI for token management.  Each token author can build a token management UI just for their token, end users won't be using this so it doesn't even need to have a familiar interface.\r\n\r\n@alexvandesande You have indicated that you want `addKey`, `execute` and `approve` standardized.  How would standardizing those add value to the ecosystem?  What can you do with those things standardized across many implementations that you wouldn't be able to do if they were not standardized?\r\n\r\n@frozeman It sounds like you have a grand vision in your head that isn't expressed clearly in this EIP or discussion.  I would love to hear more about it.\r\n\r\nAs a dApp developer who wants to verify the identity of someone interacting with my contract, I need to go to an identity provider that I trust and and say, \"account X claims to be UUID Y, please verify\" (or similar) and they would then return true or false.  This is certainly _useful_, but I do not see where in this process a standard adds value.  Since I need a pre-existing trust relationship with the identity provider, my dApp won't be accepting any random identity provider that a user gives me.  I must integrate my dApp with specific identity providers, and in almost all situations I can think of I will pick one (and only one).\r\n\r\nTo be really clear, I'm not arguing that Identity Providers are bad.  I'm arguing that creating a \"standard\" (and going through the RFC process) for every useful contract someone can think of is bad.  There _may_ be value in this being standardized, but it is not immediately apparent to me and I _want_ you to convince me that standardization _adds value_.\r\n\r\nEdit: In case it isn't clear exactly what I'm looking for, I would like to see a problem statement that shows some problem that can't be solved without a standard.  Right now this EIP is missing a problem statement.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333696869/reactions",
      "total_count": 10,
      "+1": 10,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333763447",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333763447",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333763447,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzc2MzQ0Nw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T07:33:19Z",
    "updated_at": "2017-10-03T07:33:19Z",
    "author_association": "MEMBER",
    "body": "Some upfront definitions would be good. What are keys? Are they cryptographic identities? Why not addresses? What is a claim for, and how does it work?\r\n\r\nInterface definitions probably shouldn't contain Solidity-specific types (eg, `mapping(foo=>bar) baz`), but instead the interfaces they generate (eg, `function baz(foo) returns(bar);`). How it's implemented is an implementation detail for the contract.\r\n\r\nI agree with @alexvandesande that principal types should be left up to the implementation. Role accounts are a good thing and should be encouraged, but there's no need for the spec to mandate what roles exist and what privileges they have.\r\n\r\n@MicahZoltu I believe the purpose of standardising this is to allow multiple clients (eg, wallets) to interact with multiple implementations of identity providers (Eg, multisigs, etc). Without a standard, you have the current situation, where Mist has native UI for multisigs, but only for its own API, Parity has another, and so forth.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333763447/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333798370",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333798370",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333798370,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzc5ODM3MA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T10:10:16Z",
    "updated_at": "2017-10-03T10:20:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu i see this needs a lot more explanation. I kept the standard description concise to make it readable, but many of the concepts i introduce here are not apparent right from the start. I will address each of these points here in the discussion, but also keep in mind, as i wrote above; the ERC draft is not finished yet.\r\nI will be giving a talk at the london meet up on the october 11th, where i will lay out my vision for that standard in more detail. This will be recorded and i will post the video here.\r\n\r\nFirst of this is a standard for a self sovereign identity; This means the owner controls its identity and he allows claims about himself to be attached to his identity. There are no identity providers, but claim issuer (or certifiers). Those simply say: \"I saw him in person, stored his biometric data, and attached a link on his identity\". People who want to verify that they are dealing with a person, either in their contracts, or dapps, websites, etc. can then check on their identity - given they got a signed message from one of its keys - and look for a claim they trust.\r\n\r\nBut to answer you questions:\r\n- Why i think this needs to be standardised:\r\nStandardising this allows other contracts in the future to auto verify users, and implement permission models right in their contract. Standardising also allows other identities, or claim issuers to add claims to an identity. The less important part is standardisation for UI interfaces; But also here we gain the ability to take your identity and make it useful and accessible in Mist, MetaMask, Browsers, Government UIs, border control, community tools and what not... Once an identity is created, it is meant to be used for a long time and over many platforms and UIs, otherwise it can't function as your identity over time.\r\n\r\nDo i think all of the current proposed functions need to be standardised? No; i just wanted to give a more or less complete set of functions, which make clear how they interact together.\r\n\r\n- What is an example use case\r\nImagine the following: You want to interact with an smart contract of a bank to create an account. They need to make KYC on you. In the `openAccount` call from your identity, the bank contract can see this call is coming from an identity, so he will:\r\n      -> look for claim type `1:biometric` and `2:homeAddress` and for a claim issuer they know they trust, like the German state for `1` and the Deutsche Post for `2`. As they know their identity contract addresses, they simply do: `keccak256(issuer address + claimTypeNumber)` and get the index of the claim in YOUR identity. \r\n      -> they retrieve the claim, check that the signed data matches `keccak256(YOUR identity address + claimTypeNumber)` \r\n     -> Now they check that the key which this data was signed, is still hold by the issuers identity contract.\r\n     -> They got their proof - without that they need to actually see the biometric data, nor the address, as they trust the issuer - and they can proceed in opening an account.\r\n\r\nThe whole example above, won't work automated and with unknown parties, if these processes and functions aren't standardised.\r\n\r\nAnother extension of this could be that you have to hop through multiple claim issuers, to reach one you trust, which in return makes you trust all the others, including the one you verify the identity of.\r\n\r\nAlso every claim issuer, needs to implement this identity interface himself, to make sure he is verifiable himself (and keys can be checked).\r\n\r\n@Arachnid concerning key types: If we standardise them we allow many upcoming use cases for keys, as described in my previous comment. Currently i only propose two types: `1` management keys, and `2` action keys. The former is for manage your identity and they should stay safe. There can be `n` of `m` required for any change. The latter is for actions in the world, keys which can act in the name of your identity. Those are replaceable, and for everybody who wants to interact with you, should always check of you still hold those keys in your identity.\r\n\r\nClaim types in return need to be predefined, to allow somebody who wants to verify you to look for what he want a proof about you.\r\n\r\nI choose the word keys, over addresses as this is better understandable in the \"off-chain\" world. Keys are something we use on a daily basis to get into houses and objects, and the term is used in cryptography as well. Addresses is very blockchain specific. Though your identity contract address - i would call \"address\".\r\n\r\nThe current draft allows for all kind of different key management implementations, it doesn't force any, expect that there have to be at least one second step of approval to `execute`, as stated in the draft, some functions..:\r\n\r\n*\"MUST only be done by keys of type 1, or the identity itself. If its the identity itself, the approval process will determine its approval.\"*\r\n\r\n(There is certainly a lot of improvement potential here, and when we think of compatible UIs, we will need to revise that)\r\n\r\nMany of the above concepts may not be clear yet, but they are in the description of the ERC as a very concise sentence:\r\n\r\n*\"This identity can hold keys to sign actions (transactions, documents, logins, access, etc), and claims, which are attested from third parties (issuers) and self attested, as well as a proxy function to act directly on the blockchain.\"*",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333798370/reactions",
      "total_count": 20,
      "+1": 17,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333800157",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333800157",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333800157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzgwMDE1Nw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T10:18:44Z",
    "updated_at": "2017-10-03T10:18:44Z",
    "author_association": "MEMBER",
    "body": "> I choose the word keys, over addresses, as this is better understandable in the \"off-chain\" world. Keys are something we use on a daily basis to get into houses and objects, and the term used in cryptography as well. Addresses is very blockchain specific. Though you identity contract address, i would call \"address\".\r\n\r\nThe problem is, 'keys' has a specific use in cryptography, and you're using them to refer to something that isn't a cryptographic key, or necessarily controlled by one. I'd really suggest choosing a different term.\r\n\r\nIn either case, the EIP definitely needs a definitions section.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333800157/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333803783",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333803783",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333803783,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzgwMzc4Mw==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T10:36:58Z",
    "updated_at": "2017-10-03T12:04:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "I agree we should add a definition section.\r\n\r\nShort answer to the above. `keys` are public keys: Those keys are you hands in the real world, you sign things, you make transactions etc.\r\nThrough these keys and a pointer to your identity, others can go check that its really you.\r\nIf they want to know things about you: e.g. are you a human, or have an address, then they look on the claims about you by others.\r\n\r\n‘Keys’ here can be public keys or other contract, like multisigs and reputation systems. If anybody has a better word for them, I’m happy to change that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333803783/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333846992",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333846992",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333846992,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg0Njk5Mg==",
    "user": {
      "login": "overdrev",
      "id": 1826601,
      "node_id": "MDQ6VXNlcjE4MjY2MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1826601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/overdrev",
      "html_url": "https://github.com/overdrev",
      "followers_url": "https://api.github.com/users/overdrev/followers",
      "following_url": "https://api.github.com/users/overdrev/following{/other_user}",
      "gists_url": "https://api.github.com/users/overdrev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/overdrev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/overdrev/subscriptions",
      "organizations_url": "https://api.github.com/users/overdrev/orgs",
      "repos_url": "https://api.github.com/users/overdrev/repos",
      "events_url": "https://api.github.com/users/overdrev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/overdrev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T13:46:57Z",
    "updated_at": "2017-10-03T13:46:57Z",
    "author_association": "NONE",
    "body": "claims :   \r\na.I would suggest a logic that permits explicit approval of claim by issuer -  perhaps requiring an asynchronous process.  \r\nb. Do we cover a single usage access method such that a third party can prove my info, but only once.  Maybe time limited.  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333846992/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333860319",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333860319",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333860319,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg2MDMxOQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T14:30:12Z",
    "updated_at": "2017-10-03T14:30:12Z",
    "author_association": "NONE",
    "body": "@MicahZoltu \r\n> There is value in standardizing tokens so that an application (e.g., Wallet, exchange, etc.) can interact with any token the user provides without needing to know about it in advance or write custom integrations for each token.\r\n\r\nExactly. I'd like to be able to login with my uPort identity into Mist, use my Mist identity in Status, or log in with my Status identity on a ether play game or post a blog post in Steemit from my Aragon Company identity. Each one can be implemented differently, just keep some common interfaces.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333860319/reactions",
      "total_count": 10,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333865753",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333865753",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333865753,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg2NTc1Mw==",
    "user": {
      "login": "oed",
      "id": 3909429,
      "node_id": "MDQ6VXNlcjM5MDk0Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3909429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oed",
      "html_url": "https://github.com/oed",
      "followers_url": "https://api.github.com/users/oed/followers",
      "following_url": "https://api.github.com/users/oed/following{/other_user}",
      "gists_url": "https://api.github.com/users/oed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oed/subscriptions",
      "organizations_url": "https://api.github.com/users/oed/orgs",
      "repos_url": "https://api.github.com/users/oed/repos",
      "events_url": "https://api.github.com/users/oed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T14:47:18Z",
    "updated_at": "2017-10-03T14:47:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is very interesting and it overlaps a bunch with stuff we are doing with uport. Although we have a quite different design I think discussion and standardization around this will be very usefull. I'll give a breif description of our design before I go on.\r\n\r\nAs the base of our identity we use a very simple [proxy contract](https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol), see also [ERC: Proxy standard](https://github.com/ethereum/EIPs/issues/121). This makes our system very flexible in terms of how you can control an identity. \r\nTo control a proxy contract we use a contract we call [IdentityManager](https://github.com/uport-project/uport-identity/blob/develop/docs/identityManager.md). The basic idea is that we want a single contract that multiple users can use to control their proxies, mostly to reduce gas cost. Here we have the ability to add multiple users etc, but this is something we want to iterate on in the future.\r\nTo issue and lookup claims we have a separate contract [uport-registry](https://github.com/uport-project/uport-registry). The basic idea here is that we want to separate the storing of the claims from the identity itself to a different contract.\r\n\r\nI think this ERC touches two very interesting things, *transaction execution* and *claim structures*.\r\n\r\n### Transaction execution\r\nThe `execute/approve` looks promising and definitely something that should be used for high value transactions. e.g. transaction of > 100 eth needs to be aproved by my hardware wallet. But in the case of low value transactions it seems like a bit of overhead, e.g. I need to send two transactions in order to send a tweet on leeroy. Would be interesting to have a system where some execute are automatically approved.\r\n\r\n### Claims\r\nWe've opted for not storing claims in the identity contract itself, this makes it cheeper to depoy identities while claims can still be associated with the identity with the same level of security. \r\nAnother thing we have though a lot about is the privacy of claims. Right now there is basically no privacy for claims that are on-chain, which is basically a no-go for a lot of our use cases. Instead we are mostly using off-chain claims which also can be securely linked to the identity (proxy contract in our case). Of course we see the benefits of having on-chain claims as well, and standardization around the format of these is very useful, but they should be decoupled from the identity contract itself. Maybe the claim section could be put into a separate ERC?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333865753/reactions",
      "total_count": 9,
      "+1": 9,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333882916",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333882916",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333882916,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg4MjkxNg==",
    "user": {
      "login": "bneiluj",
      "id": 3680497,
      "node_id": "MDQ6VXNlcjM2ODA0OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3680497?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bneiluj",
      "html_url": "https://github.com/bneiluj",
      "followers_url": "https://api.github.com/users/bneiluj/followers",
      "following_url": "https://api.github.com/users/bneiluj/following{/other_user}",
      "gists_url": "https://api.github.com/users/bneiluj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bneiluj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bneiluj/subscriptions",
      "organizations_url": "https://api.github.com/users/bneiluj/orgs",
      "repos_url": "https://api.github.com/users/bneiluj/repos",
      "events_url": "https://api.github.com/users/bneiluj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bneiluj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T15:40:37Z",
    "updated_at": "2017-10-03T15:40:37Z",
    "author_association": "NONE",
    "body": "I agree with @Arachnid - 'keys' should refer to cryptographic key. \r\n\r\n@frozeman Great initiative! This is so needed. It's a great step forward a standard for a self sovereign identity but it will not prevent people from creating more than one identity which is a no-go regarding KYC institution requirement process. Except if the identity public address is linked to multiple trustworthy services.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333882916/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333893466",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333893466",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333893466,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg5MzQ2Ng==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T16:15:15Z",
    "updated_at": "2017-10-03T16:22:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "@overdrev I’m not sure if a Claim permission process is needed, except when an entity wants to know the details of the claim, e.g. see the biometric data stored by the issuer. Then of course we need a async process. I have made some thoughts about that, but this is not really part of this ERC and can be a separate standard.\r\n\r\nI see it as follows: claim data (referenced by ‘bytes claim’) is double encrypted by the issuer and me, if somebody wants to see the actual data they request it at the issuers ‘bytes _location’ and request the issuers part to be decrypted, then they come to me and ask for decrypting the second part, which i can always decline.\r\n\r\nFor b. I’m not sure how a single claim proof should look like, but interesting idea.\r\n\r\n@oed thanks for participating, you guys should have actually started that standardization process ;)\r\nConcerning your approaches:\r\n\r\n**Transaction execution**: the excite function is mainly to act as your identity on the Blockchain in the least cases this contract should and will be used for storing and sending ether. If you want to move money and what that to be publicly visible and attached to your identity, use a multisig, or a wallet which is controlled by your keys from your identity .\r\n\r\n**Claim storage**: I do understand you wanted to create a system which is cheap in gas, as uport will overtake most transaction costs in the beginning, but I don’t think this applies for a self owned standard, and would be the wrong approach to that. At the same time when a standard is found and a library is deployed, deploying a contract which uses that library is quite cheap.\r\n\r\nClaims themself will be added by others, the owner of the identity will only pay for the confirmation. As I think A real used identity won’t attach every new app, or social network as new claim, those claim additions will be rather less. Things like this will be stored in other Reputation systems or uport like systems and can be attached as a self made claim to my identity, this way the identity can be kept rather raw. The “cool” stuff can happen on other experimental systems.\r\n\r\nI’d say there are two main reasons why claims should be with the identity contract:\r\n1. It allows for on chain verifications and in the best case the contract, which wants to verify, only needs to call you identity once. He doesn’t have to go look on another address, or even outside of the BC. This allows for complex automated authentication systems purely running on the Blockchain.\r\n2. People want the feeling of having their things on one place, as funny as this sounds but it makes people feel more in control. It’s hard for people to acces their identity through registry contracts, if they don’t fully trust the registry. On top of that this standard allow for many different implementations of identities, which will all be able to create claims about each other.\r\n\r\nThere is probably more reasons, which don’t come to my mind now.\r\n\r\n**Concerning privacy**: as the claim data is only meta data, the only viable information one can retrieve from your identity is: which claim issuer has claims about me (e.g. the German state, or Vitalik claims something about me), and when that data has changed.\r\n\r\nThis can be an issue, if I don’t want anybody to know I live or are German, but we share a lot more information on social networks daily. Also privacy focused claim provider can pop up, which claim things, like address etc globally, but are trusted by many. Then the only thing it leaks, is that you are privacy focused :)\r\n\r\n@bneiluj people will have more than one identity for sure, as we just start to experiment with this, but once your have gone through the effort to get claims about biometric data and address, etc. you will treat this identity as more valueable. As long as you can add new claims of importance to more than one identity, that’s fine too. The person verifying your identity doesn’t need to care, as long as he can trust the claim issuer.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333893466/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333908223",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333908223",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333908223,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzkwODIyMw==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T16:51:57Z",
    "updated_at": "2017-10-03T16:56:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid I added a definitions section. I’m still open for better names for `keys`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333908223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333911846",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333911846",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333911846,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzkxMTg0Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T17:04:28Z",
    "updated_at": "2017-10-03T17:04:28Z",
    "author_association": "MEMBER",
    "body": "@frozeman Anything other than keys, really. I'd suggest 'principals', for instance.\r\n\r\nIt's still not clear to me what goes in this field. The definition says \"public keys\", but contracts don't have public keys. What would the 'key' for a contract be?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333911846/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333931045",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333931045",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333931045,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzkzMTA0NQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T18:11:50Z",
    "updated_at": "2017-10-03T18:11:50Z",
    "author_association": "NONE",
    "body": "@oed  \r\n> I need to send two transactions in order to send a tweet on leeroy.\r\n\r\nActually I don't think that's how I would recommend. You can sign your tweet with any account, publish and say: \"I am tweeting in behalf of foo.eth\". Then the tweet app can check either that account is listed in one of these keys. No on-chain transaction required.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333931045/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333945776",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-333945776",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 333945776,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzk0NTc3Ng==",
    "user": {
      "login": "jpitts",
      "id": 509756,
      "node_id": "MDQ6VXNlcjUwOTc1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/509756?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jpitts",
      "html_url": "https://github.com/jpitts",
      "followers_url": "https://api.github.com/users/jpitts/followers",
      "following_url": "https://api.github.com/users/jpitts/following{/other_user}",
      "gists_url": "https://api.github.com/users/jpitts/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jpitts/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jpitts/subscriptions",
      "organizations_url": "https://api.github.com/users/jpitts/orgs",
      "repos_url": "https://api.github.com/users/jpitts/repos",
      "events_url": "https://api.github.com/users/jpitts/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jpitts/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T19:04:07Z",
    "updated_at": "2017-10-03T19:04:07Z",
    "author_association": "MEMBER",
    "body": "1. Will the claimTypes enumeration be maintained as part of the standard?\r\n\r\n2. Claim location might be better represented as claim uri, even if it involves a hash. But is a URI scheme involving a hash defined for all cases? I saw a lot of discussions in IPLD / IPFS about URI schemes, and in that community it seems inconclusive.\r\n\r\nExample discussion: https://github.com/ipfs/ipfs/issues/227\r\n\r\nhttps://en.wikipedia.org/wiki/Uniform_Resource_Identifier",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333945776/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334000808",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334000808",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334000808,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDAwMDgwOA==",
    "user": {
      "login": "CDsigma",
      "id": 19202424,
      "node_id": "MDQ6VXNlcjE5MjAyNDI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/19202424?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CDsigma",
      "html_url": "https://github.com/CDsigma",
      "followers_url": "https://api.github.com/users/CDsigma/followers",
      "following_url": "https://api.github.com/users/CDsigma/following{/other_user}",
      "gists_url": "https://api.github.com/users/CDsigma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CDsigma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CDsigma/subscriptions",
      "organizations_url": "https://api.github.com/users/CDsigma/orgs",
      "repos_url": "https://api.github.com/users/CDsigma/repos",
      "events_url": "https://api.github.com/users/CDsigma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CDsigma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T22:45:47Z",
    "updated_at": "2017-10-03T22:45:47Z",
    "author_association": "NONE",
    "body": "Is the plan to allow claimTypes to not only be used to verify an identity but also to verify information about an identity?\r\n\r\nclaimTypes could be used to confirm accreditations from institutions, attendance at events and place of work. So for example if a decentralized Uber was created and this dApp only wanted drivers who had gone to driving school, then claimTypes could be used to confirm this. If the drivers received the proper claimType from a credible driving school they could be drivers for this decentralized application. So claimTypes if used this way could automate the process of checking the credentials of identities.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334000808/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334034491",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334034491",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334034491,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDAzNDQ5MQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T02:36:02Z",
    "updated_at": "2017-10-04T02:36:28Z",
    "author_association": "MEMBER",
    "body": "I understand that you want to keep the contents of the ERC \"just the spec\" but reading over all of the comments here I think the lack of a _really_ clear problem statement and _really_ clear and targeted solution is causing confusion.  It sounds like there are several different interpretations of what this ERC is about in this discussion and everyone has a different image in their head as to what this will be used for.\r\n\r\n@frozeman Can you provide a problem statement or user story as a starting point?  Describe the problem that you are trying to solve (without describing the solution as part of the problem).  I just tried to think of an example problem statement that requires this system but was unable to come up with one, which is why I'm struggling to understand the value of this being a standard.  An example problem statement for a token standard (pre-ERC20) is:\r\n> I want to be able to build a smart wallet that can control any token the user desires, including future tokens that don't yet exist.  The user needs to be able to transfer tokens into the wallet and out of the wallet without risk of the tokens being trapped in the wallet contract.  Currently, each token has a slightly different API so it is not possible to build a wallet without designing it to support each token, and such a wallet would not support future tokens (with as of yet unknown APIs).\r\n\r\nNote: Be prepared for me to offer alternative solutions to your problem statement that don't involve a standard.  😉 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334034491/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334066589",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334066589",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334066589,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDA2NjU4OQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T06:59:30Z",
    "updated_at": "2017-10-04T07:02:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jpitts thanks for sharing.\r\nI would suggest coming up with a set of claimTypes and new standard additions can come up with new ones, that’s why it’s a uint256. We could also leave the type description out of here and make that a totally different standard.\r\n\r\nURI makes sense, I will change that and also change it for a string for now.\r\n\r\n@CDsigma your use case it exactly right, you can have people and institutions claiming things about you, and you can allow those claims attached to your identity. And yes; you can never verify an identity if you don’t verify claims about it.\r\n\r\n@MicahZoltu I agree that it doesn’t seem to catch on right away what the use of this ERC is, though I brought already a few exmpakes which cover your points. But I can try to reformulate:\r\n\r\n- see KYC, currently everybody collects all information about you separately, to make sure they know who you are. E.g. banks, credit services, or any service which needs to have KYC.  A standard will help in so far that everybody can auto check certain clams, and therefore don’t need to store your actually details about you anymore, as they - as long as they trust the claim issuer - don’t need to have the actual information. The current overcollecting is because of lack of a better system.\r\n- imagine you want to prove you are over eighteen. A trusted entity can add a bit ask as claim, which contains a bit that states that’s you are over eigtheen without revealing your age. Again the trust here is moved to the claim issuer, rather than the person want to prove something about themselves. In large th is can create complex trust graphs.\r\n\r\nThere are plenty more, and all come down to yourself wanting to prove something in front of others. And the claim model solves that: you can also take a look at https://sovrin.org/wp-content/uploads/2017/06/The-Inevitable-Rise-of-Self-Sovereign-Identity.pdf as they describe a similar system.\r\n\r\nSo in short the solution the ERC brings:\r\n1. I want to prove something\r\n2. Everybody can verify claims, as they know how and where to look - automatically.\r\n3. This can go as deep as it needs to reach a trusted claim issuer (jumping from issuer to issuer)\r\n4. Your identity can be taken to any interface which needs an identity, without creating a new one for every app.\r\n5. Smart contracts can verify claims automatically\r\n6. You can act outside of the Blockchain and third parties can check your identity on chain.\r\n\r\nI am not aware of any system, which doesn’t require a central authority that allows to create a self sovereign identity. And I am unclear how this can be solved without a standard.\r\n\r\nThe token standard is quite the same. Everybody could have made their own tokens, but only by creating a standard we are able to use them anywhere, and with erc223 we will be able to have those tokens interact. And as you brought up ERC20 a lot, I assume you are aware that I proposed that standard.\r\n\r\nAlso for this standard, the target is not mainly the UIs, but other identities and smart contracts. Though UIs are as important, to be able to take your identity around.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334066589/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334094453",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334094453",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334094453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDA5NDQ1Mw==",
    "user": {
      "login": "oed",
      "id": 3909429,
      "node_id": "MDQ6VXNlcjM5MDk0Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3909429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oed",
      "html_url": "https://github.com/oed",
      "followers_url": "https://api.github.com/users/oed/followers",
      "following_url": "https://api.github.com/users/oed/following{/other_user}",
      "gists_url": "https://api.github.com/users/oed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oed/subscriptions",
      "organizations_url": "https://api.github.com/users/oed/orgs",
      "repos_url": "https://api.github.com/users/oed/repos",
      "events_url": "https://api.github.com/users/oed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T09:05:06Z",
    "updated_at": "2017-10-04T09:48:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "@frozeman \r\nSorry I think I missunderstood what you are trying to do. Let me see if I understand correctly now.\r\n**Transaction execution:** So this is more something along the lines of an identitfier for an identity that you can attach accounts to? It would mostly be used to attach claims to and send claims from. Uport are trying to come up with something similar, but without relying as much on on-chain logic to do so. Check out the work of the [Decentralized Identity Foundation](http://identity.foundation/), in particular the DID spec which uport will be compatible with. \r\n\r\n**Claim storage:** So this will be kind of like a personal registry of claims associated with your identity? If it's only meta data that is being stored on-chain, where would the claim itself be stored?\r\n\r\nRight now claims are stored off-chain by the users themself in uport. One of the main reason for putting a claim on-chain would be if it needs to be verified by a smart contract. The smart contract is likely to want to know something about a particular account that it is interacting with, rather than the identity itself. Having the claims in a separate registry makes it possible to make claims on any kind of account. Not just this very specific *identity* contract. This opens upp for the possiblitity of proving something about an account with a zkp without revelaing which identity owns that account.\r\n\r\nAs for your two main reasons for keeping it in the identity contract:\r\n1. I don't really see a problem of having to look at another contract, as long as it's standardized, maybe accessable from a ENS record? Complex automated auth will still be very much possible.\r\n2. The end user will not know or care about how many contracts are involved. The end user will likely not even know what a smart contract is. The registry would of course be designed so it can be interacted with in a trust-less way. \r\n\r\nThis being said I can see some benefits of putting claims in an identity contract, but for the reasons I stated above I don't think that's the way to go.\r\n\r\nBtw, you should also check out the work being done on [verifiable claims](http://www.weboftrust.info/specs.html)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334094453/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334133332",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334133332",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334133332,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDEzMzMzMg==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T12:02:06Z",
    "updated_at": "2017-10-04T13:47:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "@oed thanks for the links, that looks very interesting and is very similar to what i am trying to do here as well, but with a purely on chain logic. What i can see every body in this space has come up with, is attributes, or claims and keys as actors. Same as me.\r\n\r\nLet me try to break down the contract:\r\n\r\n-> keys: public keys, or other owned smart contract address, which can interact in your name\r\n\r\n    - keys are there to prove identity ownership\r\n    - keys can hold money and act on the blockchain, and can be traced back to this identity\r\n    - smart contracts owned by this identity can be extension systems to the identity, e.g. reputation systems\r\n\r\n->  execute: A function to allow this identity to act directly on other smart contracts, to be an actor \"on-chain\", including holding and transfer of ether.\r\n\r\n-> claims: can be added by others, and verified by others. The claim content is stored off-chain, or onchain, but this is not defined here. Important is that the claim has to a have a proofable piece (which here is the `signature`) and a link to the claim, as well as the issuer.\r\n\r\n    - claims can requested to be added by anyone.\r\n    - claims can only be approved to be added by the owner of this identity\r\n    - claims can be removed at any time by the owner of this identity\r\n    - claims can be altered by the issuer, punishment would be removal (OR we add approval from the owner as well)\r\n\r\n--------\r\n   \r\nTo compare that to the DID, its similar, just that its all in a smart contract and verifiable on chain.\r\n\r\nTo compare that with the W3C [verifiable claims](http://www.weboftrust.info/specs.html), its basically the same, though we can try to align them even more.\r\n\r\nAlso to be clear this is not standardising how claims can look like, how the content is stored, or where. Claims can easily be DDOs for example stored on IPFS. Also how identity verifications are handled off chain, e.g how the message will look like when signing off chain and including your identity address on chain. So there is a lot of defining necessary. This ERC mainly should give a very slick framework to put all those claims and claimtypes and keys inside.\r\n\r\nConcerning the registry and the identity object (DID vs. DDOs), there can sure be a registry on top which holds the addresses of many identity contracts, e.g. governments could this way group citizens etc. but i don't see a need for that in the basic identity spec.\r\n\r\nI am open for a call, to discuss that in person, as i see some misconceptions, or i myself have some.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334133332/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334264543",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334264543",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334264543,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDI2NDU0Mw==",
    "user": {
      "login": "lukehedger",
      "id": 1913316,
      "node_id": "MDQ6VXNlcjE5MTMzMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1913316?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehedger",
      "html_url": "https://github.com/lukehedger",
      "followers_url": "https://api.github.com/users/lukehedger/followers",
      "following_url": "https://api.github.com/users/lukehedger/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehedger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehedger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehedger/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehedger/orgs",
      "repos_url": "https://api.github.com/users/lukehedger/repos",
      "events_url": "https://api.github.com/users/lukehedger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehedger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T19:30:20Z",
    "updated_at": "2017-10-04T19:30:20Z",
    "author_association": "NONE",
    "body": "We've been researching and prototyping a solution for identity in the [META Network](https://github.com/meta-network/docs/blob/master/concepts/identity.md) for the last few months and make use of a lot of the same primitives in this proposal and other projects. Our [current implementation](https://github.com/meta-network/meta-id) uses the ENS to register a subdomain to an identity owner's public address, which resolves to a content-addressed object (eg. stored in Swarm, IPFS) where the identity's metadata (or claims) can be retrieved and verified against signatures on that data. This way we utilise an existing standard and minimise what is stored on-chain.\r\n\r\nGiven how much of an essential component identity is to a system or network, it would be great to see a flexible standard that developers could build on - we know first-hand how complex this can be! If it can incorporate/accommodate other efforts (like W3C standards) then all the better.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334264543/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334447481",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334447481",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334447481,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQ0NzQ4MQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-05T12:18:44Z",
    "updated_at": "2017-10-05T12:18:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "@lukehedger looking forward to contributions.\r\n\r\nI just had a fruitful in person discussion with @oed and we came upon with a few small alterations:\r\n\r\n- I removed the `changeClaim`, as `addClaim` will do the same, and SHOULD trigger already the approval process.\r\n- i added `getKeyType` function and `getKeysByType`, as well as `getClaim` and `getClaimsByType` to allow easy retrieval.\r\n- I added more key types `3: claim signer`, `4: encryption key`, which we can debate to change them or add more.\r\n- i added the `bytes claim` to the `signature` of the claim, so that it can't be altered by the claim holder.\r\n- We were thinking how this idenities could be converted to DDOs (DID descriptor objects), see https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-fall2016/blob/master/draft-documents/DID-Spec-Implementers-Draft-01.pdf for examples of DDOs\r\n- We were talking if its best to move the claim holder part (**Identity verification** in the spec), to a separate spec, which this spec then inherits. The reasoning is that there can be claim holders, which aren't themselves identities. E.g. a smart contract about which a validity claim is issued.\r\n\r\nIt would be really good if work on the holder spec is done first, so that its a good basis, for #725. I will create an issue to discuss this spec part in the coming days.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334447481/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334473712",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334473712",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334473712,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQ3MzcxMg==",
    "user": {
      "login": "m-schmoock",
      "id": 4090425,
      "node_id": "MDQ6VXNlcjQwOTA0MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4090425?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/m-schmoock",
      "html_url": "https://github.com/m-schmoock",
      "followers_url": "https://api.github.com/users/m-schmoock/followers",
      "following_url": "https://api.github.com/users/m-schmoock/following{/other_user}",
      "gists_url": "https://api.github.com/users/m-schmoock/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/m-schmoock/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/m-schmoock/subscriptions",
      "organizations_url": "https://api.github.com/users/m-schmoock/orgs",
      "repos_url": "https://api.github.com/users/m-schmoock/repos",
      "events_url": "https://api.github.com/users/m-schmoock/events{/privacy}",
      "received_events_url": "https://api.github.com/users/m-schmoock/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-05T14:00:19Z",
    "updated_at": "2017-10-05T14:13:16Z",
    "author_association": "NONE",
    "body": "@frozeman \r\nI like the proposal, also, as already pointed out in this discussion, I would see the need to define a standard set of `claimTypes`. This can be done by defining a low-range of well known types: i.e. 0 - arbitrary_number also to be defined in this ERC). As the number 256 Bit number is big enough, we could also think about using a bit-mask to organize topics and sub-types or even claim multiple types as once... just a thought.\r\n\r\nI also think some details are missing regarding the claim (bytes) storage and access.\r\n\r\n... Also a question for a better undestanding:\r\nRegarding the `approve` function, can you hint out what do you mean by \"Triggers on successfull claim addition Event\"\r\n\r\nDoes it mean that if the approve was called by the identity itself or a type 1/2 key, the `approve` function is automatically called by the Contract, as a self verified claims do not need to be approved? If so, please point that out.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334473712/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334475261",
    "html_url": "https://github.com/ethereum/EIPs/issues/725#issuecomment-334475261",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/725",
    "id": 334475261,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQ3NTI2MQ==",
    "user": {
      "login": "oed",
      "id": 3909429,
      "node_id": "MDQ6VXNlcjM5MDk0Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3909429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oed",
      "html_url": "https://github.com/oed",
      "followers_url": "https://api.github.com/users/oed/followers",
      "following_url": "https://api.github.com/users/oed/following{/other_user}",
      "gists_url": "https://api.github.com/users/oed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oed/subscriptions",
      "organizations_url": "https://api.github.com/users/oed/orgs",
      "repos_url": "https://api.github.com/users/oed/repos",
      "events_url": "https://api.github.com/users/oed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-05T14:05:33Z",
    "updated_at": "2017-10-05T14:05:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "To add to @frozeman's comment it might be good to have an example of how this might be used. Let's assume accouont `A`, that implements the \"Claim Holder\" part (Identity verification in the spec), wants to call a smart contract `C`. `C` requires everyone that interacts with it to have some biometric data verified by verifier `V`. The interaction would go like this:\r\n\r\n`A` calls a method on `C`. `C` calls `A.getClaimsByType(1)`, finds the claim issued by `V`, then uses ecrecover to get the public address `k` of the signer of the claim. It can then call `V.getType(k)` to verify that the identity `V` owns the public address `k`.\r\n\r\nWorth noting here is that i `getClaimsByType` returns more than one claim this might become a quite costly call. One way around this would be to check which claim the contract needs and include the `claimIndex` in the method call.\r\n\r\nAs noted this allows for smart contracts to receive and use claims if they implement the \"Claim holder\" interface. But the smart contract wouldn't need the Identity part of this ERC since it can never sign claims anyway.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334475261/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
