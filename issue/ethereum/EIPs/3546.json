{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3546",
  "id": 873950486,
  "node_id": "MDU6SXNzdWU4NzM5NTA0ODY=",
  "number": 3546,
  "title": "[Discussion] Thread about the benefits of an EIP allowing Token Flagging at contract level, to notify aggregators (marketplaces, wallets & co)",
  "user": {
    "login": "dievardump",
    "id": 1753113,
    "node_id": "MDQ6VXNlcjE3NTMxMTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1753113?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dievardump",
    "html_url": "https://github.com/dievardump",
    "followers_url": "https://api.github.com/users/dievardump/followers",
    "following_url": "https://api.github.com/users/dievardump/following{/other_user}",
    "gists_url": "https://api.github.com/users/dievardump/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dievardump/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dievardump/subscriptions",
    "organizations_url": "https://api.github.com/users/dievardump/orgs",
    "repos_url": "https://api.github.com/users/dievardump/repos",
    "events_url": "https://api.github.com/users/dievardump/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dievardump/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2021-05-02T14:03:07Z",
  "updated_at": "2021-11-07T02:28:43Z",
  "closed_at": "2021-11-07T02:28:43Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Hello, I come today to open a discussion about an idea of EIP that I think would benefit the NFT space.\r\n\r\nIdea:\r\n\r\nToday, there are many marketplaces, wallets and aggregators showing data about tokens of all the collections they can find. However there is absolutely no easy way for collections managers to report a token on each and every of those platforms.\r\n\r\nMore, some collections are open (anyone can mint at any time) and decentralized (metadata on IPFS, Arweave or the likes) and it is not technically possible for the collection managers to remove the metadata linked to a token (and sometimes not legally possible if a purchase has been made).\r\nThis could sadly end up with the whole collection banned/removed from a big marketplace or a wallet because of one or a few of the tokens do not respect the law, do copyright infringement, non conformity to ToS, ...\r\n\r\nMoreover, NFTs are still \"booming\" but we will probably soon see a lot of demands to take something down because of case such as copyright infringement, and we will need a way for it to be done on all platforms indexing the data, as fast as possible.\r\n\r\nTherefore, this standard makes it possible in a very easy way for those collections to notify all platforms (marketplaces, aggregators, etc...) that a token is no longer supported/valid/recognized by the distributor (for any reason), and that those platforms should therefore update their database to either delete it or at least mark it as flagged.\r\nIt also allows other contracts to verify this state before, for example, allowing a sale.\r\n\r\nThis EIP idea would enable this flagging at the contract level, with the emitting of an event, that can be easily caught by any platform indexing the contract data, and a getter to get the current flag state of a token.\r\n\r\nBy providing an Event and a Getter, this EIP allows o-chain and off-chain verification of the state, and also make it easy for indexers to get the change of state \"as soon as possible\".\r\nFor platforms that are not indexing data in real time, the getter would be an easy check to add to the \"metadata refresh\" system they use.\r\n\r\nNote: The right to change the flag state of a token should be given only to the collection owner. This is not meant to be publicly used, as it is a mechanism for collection owners to notify aggregators\r\n\r\nNote2: as a safeguard, we could add a `string memory reason` with the flagging, that would help aggregators to understand why the flag has be made, and if it is legitimate or not to remove / hide it from their index.\r\n\r\n\r\n_An example of the use case could be the Axies that have been banned from the game because of multi accounting or any other cheat. With a specification like this one, it would have been very easy for all these platforms to get notified of those ban, and show it._\r\n\r\n\r\nFollowing, you can find a very quick draft that I put together to describe in depth how and why this would be important to have, and help us (platforms, creators and aggregators) a lot\r\n\r\n---\r\ntitle: Token Flagging\r\nauthor: Simon Fremaux (@dievardump)\r\nstatus: Idea\r\ncategory: ERC\r\ncreated: 2021-05-02\r\nrequires: 165\r\n---\r\n\r\n## Simple Summary\r\n\r\nA standardized way to allow collections to Flag a tokenId to notify consumer platforms (Marketplaces & co) to remove it efficiently from their database or mark it as flagged by the token distributor.\r\n\r\n## Abstract\r\n\r\nThis standard extends the NFT specifications ([ERC-721 specification](./eip-721.md) and [ERC-1155 specification](./eip-1155.md) and any other ID based token specification, to allow collection managers to publicly flag a token by its id.\r\n\r\nBy adding one event `event TokenFlag(uint256, bool)` and one getter `function isTokenFlagged(uint256) public view return (bool)` this specification allows collection managers to notify consuming platforms and to allow other contracts to query about a token current flag state.\r\n\r\n## Motivation\r\n\r\nToday, there are many marketplaces, wallets and aggregators showing data about tokens of all the collections they can find. However there is absolutely no easy way for collections managers to report a token on each and every of those platforms.\r\n\r\nMore, some collections are open (anyone can mint at any time) and decentralized (metadata on IPFS, Arweave or the likes) and it is not technically possible for the collection managers to remove the metadata linked to a token (and sometimes not legally possible if a purchase has been made).\r\nThis could sadly end up with the whole collection banned from a platform because of one or a few of the tokens do not respect the law, do copyright infringement, non conformity to ToS, ...\r\n\r\nMoreover, NFTs are still \"booming\" but we will probably soon see a lot of demands to take something down because of case such as copyright infringement, and we will need a way for it to be done on all platforms indexing the data, as fast as possible.\r\n\r\nTherefore, this standard makes it possible in a very easy way for those collections to notify all platforms (marketplaces, aggregators, etc...) that a token is no longer supported/valid/recognized by the distributor (for any reason), and that those platforms should therefore update their database to either delete it or at least mark it as flagged.\r\nIt also allows other contracts to verify this state before, for example, allowing a sale.\r\n\r\nThis EIP enable this flagging at the contract level, with the emitting of an event, that can be easily caught by any platform indexing the contract data, and a getter to get the current flag state of a token.\r\n\r\nBy providing an Event and a Getter, this EIP allows o-chain and off-chain verification of the state, and also make it easy for indexers to get the change of state \"as soon as possible\".\r\nFor aggregators that are not indexing data in real time, the getter would be an easy check to add to the \"metadata refresh\" system they use.\r\n\r\nNote: The right to change the flag state of a token should be given only to the collection owner. This is not meant to be publicly used, as it is a mechanism for collection owners to notify aggregators\r\n\r\n## Specification\r\n\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL\r\nNOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\r\n\"OPTIONAL\" in this document are to be interpreted as described in\r\nRFC 2119.\r\n\r\n**NFT contracts MAY implement this ERC for token flagging to provide a standard method of notifying platforms that a token might have become invalid.**\r\n\r\nMarketplaces that support this standard **MAY** decide to not allow transfer of a token if it is flagged\r\n\r\nImplementers of this standard **MUST** restrict the right to change the flag state to the collection owner. This is not meant to be publicly used, as it is a mechanism for collection owners to notify aggregators. Not for the public to report content to one platform.\r\n\r\nImplementers of this standard **MUST** emit the `TokenFlag` event when a token flag state changes.\r\n\r\nImplementers of this standard **MUST** have all of the following events and functions:\r\n\r\n```solidity\r\npragma solidity ^0.6.0;\r\nimport \"./ERC165.sol\";\r\n\r\n///\r\n/// @dev Implementation of TokenFlagging\r\n///\r\ninterface TokenFlag is ERC165 {\r\n    /// ERC165 bytes to add to interface array - set in parent contract\r\n    /// implementing this standard\r\n    ///\r\n\t\t/// bytes4(keccak256(\"isTokenFlagged(uint256)\")) == 0xcbb1d84c\r\n    /// bytes4 private constant _INTERFACE_ID_TOKENFLAG = 0xcbb1d84c;\r\n\r\n    /// @notice Called to return the current flagged state of a token\r\n    /// @param tokenId - the NFT asset queried for flag\r\n    /// @return isFlagged - boolean of the current flag state for the token\r\n    function isTokenFlagged(uint256 tokenId) public returns (bool isFlagged);\r\n\r\n    /// @dev This event MUST be emitted when a token flag state changes.\r\n    event TokenFlag(\r\n        address indexed tokenId,\r\n        bool indexed flagged,\r\n    );\r\n\r\n    /// @notice Informs callers that this contract supports TokenFlagging\r\n    /// @dev If `_registerInterface(_INTERFACE_ID_TOKENFLAG)` is called\r\n    ///      in the initializer, this should be automatic\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @return `true` if the contract implements\r\n    ///         `_INTERFACE_ID_TOKENFLAG` and `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n```\r\n### Examples\r\n\r\nThis standard being used on an ERC-721 during deployment:\r\n\r\n#### Deploying an ERC-721 and setting the royalty amount and creator\r\n\r\n```solidity\r\nconstructor (string memory name, string memory symbol, string memory baseURI) ERC721(name, symbol) {\r\n        _setBaseURI(baseURI);\r\n        // TokenFlagging interface\r\n        _registerInterface(_INTERFACE_ID_TOKENFLAG);\r\n    }\r\n```\r\n\r\n#### Checking if the NFT being sold on your marketplace is flagged\r\n\r\nNote: checking about flagging when a sale occurs is completely **OPTIONAL**. This EIP is more about data aggregators and off-chain token display / representation.\r\n\r\n```solidity\r\nfunction checkFlag(address registry, uint256 tokenId) internal returns (bool) {\r\n    (bool success, bytes memory data) = address(registry).call(abi.encodeWithSignature(\"isTokenFlagged(uint256)\", tokenId));\r\n\t\treturn success && bool(data);\r\n }\r\n```\r\n\r\n## Rationale\r\n\r\n### Too many platforms aggregating data\r\n\r\nToday, it is very complicated if not impossible to report a token on every marketplaces and aggregators there is. Also, most platforms have problems to keep up with the current market, and it can be days, if not more, before a token is removed from a platform after being reported.\r\n\r\nFor open collections that are allowing users to mint without proof-checking every mint before it happens, this is a big problem since one bad apple can result in the whole collection being banned or removed from a platform.\r\n\r\n### Not every platform has access to Token Metadata\r\n\r\nSome platforms have decided to decentralize the token Metadata, meaning that they store the metadata on decentralized systems (IPFS, Arweave, ...) before linking those metadata in the contract.\r\nThis results in the fact that they can not change those metadata to invalidate a token or destruct it, if it were to be something that does not respect the law or the contract manager Terms of Service.\r\n\r\n### Ease of use for on-chain and off-chain checking\r\n\r\nBy providing an Event and a Getter, this EIP allows o-chain and off-chain verification of the state, and also make it easy for indexers to get the change of state \"as soon as possible\".\r\nFor aggregators that are not indexing data in real time, the getter would be an easy check to add to the \"metadata refresh\" system they use.\r\n\r\n### Structure of the TokenFlag event\r\n\r\nThe `TokenFlag` event will help future-proof this standard and allow potential enhancements in future EIPs.\r\n\r\n`tokenId` allows flagging per token, and indexing it allows all consuming platforms to easily react to a flag state change.\r\n\r\n`flagged` enables to change the flagging state (for example after a period has passed)\r\n\r\n## Backwards Compatibility\r\n\r\nThis standard is completely compatible with current ERC-721 and ERC-1155 standards and any token standard based on Token IDs.\r\n\r\n## Security Considerations\r\n\r\nThe current proposal only enables the collection (contract) owner to change the flag statet of an NFT, this is due to the fact that fake would hurt the collection and the be a big problem for all platforms.\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3546/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/830814680",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-830814680",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 830814680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgzMDgxNDY4MA==",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-05-02T14:03:48Z",
    "updated_at": "2021-05-02T14:03:48Z",
    "author_association": "NONE",
    "body": "Since this is your first issue, we kindly remind you to check out [EIP-1](https://eips.ethereum.org/EIPS/eip-1) for guidance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/830814680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831179392",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-831179392",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 831179392,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgzMTE3OTM5Mg==",
    "user": {
      "login": "lenifoti",
      "id": 15185717,
      "node_id": "MDQ6VXNlcjE1MTg1NzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/15185717?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lenifoti",
      "html_url": "https://github.com/lenifoti",
      "followers_url": "https://api.github.com/users/lenifoti/followers",
      "following_url": "https://api.github.com/users/lenifoti/following{/other_user}",
      "gists_url": "https://api.github.com/users/lenifoti/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lenifoti/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lenifoti/subscriptions",
      "organizations_url": "https://api.github.com/users/lenifoti/orgs",
      "repos_url": "https://api.github.com/users/lenifoti/repos",
      "events_url": "https://api.github.com/users/lenifoti/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lenifoti/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-03T10:44:22Z",
    "updated_at": "2021-05-03T10:44:22Z",
    "author_association": "NONE",
    "body": "@dievardump Should the entity record the reason for flagging?  A bytes32 that could be standardised in some way perhaps?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831179392/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831214720",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-831214720",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 831214720,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgzMTIxNDcyMA==",
    "user": {
      "login": "dievardump",
      "id": 1753113,
      "node_id": "MDQ6VXNlcjE3NTMxMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1753113?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dievardump",
      "html_url": "https://github.com/dievardump",
      "followers_url": "https://api.github.com/users/dievardump/followers",
      "following_url": "https://api.github.com/users/dievardump/following{/other_user}",
      "gists_url": "https://api.github.com/users/dievardump/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dievardump/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dievardump/subscriptions",
      "organizations_url": "https://api.github.com/users/dievardump/orgs",
      "repos_url": "https://api.github.com/users/dievardump/repos",
      "events_url": "https://api.github.com/users/dievardump/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dievardump/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-03T12:01:54Z",
    "updated_at": "2021-05-03T12:20:57Z",
    "author_association": "NONE",
    "body": "> @dievardump Should the entity record the reason for flagging? A bytes32 that could be standardised in some way perhaps?\r\n\r\nthat's why I wanted to add (in the note 2) maybe a string for the reason. Because then consumer platforms can actually manually review why it has been flag, and make their own jugement.\r\n\r\n@anthonygraignic mentioned on discord:\r\n\r\n> Just a though about your Note2: wouldn't be interesting to change the bool in uint8 or uint256 to have a 0: not flagged and others values for categories like you said (1: nudity, 2: hate speech ... ), so platforms can get more info about it and get a long description in the string or an URI of the decision?\r\nBut I agree this kind of solution feel a bit redundant with the string\r\n\r\nI think both your comments join and that it could be a good add (something like `TokenFlag(uint256 tokenId, uint8/uint16 flagCode, string flagReason)`)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831214720/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831333207",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-831333207",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 831333207,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgzMTMzMzIwNw==",
    "user": {
      "login": "anthonygraignic",
      "id": 12660783,
      "node_id": "MDQ6VXNlcjEyNjYwNzgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/12660783?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/anthonygraignic",
      "html_url": "https://github.com/anthonygraignic",
      "followers_url": "https://api.github.com/users/anthonygraignic/followers",
      "following_url": "https://api.github.com/users/anthonygraignic/following{/other_user}",
      "gists_url": "https://api.github.com/users/anthonygraignic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/anthonygraignic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/anthonygraignic/subscriptions",
      "organizations_url": "https://api.github.com/users/anthonygraignic/orgs",
      "repos_url": "https://api.github.com/users/anthonygraignic/repos",
      "events_url": "https://api.github.com/users/anthonygraignic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/anthonygraignic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-03T15:22:36Z",
    "updated_at": "2021-05-03T15:22:36Z",
    "author_association": "NONE",
    "body": "After sleeping on it, I think the `bool` flag is better in the way that consumer platforms won't be able to ignore willingly some category.\r\nBut we could include this category in the string.\r\n \r\n\r\nI think the string should contain (or it can be a link to a JSON file):\r\n\r\n- category\r\n- reason\r\n- decision URI or precision\r\n\r\n\r\nA draft list of category from [a comparative study of the Council of Europe](https://rm.coe.int/CoERMPublicCommonSearchServices/DisplayDCTMContent?documentId=09000016806575b6):\r\n\r\n- the protection of national security, territorial integrity or public safety (e.g.\r\nterrorism),\r\n- the prevention of disorder or crime (e.g. child pornography),\r\n- the protection of health or morals,\r\n- the protection of the reputation or rights of others (e.g. defamation, invasion of\r\nprivacy, intellectual property rights),\r\n- preventing the disclosure of information received in confidence. \r\n\r\n\r\nNB: Some interesting reading and EU-related legislation (would love to get inputs from other countries)\r\n\r\n- [Illegal content on online platforms](https://digital-strategy.ec.europa.eu/en/policies/illegal-content-online-platforms) \r\n- [Facebook Transparency Report](https://transparency.facebook.com/)\r\n- [Google Transparency Report](https://transparencyreport.google.com/)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/831333207/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248891",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-950248891",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 950248891,
    "node_id": "IC_kwDOAq426M44o6W7",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-10-24T02:26:40Z",
    "updated_at": "2021-10-24T02:26:40Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248891/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541374",
    "html_url": "https://github.com/ethereum/EIPs/issues/3546#issuecomment-962541374",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3546",
    "id": 962541374,
    "node_id": "IC_kwDOAq426M45Xzc-",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-07T02:28:42Z",
    "updated_at": "2021-11-07T02:28:42Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
