{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/672/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/672/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/672/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/672",
  "id": 243353285,
  "node_id": "MDU6SXNzdWUyNDMzNTMyODU=",
  "number": 672,
  "title": "ReverseENS Pseudo-Introspection, or standard interface detection",
  "user": {
    "login": "jbaylina",
    "id": 4180156,
    "node_id": "MDQ6VXNlcjQxODAxNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4180156?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbaylina",
    "html_url": "https://github.com/jbaylina",
    "followers_url": "https://api.github.com/users/jbaylina/followers",
    "following_url": "https://api.github.com/users/jbaylina/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbaylina/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbaylina/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbaylina/subscriptions",
    "organizations_url": "https://api.github.com/users/jbaylina/orgs",
    "repos_url": "https://api.github.com/users/jbaylina/repos",
    "events_url": "https://api.github.com/users/jbaylina/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbaylina/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2017-07-17T10:29:57Z",
  "updated_at": "2023-02-17T03:37:06Z",
  "closed_at": "2018-02-20T15:27:03Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Preamble\r\n\r\n    EIP: <to be assigned>\r\n    Title: ReverseENS Pseudo-Introspection, or standard interface detection\r\n    Author: Jordi Baylina @jbaylina, Jorge Izquierdo @izqui\r\n    Type: Standard Track\r\n    Category: ERC\r\n    Status: Draft\r\n    Created: 2017-07-14\r\n\r\n## Simple Summary\r\n\r\nCreates a standard method to publish and discover which interfaces a smart contract or a regular address implements.\r\n\r\n## Abstract\r\n\r\nThis ERC standardizes a way to publish which interfaces does a specific address support or which is the delegated counterparty address that can handle the interface on its behalf. \r\n\r\nThe proposed mechanism allows backwards compatibility for all contracts that can execute arbitrary external transactions (multisigs) and provides an upgrade path for contracts that can designate other contracts as the implementation of a certain interface.\r\n\r\n## Motivation\r\n\r\nFor some \"standard interfaces\" like the ERC 20 token interface ( [#20](https://github.com/ethereum/EIPs/issues/20) ), it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be utilized. \r\n\r\n## Specification\r\n\r\nThe interfaces that a specific address implements will be registered using ReverseENS records. Any address can automatically claim its own `.addr.reverse` for just gas and point it to a resolver. Then, for every new interface the contract supports, it will create a new record (`setSubnodeOwner`) to set each desired address that implements the interface. The public resolver can be used for this purpose, as it implements `addr()` and `setAddr(address)`.\r\n\r\nIf the resolver or the `addr()` for `[InterfaceName].[ADDRESS].addr.reverse` is 0, then we consider the address to not implement the interface.\r\n\r\nOtherwise, the returned `addr()` points to the the contract that implements that interface for the specific address.\r\n\r\nThis address can be the same address if the contract implements the interface, or the address of a different contract (proxy contract) that handles this interface.\r\n\r\n#### Example \r\n```\r\nITokenFallback.1234567890123456789012345678901234567890.addr.reverse -> 0x1234567890123456789012345678901234567890\r\n```\r\n## Rationale\r\n\r\nWe tried to keep this specification as simple as possible. This implementation is also compatible with the current solidity version and the current ENS implementation.\r\n\r\nThis standard has many advantages in respect to the current EIP165 proposal:\r\n\r\n* It allows the definition of different proxy contracts for each interface. \r\n* It allows to extend the functionality with future interfaces by just adding an entry to the ReverseENS which points to a new proxy contract that handles this interface.\r\n* It allows for interface updates\r\n* It allows the definition of functionality for account addresses.\r\n* It allows the addition of interfaces to already deployed multisigs and DAOs.\r\n\r\nAs an example, with this interface itâ€™s trivial to define a proxy contract for a regular address that implements ITokenFallback that defines who can send a token to this address and what to do with this token.\r\n\r\n## Backwards Compatibility\r\n\r\nThis interface allows regular accounts and generic contracts to make any call like multisigs or DAOs, and to define new contracts that implement this interface. \r\n\r\n## Example implementation\r\n\r\n```Solidity\r\npragma solidity ^0.4.18;\r\n\r\ninterface IENS {\r\n    function owner(bytes32 _node) public constant returns(address);\r\n    function resolver(bytes32 _node) public constant returns(address);\r\n    function ttl(bytes32 _node) public constant returns(uint64);\r\n    function setOwner(bytes32 _node, address _owner) public;\r\n    function setSubnodeOwner(bytes32 _node, bytes32 _label, address _owner) public;\r\n    function setResolver(bytes32 _node, address _resolver) public;\r\n    function setTTL(bytes32 _node, uint64 _ttl) public;\r\n}\r\n\r\ninterface IReverseRegistrar {\r\n    function claimWithResolver(address _owner, address _resolver) public returns (bytes32 node);\r\n}\r\n\r\ninterface IPublicResolver {\r\n    function addr(bytes32 _node) public constant returns (address ret);\r\n    function setAddr(bytes32 _node, address _addr) public;\r\n}\r\n\r\n// [functionSig or interfaceId].[address].addr.reverse\r\n\r\n// Base contract for any contract that uses EnsPseudoIntrospection\r\ncontract EIP672 {\r\n    address constant ENS_MAIN = 0x314159265dD8dbb310642f98f50C066173C1259b;\r\n    address constant ENS_ROPSTEM = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;\r\n    address constant ENS_RINKEBY = 0xe7410170f87102DF0055eB195163A03B7F2Bff4A;\r\n    address constant ENS_SIMULATOR = 0x8cDE56336E289c028C8f7CF5c20283fF02272182;\r\n    bytes32 constant public REVERSE_ROOT_NODE = keccak256(keccak256(bytes32(0), keccak256('reverse')), keccak256('addr'));\r\n    bytes32 constant public PUBLICRESOLVE_ROOT_NODE = keccak256(keccak256(bytes32(0), keccak256('eth')), keccak256('resolver'));\r\n    IENS public ens;\r\n\r\n    function EIP672() public {\r\n      if (isContract(ENS_MAIN)) {\r\n        ens = IENS(ENS_MAIN);\r\n      } else if (isContract(ENS_ROPSTEM)) {\r\n        ens = IENS(ENS_ROPSTEM);\r\n      } else if (isContract(ENS_RINKEBY)) {\r\n        ens = IENS(ENS_RINKEBY);\r\n      } else if (isContract(ENS_SIMULATOR)) {\r\n        ens = IENS(ENS_SIMULATOR);\r\n      } else {\r\n        assert(false);\r\n      }\r\n\r\n      IReverseRegistrar reverseRegistrar = IReverseRegistrar(ens.owner(REVERSE_ROOT_NODE));\r\n\r\n      IPublicResolver resolver = IPublicResolver(ens.resolver(PUBLICRESOLVE_ROOT_NODE));\r\n      IPublicResolver publicResolver = IPublicResolver(resolver.addr(PUBLICRESOLVE_ROOT_NODE));\r\n\r\n      reverseRegistrar.claimWithResolver(\r\n        address(this),\r\n        address(publicResolver));\r\n    }\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n\r\n        bytes32 node = rootNodeForAddress(address(this));\r\n        bytes32 ifaceLabelHash = keccak256(ifaceLabel);\r\n        bytes32 ifaceNode = keccak256(node, ifaceLabelHash);\r\n\r\n        ens.setSubnodeOwner(node, ifaceLabelHash, address(this));\r\n\r\n        IPublicResolver resolver = IPublicResolver(ens.resolver(PUBLICRESOLVE_ROOT_NODE));\r\n        IPublicResolver publicResolver = IPublicResolver(resolver.addr(PUBLICRESOLVE_ROOT_NODE));\r\n\r\n        ens.setResolver(ifaceNode, publicResolver);\r\n        publicResolver.setAddr(ifaceNode, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\r\n        bytes32 node = rootNodeForAddress(address(addr));\r\n        bytes32 ifaceNode = keccak256(node, keccak256(ifaceLabel));\r\n        IPublicResolver resolver = IPublicResolver(ens.resolver(ifaceNode));\r\n        if (address(resolver) == 0) return 0;\r\n        return resolver.addr(ifaceNode);\r\n    }\r\n\r\n    function rootNodeForAddress(address addr) internal constant returns (bytes32) {\r\n        return keccak256(REVERSE_ROOT_NODE, keccak256HexAddress(addr));\r\n    }\r\n\r\n    function keccak256HexAddress(address addr) private constant returns (bytes32 ret) {\r\n        addr; ret; // Stop warning us about unused variables\r\n        assembly {\r\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\r\n            let i := 40\r\n        loop:\r\n            i := sub(i, 1)\r\n            mstore8(i, byte(and(addr, 0xf), lookup))\r\n            addr := div(addr, 0x10)\r\n            i := sub(i, 1)\r\n            mstore8(i, byte(and(addr, 0xf), lookup))\r\n            addr := div(addr, 0x10)\r\n            jumpi(loop, i)\r\n            ret := keccak256(0, 40)\r\n        }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n}\r\n```\r\n\r\n## Test Cases\r\n\r\nYou can check the implementation and a test here: https://github.com/jbaylina/eip672\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n\r\n\r\n\r\n\r\n\r\n",
  "closed_by": {
    "login": "jbaylina",
    "id": 4180156,
    "node_id": "MDQ6VXNlcjQxODAxNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4180156?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbaylina",
    "html_url": "https://github.com/jbaylina",
    "followers_url": "https://api.github.com/users/jbaylina/followers",
    "following_url": "https://api.github.com/users/jbaylina/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbaylina/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbaylina/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbaylina/subscriptions",
    "organizations_url": "https://api.github.com/users/jbaylina/orgs",
    "repos_url": "https://api.github.com/users/jbaylina/repos",
    "events_url": "https://api.github.com/users/jbaylina/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbaylina/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/672/reactions",
    "total_count": 7,
    "+1": 7,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/672/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/315895608",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-315895608",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 315895608,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTg5NTYwOA==",
    "user": {
      "login": "LefterisJP",
      "id": 1658405,
      "node_id": "MDQ6VXNlcjE2NTg0MDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1658405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LefterisJP",
      "html_url": "https://github.com/LefterisJP",
      "followers_url": "https://api.github.com/users/LefterisJP/followers",
      "following_url": "https://api.github.com/users/LefterisJP/following{/other_user}",
      "gists_url": "https://api.github.com/users/LefterisJP/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LefterisJP/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LefterisJP/subscriptions",
      "organizations_url": "https://api.github.com/users/LefterisJP/orgs",
      "repos_url": "https://api.github.com/users/LefterisJP/repos",
      "events_url": "https://api.github.com/users/LefterisJP/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LefterisJP/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-17T21:50:16Z",
    "updated_at": "2017-07-17T21:50:16Z",
    "author_association": "MEMBER",
    "body": "It's an interesting idea and just as the original [EIP165](https://github.com/ethereum/EIPs/issues/165) idea it can be really useful for many contract developers. \r\n\r\nI have some questions.\r\n\r\n\r\n1. How would you define `InterfaceName` here? Would the community need to agree on what the name for each interface be? Say `ERC20` for the standard token contract?\r\n\r\n2. How would different versions of an interface be handled? Append something like `v1`, `v2` or just new names all together?\r\n\r\n3. Since the deployer of the contract is the one who would have to invoke the reverse ENS registrar to register the interface manually if they:\r\n    1. Either lie about it and register interfaces they don't implement\r\n    2. Forget to register an interface they do implement\r\n\r\nThen there is nothing that can be done to enforce it, right? All this should just be seen as only a guideline by the contract author?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/315895608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/315920240",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-315920240",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 315920240,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTkyMDI0MA==",
    "user": {
      "login": "jbaylina",
      "id": 4180156,
      "node_id": "MDQ6VXNlcjQxODAxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4180156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbaylina",
      "html_url": "https://github.com/jbaylina",
      "followers_url": "https://api.github.com/users/jbaylina/followers",
      "following_url": "https://api.github.com/users/jbaylina/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbaylina/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbaylina/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbaylina/subscriptions",
      "organizations_url": "https://api.github.com/users/jbaylina/orgs",
      "repos_url": "https://api.github.com/users/jbaylina/repos",
      "events_url": "https://api.github.com/users/jbaylina/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbaylina/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-18T00:09:01Z",
    "updated_at": "2017-07-18T00:09:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "@LefterisJP \r\n\r\n1. Yes, the idea is to NOT define which names should be used in this standard and let it open.  I think that the best approach is that each standard should define each own interface names.  The only precaution to be taken is that it should not be repeated the same name for different interfaces in different standards. \r\n\r\n2. Again, this is not defined in this standard and should be defined in the specific ERC for each interface. A good way to define names (may be it could be a recommendation on this standard) , is to use the same rules that uses Microsoft for their COM interfaces: Prepend an `I` in front of the  interface name and add a version number at the end of the name starting on version 2. As an example:\r\n`IMinimeController`, `IMinimeController2`\r\n\r\n3. As far as I understand the reverseENS, only the contract itself can claim the reverse name for its address, not the deployer. In general, the claim of the reverse name will be done in constructors for real contracts. I can also be done in specific calls for regular addresses, wallets, daos, uport proxy, etc.  And may be some future contracts may implement some mechanisms with some rules for implementing future interfaces.\r\n\r\nThe called party can lie about the interface implementation, they can also implement it in the wrong way. The caller should be aware of that and should not assume and check any thing that is executed in an untrusted contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/315920240/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345900026",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-345900026",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 345900026,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTkwMDAyNg==",
    "user": {
      "login": "stevenh512",
      "id": 110500,
      "node_id": "MDQ6VXNlcjExMDUwMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/110500?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stevenh512",
      "html_url": "https://github.com/stevenh512",
      "followers_url": "https://api.github.com/users/stevenh512/followers",
      "following_url": "https://api.github.com/users/stevenh512/following{/other_user}",
      "gists_url": "https://api.github.com/users/stevenh512/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stevenh512/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stevenh512/subscriptions",
      "organizations_url": "https://api.github.com/users/stevenh512/orgs",
      "repos_url": "https://api.github.com/users/stevenh512/repos",
      "events_url": "https://api.github.com/users/stevenh512/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stevenh512/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-21T02:49:01Z",
    "updated_at": "2017-11-21T02:49:01Z",
    "author_association": "NONE",
    "body": "I see one problem with this, it breaks reverse resolution. I don't see any reason why the root node can't use the reverse resolver, as long as the subnodes for each interface use the public resolver. If you set the root node to use the public resolver and provide either 1) a way to transfer ownership of the root node to another address (for example the contract's owner/deployer) or 2) a way to set the contract's \"name\" in the reverse resolver, this should work without breaking reverse resolution.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345900026/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346132212",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-346132212",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 346132212,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjEzMjIxMg==",
    "user": {
      "login": "jbaylina",
      "id": 4180156,
      "node_id": "MDQ6VXNlcjQxODAxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4180156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbaylina",
      "html_url": "https://github.com/jbaylina",
      "followers_url": "https://api.github.com/users/jbaylina/followers",
      "following_url": "https://api.github.com/users/jbaylina/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbaylina/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbaylina/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbaylina/subscriptions",
      "organizations_url": "https://api.github.com/users/jbaylina/orgs",
      "repos_url": "https://api.github.com/users/jbaylina/repos",
      "events_url": "https://api.github.com/users/jbaylina/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbaylina/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-21T19:18:19Z",
    "updated_at": "2017-11-21T19:18:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "@stevenh512 This standard does not break the rerverse resolution. This is done in the name field of resolver for [address].addr.reverse   This standard just add subnodes of the form [InterfaceName].[addres].addr.reverse whos addr method of their resolver points to the contract that implements that interface for that address.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346132212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346517673",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-346517673",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 346517673,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjUxNzY3Mw==",
    "user": {
      "login": "stevenh512",
      "id": 110500,
      "node_id": "MDQ6VXNlcjExMDUwMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/110500?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stevenh512",
      "html_url": "https://github.com/stevenh512",
      "followers_url": "https://api.github.com/users/stevenh512/followers",
      "following_url": "https://api.github.com/users/stevenh512/following{/other_user}",
      "gists_url": "https://api.github.com/users/stevenh512/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stevenh512/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stevenh512/subscriptions",
      "organizations_url": "https://api.github.com/users/stevenh512/orgs",
      "repos_url": "https://api.github.com/users/stevenh512/repos",
      "events_url": "https://api.github.com/users/stevenh512/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stevenh512/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-23T02:03:38Z",
    "updated_at": "2017-11-23T02:30:20Z",
    "author_association": "NONE",
    "body": "@jbaylina I understand I may have miscommunicated what I meant in my previous comment and also (after watching your talk about this and Yoga Token) that English is probably not your first language, so perhaps we're misunderstanding each other a little bit here. My fault for not explaining more clearly.\r\n\r\nIt's not the adding of subnodes (or the requirement that those subnodes use the public resolver or some other resolver that provides `addr` and `setAddr` methods) that breaks reverse resolution, it's the fact that the root `[address].addr.reverse` node is being unnecessarily set to use the public resolver combined with the fact that the contract's owner/creator has no way to take owership of that root node and change it. For reverse resolution to work, the root node needs a resolver that provides `name` and `setName` methods, which the reverse resolver does.\r\n\r\nThe way ENS works, if the root node is using the reverse resolver (so that reverse resolution works as expected), there is no reason why the `[interface].[address].addr.reverse` subnodes can't use the public resolver or any other resolver you choose. Other than the fact that the root node's owner can always take ownership of them, they're treated as completely separate entities.\r\n\r\nI'm having network issues at the moment, but if you'd like I can try sending a PR on your `eip672` repository in a few days.\r\n\r\n(edited for clarity and to fix typos)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346517673/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346545841",
    "html_url": "https://github.com/ethereum/EIPs/issues/672#issuecomment-346545841",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/672",
    "id": 346545841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjU0NTg0MQ==",
    "user": {
      "login": "jbaylina",
      "id": 4180156,
      "node_id": "MDQ6VXNlcjQxODAxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4180156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbaylina",
      "html_url": "https://github.com/jbaylina",
      "followers_url": "https://api.github.com/users/jbaylina/followers",
      "following_url": "https://api.github.com/users/jbaylina/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbaylina/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbaylina/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbaylina/subscriptions",
      "organizations_url": "https://api.github.com/users/jbaylina/orgs",
      "repos_url": "https://api.github.com/users/jbaylina/repos",
      "events_url": "https://api.github.com/users/jbaylina/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbaylina/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-23T07:24:56Z",
    "updated_at": "2017-11-23T07:24:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "@stevenh512\r\n\r\nAh, yea I see your point! \r\n\r\nI merged the PR.  Also note that `claimWithResolver` could be changed to just  a `claim`. It's not necessary to set a resolver for the address node.  Unless, of course, if you want to set a name for the address.\r\n\r\nBTW, good PR! This repository may became a ReverseENS manager for contracts, instead of just an EIP672 helper!.   new name proposals for the repository are accepted..  \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/346545841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
