{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/134/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/134/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/134/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/134",
  "id": 165398541,
  "node_id": "MDU6SXNzdWUxNjUzOTg1NDE=",
  "number": 134,
  "title": "Replay Attack Protection: Include Blocklimit and Blockhash in each Transaction",
  "user": {
    "login": "aakilfernandes",
    "id": 1577353,
    "node_id": "MDQ6VXNlcjE1NzczNTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aakilfernandes",
    "html_url": "https://github.com/aakilfernandes",
    "followers_url": "https://api.github.com/users/aakilfernandes/followers",
    "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
    "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
    "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
    "repos_url": "https://api.github.com/users/aakilfernandes/repos",
    "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 52,
  "created_at": "2016-07-13T19:11:16Z",
  "updated_at": "2022-01-30T02:23:57Z",
  "closed_at": "2022-01-30T02:23:57Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Specification\n\nIn each transaction (prior to signing), include the following\n1. The `blockhash` of a recent block\n2. A single byte `blocklimit`\n\nIn order for a transaction to be valid, it must be included in the blockchain within `blocklimit` blocks of a block with hash `blockhash`. Transactions with a `blocklimit` and `blockhash` of 0 are always valid, regardless of the chain history.\n## Reasoning\n\nThis would offer a number of improvements\n1. It would prevent transactions on one chain from being processed on another chain. This would mean the same private keys could be used on both chains.\n2. It would provide definitive proof that a transaction would not be included in the chain (you would know within `blocklimit` blocks a transaction would not be broadcast, therefore you could safely ignore it).\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/134/reactions",
    "total_count": 9,
    "+1": 9,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/134/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/232457892",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-232457892",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 232457892,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMjQ1Nzg5Mg==",
    "user": {
      "login": "aakilfernandes",
      "id": 1577353,
      "node_id": "MDQ6VXNlcjE1NzczNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aakilfernandes",
      "html_url": "https://github.com/aakilfernandes",
      "followers_url": "https://api.github.com/users/aakilfernandes/followers",
      "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
      "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
      "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
      "repos_url": "https://api.github.com/users/aakilfernandes/repos",
      "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-13T19:15:42Z",
    "updated_at": "2016-07-13T19:15:42Z",
    "author_association": "NONE",
    "body": "Ps thanks to @pipermerriam and @PeterBorah for informing this\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/232457892/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233401385",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-233401385",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 233401385,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzQwMTM4NQ==",
    "user": {
      "login": "charlieknoll",
      "id": 1767009,
      "node_id": "MDQ6VXNlcjE3NjcwMDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1767009?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charlieknoll",
      "html_url": "https://github.com/charlieknoll",
      "followers_url": "https://api.github.com/users/charlieknoll/followers",
      "following_url": "https://api.github.com/users/charlieknoll/following{/other_user}",
      "gists_url": "https://api.github.com/users/charlieknoll/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charlieknoll/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charlieknoll/subscriptions",
      "organizations_url": "https://api.github.com/users/charlieknoll/orgs",
      "repos_url": "https://api.github.com/users/charlieknoll/repos",
      "events_url": "https://api.github.com/users/charlieknoll/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charlieknoll/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-18T17:38:58Z",
    "updated_at": "2016-07-18T17:38:58Z",
    "author_association": "NONE",
    "body": "This would create a problem with offline transactions signed long before they are submitted to the network.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233401385/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233404768",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-233404768",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 233404768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzQwNDc2OA==",
    "user": {
      "login": "pipermerriam",
      "id": 824194,
      "node_id": "MDQ6VXNlcjgyNDE5NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/824194?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pipermerriam",
      "html_url": "https://github.com/pipermerriam",
      "followers_url": "https://api.github.com/users/pipermerriam/followers",
      "following_url": "https://api.github.com/users/pipermerriam/following{/other_user}",
      "gists_url": "https://api.github.com/users/pipermerriam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pipermerriam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pipermerriam/subscriptions",
      "organizations_url": "https://api.github.com/users/pipermerriam/orgs",
      "repos_url": "https://api.github.com/users/pipermerriam/repos",
      "events_url": "https://api.github.com/users/pipermerriam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pipermerriam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-18T17:50:54Z",
    "updated_at": "2016-07-18T17:51:22Z",
    "author_association": "MEMBER",
    "body": "@charlieknoll maybe you missed this part of the proposal.\n\n> Transactions with a `blocklimit` and `blockhash` of 0 are always valid, regardless of the chain history.\n\nI believe that addresses your concern.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233404768/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233413055",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-233413055",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 233413055,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzQxMzA1NQ==",
    "user": {
      "login": "charlieknoll",
      "id": 1767009,
      "node_id": "MDQ6VXNlcjE3NjcwMDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1767009?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charlieknoll",
      "html_url": "https://github.com/charlieknoll",
      "followers_url": "https://api.github.com/users/charlieknoll/followers",
      "following_url": "https://api.github.com/users/charlieknoll/following{/other_user}",
      "gists_url": "https://api.github.com/users/charlieknoll/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charlieknoll/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charlieknoll/subscriptions",
      "organizations_url": "https://api.github.com/users/charlieknoll/orgs",
      "repos_url": "https://api.github.com/users/charlieknoll/repos",
      "events_url": "https://api.github.com/users/charlieknoll/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charlieknoll/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-18T18:18:54Z",
    "updated_at": "2016-07-18T18:18:54Z",
    "author_association": "NONE",
    "body": "@pipermerriam yes I missed that, thanks.  Looks like a good idea to me.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/233413055/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236406779",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236406779",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236406779,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQwNjc3OQ==",
    "user": {
      "login": "koeppelmann",
      "id": 2594089,
      "node_id": "MDQ6VXNlcjI1OTQwODk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2594089?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/koeppelmann",
      "html_url": "https://github.com/koeppelmann",
      "followers_url": "https://api.github.com/users/koeppelmann/followers",
      "following_url": "https://api.github.com/users/koeppelmann/following{/other_user}",
      "gists_url": "https://api.github.com/users/koeppelmann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/koeppelmann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/koeppelmann/subscriptions",
      "organizations_url": "https://api.github.com/users/koeppelmann/orgs",
      "repos_url": "https://api.github.com/users/koeppelmann/repos",
      "events_url": "https://api.github.com/users/koeppelmann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/koeppelmann/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T03:30:18Z",
    "updated_at": "2016-07-31T03:30:18Z",
    "author_association": "NONE",
    "body": "Good proposal - would like to see it implemented!\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236406779/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236416350",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236416350",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236416350,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQxNjM1MA==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T07:41:36Z",
    "updated_at": "2016-07-31T07:41:36Z",
    "author_association": "NONE",
    "body": "Only using a blockhash would probably be enough, as only during few transactions during a fork would be affected, the proposal is fine as is clients should however default to a 0 blocklimit.\n\nOtherwise users might run into problems when signing transactions offline or when there is a long delay between signing and publishing a transaction, ie multisig.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236416350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236423076",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236423076",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236423076,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQyMzA3Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T10:43:35Z",
    "updated_at": "2016-07-31T10:43:35Z",
    "author_association": "MEMBER",
    "body": "We've been discussing something similar in the Go-ethereum channel. A couple of slight changes make it significantly more general:\n- As others have suggested, 'blocklimit' is redundant.\n- Include the genesis hash in the list of hashes that will be checked; this allows distinguishing between different Ethereum networks (testnet vs mainnet, Ethereum clones)\n\nA more significant change is to specify either that every nth (say, 10,000th) block hash gets added to the list, allowing distinctions based on forks after a short period, or to specify that the node should look up the hash in a contract at a given address. That contract would be implemented such that it allows anyone to submit a valid recent blockhash to be stored indefinitely, allowing anyone to verify that the current chain had that blockhash in the past, and therefore allowing anyone to create permanent 'fork points' at any time.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236423076/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236428025",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236428025",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236428025,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQyODAyNQ==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T12:44:43Z",
    "updated_at": "2016-07-31T12:44:43Z",
    "author_association": "NONE",
    "body": "Using the genesis hash is probably a good idea.\n\nFor the \"every n-th\" block either a merkle tree root (or some subleaf) of these blocks can be used.\n\nTransactions should still be able to include a nonce to make sure that if an account is doing many transaction, they can't be replayed within the span of the n blocks of the merkle tree.\n\nFor offline transactions, the tx could use a scheme based on `TxNonce = H(Account_Address + LastTxNonce` so the offline client need not know the chain and still safely transact.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236428025/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236436413",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236436413",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236436413,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQzNjQxMw==",
    "user": {
      "login": "aakilfernandes",
      "id": 1577353,
      "node_id": "MDQ6VXNlcjE1NzczNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aakilfernandes",
      "html_url": "https://github.com/aakilfernandes",
      "followers_url": "https://api.github.com/users/aakilfernandes/followers",
      "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
      "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
      "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
      "repos_url": "https://api.github.com/users/aakilfernandes/repos",
      "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T15:31:54Z",
    "updated_at": "2016-07-31T15:31:54Z",
    "author_association": "NONE",
    "body": "> That contract would be implemented such that it allows anyone to submit a valid recent blockhash to be stored indefinitely, allowing anyone to verify that the current chain had that blockhash in the past, and therefore allowing anyone to create permanent 'fork points' at any time.\n\nThis is interesting. However it wouldn't offer replay protection to private chains or forks where the contract wasn't deployed. Also there's no incentive to submit blocks.\n\n> As others have suggested, 'blocklimit' is redundant\n\nAgreed. I think setting some sort of pool of blocks to check (last 256 + every 10k since genesis + genesis) is sufficient.\n\n@Arachnid is the go team working on replay attack protection? I'm wondering if I should turn this into a formal EIP or let those with better knowledge of the problem take the lead.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236436413/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236437291",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236437291",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236437291,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQzNzI5MQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T15:48:16Z",
    "updated_at": "2016-07-31T15:48:16Z",
    "author_association": "MEMBER",
    "body": "> This is interesting. However it wouldn't offer replay protection to private chains or forks where the contract wasn't deployed.\n\nDeploying that contract would be part of the process of deploying a new chain, just like the built-in contracts.\n\n> Also there's no incentive to submit blocks.\n\nThe cost is minimal, and once you've submitted a block, you can use it in future TXes for replay prevention. I think tscs37's point that it would allow someone to bypass the \"expiry\" feature by submitting its blockhash is a good one.\n\nMy goal was to prevent the expansion of state required by fast and light clients beyond what's under the state hash and the 256 most recent block hashes, which checking in every nth block would do - clients would need to explicitly fetch those block headers when fast syncing in order to be able to validate TXes.\n\n> @Arachnid is the go team working on replay attack protection? I'm wondering if I should turn this into a formal EIP or let those with better knowledge of the problem take the lead.\n\nWe've been discussing it, and I believe someone's working on an EIP; you might ask about it in the go-ethereum channel.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236437291/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236444169",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236444169",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236444169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQ0NDE2OQ==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T17:33:07Z",
    "updated_at": "2016-07-31T17:33:07Z",
    "author_association": "NONE",
    "body": ":+1:. This has more uses than merely large scale forks a la the current situation. If you wish for transaction A to work and only work in a given microfork (for example, a transaction that only makes sense if another transaction was or wasn't sent) then this is quite useful. Or if you wish to embargo a 51% attacker's chain, then this is a very simple way to do it.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236444169/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236449047",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236449047",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236449047,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQ0OTA0Nw==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T18:43:39Z",
    "updated_at": "2016-07-31T18:43:39Z",
    "author_association": "NONE",
    "body": "I think the intention should less be to prevent replays across forks. This can be a neat side-effect.\n\nBut it can be used to make light and offline clients much more easy to write and if done the right way, could allow single addresses to issue concurrent transactions.\n\nWith the current nonce system it's not easily possible to distribute the generation of transaction, ie thinking of a large exchange or bank.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236449047/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236450564",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236450564",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236450564,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQ1MDU2NA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T19:10:57Z",
    "updated_at": "2016-07-31T19:44:40Z",
    "author_association": "MEMBER",
    "body": "I also like this idea. Mostly, I like the contract-route. So I would suggest the following. \n1. A transaction _must_ contain a \"valid-after-hash\" field. Let's call it `VAH`. This makes it a hard fork. \n2. The `VAH` must contain a hash from pool `P`, in order to be valid. \n3. The pool `P` consists of the following hashes:\n   - The hashes of all _odd_-numbered blocks from the most recent 256 blocks. \n   - The genesis hash\n   - All hashes in the contract `C`. \n\nThe reason for using hashes only from odd-numbered blocks, is that we can ensure that `C` only contains hashes from even-numbered blocks. This makes it possible to obtain the expiration-feature on transactions. \n\nI sketched up an example of how contract `C` could look: \n\n```\ncontract HashSave{\n\n    mapping  (bytes32 => bool) hashes;\n\n    function save(uint blockNumber) returns (bytes32)\n    {   \n        if( blockNumber % 2 != 0 ) throw;\n        //Could instead add more safeguards;\n        // the check below only allows to save every 128th block, \n        // around once every 30 minutes with 14s blocktime\n        //if( blockNumber % 128 != 0 ) throw;\n\n        bytes32 hash = block.blockhash(blockNumber);\n        if (hash != 0) {\n            hashes[hash] = true;\n            return hash;\n            //Todo, add event\n        }\n        return 0;\n    }\n}\n```\n\nAs you can see, anyone can submit a hash, \"savepoint\", to the contract. If we are afraid that this will become a DoS-vector, where an attacker submit every (other) hash, which makes verification of tx:s more difficult (if this verification fails, there's no gas cost, remember) since the pool cache grows, we may want to add further restrictions, so that only every N:th block hash can be saved. \n\nPros:\n- This makes it easy to handle forks safely, both for regular wallets and offline-wallets. \n  - Regular wallets can use a recent odd-numbered blockhash (presumably from six blocks back or so, since chain can be reorganized). \n  - Offline wallets can use genesis, or a 'savepoint'/'forkpoint' on the desired chain.\n- Light clients need only recent hashes (they already have those) and the current state. \n- It is possible to make tx:s that expire after a while (most of them probably will). This will also make it easier to clean out the transaction-pool caches of pending (but stale) transactions. \n\nCons: \n- Is a hardfork\n- Adds a verification-step to transaction. This validation is not paid for by the sender. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236450564/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236452296",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236452296",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236452296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjQ1MjI5Ng==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-31T19:45:06Z",
    "updated_at": "2016-07-31T19:45:06Z",
    "author_association": "NONE",
    "body": "I like your mockup, this could certainly work.\n\nOnly concern is the savepoint-numbers. I'd prefer ever 512th block to be saved, maybe even every 1024th block. A savepoint every couple hours is with much safety margin to operate safely over a fork with a good majority hashpower.\n\nThis could be included into the weak-subjectivity of Serenity, so that these savepoints also act as beacons for clients to safely join the network.\n\nTo make this more useful I'd recommend the following configuration; instead of using a `bytes32 => bool` I'd use a mapping of `bytes32 => bytes32` where the key is the blockhash of the beacon and the value is a merkle-root hash of all beaconed blocks, which should be easily calculable.\n\nThe save function should simply attempt to save the last block that could be considered a beacon. If none of the last 256 blocks are a beacon candidate it throws. (Which requires the beacon range to be above 256 or else you get double calls on the same beacon) It should largely operate automatic with no external input parameters.\n\nThis could allow full nodes like geth to utilize this contract for an even faster sync to the network where they sync to the state of the last beacon and then sync backwards to the network while being able to operate within minutes. Since a forked chain will eventually within the beacon-interval end up with a different beacon merkle root, the fast sync will very quickly detect it and can consider other chain sources.\n\nOn creation the contract precompile should include the genesis block and in a second operation the block number 1920010.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236452296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236510884",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236510884",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236510884,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjUxMDg4NA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-01T07:43:02Z",
    "updated_at": "2016-08-01T07:43:02Z",
    "author_association": "MEMBER",
    "body": "It's worth noting that using odd/even numbers means that a reorg could change the meaning of your transaction; we need to define what happens to a transaction whose VAH is an uncle; does it get ignored?\n\nI don't see a problem with making the save-interval on the contract small, because any resource consumption attack requires a lot of resources from the attacker, for very low return (lookups are O(log n), and it would take a _lot_ of ether to bloat the contract past what can be easily cached).\n\n@tscs37 Can you elaborate on why you'd store a merkle root against the hash, and how it would work?\n\nAlso, it's unclear to me that having such a contract would improve sync; the contract wouldn't by nature be any more reliable than the information it can get from the nodes it's trying to sync with.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236510884/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236520430",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236520430",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236520430,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjUyMDQzMA==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-01T08:32:39Z",
    "updated_at": "2016-08-01T08:32:39Z",
    "author_association": "NONE",
    "body": "Storing a merkle root allows clients to very quickly sync up with the correct network if multiple competing chains are present, allowing forks even against the GHOST block-weight-protocol if the client implements it.\n\nThis means that if, for example, miners execute a softfork, even a majority hashrate has no meaning as users can opt to use the non-softforked chain.\n\nIt also enables weak subjectivity; a single merkle root hash is enough for a client to instantly sync to the correct chain by inspecting the block data/state.\n\n---\n\nI'd still try to keep the save interval somewhat big, a short interval is not that necessary and at 512 blocks, the wait maximum wait time is 58.9 minutes and also means the last savepoint is at maximum 58.9 minutes old.\n\n---\n\nRe: Uncles; as uncles are valid parts of the chain, they should also be allowed as VAH values.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236520430/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236533731",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236533731",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236533731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjUzMzczMQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-01T09:33:23Z",
    "updated_at": "2016-08-01T09:33:23Z",
    "author_association": "MEMBER",
    "body": "My thoughts:\n\nRe reorgs and odd/even: a reorg never change the block number. \nRe uncles: they should be ignored, since they are not accessible from within the EVM. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236533731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236545429",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236545429",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236545429,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjU0NTQyOQ==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-01T10:29:08Z",
    "updated_at": "2016-08-01T10:29:08Z",
    "author_association": "NONE",
    "body": "The problem with using blocknumbers is that they are not replay safe.\n\nIf the users fears that a reorg might drop the transaction, they can use a block that is farther in the past. Using a block hash from a couple beacon intervals is enough safety against reorgs.\n\nUncles are not accessible to the EVM but to the validating nodes. This is equally solved by waiting for blocks to matures a bit as it is by using uncles.\n\nThis might be an interesting extension to the EVM, to be able to access uncle data like their blocknumber and hash as part of future consensus algorithms.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236545429/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236679723",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236679723",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236679723,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjY3OTcyMw==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-01T19:21:02Z",
    "updated_at": "2016-08-01T19:21:02Z",
    "author_association": "MEMBER",
    "body": "Nice discussion going!\n\nSo a few thoughts... \n\n### Uncles\n\nI have two objection to accepting uncles as `VAH`. Firstly, from a practical perspective - uncles are not accessible from within the blockchain, thus can never be saved by contract `C`. Also, I believe it would add a lot of complexity, since uncles (and grand-uncles) are complex as it is. \n\nSecondly, from a more theoretic perspective, uncles represent \"roads not taken\". By stating \"This transaction is only valid after hash X\", we want the transaction to only happen if block X has happened. So if X is an uncle, it means that the chain we aimed for with the `VAH` has explicitly been abandoned. \n\n### Blocknumbers\n\n> The problem with using blocknumbers is that they are not replay safe\n\n@tscs37 Could you elaborate? Replay safe in what fashion? Using blocknumbers how?\n\nI touched on the problem with reorganisations above: \"Regular wallets can use a recent odd-numbered blockhash (presumably from six blocks back or so, since chain can be reorganized).\". \n\nI dont understand any other potential problems with chain reorganisations. Any mined block (both mainchain and uncles) have a hash and a blocknumber. A block can never be reorganized from being number `34535` into being `34536`. \n\n### More clever use of key->value\n\nI don't understand the syncing problem that we're solving with merkle trees either, actually. And I'm not saying that as in \"you're wrong\", but genuinely I do not understand :)\n\n> This could allow full nodes like geth to utilize this contract for an even faster sync to the network\n>  where they sync to the state of the last beacon and then sync backwards\n\nIf they sync up until the last hour, aren't they already synced ? \n\nHaving said that, I agree that if we can put something more clever and usable instead of `true`, I'm all for it. We don't need to worry about gas consumption, almost the opposite. \n\n### Beacon interval\n\nI'm torn on the intervals. I definitely feel that 8hours is unnecessarily long. If, somehow, for some reason, an unplanned HF occurs, there could be a lot of replayed transactions occuring in that timespan. 1 hour sounds better to me. \n\n> it would take a lot of ether to bloat the contract past what can be easily cached\n\nWould it really? BTCRelay has 110742 entries, all bitcoin block headers since a while back. I'm sure it wasn't _cheap_, but doable. And it's pay once, live with it forever.  \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236679723/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236809624",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236809624",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236809624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjgwOTYyNA==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T06:11:48Z",
    "updated_at": "2016-08-02T06:11:48Z",
    "author_association": "NONE",
    "body": "> I dont understand any other potential problems with chain reorganisations. Any mined block (both mainchain and uncles) have a hash and a blocknumber. A block can never be reorganized from being number 34535 into being 34536.\n\nIf a fork were to occur at block 34534, then both chains now have differing blocks 34535 and 34536, so using blocknumbers will not be replay safe across those chains.\n\n---\n\nI'm in favor of slightly longer beacon intervals because it allows forks to assert themselves.\n\nUntil the winning chain is determined some time may pass and until then it might be beneficial to replay as much as possible on both chains. After one or a few hours the network should have mostly stabilized on one fork.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236809624/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236814020",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236814020",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236814020,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjgxNDAyMA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T06:39:10Z",
    "updated_at": "2016-08-02T06:39:10Z",
    "author_association": "MEMBER",
    "body": "Ah, I think there has been a misunderstanding. I never meant to use blocknumbers, but hashes from a pool.\nSo what I meant was that the pool contains hashes from odd-numbered recent blocks (and contract C hashes, and genesis).\nAnd the hashes from odd-numbered recent blocks have expiry built in.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236814020/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236881899",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236881899",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236881899,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjg4MTg5OQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T11:53:36Z",
    "updated_at": "2016-08-02T11:53:36Z",
    "author_association": "MEMBER",
    "body": "> Would it really? BTCRelay has 110742 entries, all bitcoin block headers since a while back. I'm sure it wasn't cheap, but doable. And it's pay once, live with it forever.\n\nSo, thinking about this more, submitting lots of hashes doesn't seem like a viable attack strategy. In order to force a client to keep an otherwise-irrelevant hash in memory, you have to submit transactions that reference it, which means they're valid, and thus cost gas. The only other attack is to ensure that the contract's list is too large to be entirely cached in memory - which clients will likely assume anyway for simplicity - and thus force the client to do one trie lookup for each transaction you submit with an invalid hash.\n\nWe could specify that transactions from accounts with a balance but an invalid hash are valid transactions, but have no effect on the state besides charging them a modest amount of gas for the lookup, but I personally don't think the effort of doing a second trie lookup (the account balance being the first) is a big enough threat to warrant that.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236881899/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236884567",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236884567",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236884567,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjg4NDU2Nw==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T12:07:16Z",
    "updated_at": "2016-08-02T12:07:16Z",
    "author_association": "NONE",
    "body": "> We could specify that transactions from accounts with a balance but an invalid hash are valid transactions, but have no effect on the state besides charging them a modest amount of gas for the lookup, ...\n\nIf the client operates correctly then invalid hashes should not appear, so invalid hashes are a sign the transaction is from another network or malfunctioning client.\n\nIn either case causing the account a subtraction of gas could cause issues again, where transactions of one network are replayed to cause gascosts on the other.\n\n---\n\nAfter some thinking I believe that a `128` Beacon Interval would be far enough to not store excessive data on the chain and also not too far that a fork will cause havoc with replays for very long (~about 30 seconds)\n\nBeacons should expire after some time so clients, even light clients, can keep the entirety of the beacon list in memory. \n\nBy default this can be placed at `1024 * 1024`, this means in general transactions are valid for 120 days (roughly) before they'll be dropped and there are only about 8192 active beacons. If the blocktime decreases by more than a factor of 10 it might be viable to fork so that this value can be increased accordingly.\n\nIf a transaction is expected to hang around in the mempool for a while it can use the Genesis Hash, which is basically beacon #0 and virtually never expires.\n\nIn short that means a client needs to hold the following memory contents:\n\n```\n1x 32 bytes for the Genesis hash\n8192x 32 bytes for Beacons + 32 bytes for Expiry Block Number\n1x 32 bytes for incoming Beacons as buffer + 32 bytes for incoming Beacons Expiry Numbers\n= 524384 bytes = 512.1 kBytes\n```\n\nThe Beacon Contract should also store the block in which the beacon was stored, ie the Beacon 1920111 was stored at Block 1920122.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236884567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236908506",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236908506",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236908506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjkwODUwNg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T13:45:18Z",
    "updated_at": "2016-08-02T13:45:18Z",
    "author_association": "MEMBER",
    "body": "> If the client operates correctly then invalid hashes should not appear, so invalid hashes are a sign the transaction is from another network or malfunctioning client.\n\nOr it's an attack. I don't believe costing a little gas on an alternate fork is a significant concern, but as I said, I also don't think it's really necessary to do this to protect against DoS attacks.\n\n> Beacons should expire after some time so clients, even light clients, can keep the entirety of the beacon list in memory.\n\nThis would remove one of the main points of having beacons, which is to support offline clients that can't fetch recent blocks from the network. I don't believe that fetching a trie entry to validate a transaction is an undue burden.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236908506/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236911856",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236911856",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236911856,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjkxMTg1Ng==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T13:56:38Z",
    "updated_at": "2016-08-02T13:56:38Z",
    "author_association": "NONE",
    "body": "Offline Wallets can utilize the Genesis Hash to construct a transaction even if no network connection is present, if that is not enough security, the user can simply transport a single and recent beacon hash to the offline wallet.\n\nI think for 99.99% of all offline wallets we can safely assume the user is capable of transporting a beacon hash to the signing software that is no older than 120 days, which is a low estimate on a 10 second blocktime.\n\nTo make this simpler, a transaction may be allowed to only use 8 hexadecimal digits of a blockhash, similar to a git commit hash.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236911856/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236915750",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236915750",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236915750,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjkxNTc1MA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T14:09:26Z",
    "updated_at": "2016-08-02T14:09:26Z",
    "author_association": "MEMBER",
    "body": "> Offline Wallets can utilize the Genesis Hash to construct a transaction even if no network connection is present, if that is not enough security, the user can simply transport a single and recent beacon hash to the offline wallet.\n\nThe genesis hash won't protect against forks, and \"simply transport a single and recent beacon hash\" is papering over a lot of complexity.\n\nI honestly don't see the point in expiring beacons. It adds complexity both to the contract and to the implementations, for something that I think is a nonissue.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236915750/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236931029",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236931029",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236931029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjkzMTAyOQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T14:57:20Z",
    "updated_at": "2016-08-02T14:57:20Z",
    "author_association": "MEMBER",
    "body": "Agree w @arachnid. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236931029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236941699",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236941699",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236941699,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjk0MTY5OQ==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T15:30:36Z",
    "updated_at": "2016-08-02T15:30:36Z",
    "author_association": "NONE",
    "body": "Right, expiring beacons makes it complicated.\n\nIf the blockhash is valid indefinitely than wallet owners can use any hash as long as it is not before a recent fork.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236941699/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236966422",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236966422",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236966422,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjk2NjQyMg==",
    "user": {
      "login": "tscs37",
      "id": 1774339,
      "node_id": "MDQ6VXNlcjE3NzQzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1774339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tscs37",
      "html_url": "https://github.com/tscs37",
      "followers_url": "https://api.github.com/users/tscs37/followers",
      "following_url": "https://api.github.com/users/tscs37/following{/other_user}",
      "gists_url": "https://api.github.com/users/tscs37/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tscs37/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tscs37/subscriptions",
      "organizations_url": "https://api.github.com/users/tscs37/orgs",
      "repos_url": "https://api.github.com/users/tscs37/repos",
      "events_url": "https://api.github.com/users/tscs37/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tscs37/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T16:48:13Z",
    "updated_at": "2016-08-02T16:48:13Z",
    "author_association": "NONE",
    "body": "I've been playing a bit with solidity and I think I came up with a simple contract that conveys the beacon thing well enough, IMO.\n\nhttps://gist.github.com/tscs37/dccee713495dd1502f8dfede1740dda8\n\ndeployed on testnet at: 0x8c7Aec1F480d8DAc5F045DA62e091AFAd71311FC\n\nto validate a client would simply do this:\n\n```\nif (beacons.checkBeacon(tx.beacon) < block.number)\n    return valid\nelse\n    return invalid\n```\n\nthe arithmetic works in 32bit just as it works in 256bit so light clients won't need to perform full 256bit arithmetic of the EVM.\n\nit stores the blocknumber with a 1 offset so that the zero value of the mapping wraps around and becomes bigger than the blocknumber, additionally the genesis block is not a special case in the contract, which is advantagous if someone wants to start a new chain.\n\nI also noticed that a nonce will still be needed, even if the Beacon Interval goes down to 2 or even 1 as even then transactions cannot be replayed on other networks but on the same network they can.\n\nFor Offline Wallets there are three options now:\n- Use the Genesis Hash, not secure against HF-replays\n- Use some hash after a recent hardfork, secure against HF-replays\n- Use legacy format and rely on nonces as before\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236966422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236972827",
    "html_url": "https://github.com/ethereum/EIPs/issues/134#issuecomment-236972827",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/134",
    "id": 236972827,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNjk3MjgyNw==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-02T17:09:07Z",
    "updated_at": "2016-08-02T17:09:07Z",
    "author_association": "MEMBER",
    "body": "I looked through it briefly, some comments: \n\n```\nfunction getLastBeaconHash() constant public returns (bytes32) {\n    return block.blockhash(block.number - (block.number % BeaconInterval));\n}\n```\n\nThis will only work if the `saveBeacon` is actually invoked every beacon interval. In my mind, I'm thinking that this will only be called maybe a once or twice a year (barring attacks). So a small interval means higher resolution when we legitimately need to call it - at hard forks. But I don't expect benign users to actually call it at regular intervals. \n\nAnd yeah, I agree that some const methods are needed to get the last couple of beacons or so, so maybe that will have to be added also. \n\nI didn't consider the genesiss hash be part of the contract `C`. I think from a test-perspective, it may be easier if genesis is left out (then they can use the same code and prepolulate it into the testnet/privatenet, instead of actually deploying a contract with the proper genesis). \n\nSo the contract's only 'mission', is to provide checkpoints after forks. \n\nAnd yes, nonce is still needed.  \n\nAnd lastly, the \"legacy format\" will have to go. This must be a mandatory field, RLP-encoding does not allow optional fields. If we don't want to add another flag, or special meaning to hash `0x000...0`, but I don't see any reason to make it optional really. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/236972827/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
