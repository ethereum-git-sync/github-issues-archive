{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/5102",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/5102/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/5102/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/5102/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/5102",
  "id": 1244293988,
  "node_id": "I_kwDOAq426M5KKmtk",
  "number": 5102,
  "title": "Suggesting ERC20 and ERC721 one-time off-chain approval for safer NFT trading",
  "user": {
    "login": "themez",
    "id": 1323793,
    "node_id": "MDQ6VXNlcjEzMjM3OTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1323793?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/themez",
    "html_url": "https://github.com/themez",
    "followers_url": "https://api.github.com/users/themez/followers",
    "following_url": "https://api.github.com/users/themez/following{/other_user}",
    "gists_url": "https://api.github.com/users/themez/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/themez/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/themez/subscriptions",
    "organizations_url": "https://api.github.com/users/themez/orgs",
    "repos_url": "https://api.github.com/users/themez/repos",
    "events_url": "https://api.github.com/users/themez/events{/privacy}",
    "received_events_url": "https://api.github.com/users/themez/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2022-05-22T15:49:26Z",
  "updated_at": "2022-07-18T18:07:46Z",
  "closed_at": "2022-05-23T03:50:29Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Currently, mainstream NFT trading markets utilize the approve function to take control of users’ assets for order matching.\r\n\r\nTo save gas, trading markets request users to approve the max amount of ERC20 tokens and all ERC721 tokens, so users don't need to approve each trade repeatedly. But this leaves a tremendous potential security threat: if the market contract is compromised, all users’ assets could be stolen.\r\n\r\nSo I want to discuss a more secure way of trading, learning from main trading markets’ offline listing and bidding mechanisms. We could store users’ one-time approval off-chain and make them expirable.\r\n\r\n### Extensions of token protocol\r\n\r\nAdd extension function to ERC20:\r\n\r\n```solidity\r\ntransferFromWithAuthority(address from, address to, uint256 amount, uint256 nonce, uint256 expiration, bytes signature)\r\n```\r\n\r\nAdd extension function to ERC721:\r\n\r\n```solidity\r\nfunction transferFromWithAuthority(address from, address to, uint256 tokenId, uint256 nonce, uint256 expiration, bytes signature)\r\n```\r\n\r\n### Process of listing ERC721 token\r\n\r\n1. sign for approving ERC721 token\r\n```typescript\r\nsigner._signTypedData(\r\n    domain,\r\n    {\r\n      Approve: [\r\n        { name: 'tokenId', type: 'uint256' },\r\n        { name: 'operator', type: 'address' },\r\n        { name: 'expiration', type: 'uint256' },\r\n        { name: 'nonce', type: 'uint256' },\r\n      ],\r\n    },\r\n    {\r\n      tokenId: 1,\r\n      operator: '0x0000000000000000000000000000000000000000',\r\n      expiration: 1653868800,\r\n      nonce: 1234567 // a random number, signature can only be used once\r\n    }\r\n  )\r\n\r\n```\r\n\r\n2. sign for the market order\r\n3. order taker executing market contract\r\n\r\n```solidity\r\nfunction atomicMatch(Order order, bytes orderSignature, uint256 authorityNonce, uint256 authorityExpiration, bytes nftAuthoritySignature) public payable {\r\n    require(validateOrder(order, orderSignature), 'Invalid order');\r\n    require(msg.value == order.amount, 'No enough value');\r\n    ERC721(order.itemAddress).transferFromWithAuthority(order.from, order.to, order.tokenId, authorityNonce, authorityExpiration, nftAuthoritySignature);\r\n    payable(order.maker).transfer(order.amount);\r\n}\r\n```\r\n\r\nThe marketplace then needs to store two signatures off-chain,  one more comparing the mainstream market like the opensea. It seems there’s no way to sign only once for two contracts to operate.\r\n\r\n### Process of biding using ERC20 token\r\n\r\n1. sign for approving ERC20 token\r\n```typescript\r\n  signer._signTypedData(\r\n    domain,\r\n    {\r\n      Approve: [\r\n        { name: 'spender', type: 'address' },\r\n        { name: 'amount', type: 'uint256' },\r\n        { name: 'expiration', type: 'uint256' },\r\n        { name: 'nonce', type: 'uint256'},\r\n      ],\r\n    },\r\n    {\r\n      spender: '0x0000000000000000000000000000000000000000',\r\n      amount: 1000000000000000000,\r\n      expiration: 1653868800,\r\n      nonce: 1234567, // a random number, signature can only be used once\r\n    }\r\n  )\r\n```\r\n2. sign for the market order\r\n3. owner takes the bidding\r\n```solidity\r\nfunction atomicMatch(\r\n    Order order, bytes orderSignature, \r\n    uint256 erc20AuthorityNonce, uint256 erc20AuthorityExpiration,  bytes erc20AuthoritySignature, \r\n    uint256 erc721AuthorityNonce, uint256 erc721AuthorityExpiration, bytes erc721AuthoritySignature) {\r\n    require(validateOrder(order, orderSignature), 'Invalid order');\r\n    ERC20(order.paymentTokenAddress).transferFromWithAuthority(order.from, order.to, order.amount, erc20AuthorityNonce, erc20AuthorityExpiration, erc20AuthoritySignature);\r\n    ERC721(order.itemAddress).transferFromWithAuthority(order.from, order.to, order.tokenId, erc721AuthorityNonce, erc721AuthorityExpiration, erc721AuthoritySignature);\r\n}\r\n```\r\n",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/5102/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/5102/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1134143823",
    "html_url": "https://github.com/ethereum/EIPs/issues/5102#issuecomment-1134143823",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/5102",
    "id": 1134143823,
    "node_id": "IC_kwDOAq426M5DmalP",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-23T03:50:29Z",
    "updated_at": "2022-05-23T03:50:29Z",
    "author_association": "MEMBER",
    "body": "Please either create an EIP (pull request), or post this in Ethereum Magicians if you would like to discuss it more first.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1134143823/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
