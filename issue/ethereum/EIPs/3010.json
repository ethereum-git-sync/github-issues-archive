{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3010",
  "id": 711549030,
  "node_id": "MDU6SXNzdWU3MTE1NDkwMzA=",
  "number": 3010,
  "title": "EIP-3009: \"Transfer With Authorization\" - ERC20 meta-transactions",
  "user": {
    "login": "petejkim",
    "id": 30173,
    "node_id": "MDQ6VXNlcjMwMTcz",
    "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/petejkim",
    "html_url": "https://github.com/petejkim",
    "followers_url": "https://api.github.com/users/petejkim/followers",
    "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
    "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
    "organizations_url": "https://api.github.com/users/petejkim/orgs",
    "repos_url": "https://api.github.com/users/petejkim/repos",
    "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
    "received_events_url": "https://api.github.com/users/petejkim/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 21,
  "created_at": "2020-09-30T00:27:56Z",
  "updated_at": "2022-02-08T15:01:57Z",
  "closed_at": "2022-01-05T03:12:35Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "**Pull Request: [EIP-3009: transferWithAuthorization](https://github.com/ethereum/EIPs/pull/3009)**\r\n\r\nThis is the place to discuss EIP-3009 \"Transfer With Authorization\", implemented by the USD Coin (USDC) v2 smart contract alongside [EIP-2612: permit](https://eips.ethereum.org/EIPS/eip-2612).\r\n\r\n- - -\r\n\r\n---\r\neip: 3009\r\ntitle: Transfer With Authorization\r\nauthor: Peter Jihoon Kim (@petejkim), Kevin Britz (@kbrizzle), David Knott (@DavidLKnott)\r\ndiscussions-to: https://github.com/ethereum/EIPs/issues/3010\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2020-09-28\r\nrequires: 20, 712\r\n---\r\n\r\n## Simple Summary\r\n\r\nA contract interface that enables transferring of fungible assets via a signed authorization.\r\n\r\n## Abstract\r\n\r\nA set of functions to enable meta-transactions and atomic interactions with [ERC-20](./eip-20.md) token contracts via signatures conforming to the [EIP-712](./eip-712.md) typed message signing specification.\r\n\r\nThis enables the user to:\r\n\r\n- delegate the gas payment to someone else,\r\n- pay for gas in the token itself rather than in ETH,\r\n- perform one or more token transfers and other operations in a single atomic transaction,\r\n- transfer ERC-20 tokens to another address, and have the recipient submit the transaction,\r\n- batch multiple transactions with minimal overhead, and\r\n- create and perform multiple transactions without having to worry about them failing due to accidental nonce-reuse or improper ordering by the miner.\r\n\r\n## Motivation\r\n\r\nThere is an existing spec, [EIP-2612](./eip-2612), that also allows meta-transactions, and it is encouraged that a contract implements both for maximum compatibility. The two primary differences between this spec and EIP-2612 are that:\r\n\r\n- EIP-2612 uses sequential nonces, but this uses random 32-byte nonces, and that\r\n- EIP-2612 relies on the ERC-20 `approve`/`transferFrom` (\"ERC-20 allowance\") pattern.\r\n\r\nThe biggest issue with the use of sequential nonces is that it does not allow users to perform more than one transaction at time without risking their transactions failing, because:\r\n\r\n- DApps may unintentionally reuse nonces that have not yet been processed in the blockchain.\r\n- Miners may process the transactions in the incorrect order.\r\n\r\nThis can be especially problematic if the gas prices are very high and transactions often get queued up and remain unconfirmed for a long time. Non-sequential nonces allow users to create as many transactions as they want at the same time.\r\n\r\nThe ERC-20 allowance mechanism is susceptible to the [multiple withdrawal attack](https://blockchain-projects.readthedocs.io/multiple_withdrawal.html)/[SWC-114](https://swcregistry.io/docs/SWC-114), and encourages antipatterns such as the use of the \"infinite\" allowance. The wide-prevalence of upgradeable contracts have made the conditions favorable for these attacks to happen in the wild.\r\n\r\nThe deficiencies of the ERC-20 allowance pattern brought about the development of alternative token standards such as the [ERC-777](./eip-777) and [ERC-677](https://github.com/ethereum/EIPs/issues/677). However, they haven't been able to gain much adoption due to compatibility and potential security issues.\r\n\r\n## Specification\r\n\r\n### Event\r\n\r\n```solidity\r\nevent AuthorizationUsed(\r\n    address indexed authorizer,\r\n    bytes32 indexed nonce\r\n);\r\n\r\n// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\r\nbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\r\n\r\n// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\r\nbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\r\n\r\n/**\r\n * @notice Returns the state of an authorization\r\n * @dev Nonces are randomly generated 32-byte data unique to the authorizer's\r\n * address\r\n * @param authorizer    Authorizer's address\r\n * @param nonce         Nonce of the authorization\r\n * @return True if the nonce is used\r\n */\r\nfunction authorizationState(\r\n    address authorizer,\r\n    bytes32 nonce\r\n) external view returns (bool);\r\n\r\n/**\r\n * @notice Execute a transfer with a signed authorization\r\n * @param from          Payer's address (Authorizer)\r\n * @param to            Payee's address\r\n * @param value         Amount to be transferred\r\n * @param validAfter    The time after which this is valid (unix time)\r\n * @param validBefore   The time before which this is valid (unix time)\r\n * @param nonce         Unique nonce\r\n * @param v             v of the signature\r\n * @param r             r of the signature\r\n * @param s             s of the signature\r\n */\r\nfunction transferWithAuthorization(\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    uint256 validAfter,\r\n    uint256 validBefore,\r\n    bytes32 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n) external;\r\n\r\n/**\r\n * @notice Receive a transfer with a signed authorization from the payer\r\n * @dev This has an additional check to ensure that the payee's address matches\r\n * the caller of this function to prevent front-running attacks. (See security\r\n * considerations)\r\n * @param from          Payer's address (Authorizer)\r\n * @param to            Payee's address\r\n * @param value         Amount to be transferred\r\n * @param validAfter    The time after which this is valid (unix time)\r\n * @param validBefore   The time before which this is valid (unix time)\r\n * @param nonce         Unique nonce\r\n * @param v             v of the signature\r\n * @param r             r of the signature\r\n * @param s             s of the signature\r\n */\r\nfunction receiveWithAuthorization(\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    uint256 validAfter,\r\n    uint256 validBefore,\r\n    bytes32 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n) external;\r\n```\r\n\r\n**Optional:**\r\n\r\n```solidity\r\nevent AuthorizationCanceled(\r\n    address indexed authorizer,\r\n    bytes32 indexed nonce\r\n);\r\n\r\n// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\r\nbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\r\n\r\n/**\r\n * @notice Attempt to cancel an authorization\r\n * @param authorizer    Authorizer's address\r\n * @param nonce         Nonce of the authorization\r\n * @param v             v of the signature\r\n * @param r             r of the signature\r\n * @param s             s of the signature\r\n */\r\nfunction cancelAuthorization(\r\n    address authorizer,\r\n    bytes32 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n) external;\r\n```\r\n\r\n\r\nThe arguments `v`, `r`, and `s` must be obtained using the [EIP-712](./eip-712.md) typed message signing spec.\r\n\r\n**Example:**\r\n\r\n```\r\nDomainSeparator := Keccak256(ABIEncode(\r\n  Keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n  ),\r\n  Keccak256(\"USD Coin\"),                      // name\r\n  Keccak256(\"2\"),                             // version\r\n  1,                                          // chainId\r\n  0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48  // verifyingContract\r\n))\r\n```\r\n\r\nWith the domain separator, the typehash, which is used to identify the type of the EIP-712 message being used, and the values of the parameters, you are able to derive a Keccak-256 hash digest which can then be signed using the token holder's private key.\r\n\r\n**Example:**\r\n\r\n```\r\n// Transfer With Authorization\r\nTypeHash := Keccak256(\r\n  \"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\"\r\n)\r\nParams := { From, To, Value, ValidAfter, ValidBefore, Nonce }\r\n\r\n// ReceiveWithAuthorization\r\nTypeHash := Keccak256(\r\n  \"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\"\r\n)\r\nParams := { From, To, Value, ValidAfter, ValidBefore, Nonce }\r\n\r\n// CancelAuthorization\r\nTypeHash := Keccak256(\r\n  \"CancelAuthorization(address authorizer,bytes32 nonce)\"\r\n)\r\nParams := { Authorizer, Nonce }\r\n```\r\n\r\n```\r\n// \"‖\" denotes concatenation.\r\nDigest := Keecak256(\r\n  0x1901 ‖ DomainSeparator ‖ Keccak256(ABIEncode(TypeHash, Params...))\r\n)\r\n\r\n{ v, r, s } := Sign(Digest, PrivateKey)\r\n```\r\n\r\nSmart contract functions that wrap `receiveWithAuthorization` call may choose to reduce the number of arguments by accepting the full ABI-encoded set of arguments for the `receiveWithAuthorization` call as a single argument of the type `bytes`.\r\n\r\n**Example:**\r\n\r\n```solidity\r\n// keccak256(\"receiveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)\")[0:4]\r\nbytes4 private constant _RECEIVE_WITH_AUTHORIZATION_SELECTOR = 0xef55bec6;\r\n\r\nfunction deposit(address token, bytes calldata receiveAuthorization)\r\n    external\r\n    nonReentrant\r\n{\r\n    (address from, address to, uint256 amount) = abi.decode(\r\n        receiveAuthorization[0:96],\r\n        (address, address, uint256)\r\n    );\r\n    require(to == address(this), \"Recipient is not this contract\");\r\n\r\n    (bool success, ) = token.call(\r\n        abi.encodePacked(\r\n            _RECEIVE_WITH_AUTHORIZATION_SELECTOR,\r\n            receiveAuthorization\r\n        )\r\n    );\r\n    require(success, \"Failed to transfer tokens\");\r\n\r\n    ...\r\n}\r\n```\r\n\r\n### Use with web3 providers\r\n\r\nThe signature for an authorization can be obtained using a web3 provider with the `eth_signTypedData{_v4}` method.\r\n\r\n**Example:**\r\n\r\n```javascript\r\nconst data = {\r\n  types: {\r\n    EIP712Domain: [\r\n      { name: \"name\", type: \"string\" },\r\n      { name: \"version\", type: \"string\" },\r\n      { name: \"chainId\", type: \"uint256\" },\r\n      { name: \"verifyingContract\", type: \"address\" },\r\n    ],\r\n    TransferWithAuthorization: [\r\n      { name: \"from\", type: \"address\" },\r\n      { name: \"to\", type: \"address\" },\r\n      { name: \"value\", type: \"uint256\" },\r\n      { name: \"validAfter\", type: \"uint256\" },\r\n      { name: \"validBefore\", type: \"uint256\" },\r\n      { name: \"nonce\", type: \"bytes32\" },\r\n    ],\r\n  },\r\n  domain: {\r\n    name: tokenName,\r\n    version: tokenVersion,\r\n    chainId: selectedChainId,\r\n    verifyingContract: tokenAddress,\r\n  },\r\n  primaryType: \"TransferWithAuthorization\",\r\n  message: {\r\n    from: userAddress,\r\n    to: recipientAddress,\r\n    value: amountBN.toString(10),\r\n    validAfter: 0,\r\n    validBefore: Math.floor(Date.now() / 1000) + 3600, // Valid for an hour\r\n    nonce: Web3.utils.randomHex(32),\r\n  },\r\n};\r\n\r\nconst signature = await ethereum.request({\r\n  method: \"eth_signTypedData_v4\",\r\n  params: [userAddress, JSON.stringify(data)],\r\n});\r\n\r\nconst v = \"0x\" + signature.slice(130, 132);\r\nconst r = signature.slice(0, 66);\r\nconst s = \"0x\" + signature.slice(66, 130);\r\n```\r\n\r\n## Rationale\r\n\r\n### Unique Random Nonce, Instead of Sequential Nonce\r\n\r\nOne might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice:\r\n\r\n- For native Ethereum transactions, when a transaction with a nonce value that is too-high is submitted to the network, it will stay pending until the transactions consuming the lower unused nonces are confirmed.\r\n- However, for meta-transactions, when a transaction containing a sequential nonce value that is too high is submitted, instead of staying pending, it will revert and fail immediately, resulting in wasted gas.\r\n- The fact that miners can also reorder transactions and include them in the block in the order they want (assuming each transaction was submitted to the network by different meta-transaction relayers) also makes it possible for the meta-transactions to fail even if the nonces used were correct. (e.g. User submits nonces 3, 4 and 5, but miner ends up including them in the block as 4,5,3, resulting in only 3 succeeding)\r\n- Lastly, when using different applications simultaneously, in absence of some sort of an off-chain nonce-tracker, it is not possible to determine what the correct next nonce value is if there exists nonces that are used but haven't been submitted and confirmed by the network.\r\n- Under high gas price conditions, transactions can often \"get stuck\" in the pool for a long time. Under such a situation, it is much more likely for the same nonce to be unintentionally reused twice. For example, if you make a meta-transaction that uses a sequential nonce from one app, and switch to another app to make another meta-transaction before the previous one confirms, the same nonce will be used if the app relies purely on the data available on-chain, resulting in one of the transactions failing.\r\n- In conclusion, the only way to guarantee transaction ordering is for relayers to submit transactions one at a time, waiting for confirmation between each submission (and the order in which they should be submitted can be part of some off-chain metadata), rendering sequential nonce irrelevant.\r\n\r\n### Valid After and Valid Before\r\n\r\n- Relying on relayers to submit transactions for you means you may not have exact control over the timing of transaction submission.\r\n- These parameters allow the user to schedule a transaction to be only valid in the future or before a specific deadline, protecting the user from potential undesirable effects that may be caused by the submission being made either too late or too early.\r\n\r\n### EIP-712\r\n\r\n- EIP-712 ensures that the signatures generated are valid only for this specific instance of the token contract and cannot be replayed on a different network with a different chain ID.\r\n- This is achieved by incorporating the contract address and the chain ID in a Keccak-256 hash digest called the domain separator. The actual set of parameters used to derive the domain separator is up to the implementing contract, but it is highly recommended that the fields `verifyingContract` and `chainId` are included.\r\n\r\n## Backwards Compatibility\r\n\r\nNew contracts benefit from being able to directly utilize EIP-3009 in order to create atomic transactions, but existing contracts may still rely on the conventional ERC-20 allowance pattern (`approve`/`transferFrom`).\r\n\r\nIn order to add support for EIP-3009 to existing contracts (\"parent contract\") that use the ERC-20 allowance pattern, a forwarding contract (\"forwarder\") can be constructed that takes an authorization and does the following:\r\n\r\n1. Extract the user and deposit amount from the authorization\r\n2. Call `receiveWithAuthorization` to transfer specified funds from the user to the forwarder\r\n3. Approve the parent contract to spend funds from the forwarder\r\n4. Call the method on the parent contract that spends the allowance set from the forwarder\r\n5. Transfer the ownership of any resulting tokens back to the user\r\n\r\n**Example:**\r\n\r\n```solidity\r\ninterface IDeFiToken {\r\n    function deposit(uint256 amount) external returns (uint256);\r\n\r\n    function transfer(address account, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\ncontract DepositForwarder {\r\n    bytes4 private constant _RECEIVE_WITH_AUTHORIZATION_SELECTOR = 0xef55bec6;\r\n\r\n    IDeFiToken private _parent;\r\n    IERC20 private _token;\r\n\r\n    constructor(IDeFiToken parent, IERC20 token) public {\r\n        _parent = parent;\r\n        _token = token;\r\n    }\r\n\r\n    function deposit(bytes calldata receiveAuthorization)\r\n        external\r\n        nonReentrant\r\n        returns (uint256)\r\n    {\r\n        (address from, address to, uint256 amount) = abi.decode(\r\n            receiveAuthorization[0:96],\r\n            (address, address, uint256)\r\n        );\r\n        require(to == address(this), \"Recipient is not this contract\");\r\n\r\n        (bool success, ) = address(_token).call(\r\n            abi.encodePacked(\r\n                _RECEIVE_WITH_AUTHORIZATION_SELECTOR,\r\n                receiveAuthorization\r\n            )\r\n        );\r\n        require(success, \"Failed to transfer to the forwarder\");\r\n\r\n        require(\r\n            _token.approve(address(_parent), amount),\r\n            \"Failed to set the allowance\"\r\n        );\r\n\r\n        uint256 tokensMinted = _parent.deposit(amount);\r\n        require(\r\n            _parent.transfer(from, tokensMinted),\r\n            \"Failed to transfer the minted tokens\"\r\n        );\r\n\r\n        uint256 remainder = _token.balanceOf(address(this);\r\n        if (remainder > 0) {\r\n            require(\r\n                _token.transfer(from, remainder),\r\n                \"Failed to refund the remainder\"\r\n            );\r\n        }\r\n\r\n        return tokensMinted;\r\n    }\r\n}\r\n```\r\n\r\n## Test Cases\r\n\r\nSee [EIP3009.test.ts](https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts).\r\n\r\n## Implementation\r\n\r\n**EIP3009.sol**\r\n```solidity\r\nabstract contract EIP3009 is IERC20Transfer, EIP712Domain {\r\n    // keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\r\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\r\n\r\n    // keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\r\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\r\n\r\n    mapping(address => mapping(bytes32 => bool)) internal _authorizationStates;\r\n\r\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\r\n\r\n    string internal constant _INVALID_SIGNATURE_ERROR = \"EIP3009: invalid signature\";\r\n\r\n    function authorizationState(address authorizer, bytes32 nonce)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _authorizationStates[authorizer][nonce];\r\n    }\r\n\r\n    function transferWithAuthorization(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(now > validAfter, \"EIP3009: authorization is not yet valid\");\r\n        require(now < validBefore, \"EIP3009: authorization is expired\");\r\n        require(\r\n            !_authorizationStates[from][nonce],\r\n            \"EIP3009: authorization is used\"\r\n        );\r\n\r\n        bytes memory data = abi.encode(\r\n            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\r\n            from,\r\n            to,\r\n            value,\r\n            validAfter,\r\n            validBefore,\r\n            nonce\r\n        );\r\n        require(\r\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,\r\n            \"EIP3009: invalid signature\"\r\n        );\r\n\r\n        _authorizationStates[from][nonce] = true;\r\n        emit AuthorizationUsed(from, nonce);\r\n\r\n        _transfer(from, to, value);\r\n    }\r\n}\r\n```\r\n\r\n**IERC20Transfer.sol**\r\n```solidity\r\nabstract contract IERC20Transfer {\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual;\r\n}\r\n```\r\n\r\n**EIP712Domain.sol**\r\n```solidity\r\nabstract contract EIP712Domain {\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n}\r\n```\r\n\r\n**EIP712.sol**\r\n```solidity\r\nlibrary EIP712 {\r\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    function makeDomainSeparator(string memory name, string memory version)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    EIP712_DOMAIN_TYPEHASH,\r\n                    keccak256(bytes(name)),\r\n                    keccak256(bytes(version)),\r\n                    address(this),\r\n                    bytes32(chainId)\r\n                )\r\n            );\r\n    }\r\n\r\n    function recover(\r\n        bytes32 domainSeparator,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bytes memory typeHashAndData\r\n    ) internal pure returns (address) {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                keccak256(typeHashAndData)\r\n            )\r\n        );\r\n        address recovered = ecrecover(digest, v, r, s);\r\n        require(recovered != address(0), \"EIP712: invalid signature\");\r\n        return recovered;\r\n    }\r\n}\r\n```\r\n\r\nA fully working implementation of EIP-3009 can be found in [this repository](https://github.com/CoinbaseStablecoin/eip-3009/blob/master/contracts/lib/EIP3009.sol). The repository also includes [an implementation of EIP-2612](https://github.com/CoinbaseStablecoin/eip-3009/blob/master/contracts/lib/EI32612.sol) that uses the EIP-712 library code presented above.\r\n\r\n## Security Considerations\r\n\r\nUse `receiveWithAuthorization` instead of `transferWithAuthorization` when calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run the `transferWithAuthorization` call to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits. `receiveWithAuthorization` prevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.\r\n\r\nWhen submitting multiple transfers simultaneously, be mindful of the fact that relayers and miners will decide the order in which they are processed. This is generally not a problem if the transactions are not dependent on each other, but for transactions that are highly dependent on each other, it is recommended that the signed authorizations are submitted one at a time.\r\n\r\nThe zero address must be rejected when using `ecrecover` to prevent unauthorized transfers and approvals of funds from the zero address. The built-in `ecrecover` returns the zero address when a malformed signature is provided.\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3010/reactions",
    "total_count": 5,
    "+1": 5,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/701704290",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-701704290",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 701704290,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMTcwNDI5MA==",
    "user": {
      "login": "petejkim",
      "id": 30173,
      "node_id": "MDQ6VXNlcjMwMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petejkim",
      "html_url": "https://github.com/petejkim",
      "followers_url": "https://api.github.com/users/petejkim/followers",
      "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
      "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
      "organizations_url": "https://api.github.com/users/petejkim/orgs",
      "repos_url": "https://api.github.com/users/petejkim/repos",
      "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petejkim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-30T23:46:47Z",
    "updated_at": "2020-09-30T23:47:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "If you want to try it out, there is a fully gasless (free) demo that runs on Görli testnet: [USDC L2 Demo](https://usdc-l2-demo.petejkim.com/). Click on \"Give Me Some\" to get tokens, again, gaslessly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/701704290/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/701887746",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-701887746",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 701887746,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMTg4Nzc0Ng==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-01T05:08:14Z",
    "updated_at": "2020-10-01T05:08:14Z",
    "author_association": "MEMBER",
    "body": "Consider adding a method for `invalidateNonce`.  This would allow someone to send a transaction that would just invalidate a nonce, without taking any action.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/701887746/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/702155840",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-702155840",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 702155840,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjE1NTg0MA==",
    "user": {
      "login": "juli",
      "id": 71986,
      "node_id": "MDQ6VXNlcjcxOTg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/71986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/juli",
      "html_url": "https://github.com/juli",
      "followers_url": "https://api.github.com/users/juli/followers",
      "following_url": "https://api.github.com/users/juli/following{/other_user}",
      "gists_url": "https://api.github.com/users/juli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/juli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/juli/subscriptions",
      "organizations_url": "https://api.github.com/users/juli/orgs",
      "repos_url": "https://api.github.com/users/juli/repos",
      "events_url": "https://api.github.com/users/juli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/juli/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-01T13:59:52Z",
    "updated_at": "2020-10-01T13:59:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu what is the benefit of that method? looks like it will make it easier to attack relayers.\r\n\r\n@petejkim Glad to see more work towards standardization of token contract methods for gas less transactions. Unfortunatelly  random nonces require extra storage. Sequential nonces to make sure calls are executed in order or not executed are a good feature IMO. I understand random nonces help relayers if transactions are mined out of order. But I don't think it is worth solving the sequential nonce reuse problem from the end users side this way. The user wallet could track what sequential nonces were used to avoid reusing them. If the users sign the same nonce on purpose, making relayers waste money then they can be punished.  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/702155840/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703027015",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-703027015",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 703027015,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzAyNzAxNQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-03T01:50:46Z",
    "updated_at": "2020-10-03T01:50:46Z",
    "author_association": "MEMBER",
    "body": "> what is the benefit of that method? looks like it will make it easier to attack relayers\r\n\r\nAs a user, if I send a transaction out to take some action and for whatever reason it doesn't get picked up soon (perhaps I don't compensate the relayer enough in the transaction), I will forever have that particular transaction pending and available to be executed at any time in the future, potentially when it is profitable for someone else to have that transaction show up.\r\n\r\nAs a user, I want the ability to \"cancel\" that transaction by invalidating a particular nonce so that no one can include it at an arbitrary point in time in the future.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703027015/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703032721",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-703032721",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 703032721,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzAzMjcyMQ==",
    "user": {
      "login": "petejkim",
      "id": 30173,
      "node_id": "MDQ6VXNlcjMwMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petejkim",
      "html_url": "https://github.com/petejkim",
      "followers_url": "https://api.github.com/users/petejkim/followers",
      "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
      "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
      "organizations_url": "https://api.github.com/users/petejkim/orgs",
      "repos_url": "https://api.github.com/users/petejkim/repos",
      "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petejkim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-03T02:26:10Z",
    "updated_at": "2020-10-03T02:31:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu I agree with what you said. USDCv2 does have [`cancelAuthorization`](https://github.com/centrehq/centre-tokens/blob/master/contracts/v2/GasAbstraction.sol#L265) that does exactly that, but it was removed to keep this spec small, since it's possible to replicate that by calling `transferWithAuthorization` with 0 value and the same nonce. `cancelAuthorization` does take fewer arguments and consume less gas though. Do you think I should include it?\r\n\r\nI will also address the rest of your feedback over the weekend, thanks for reviewing, really appreciate it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703032721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703199159",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-703199159",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 703199159,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzE5OTE1OQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-04T04:09:58Z",
    "updated_at": "2020-10-04T04:09:58Z",
    "author_association": "MEMBER",
    "body": "Keeping EIPs small and modular is certainly reasonable and I support it.  Perhaps consider creating a second EIP that depends on this one which adds `cancelAuthorization`?  Then implementors can choose to implement one or both.  The advantage of an explicit cancel is the gas savings.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703199159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703515835",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-703515835",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 703515835,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzUxNTgzNQ==",
    "user": {
      "login": "yahgwai",
      "id": 1663175,
      "node_id": "MDQ6VXNlcjE2NjMxNzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1663175?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yahgwai",
      "html_url": "https://github.com/yahgwai",
      "followers_url": "https://api.github.com/users/yahgwai/followers",
      "following_url": "https://api.github.com/users/yahgwai/following{/other_user}",
      "gists_url": "https://api.github.com/users/yahgwai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yahgwai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yahgwai/subscriptions",
      "organizations_url": "https://api.github.com/users/yahgwai/orgs",
      "repos_url": "https://api.github.com/users/yahgwai/repos",
      "events_url": "https://api.github.com/users/yahgwai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yahgwai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-05T09:29:08Z",
    "updated_at": "2020-10-05T09:29:08Z",
    "author_association": "NONE",
    "body": "There are other options for concurrent nonce management that may be relevant here. They typically require a bit more work on the client side, but can reduce gas costs in the contract by not having to always use a new storage slot.\r\n\r\n[Multinonce](https://github.com/PISAresearch/metamask-comp/blob/master/src/contracts/MultiNonceMetaTransaction/MultiNonceMetaTransaction.sol): A two dimensional nonce that allows the client to choose between concurrent and sequential behaviour. The nonce is both an index and a sequential nonce; the contract stores a mapping of index -> nonce. The client specifies both index and a nonce which is current nonce at that index + 1. For concurrency they use a new index, or a very old index for which they know no pending transactions exist. For 2 transactions that must be mined sequentially the client specifies the same index.\r\n\r\n[BitFlip](https://github.com/PISAresearch/metamask-comp/blob/master/src/contracts/BitFlipMetaTransaction/BitFlipMetaTransaction.sol): The nonce is a single bit to be turned _on_. If the bit is already _on_ that nonce has already been used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703515835/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/706444635",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-706444635",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 706444635,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNjQ0NDYzNQ==",
    "user": {
      "login": "juli",
      "id": 71986,
      "node_id": "MDQ6VXNlcjcxOTg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/71986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/juli",
      "html_url": "https://github.com/juli",
      "followers_url": "https://api.github.com/users/juli/followers",
      "following_url": "https://api.github.com/users/juli/following{/other_user}",
      "gists_url": "https://api.github.com/users/juli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/juli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/juli/subscriptions",
      "organizations_url": "https://api.github.com/users/juli/orgs",
      "repos_url": "https://api.github.com/users/juli/repos",
      "events_url": "https://api.github.com/users/juli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/juli/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-09T23:38:31Z",
    "updated_at": "2020-10-09T23:38:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "I suggest using `mapping (address => mapping(address => uint256)) nonces` to have sequential nonces for each account holder and each different `tx.origin` (EOAs used by relayers) . This way users can't invalidate relayed transactions without the relayer accepting the new version of the transaction with an already used nonce. This approach is aligned with relayer's incentives. This also solves the out of order mining problem, makes it a bit harder to attack relayers, and storage cost is reduced.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/706444635/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/707012546",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-707012546",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 707012546,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNzAxMjU0Ng==",
    "user": {
      "login": "sohkai",
      "id": 4166642,
      "node_id": "MDQ6VXNlcjQxNjY2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4166642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sohkai",
      "html_url": "https://github.com/sohkai",
      "followers_url": "https://api.github.com/users/sohkai/followers",
      "following_url": "https://api.github.com/users/sohkai/following{/other_user}",
      "gists_url": "https://api.github.com/users/sohkai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sohkai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sohkai/subscriptions",
      "organizations_url": "https://api.github.com/users/sohkai/orgs",
      "repos_url": "https://api.github.com/users/sohkai/repos",
      "events_url": "https://api.github.com/users/sohkai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sohkai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-12T09:48:41Z",
    "updated_at": "2020-10-12T10:15:22Z",
    "author_association": "NONE",
    "body": "**Edit**: Ah, I just saw this was also mentioned on the original PR as a comment to remove the internal state details as well.\r\n\r\nCcould we simplify the requirement of a separate function name by simply using the auto-generated getter (as EIP-2612 also currently suggests)?\r\n\r\nSo instead of:\r\n\r\n```\r\nmapping(address => mapping(bytes32 => bool)) authorizationStates;\r\n\r\nfunction authorizationState(\r\n    address authorizer,\r\n    bytes32 nonce\r\n) external view returns (bool);\r\n```\r\n\r\nIt's just:\r\n\r\n```\r\nmapping(address => mapping(bytes32 => bool)) public authorizationState;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/707012546/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 1,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/707311555",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-707311555",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 707311555,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNzMxMTU1NQ==",
    "user": {
      "login": "petejkim",
      "id": 30173,
      "node_id": "MDQ6VXNlcjMwMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petejkim",
      "html_url": "https://github.com/petejkim",
      "followers_url": "https://api.github.com/users/petejkim/followers",
      "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
      "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
      "organizations_url": "https://api.github.com/users/petejkim/orgs",
      "repos_url": "https://api.github.com/users/petejkim/repos",
      "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petejkim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-12T19:45:14Z",
    "updated_at": "2020-10-12T19:45:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "@sohkai Yep, that works!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/707311555/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/708930559",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-708930559",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 708930559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwODkzMDU1OQ==",
    "user": {
      "login": "invocamanman",
      "id": 32056120,
      "node_id": "MDQ6VXNlcjMyMDU2MTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/32056120?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/invocamanman",
      "html_url": "https://github.com/invocamanman",
      "followers_url": "https://api.github.com/users/invocamanman/followers",
      "following_url": "https://api.github.com/users/invocamanman/following{/other_user}",
      "gists_url": "https://api.github.com/users/invocamanman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/invocamanman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/invocamanman/subscriptions",
      "organizations_url": "https://api.github.com/users/invocamanman/orgs",
      "repos_url": "https://api.github.com/users/invocamanman/repos",
      "events_url": "https://api.github.com/users/invocamanman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/invocamanman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-15T06:31:19Z",
    "updated_at": "2020-10-15T06:31:19Z",
    "author_association": "NONE",
    "body": "I think might be helpful add a security consideration to **never** use the `transferWithAuthorization` as a method of the token reception protocol of any smart contract, in other words, use it as a approve/transferFrom in the same transaction.\r\nThe reason behind is that the signature of the `transferWithAuthorization` could be taken and used, so anyone could perform a frontRunning attack, stealing the signature and executing `transferWithAuthorization` directly to the smart contract, skipping the reception protocol and likely result in the loss of the tokens.\r\n\r\nAn example of the attack:\r\nSuppose a case that `User A` wants to deposit 1000 tokens to the `Smart Contract B`. `Smart contract B` has a deposit function wich implements `transferWithAuthorization` as a token reception method. When `User A` sends the transaction, including the signature to trigger the `transferWithAuthorization`, someone could perform the attack previously described, the 1000 tokens will be correctly transferred from the user to the smart contract, but the smart contract would not be aware, and the user has lost his tokens",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/708930559/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/712153651",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-712153651",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 712153651,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxMjE1MzY1MQ==",
    "user": {
      "login": "leekt",
      "id": 15259621,
      "node_id": "MDQ6VXNlcjE1MjU5NjIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/15259621?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leekt",
      "html_url": "https://github.com/leekt",
      "followers_url": "https://api.github.com/users/leekt/followers",
      "following_url": "https://api.github.com/users/leekt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leekt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leekt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leekt/subscriptions",
      "organizations_url": "https://api.github.com/users/leekt/orgs",
      "repos_url": "https://api.github.com/users/leekt/repos",
      "events_url": "https://api.github.com/users/leekt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leekt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-19T13:23:47Z",
    "updated_at": "2020-10-19T13:25:22Z",
    "author_association": "NONE",
    "body": "Seems it needs some msg.sender verification to reduce the front-running risk @invocamanman described.\r\nlike `require(msg.sender == _to)` or get `_msgSender` as parameter and verify that within signature and `require(msg.sender == _msgSender)`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/712153651/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/712565569",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-712565569",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 712565569,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxMjU2NTU2OQ==",
    "user": {
      "login": "petejkim",
      "id": 30173,
      "node_id": "MDQ6VXNlcjMwMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petejkim",
      "html_url": "https://github.com/petejkim",
      "followers_url": "https://api.github.com/users/petejkim/followers",
      "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
      "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
      "organizations_url": "https://api.github.com/users/petejkim/orgs",
      "repos_url": "https://api.github.com/users/petejkim/repos",
      "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petejkim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-20T03:29:57Z",
    "updated_at": "2020-10-20T03:34:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think it's useful to support being able to send to EOAs, so I think there are two ways to address this:\r\n\r\n1. If the recipient is a contract address (`extcodesize` > 0), require the recipient address (`to`) to be `msg.sender`.\r\nOR\r\n2. Add another type hash `ReceiveWithAuthorization`, which requires the recipient address to be `msg.sender`.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/712565569/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/723287532",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-723287532",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 723287532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMzI4NzUzMg==",
    "user": {
      "login": "petejkim",
      "id": 30173,
      "node_id": "MDQ6VXNlcjMwMTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/30173?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petejkim",
      "html_url": "https://github.com/petejkim",
      "followers_url": "https://api.github.com/users/petejkim/followers",
      "following_url": "https://api.github.com/users/petejkim/following{/other_user}",
      "gists_url": "https://api.github.com/users/petejkim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petejkim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petejkim/subscriptions",
      "organizations_url": "https://api.github.com/users/petejkim/orgs",
      "repos_url": "https://api.github.com/users/petejkim/repos",
      "events_url": "https://api.github.com/users/petejkim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petejkim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-06T20:34:10Z",
    "updated_at": "2020-11-06T20:36:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "> There are other options for concurrent nonce management that may be relevant here. They typically require a bit more work on the client side, but can reduce gas costs in the contract by not having to always use a new storage slot.\r\n> \r\n> [Multinonce](https://github.com/PISAresearch/metamask-comp/blob/master/src/contracts/MultiNonceMetaTransaction/MultiNonceMetaTransaction.sol): A two dimensional nonce that allows the client to choose between concurrent and sequential behaviour. The nonce is both an index and a sequential nonce; the contract stores a mapping of index -> nonce. The client specifies both index and a nonce which is current nonce at that index + 1. For concurrency they use a new index, or a very old index for which they know no pending transactions exist. For 2 transactions that must be mined sequentially the client specifies the same index.\r\n> \r\n> [BitFlip](https://github.com/PISAresearch/metamask-comp/blob/master/src/contracts/BitFlipMetaTransaction/BitFlipMetaTransaction.sol): The nonce is a single bit to be turned _on_. If the bit is already _on_ that nonce has already been used.\r\n\r\nThose are interesting ideas, but in absence of some off-chain nonce tracker, it doesn't solve the problem of not being able to reliably obtain an unused nonce, especially when multiple DApps are used simultaneously. Bitflip is certainly better than the conventional incremental nonce though.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/723287532/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/723958056",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-723958056",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 723958056,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMzk1ODA1Ng==",
    "user": {
      "login": "yahgwai",
      "id": 1663175,
      "node_id": "MDQ6VXNlcjE2NjMxNzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1663175?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yahgwai",
      "html_url": "https://github.com/yahgwai",
      "followers_url": "https://api.github.com/users/yahgwai/followers",
      "following_url": "https://api.github.com/users/yahgwai/following{/other_user}",
      "gists_url": "https://api.github.com/users/yahgwai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yahgwai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yahgwai/subscriptions",
      "organizations_url": "https://api.github.com/users/yahgwai/orgs",
      "repos_url": "https://api.github.com/users/yahgwai/repos",
      "events_url": "https://api.github.com/users/yahgwai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yahgwai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-09T11:35:58Z",
    "updated_at": "2020-11-09T11:35:58Z",
    "author_association": "NONE",
    "body": "> it doesn't solve the problem of not being able to reliably obtain an unused nonce, especially when multiple DApps are used simultaneously\r\n\r\nDapps can do this by choosing a random index - the collision chance is negligible. Ofc each new dapp wold incur a 20k store instead of a 5k store for using a new rand.\r\n\r\nOther options for figuring out the currently used nonces are to ask the wallet for the next nonce, or to look in the pending pool for the `AuthorizationUsed` event being emitted from transactions.\r\n\r\nGenerally though I think @juli's `mapping (address => mapping(address => uint256)) nonces` may be the best approach",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/723958056/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/833912673",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-833912673",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 833912673,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgzMzkxMjY3Mw==",
    "user": {
      "login": "ThomasRogg",
      "id": 39573524,
      "node_id": "MDQ6VXNlcjM5NTczNTI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/39573524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ThomasRogg",
      "html_url": "https://github.com/ThomasRogg",
      "followers_url": "https://api.github.com/users/ThomasRogg/followers",
      "following_url": "https://api.github.com/users/ThomasRogg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ThomasRogg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ThomasRogg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ThomasRogg/subscriptions",
      "organizations_url": "https://api.github.com/users/ThomasRogg/orgs",
      "repos_url": "https://api.github.com/users/ThomasRogg/repos",
      "events_url": "https://api.github.com/users/ThomasRogg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ThomasRogg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-06T22:24:44Z",
    "updated_at": "2021-05-06T22:24:44Z",
    "author_association": "NONE",
    "body": "A side note: I believe that there is a bug in the code listed in the EIP-3009. I fixed it in a pull request on the repo the actual code files are in: https://github.com/CoinbaseStablecoin/eip-3009/pull/1\r\n\r\nThe USDCv2 code seems to be correct, however. Just not the reference implementation I see in the EIP-3009.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/833912673/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950249002",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-950249002",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 950249002,
    "node_id": "IC_kwDOAq426M44o6Yq",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-10-24T02:27:50Z",
    "updated_at": "2021-10-24T02:27:50Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950249002/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1005345576",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-1005345576",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 1005345576,
    "node_id": "IC_kwDOAq426M477Fso",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-05T03:12:34Z",
    "updated_at": "2022-01-05T03:12:34Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1005345576/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1015825773",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-1015825773",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 1015825773,
    "node_id": "IC_kwDOAq426M48jEVt",
    "user": {
      "login": "omidziaee",
      "id": 12073782,
      "node_id": "MDQ6VXNlcjEyMDczNzgy",
      "avatar_url": "https://avatars.githubusercontent.com/u/12073782?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/omidziaee",
      "html_url": "https://github.com/omidziaee",
      "followers_url": "https://api.github.com/users/omidziaee/followers",
      "following_url": "https://api.github.com/users/omidziaee/following{/other_user}",
      "gists_url": "https://api.github.com/users/omidziaee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/omidziaee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/omidziaee/subscriptions",
      "organizations_url": "https://api.github.com/users/omidziaee/orgs",
      "repos_url": "https://api.github.com/users/omidziaee/repos",
      "events_url": "https://api.github.com/users/omidziaee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/omidziaee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-18T20:54:58Z",
    "updated_at": "2022-01-18T20:54:58Z",
    "author_association": "NONE",
    "body": "Hi,\r\nQuick question regarding the \"Use with web3 providers\" section, after you get the v, r, s how do you submit the transaction? Do you use the contract method \"transferWithAuthorization\"? Could you please elaborate more on that with an example?\r\nThanks,",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1015825773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1024263568",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-1024263568",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 1024263568,
    "node_id": "IC_kwDOAq426M49DQWQ",
    "user": {
      "login": "jejopl",
      "id": 32012330,
      "node_id": "MDQ6VXNlcjMyMDEyMzMw",
      "avatar_url": "https://avatars.githubusercontent.com/u/32012330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jejopl",
      "html_url": "https://github.com/jejopl",
      "followers_url": "https://api.github.com/users/jejopl/followers",
      "following_url": "https://api.github.com/users/jejopl/following{/other_user}",
      "gists_url": "https://api.github.com/users/jejopl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jejopl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jejopl/subscriptions",
      "organizations_url": "https://api.github.com/users/jejopl/orgs",
      "repos_url": "https://api.github.com/users/jejopl/repos",
      "events_url": "https://api.github.com/users/jejopl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jejopl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-28T14:15:24Z",
    "updated_at": "2022-01-28T14:15:24Z",
    "author_association": "NONE",
    "body": "@omidziaee Yeah, you are calling contract method. Here's the example in JS\r\n\r\n\r\n```\r\nconst ABI = [...];\r\nconst tokenAddress = \"0x213...\"\r\nconst YourToken = new window.web3.eth.Contract(ABI, tokenAddress);\r\n\r\n// transaction that you have signed\r\nconst transactionData = {\r\n   owner: ...\r\n   [...]\r\n}\r\n\r\nconst owner =  transactionData.owner\r\nconst spender = transactionData.spender\r\nconst amount = web3.utils.toWei(transactionData.amount, \"Ether\");\r\nconst validAfter = transactionData.valid_after;\r\nconst validBefore = transactionData.valid_before;\r\nconst nonce = transactionData.nonce;\r\nconst { v, r, s } = transactionData.signature;\r\n\r\nconst transaction = await YourToken.methods\r\n    .transferWithAuthorization(owner, spender, amount, validAfter, validBefore, nonce, v, r, s)\r\n    .send({ from: spender, gas: \"21000\" })\r\n    .catch((error) => ({error}));\r\n    \r\n if(transaction.error) {\r\n // handle error here\r\n } else if (transaction.transactionHash) {\r\n // success\r\n }\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1024263568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1032461761",
    "html_url": "https://github.com/ethereum/EIPs/issues/3010#issuecomment-1032461761",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3010",
    "id": 1032461761,
    "node_id": "IC_kwDOAq426M49ih3B",
    "user": {
      "login": "danielnordh",
      "id": 3393669,
      "node_id": "MDQ6VXNlcjMzOTM2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3393669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danielnordh",
      "html_url": "https://github.com/danielnordh",
      "followers_url": "https://api.github.com/users/danielnordh/followers",
      "following_url": "https://api.github.com/users/danielnordh/following{/other_user}",
      "gists_url": "https://api.github.com/users/danielnordh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danielnordh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danielnordh/subscriptions",
      "organizations_url": "https://api.github.com/users/danielnordh/orgs",
      "repos_url": "https://api.github.com/users/danielnordh/repos",
      "events_url": "https://api.github.com/users/danielnordh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danielnordh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-08T10:39:18Z",
    "updated_at": "2022-02-08T15:01:57Z",
    "author_association": "NONE",
    "body": "I'm trying to use `transferWithAuthorization` with a Dart client approving the transaction, then sending it to a JS backend server for submitting to the blockchain. \r\n\r\nI'm using the [eth-sig-util](https://github.com/wakumo/eth-sig-util) package for signing the typed data, and the [web3dart](https://github.com/simolus3/web3dart) package for creating and signing the transaction.\r\n\r\n**My understanding of the flow so far**\r\n1. Create typedData\r\n2. Sign typedData\r\n3. Create transaction calling `transferWithAuthorization`\r\n4. Sign transaction\r\n5. Send signed transaction to backend\r\n6. Have backend submit the signed transaction to the blockchain\r\n\r\nI'm currently getting stuck on step 4, with `Web3.Transaction.callContract` complaining about a wrong type but not saying which parameter it refers to. Error: `int is not a subtype of BigInt`\r\n\r\nThe only parameter that seems to be an `int` is `v`.\r\n\r\n**Update**\r\nCasting the v, r, s parameters to the following gets me past step 3.\r\n\r\n```\r\nBigInt.from(sigParams.v),\r\nbigIntToUint8List(sigParams.r),\r\nbigIntToUint8List(sigParams.s)\r\n```\r\nThe latter two done with:\r\n\r\n```\r\nUint8List bigIntToUint8List(BigInt bigInt) =>\r\n    bigIntToByteData(bigInt).buffer.asUint8List();\r\n\r\nByteData bigIntToByteData(BigInt bigInt) {\r\n  final data = ByteData((bigInt.bitLength / 8).ceil());\r\n  var _bigInt = bigInt;\r\n\r\n  for (var i = 1; i <= data.lengthInBytes; i++) {\r\n    data.setUint8(data.lengthInBytes - i, _bigInt.toUnsigned(8).toInt());\r\n    _bigInt = _bigInt >> 8;\r\n  }\r\n  return data;\r\n}\r\n```\r\n\r\nBut now I get stuck on step 4, ethClient.signTransaction, with an invalid v value:\r\n`RPCError (RPCError: got code 3 with msg \"execution reverted: ECRecover: invalid signature 'v' value\".)`\r\n\r\nDart code for a function that should return a hash of the broadcast transaction:\r\n\r\n```\r\nFuture<String?> signUSDC(BigInt amount, Web3Dart.EthereumAddress ethAddress, User user) async {\r\n    final config = ref.read(configurationProvider).instance;\r\n    final wallet =\r\n        Web3Dart.Wallet.fromJson(user.ethereumWallet!, kWalletPassword);\r\n\r\n    final validAfter = BigInt.zero;\r\n    final validBefore = BigInt.from(9223372036854775807);\r\n    final nonce = Nonce.secure(32);\r\n    final nonceBytes = utf8.encode(nonce.toString());\r\n\r\n    final Map<String, dynamic> rawTypedData = {\r\n      \"types\": {\r\n        \"EIP712Domain\": [\r\n          {\"name\": \"name\", \"type\": \"string\"},\r\n          {\"name\": \"version\", \"type\": \"string\"},\r\n          {\"name\": \"chainId\", \"type\": \"uint256\"},\r\n          {\"name\": \"verifyingContract\", \"type\": \"address\"}\r\n        ],\r\n        \"TransferWithAuthorization\": [\r\n          {\"name\": \"from\", \"type\": \"address\"},\r\n          {\"name\": \"to\", \"type\": \"address\"},\r\n          {\"name\": \"value\", \"type\": \"uint256\"},\r\n          {\"name\": \"validAfter\", \"type\": \"uint256\"},\r\n          {\"name\": \"validBefore\", \"type\": \"uint256\"},\r\n          {\"name\": \"nonce\", \"type\": \"bytes32\"}\r\n        ]\r\n      },\r\n      \"domain\": {\r\n        \"name\": \"USDC\",\r\n        \"version\": \"2\",\r\n        \"chainId\": config.chain.chainId,\r\n        \"verifyingContract\": config.chain.usdcContract\r\n      },\r\n      \"primaryType\": \"TransferWithAuthorization\",\r\n      \"message\": {\r\n        \"from\": user.pubKey,\r\n        \"to\": ethAddress.toString(),\r\n        \"value\": amount.toString(),\r\n        \"validAfter\": validAfter.toString(),\r\n        \"validBefore\": validBefore.toString(),\r\n        \"nonce\": nonceBytes.toString()\r\n      }\r\n    };\r\n\r\n    String signature = EthSigUtil.signTypedData(\r\n        privateKey: bytesToHex(wallet.privateKey.privateKey),\r\n        jsonData: jsonEncode(rawTypedData),\r\n        version: TypedDataVersion.V4,\r\n        chainId: config.chain.chainId);\r\n\r\n    final contract = await ref.read(usdcContractProvider.future);\r\n    var sigParams = SignatureUtil.fromRpcSig(signature);\r\n\r\n    final transaction = Web3Dart.Transaction.callContract(\r\n      contract: contract,\r\n      function: contract.function('transferWithAuthorization'),\r\n      parameters: [\r\n        Web3Dart.EthereumAddress.fromHex(user.pubKey!),\r\n        ethAddress,\r\n        amount,\r\n        validAfter,\r\n        validBefore,\r\n        nonceBytes,\r\n        BigInt.from(sigParams.v),\r\n        bigIntToUint8List(sigParams.r),\r\n        bigIntToUint8List(sigParams.s)\r\n      ],\r\n    );\r\n    final signedTx = await ethClient.signTransaction(wallet.privateKey, transaction);\r\n    final hexTx = \"0x\" + hex.encode(signedTx); // not sure if signedTx or hexTx should be used\r\n\r\n    try {\r\n      // submit signed transaction to backend, get hash in return\r\n      final body = json.encode((await defaultParams)\r\n        ..addAll({\r\n          \"serializedTx\": signedTx,\r\n          \"validationCode\": \"redacted_code\"\r\n        }));\r\n\r\n      return sendRequest(baseUrl.asUri / 'redacted_endpoint',\r\n          method: DataRequestMethod.POST,\r\n          body: body,\r\n          omitDefaultParams: false, onSuccess: (map) {\r\n        return map['hash'] as String;\r\n      }, onError: (error) {\r\n        return null;\r\n      });\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1032461761/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
