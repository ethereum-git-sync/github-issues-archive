{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1776",
  "id": 414181860,
  "node_id": "MDU6SXNzdWU0MTQxODE4NjA=",
  "number": 1776,
  "title": "ERC-1776 Native Meta Transactions",
  "user": {
    "login": "wighawag",
    "id": 790580,
    "node_id": "MDQ6VXNlcjc5MDU4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wighawag",
    "html_url": "https://github.com/wighawag",
    "followers_url": "https://api.github.com/users/wighawag/followers",
    "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
    "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
    "organizations_url": "https://api.github.com/users/wighawag/orgs",
    "repos_url": "https://api.github.com/users/wighawag/repos",
    "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wighawag/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 19,
  "created_at": "2019-02-25T16:09:10Z",
  "updated_at": "2021-12-04T20:13:00Z",
  "closed_at": "2021-12-04T20:13:00Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Introduction  \r\nNative Meta transactions (a term first coined by Austin Thomas Griffith here : [https://medium.com/gitcoin/native-meta-transactions-e509d91a8482](https://medium.com/gitcoin/native-meta-transactions-e509d91a8482)) allows users that simply own [ERC20](https://eips.ethereum.org/EIPS/eip-20) or [ERC777](https://eips.ethereum.org/EIPS/eip-777) ([ERC1155](https://eips.ethereum.org/EIPS/eip-1155) could be added too) tokens to perform operations on the ethereum network without needing to own ether themselves by letting a third party, the relayer, the responsibility to execute a transaction on the ethereum network carrying the desired operations (the so called meta transaction) in exchange of a token reward to cover the relayer's gas cost. They differ from traditional meta transactions ([https://medium.com/uport/making-uport-smart-contracts-smarter-part-3-fixing-user-experience-with-meta-transactions-105209ed43e0](https://medium.com/uport/making-uport-smart-contracts-smarter-part-3-fixing-user-experience-with-meta-transactions-105209ed43e0)) in that they only require support from the meta transaction processor contract itself and do not need the user wallet to be contract based.  \r\n  \r\nThe proposal here define the message format and meta transaction processor contract interface required for **web3 wallets and browsers** to provide a meaningful meta-transaction display when users are requested to approve. This could even allow wallets/browsers to not bother users by displaying an ether balance when such users do not have any ether or when the application being used does not require it.  \r\n  \r\nIt does not dictate how such signed message get injected on the network except for the meaning of each message parameters and their security requirements. More precisely, it does not dictate the ABI signature for the smart contract function executing the meta-transaction (the one signed and broadcast by the relayer).  This is left as work for another standard.\r\n  \r\nNevertheless due to nature of ERC20 this proposal also need to define how smart contract recipient of such meta transaction need to behave when being called. In particular it specify how the ```from``` field is to be verified. \r\n\r\n  \r\n## Why native meta transactions?  \r\n  \r\nIt is common today for users to own ERC20 tokens without owning any ether. More and more applications reward their users without requiring prior on-chain interactions. It is thus possible for users to have been given tokens without them ever owning ether.  With native meta transactions and a willing relayer (the company behind the token for example), such users can now interact with ethereum. \r\n  \r\nWithout meta transactions, it would be impossible for them to interact with the ethereum network when required. Indeed, unless they have ether they can't interact with the ethereum network, requiring them to go through a difficult and costly process to acquire it. They can't even exchange their token for ether without having ether to pay the gas associated with such transaction.  \r\n  \r\nWhile normal meta-transactions are possible using smart contract based wallet (like gnosis safe: https://safe.gnosis.io), there are currently more users with EOA (Externally Owned Account) based wallet and this might be the case for a while as there is an inherent cost to smart contract wallet. Native meta transactions also allow new tokens to be used without requiring generic relayer support on the part of the smart contract wallet. They thus offer native support for meta-transactions without any requirement from the users except to have a private key and enough tokens to pay for the gas.  \r\n  \r\nAs mentioned, Native Meta Transactions are great for applications whose users do not necessarily own or even know about ether. This is also useful for applications that want to distribute their tokens to new non-crypto users. Indeed, with such meta-transactions they can then start interacting in ethereum without having to think about ether. Application with the support of web3 wallet and browsers can then provide a less confusing experience where users can simply operate on one currency, at least until their horizon expands.  \r\n  \r\n## Specification \r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).\r\n \r\nFor operability and the ability for wallet to display a more meaningful UI the following need to be defined:  \r\n  \r\n1) a signed message format that include all the required information for performing a meta transaction and protecting the user  \r\n2) a public getter on the meta transaction processor smart Contract for the current nonce  \r\n3) a way to verifiy the meta transaction signer.  \r\n  \r\n### Message format  \r\n  \r\nThe proposal is using a message format based on [ERC712](https://eips.ethereum.org/EIPS/eip-712) so that wallet that support ERC712 but do not support the proposal described here can still offer an approval display showing all the information albeit in a less than ideal presentation.  \r\n    \r\nHere is the proposed ERC712 message format :  \r\n```typeHash = keccak256(\"ERC20MetaTransaction(address from,address to,address tokenContract,uint256 amount,bytes data,uint256 batchId,uint256 batchNonce,uint256 expiry,uint256 txGas,uint256 baseGas,uint256 tokenGasPrice,address relayer)\");```  \r\n\r\nThe meaning of each field is as follow:  \r\n  \r\n* **from**: the account from which the meta-transaction is executed for and from which the token will be deduced. It MUST be either equal to the resulting message signer or have been given execution rights to the signer (via [ERC1271](https://eips.ethereum.org/EIPS/eip-1271) or [ERC1654](https://github.com/ethereum/EIPs/issues/1654))  \r\n* **to**: the target that will receive the token amount (if any, see below). If it is a contract's address the data(see below) passed will be executed on it. \r\n* **tokenContract**: token address that will be used for relayer payment and the `amount` field if non-zero. This allows the standard to work for both per-token metatx implementation and general implementation that would support multiple token. \r\n* **amount**: the amount in token to be sent to ```to```  \r\n* **data**: the bytes to be executed at ```to``` (if empty, only a transfer will be executed)  \r\n* **batchId**: Nonces are 2 dimensional, the batchId part can be randomly generated so that meta-transaction that have no prior requirement can be included without waiting for previous meta-tx\r\n* **batchNonce**: the second part of the nonce, is the batchNonce, that allow a user to batch multiple meta-transaction and ensure they get included in order\r\n* **expiry**: the time limit at which the meta-transaction must be executed. If that meta-tx do not get executed in time, it reverts at the expense of the relayer.\r\n* **txGas**: the exact amount of gas to be used to execute the meta-transaction. This field also prevents attacks that could happen if the logic of the call relies on gas provided for whatever reason. (note though that the total cost of the transaction executing the meta-transaction will obviously have a higher cost)\r\n* **baseGas**: As meta tx has extra operation to be performed on top of calling the receiving address, this value determine the minimum gas the relayer will be paid on top. This is thus independent of opcode pricing and relayer are free to reject meta tx with a too low baseGas\r\n* **tokenGasPrice** the gasPrice set in token, (the relayer will decide to accept meta-transaction or not depending on the value of such). \r\n* **relayer** (optionally set to zero) used to protect the chosen relayer from front running attacks where the intended executor would lose its gas by someone inserting the transaction before. Letting it to be zero (acts as a wildcard) could still be worthwhile for situations where the users would benefit of having different relayers. This is out of scope of this proposal to define how such relayers network would work together. \r\n  \r\n### batch and nonce \r\nIn order for the wallet or application to request a valid meta transaction it needs to be able to know the current nonce\r\n\r\nThe token contract MUST implement a getter for the current nonce as follow:  \r\n  \r\n```function meta_nonce(address from, uint256 batchId) external view returns(uint256);```  \r\n  \r\nNonces work similarly to normal ethereum transactions: a transaction can only be executed if it matches the last nonce + 1, and once a transaction has occurred, the `lastNonce` will be updated to the current one. This prevents transactions to be executed out of order or more than once.  \r\n\r\nBut instead of being one-dimensional, each nonce is actually associated to a batchId. This is offer great flexibility to the user and allow them to batch meta-transaction together if so desried while still allowing them to submit other meta-tx in paralel.\r\n  \r\n### expiry and EIP-1681\r\n\r\nWhile a previous version of this standard was using a `minGasPrice` to ensure that the user meta-transaction get included at a minimum price, such field becomes unecessary if we have an `expiry` field that have also a more meaningful purpose.\r\n\r\nOne of the danger, `minGasPrice` were protecting against, was relayers that would include the tx at a very low gas price to get a higher profit. With an `expiry` field, the relayer has to ensure the gasPrice is adequate so that the meta-tx is included in time. \r\n\r\nOn the other hand, the relayer is now risking to submit the transaction just a bit too late. To solve this, we can rely on [EIP-1681](https://eips.ethereum.org/EIPS/eip-1681) that can ensure the relayers that if the cannot get included after the expiry time-limit.\r\n\r\n### execute transaction and receiver verification  \r\n  \r\nWhen executing the meta-transaction the contract must then verify the signature and if the nonce matches as specified above.  \r\n  \r\nThen for the case of ERC20 the implementation need to ensure that the first parameter of the call being made is equal to ```from```. The receiver will thus be able to accept calls from the token by knowing that the first parameter is indeed the ```from``` and not some arbitrary address. This means only such receiver will be able to accept such meta transactions securely. \r\n \r\nIn order to do it, the receiver simply check if msg.sender is the meta transaction processor contract itself and if so can assume that first parameter is equal to the ```from``` specified as part of the meta transaction message,  \r\n\r\nRemember, such ERC20 meta transaction receiver need to have as first parameters the \"sender\" whose token will be deduced.\r\n\r\nfor example:\r\n```\r\nfunction anyMethod(address sender, ERC20 token, uint256 value) external {\r\n  require(sender ==  msg.sender ||  msg.sender ==  <metaTransactionProcessor>, \"sender has to be the actual sender or the meta transaction processor contract itself\");\r\n  require(value == price, \"value != price\");\r\n  token.transferFrom(sender, address(this), value);\r\n  balance += value;\r\n  ...\r\n}\r\n``` \r\n \r\nThe meta transaction processor will ensure the ERC20 token as the permitted allowance and \r\n\r\n  \r\n ### Balance checks \r\nTo protect from malicious user the relayers also need to ensure the user (```from```) has enough balance. While it is technically possible for the user to withdraw token just in time (between the meta-tx is send and mined), it is unlikely to happen since it is unlikely to benefit the user unless it wishes to cancel the last minute. They could achieve a similar feat anyway by publishing a different signed message with the same nonce (albeit at a higher gas cost than a simple transfer).  This is a risk that need to be taken by the relayer.\r\n  \r\n### Gas accounting and refund  \r\nThe ```txGas``` set as part of the message represent the gas passed to the contract call made (the meta transaction). This ensure the signer that its call will be executed as intended with as many gas as it asked for. This means though that the total gas cost of the realyer's transaction will be higher than that.\r\n\r\nAs mentioned above, this is solved with ```baseGas``` parameter that can be updated if opcode pricing changes. While this might feel like yet another extra field, it is important to note that the alternative (not having it) is worse since either the smart contract hard code the extra gas or the relayer have to pay the cost.\r\n    \r\n### Gas estimate  \r\nIn order to estimate the ```txGas``` to use for the meta transaction, the meta transaction call data can be used. The behaviour will be identical. As such there is no need to expose an estimateGas function for that.\r\n\r\nAs for the extra gas required by the relayer, the whole meta transaction call can be estimated as usual. \r\n  \r\n### Relayer cooperations\r\n\r\nOne possibility that remains a problem for relayers is that a user could submit the meta-tx message and signature to multiple relayer at once.\r\nThis possibility pose a problem to relayers as they run the risk that their tx get included after another. \r\n\r\nWith the addition of expiry, we could imagine a simple method to avoid such issues:\r\n\r\nEvery meta-tx that include both an expiry field and relayer field, can always be included in a block if it reaches before `expiry`. If the nonce is already used, the actual meta-tx is not executed, but the relayer is getting rewarded for the gas spent (+ `baseGas`).\r\n\r\nThis would ensure relayers that they get paid for the work they do, while still allowing users to choose which relayer they want. The expiry field would also allow.\r\n  \r\n## Example Implementation  \r\n  \r\nsee https://github.com/wighawag/singleton-1776-meta-transaction/blob/master/contracts/src/GenericMetaTxProcessor.sol\r\n  \r\n## wallet / browser  \r\n  \r\nWeb3 wallet and browsers MUST provide a meaningful interface when such signed message is being requested. They could for example show a similar UI to traditional ether transaction except it should clearly state the token being used as well as the other parameters. For the data field, they should also be able to use function signature registry to display the function being called and the arguments.  ",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1776/reactions",
    "total_count": 49,
    "+1": 29,
    "-1": 0,
    "laugh": 4,
    "hooray": 4,
    "confused": 0,
    "heart": 5,
    "rocket": 4,
    "eyes": 3
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467460341",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-467460341",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 467460341,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzQ2MDM0MQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T14:31:59Z",
    "updated_at": "2019-02-26T14:38:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "Nice!\r\n\r\nTwo initial comments:\r\n\r\n1. I would personally pack the gas receipt arguments in the `_data` byte arrays, allowing people to omit these arguments if not used and do something like [this](https://github.com/horizon-games/multi-token-standard/blob/695d3fc1cd71814891f74bcf3a6d05d539752788/contracts/tokens/ERC1155/ERC1155Meta.sol#L102).\r\n\r\n2. I would suggest specifying somewhere that a signer can't be `0x0`. `ecrecover()` can return 0x0, so a token that implements native meta-tx methods could see people generate signature on the behalf of 0x0, which could lead to undesirable consequences if 0x0 is considered a \"burn\" address. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467460341/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467609738",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-467609738",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 467609738,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzYwOTczOA==",
    "user": {
      "login": "austintgriffith",
      "id": 2653167,
      "node_id": "MDQ6VXNlcjI2NTMxNjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2653167?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/austintgriffith",
      "html_url": "https://github.com/austintgriffith",
      "followers_url": "https://api.github.com/users/austintgriffith/followers",
      "following_url": "https://api.github.com/users/austintgriffith/following{/other_user}",
      "gists_url": "https://api.github.com/users/austintgriffith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/austintgriffith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/austintgriffith/subscriptions",
      "organizations_url": "https://api.github.com/users/austintgriffith/orgs",
      "repos_url": "https://api.github.com/users/austintgriffith/repos",
      "events_url": "https://api.github.com/users/austintgriffith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/austintgriffith/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T20:55:26Z",
    "updated_at": "2019-02-26T20:55:26Z",
    "author_association": "MEMBER",
    "body": "^^ Such good input. @PhABC, is this similar to your \"Meta20\" work? Do you smell a collaboration or should these two remain separate? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467609738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467639164",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-467639164",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 467639164,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzYzOTE2NA==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T22:24:22Z",
    "updated_at": "2019-02-26T22:24:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, it's very closely related to the MetaTX ERC20 wrapper indeed. Ideally the ERC-20 wrapper can comply with this standard and vice versa. For those wondering what Austin is referring to, here's the relevant repository: https://github.com/horizon-games/ERC20-meta-wrapper. The native metaTX token contract is [here](https://github.com/horizon-games/multi-token-standard/blob/master/contracts/tokens/ERC1155/ERC1155Meta.sol).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467639164/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468216524",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-468216524",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 468216524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODIxNjUyNA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T10:15:23Z",
    "updated_at": "2019-02-28T10:15:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "yes we could easily add support for ERC-1155. it should work as ERC-777. We could simply a third EIP712 message type definition with the same data\r\n\r\n> * I would personally pack the gas receipt arguments in the `_data` byte arrays, allowing people to omit these arguments if not used and do something like [this](https://github.com/horizon-games/multi-token-standard/blob/695d3fc1cd71814891f74bcf3a6d05d539752788/contracts/tokens/ERC1155/ERC1155Meta.sol#L102).\r\n\r\nCurrently the standard as it stands to not preocuppy itself with the function that execute the meta transaction. If it did, I would like to know more about the reasoning behind the optionality of the arguments : which one, what would be the default values / behavior in each case ?\r\n\r\nWould the signature scheme need to change ?\r\nIt seems to me that this won't the case as we could have them set to zero values (like the relayer field).\r\n\r\n> * I would suggest specifying somewhere that a signer can't be `0x0`. `ecrecover()` can return 0x0, so a token that implements native meta-tx methods could see people generate signature on the behalf of 0x0, which could lead to undesirable consequences if 0x0 is considered a \"burn\" address.\r\n\r\nGood point, I ll add that\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468216524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468748829",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-468748829",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 468748829,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODc0ODgyOQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-01T17:42:39Z",
    "updated_at": "2019-03-01T18:33:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "I want to discuss the current data passed related to the \"gas payment\" first, perhaps how this data is encoded in function calls is a different topic indeed.\r\n\r\n> `gasPrice`:\r\n\r\nI would personally remove `gasPrice`, because that's something the relayer can choose on their own and is therefore not needed. If the `tokenGasPrice` is not enough for current market fee, they just won't execute the transaction. Otherwise, they can have their own transaction fee model. \r\n\r\n> `gasLimit`:\r\n\r\nTo keep, this is important.\r\n\r\n> `tokenGasPrice`:\r\n\r\nI would rename that to `gasPrice` since I would remove the former gasPrice\r\n\r\n> `relayer`: \r\n\r\nShould leave in as well.\r\n\r\n> `gasToken` :\r\n\r\nI would add a field such that the user can specify how they will pay for gas: In WETH? In DAI? In WBTC?\r\n\r\n> `baseGas`:\r\n\r\nI was once pondering if we should add a `baseGas` value, which is a value that accounts for gas not tracked within the MetaTX call, but that still needs to be spent by relayer. For instance, these costs include 21000 transaction cost, gas per byte of `CALLDATA` (function arguments), etc. However, it seems like each contract could hardcode it's own base gasCost that it would add when doing the reimbursement. This is not perfect, but it would remove the need for an additional field. Another way to deal with this would be to increase the `gasPrice` such that it covers the cost of `baseFee`. All in all, it's possible to avoid needing a `baseGas` fee, but I was curious if other thought the simplicity of this additional field would be worth it. \r\n\r\nIn our native meta-tx, we are currently using this as a \"gasReceipt\" struct:\r\n\r\n```javascript\r\n// Gas Receipt\r\nstruct GasReceipt {\r\n  uint256 gasLimit;             // Max amount of gas that can be reimbursed\r\n  uint256 baseGas;              // Base gas cost (includes things like 21k, CALLDATA size, etc.)\r\n  uint256 gasPrice;             // Price denominated in token X per gas unit\r\n  address feeToken;             // Token to pay for gas as `uint256(tokenAddress)`, where 0x0 is MetaETH\r\n  address payable feeRecipient; // Address to send payment to\r\n}\r\n```\r\n\r\nWill probably remove the `baseGas` field however.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468748829/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468765621",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-468765621",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 468765621,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODc2NTYyMQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-01T18:36:20Z",
    "updated_at": "2019-03-01T18:36:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm also thinking of whether we should add a general `data` field in there as well, which could be used for additional logic. For instance, perhaps one wants to pay the gasFee via an ERC-721, ERC-20 or ERC-1155 token, which isn't really possible with `gasToken` alone. Perhaps some contract would like to add the `baseFee` that we removed. I'm guessing most of the time it would be `0x0` however, but in my case I know that in one of my use case I need to specify whether the gasToken is ERC-20 or ERC-1155. I'm just not sure what the best way to handle this is. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/468765621/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469223303",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-469223303",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 469223303,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTIyMzMwMw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T11:43:39Z",
    "updated_at": "2019-03-04T11:43:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @PhABC \r\nthanks for the feedback.\r\n\r\n> > gasPrice::\r\n\r\n> I would personally remove gasPrice, because that's something the relayer can choose on their own and is therefore not needed. If the tokenGasPrice is not enough for current market fee, they just won't execute the transaction. Otherwise, they can have their own transaction fee model.\r\n\r\nI made this decision to include the actual ethereum gasPrice as a message field for 2 reasons :\r\n1) Unless the gasPrice is specified by the user, there is no incentive for the relayer to not reduce the gasPrice. If the user increase the token gas price it can't be sure the relayer will increase the gasPrice use for the transaction itself. gasPrice should be included so the signer is in control of the transaction speed.\r\n\r\n2) We should aim for full determinisim. gasPrice being a variable decided by the transaction signer, it can affect the logic of the call being made. While it is true that gasPrice is not usually used it could be.\r\n\r\n\r\n> > gasLimit:\r\n\r\n> To keep, this is important.\r\n\r\nIndeed, but unless it was clear enough, such gasLimit represent the amount of gas passed into the call (executed by the meta-transaction as part of the transaction executed by the relayer) so that the call is deterministic based solely on the input of the signer.\r\n\r\nAs such the meta-transaction implementation need to ensure enough gas is passed to the transaction so that when calling ```_to.call.gas(_gasLimit)(_data);``` the exact _gasLimit is passed in (solidity does not enforce this by itself and less could be passed in).\r\nAlso anything executed after that (gas refund tx...) need to have enough gas so the transaction does not run out of gas at the expense of the relayer.  This extra gas is what ```baseGas``` would need to cover (see below)\r\n\r\n\r\n> > gasToken :\r\n\r\n> I would add a field such that the user can specify how they will pay for gas: In WETH? In DAI? In WBTC?\r\n\r\nInteresting, I actually did not thought about that because for our use case we did not plan to support such.\r\nThinking about it, thought I am not sure it should be included as part of this standard. It feels like it belongs to a different one where wallet can let user choose the token they wish to use to operate the transaction. This brings more questions and to me this should not be the responsibility of tokens to support it. After all we would **only need one canonical implementation ( a la 820)** and token that support native meta transaction would not need to implement it then as any application could use the canonical implementation instead (which is more likely to be already approved). \r\n\r\nAt the same time, the change is minimal and for contract that do not want to support different token, they would not even need to add that to the calldata.\r\n\r\nStill, how wallet would know whether other tokens (non-native) are supported ?\r\n\r\nMaybe the field could still be added but wallet should not think that they can let the user chose any token. So when an EIP712 signature is requested with the field ```gasToken``` specified, the wallet do not let the user change. On the other hand when it is not specified, it request the user to choose one.\r\n\r\nThis forbids the ability to suggest a default one though, unless the standard evolve to be a different RPC call (I liked the idea of being solely a EIP712 message definition, for several reason, one being backward compatibility).\r\n\r\nSo unless we can clarify the idea , my current stance is to not include it as part of this standard, that focus on **native** meta transaction. \r\n\r\n> > baseGas:\r\n\r\n> I was once pondering if we should add a baseGas value, which is a value that accounts for gas not tracked within the MetaTX call, but that still needs to be spent by relayer. For instance, these costs include 21000 transaction cost, gas per byte of CALLDATA (function arguments), etc. However, it seems like each contract could hardcode it's own base gasCost that it would add when doing the reimbursement. This is not perfect, but it would remove the need for an additional field. \r\n\r\nbaseGas is indeed an important topic and that is what I was alluding to by the \"extra gas required by the relayer\". One thing is certain is that **wallet/browser will need a way to know that value to display it to the user**. I was at some point thinking of adding a mandatory function like ```baseGas() returns (uint256)``` that would let the wallet know what baseGas will be needed. We would need one for ERC-20 and one for ERC-777 , etc....\r\n\r\nBy the way, as mentioned about ```gasLimit```,  ```baseGas``` is not only the 21000 + calldata etc, but also the gas cost of gas refund transfer and other as the ```gasLimit``` specified in the signed message is about the gasLimit used in the call itself.\r\n\r\n> Another way to deal with this would be to increase the gasPrice such that it covers the cost of baseFee. \r\n\r\nThis is not that simple. a user could simply specify a high gasLimit to make believe the relayer that its margin will cover the extra fee, while the actual transaction consume very little.\r\n\r\n>All in all, it's possible to avoid needing a baseGas fee, but I was curious if other thought the simplicity of this additional field would be worth it.\r\n\r\nInstead of including it in the message, I was thinking that the wallet should estimate gas of the relayer transaction to predict the actual amount of token being refunded. This would require us to define the abi signature of such function and is not ideal in my opinion as it gives you the total gas cost and can't predict the actual gas used when executed for real.\r\n\r\nI currently like to have it included as part of the message to sign to avoid ambiguity and ensure the data is the same for everybody (wallet, user, relayer). \r\n\r\nThis does not allow the wallet/browser to figure it by itself though. But is that even desired ?\r\n\r\nTo summarize our 3 options are :\r\n\r\n1) adding ```meta_erc20_baseGas``` ```meta_erc777_baseGas```\r\n2) adding ```baseGas``` field\r\n3) using estimateGas \r\n\r\n1 and 2 together would :\r\n- allows wallet to display the value to the user\r\n- allows the wallet to compute it itself for generic application that might not know the value required\r\n- allows wallet to display the value when supporting only erc-712 and not ERC-1776\r\n\r\nHaving said that, I am not sure whether wallet need to be able to figure the value by themselves. At the end of the day, a relayer would be needed and such relayer would not accept random tokens. As such the relayer would be able to know what baseGas to use and the wallet would be able to know without having the smart contract to publicly tell.\r\n\r\nAs such the ```baseGas``` message field might be all what we need.\r\n\r\n\r\nNote though that if ```baseGas``` is a fixed value (worst case value) the smart contract can avoid requiring it to be passed as calldata as such there is not much cost of ```baseGas``` being included in the message.\r\n\r\n\r\n> I'm also thinking of whether we should add a general data field in there as well, which could be used for additional logic. For instance, perhaps one wants to pay the gasFee via an ERC-721, ERC-20 or ERC-1155 token, which isn't really possible with gasToken alone. Perhaps some contract would like to add the baseFee that we removed. I'm guessing most of the time it would be 0x0 however, but in my case I know that in one of my use case I need to specify whether the gasToken is ERC-20 or ERC-1155. I'm just not sure what the best way to handle this is.\r\n\r\nHmm, if you only need to differentiate between ERC-20 and ERC-1155 you could do as the current draft do in regard to ERC777 and ERC20 : 2 different signature scheme with the same data\r\n\r\n\r\n> For instance, perhaps one wants to pay the gasFee via an ERC-721, ERC-20 or ERC-1155 token, which isn't really possible with gasToken alone. \r\n\r\nI would say, let's focus on something concrete we have now. We could always create a new standard for wallet to support ERC-721... (as an extension)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469223303/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469692564",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-469692564",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 469692564,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTY5MjU2NA==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-05T14:08:30Z",
    "updated_at": "2019-03-05T14:08:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Unless the gasPrice is specified by the user, there is no incentive for the relayer to not reduce the gasPrice. If the user increase the token gas price it can't be sure the relayer will increase the gasPrice use for the transaction itself. gasPrice should be included so the signer is in control of the transaction speed.\r\n\r\nThis doesn't really matter because the relayer can always wait before submitting the tx. If multiple relayers can execute, then this is no problem and if the relayer is enforced by you, you can change relayer if the service they provide isn't good. Think of exchanges like Binance that will withdraw your funds with a gas price of 50 Gwei to ensure good customer service. It also gives no room to the relayer to adjust the gas price if market changes, which reduces the chances that the tx will be submitted.\r\n\r\n>  It feels like it belongs to a different one where wallet can let user choose the token they wish to use to operate the transaction. \r\n\r\nOnly supporting the current token makes the MetaTX market less efficient however, since now relayers are \"forced\" to accept the given token if they want to serve their users, instead of only accepting DAI or WBTC for instance. This adds complexity to the relayer and could fragment relayers. It's likely that smaller/new tokens would not be able to find reliable relayers as the risk for the relayers is too large. However, if users could specify `DAI` (or other common currency), then all MetaTX for all tokens with native metaTX are equivalent for relayers. \r\n\r\n> Still, how wallet would know whether other tokens (non-native) are supported?\r\n\r\nWallet just need to check token balances and check the approvals. Wallet could by default use the native token of the contract, which offers the same experience as your current proposal, but with the added flexibility that one *could* use another token to pay for gas.\r\n\r\n> As such the meta-transaction implementation need to ensure enough gas is passed to the transaction so that when calling _to.call.gas(_gasLimit)(_data); the exact _gasLimit is passed in (solidity does not enforce this by itself and less could be passed in).\r\n\r\nHere again I would not enforce this per say and leave it to the relayer, where the contract reimburses *up to* the gas limit. A relayer will therefore have no incentive to exceed and the transaction will still go through if the relayer undervalues the amount of gas required. In your proposal, if `gasLimit` becomes insufficient, the tx is not-executable anymore, while in what i'm proposing, so long as there is a margin for profit, the tx is executable even if `gasLimit` is too low. Here again I personally think the flexibility improves the user experience and the probability that the tx will be executed correctly. \r\n\r\n> This is not that simple. a user could simply specify a high gasLimit to make believe the relayer that its margin will cover the extra fee, while the actual transaction consume very little.\r\n\r\nMiners need to make the same type of decisions, where if a transaction gasLimit can be much higher than what is actually consumed. I don't think this will be a problem in practice with good enough tools.\r\n\r\n> Note though that if baseGas is a fixed value (worst case value) the smart contract can avoid requiring it to be passed as calldata as such there is not much cost of baseGas being included in the message.\r\n\r\nThat sounds reasonable. The simplicity of including a baseGas field for most implementations seems indeed worth it. \r\n\r\n> I would say, let's focus on something concrete we have now. We could always create a new standard for wallet to support ERC-721... (as an extension)\r\n\r\nWithout `gasToken` the current standard only seem to support ERC-20, but not ERC-721 nor ERC-1155, which is a mistake imo. I'm not sure what is the easiest way to generalize the standard however. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469692564/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/470603837",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-470603837",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 470603837,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDYwMzgzNw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-07T16:50:18Z",
    "updated_at": "2019-03-07T21:55:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This doesn't really matter because the relayer can always wait before submitting the tx. If multiple relayers can execute, then this is no problem and if the relayer is enforced by you, you can change relayer if the service they provide isn't good. Think of exchanges like Binance that will withdraw your funds with a gas price of 50 Gwei to ensure good customer service. It also gives no room to the relayer to adjust the gas price if market changes, which reduces the chances that the tx will be submitted.\r\n\r\nI am not convinced:\r\n\r\nFor the case when there is many relayers, indeed, the gasPrice used will tend towards the ethereum gasPrice equivalent to the tokenGasPrice value but then this is mostly equivalent to letting the user dictate the gasPrice. \r\n\r\nIf there is only one relayer (whether it was the only specified or not) on the other hand, the user becomes at the mercy of its decision. That relayer is incentivised to get paid more than what it is providing and so the user will wait longer than it should for its transaction. While we could argue that's the nature of such small market, my point is that the tokenGasPrice can still increase to offer incentive for such relayer to relay, on the other hand the actual ethereum gasPrice should be in the hand of the signer, so the relayer can't malicious grab the price and provide a slow experience. In such situation, the user can't simply increase the tokenGasPrice as he has no guarantee the relayer will increase teh gasPrice in exchange.\r\nIf the relayer is not broadcasting the transaction, the user can simply look for another one. This is the same in both case.\r\n\r\nIn other words, the only advantage  a gasPrice determined by the relayer bring to the user is when the relayer (by potentially losing money, at least its margin) increase the gasPrice. The other way could only be to the detriment of the user.\r\n\r\nAs such for gas market price changes, which is only a problem for the user when the gas price is not sufficient anymore. We could allow the relayer to increase it but never make it lower than specified by the user.  \r\n\r\nThis conflict though with the other issue arising from letting the relayer set the gas price: the user is not in control of the execution data anymore. In principle, I think it is important that the relayer should not have any say to the data being sent as part of the transaction. gasPrice, is such data. \r\n\r\nI agree though that we could specify the need to not use gasPrice in receiver call as part of the standard. Personally I do not see any use case that would be restricted but is that a safe assumption?\r\n\r\nif that is safe, I would agree to let the relayer **increase** the gasPrice but not **decrease** it.\r\n\r\nBy the way, there is another potential side benefit of a fixed gasPrice: it might help a network of relayers to coordinate since there would be no easy way for a late relayer to grab the price by submiting a transaction later. \r\n\r\n> Only supporting the current token makes the MetaTX market less efficient however, since now relayers are \"forced\" to accept the given token if they want to serve their users, instead of only accepting DAI or WBTC for instance. This adds complexity to the relayer and could fragment relayers. It's likely that smaller/new tokens would not be able to find reliable relayers as the risk for the relayers is too large. However, if users could specify DAI (or other common currency), then all MetaTX for all tokens with native metaTX are equivalent for relayers.\r\n\r\nI think you convinced me on this one, not from this response specifically but from the general idea of generic meta transaction. This has some implications though and I am still ensure if they all fine. For example the current draft allow the transaction to specify a token amount to send to the destination. If we want to support that, we probably want to add yet another field ```tokenToSend``` but this also implies that we need a different way to support ERC-20 tokens. Approval is not transitive and as such the sender will need to either approve the receiver before hand (not great user experience) or the contract will need to transfer token first and let the receiver know of the token received (like a erc-20 tokensReceiced hook) and revert the transfer if the call failed (with all the gas cost it implies).\r\n\r\nOne thing worth noting here is that as I said we would only need one smart contract implementation for all native meta transaction, then. The current proposal could still focus on the message format, each field's role, receivers expectation and wallet support though.\r\n\r\n> > Still, how wallet would know whether other tokens (non-native) are supported?\r\n> Wallet just need to check token balances and check the approvals. Wallet could by default use the native token of the contract, which offers the same experience as your current proposal, but with the added flexibility that one could use another token to pay for gas.\r\n\r\nThe question was about how the wallet know that the token supporting meta transaction support a specific token, not that the user approved the token. But now that I think a bit more clearly about such generic meta transaction contract, I can see that there is not reason the implementation limit which tokens are supported, this is up to the receiver (relayer and destination) to accept them or not. \r\n\r\n> Here again I would not enforce this per say and leave it to the relayer, where the contract reimburses up to the gas limit. A relayer will therefore have no incentive to exceed and the transaction will still go through if the relayer undervalues the amount of gas required. \r\n\r\nAgain by principle, the relayer should not have any say in the data passed to the call and this is even more important for gas than gasPrice.\r\n\r\nBut more importantly, if the relayer decide what amount of gas is passed to the call, when it fails, who is to pay the meta transaction? This should not be the user if the call failed due to the lack of gas.\r\n\r\n> In your proposal, if gasLimit becomes insufficient, the tx is not-executable anymore, while in what i'm proposing, so long as there is a margin for profit, the tx is executable even if gasLimit is too low\r\n\r\nThe only time the gasLimit would be too low  in my proposal is when the user miscalculate the cost. It can't **become** insuficient.\r\nTo be more clear, in the current proposal, gasLimit is not the gasLimit the relayer need to send, it is the gaslimit sent as part of the call. It is up to the relayer to provide enough gas to reach the call executing with enough gas to complete the transaction. If the relayer do not, it lose its gas. \r\n\r\nAs such if ever the user sign a gasLimit too low, the relayer (provided it sent enough gas for the whole tx) will be rewarded for the execution anyway (and the meta nonce increased) since we can calculate that it was the user's mistake not the relayer.\r\n\r\n> Miners need to make the same type of decisions, where if a transaction gasLimit can be much higher than what is actually consumed. I don't think this will be a problem in practice with good enough tools.\r\n\r\nThat's not a fair comparison. In the miner case, there is not extra margin decided by the miner The miner simply knows that they will be paid x for y gas.\r\n\r\n> Without gasToken the current standard only seem to support ERC-20, but not ERC-721 nor ERC-1155, which is a mistake imo. I'm not sure what is the easiest way to generalize the standard however.\r\n\r\nAs said about ERC1155 we can easily add ERC712 specific message preamble in the TYPEHASH. \r\nWe could standardize it like ```<ERCXXX>MetaTransaction(...``` and the ```gasToken``` field would define the id.\r\n\r\nI' ll add that to the proposal.\r\n\r\nWe could also simply add a string field instead that state the ERC to be used like : ```tokenERC```.  I personally prefers the preamble but I would not mind changing it.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/470603837/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/486237729",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-486237729",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 486237729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NjIzNzcyOQ==",
    "user": {
      "login": "sboucherit",
      "id": 47741556,
      "node_id": "MDQ6VXNlcjQ3NzQxNTU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/47741556?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sboucherit",
      "html_url": "https://github.com/sboucherit",
      "followers_url": "https://api.github.com/users/sboucherit/followers",
      "following_url": "https://api.github.com/users/sboucherit/following{/other_user}",
      "gists_url": "https://api.github.com/users/sboucherit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sboucherit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sboucherit/subscriptions",
      "organizations_url": "https://api.github.com/users/sboucherit/orgs",
      "repos_url": "https://api.github.com/users/sboucherit/repos",
      "events_url": "https://api.github.com/users/sboucherit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sboucherit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-24T13:45:55Z",
    "updated_at": "2019-04-26T08:54:44Z",
    "author_association": "NONE",
    "body": "Hello. Can we compare what has been done here with EIP1613/Tabookey ( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1613.md ) ? Can we combine both ? (Native MetaTX in your token contract + you use Tabookey's relay)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/486237729/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/572993679",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-572993679",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 572993679,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3Mjk5MzY3OQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-10T11:11:35Z",
    "updated_at": "2020-01-10T11:11:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "Updated the draft with latest improvement.\r\n\r\nMost notably, the addition of ```baseGas``` which allows implementation to be fully independent of opcode pricing",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/572993679/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/575843333",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-575843333",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 575843333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NTg0MzMzMw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-18T00:19:40Z",
    "updated_at": "2020-01-18T00:19:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "Just made a new update, that include the following:\r\n\r\n1) the use of an expiry time replace the need for `minTxGas` and allow for a more friendly experience as the user can be sure that after a certain time, the tx has been canceled. Plus with EIP-1681, this will not affect relayer.\r\n\r\n2) I also updated the message format with a 2 dimensional nonce (batchId, batchNonce). This offers great flexibility to the user when it comes to submitting meta-tx in different applications.\r\n\r\nI also added a paragraph on the use of `expiry` and `relayer` field to protect relayer from other relayers.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/575843333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/577314953",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-577314953",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 577314953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NzMxNDk1Mw==",
    "user": {
      "login": "lirazsiri",
      "id": 1171354,
      "node_id": "MDQ6VXNlcjExNzEzNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1171354?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lirazsiri",
      "html_url": "https://github.com/lirazsiri",
      "followers_url": "https://api.github.com/users/lirazsiri/followers",
      "following_url": "https://api.github.com/users/lirazsiri/following{/other_user}",
      "gists_url": "https://api.github.com/users/lirazsiri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lirazsiri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lirazsiri/subscriptions",
      "organizations_url": "https://api.github.com/users/lirazsiri/orgs",
      "repos_url": "https://api.github.com/users/lirazsiri/repos",
      "events_url": "https://api.github.com/users/lirazsiri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lirazsiri/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-22T18:12:20Z",
    "updated_at": "2020-01-22T18:16:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Hello. Can we compare what has been done here with EIP1613/Tabookey ( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1613.md ) ? Can we combine both ? (Native MetaTX in your token contract + you use Tabookey's relay)\r\n\r\nThere seems to be a bit of a misunderstanding here as the Gas Station Network (EIP 1613) has always supported native meta transactions signed by externally owned accounts. From day one. The differences between the GSN and EIP 1776 is that:\r\n\r\n* The GSN includes a robust, decentralized solution to the decentralized relay discovery problem (the on-chain RelayHub registry)\r\n* The GSN supports relaying meta-transactions on behalf of externally owned accounts AND account contracts.\r\n* The GSN contracts that handle meta transations have passed security audits and have been live on mainnet since Aug 2019.\r\n* The GSN has been integrated into multiple middleware layers including ZeppelinOS\r\n\r\nAn update to the GSN is in progress that adds:\r\n\r\n* EIP 712 support so that meta transactions are encoded in a standard format. \r\n* Batched transactions\r\n* Improved native support for unmodified destination contracts already live on mainnet. This can already be accomplished with the current version of the GSN but the implementation is cumbersome.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/577314953/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/590705283",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-590705283",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 590705283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDcwNTI4Mw==",
    "user": {
      "login": "tomarsachin2271",
      "id": 44962043,
      "node_id": "MDQ6VXNlcjQ0OTYyMDQz",
      "avatar_url": "https://avatars.githubusercontent.com/u/44962043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomarsachin2271",
      "html_url": "https://github.com/tomarsachin2271",
      "followers_url": "https://api.github.com/users/tomarsachin2271/followers",
      "following_url": "https://api.github.com/users/tomarsachin2271/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomarsachin2271/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomarsachin2271/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomarsachin2271/subscriptions",
      "organizations_url": "https://api.github.com/users/tomarsachin2271/orgs",
      "repos_url": "https://api.github.com/users/tomarsachin2271/repos",
      "events_url": "https://api.github.com/users/tomarsachin2271/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomarsachin2271/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-25T06:25:28Z",
    "updated_at": "2020-02-25T06:25:28Z",
    "author_association": "NONE",
    "body": "EIP712 format is created to make it easy for user to understand and see what he is signing which is way better than signing a hexadecimal string. And as more and more DApps will be including meta transactions and blockchain mainstream adoption increases, with the current fields in the format given in this EIP, I still feel a normal end-user would not know what is happening in the meta transaction.\r\n\r\nSo a **description** field in the format should be added, that'll include the description of transaction in a human readable form.\r\nEven though standard transactions like token transfer or approval or native value transfer can be interpreted by the wallet but its not possible to interpret every general contract interaction, by the wallet.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/590705283/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591343103",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-591343103",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 591343103,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTM0MzEwMw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T10:03:53Z",
    "updated_at": "2020-02-26T10:03:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "@tomarsachin2271 thanks for your feedback.\r\n\r\nThe goal of this standard is so that when it get accepted, wallets will be able to show meaningful information, instead of the raw EIP-712 message. They would also let the user specify/change some of the parameter, like expiryTime.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591343103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/741948312",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-741948312",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 741948312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0MTk0ODMxMg==",
    "user": {
      "login": "tina1998612",
      "id": 19768276,
      "node_id": "MDQ6VXNlcjE5NzY4Mjc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/19768276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tina1998612",
      "html_url": "https://github.com/tina1998612",
      "followers_url": "https://api.github.com/users/tina1998612/followers",
      "following_url": "https://api.github.com/users/tina1998612/following{/other_user}",
      "gists_url": "https://api.github.com/users/tina1998612/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tina1998612/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tina1998612/subscriptions",
      "organizations_url": "https://api.github.com/users/tina1998612/orgs",
      "repos_url": "https://api.github.com/users/tina1998612/repos",
      "events_url": "https://api.github.com/users/tina1998612/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tina1998612/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-12-09T18:00:37Z",
    "updated_at": "2020-12-09T18:00:37Z",
    "author_association": "NONE",
    "body": "Can someone point me out the main differences between this and [ERC865](https://github.com/ethereum/EIPs/issues/865)? \r\n\r\nI looked into the main function that recovers the sender from the signature and then let a third party submit the transaction while paying for the gas fee and receives tokens as reward. Looks the same to me. \r\n\r\nThanks:)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/741948312/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/741985201",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-741985201",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 741985201,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0MTk4NTIwMQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-12-09T19:07:22Z",
    "updated_at": "2020-12-09T19:07:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "@tina1998612 the main difference is that EIP-1776 support any call, while ERC865 only support erc20 transfer",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/741985201/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705494",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-974705494",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 974705494,
    "node_id": "IC_kwDOAq426M46GNNW",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-20T20:12:33Z",
    "updated_at": "2021-11-20T20:12:33Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086439",
    "html_url": "https://github.com/ethereum/EIPs/issues/1776#issuecomment-986086439",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1776",
    "id": 986086439,
    "node_id": "IC_kwDOAq426M46xnwn",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-04T20:12:59Z",
    "updated_at": "2021-12-04T20:12:59Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
