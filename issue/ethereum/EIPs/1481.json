{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1481",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1481",
  "id": 368154431,
  "node_id": "MDU6SXNzdWUzNjgxNTQ0MzE=",
  "number": 1481,
  "title": "EIP-1480: Access Control Standard",
  "user": {
    "login": "ben-kaufman",
    "id": 10667901,
    "node_id": "MDQ6VXNlcjEwNjY3OTAx",
    "avatar_url": "https://avatars.githubusercontent.com/u/10667901?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ben-kaufman",
    "html_url": "https://github.com/ben-kaufman",
    "followers_url": "https://api.github.com/users/ben-kaufman/followers",
    "following_url": "https://api.github.com/users/ben-kaufman/following{/other_user}",
    "gists_url": "https://api.github.com/users/ben-kaufman/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ben-kaufman/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ben-kaufman/subscriptions",
    "organizations_url": "https://api.github.com/users/ben-kaufman/orgs",
    "repos_url": "https://api.github.com/users/ben-kaufman/repos",
    "events_url": "https://api.github.com/users/ben-kaufman/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ben-kaufman/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2018-10-09T11:00:32Z",
  "updated_at": "2021-12-18T21:11:28Z",
  "closed_at": "2021-12-18T21:11:28Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 1480\r\ntitle: Modular Access Control Mechanism\r\nauthor: Matan Tsuberi <mtsuberi@daostack.io>, Ben Kaufman <ben@daostack.io>, Adam Levi <adam@daostack.io>, Oren Sokolowsky <oren@daostack.io>\r\ndiscussions-to: <URL>\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2018-10-08\r\nrequires: 165\r\n---\r\n\r\n<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->\r\n\r\n## Simple Summary\r\n\r\n<!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the EIP.-->\r\n\r\nStandard access control mechanism for smart contracts.\r\n\r\n## Abstract\r\n\r\n<!--A short (~200 word) description of the technical issue being addressed.-->\r\n\r\nThis EIP presents a generalized mechanism for access control on smart contracts, enabling the use of complex boolean expressions for limiting access to contract's functions. The mechanism utilizes the idea of [\"keys\"](https://en.wikipedia.org/wiki/Capability-based_security) for the access limitations. Keys could be transferable, expirable, limited to certain amount of uses or limited to certain fucntion parameters use.\r\n\r\n## Motivation\r\n\r\n<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->\r\n\r\nAccess control is one of the basic components most smart contract applications and frameworks need to have. The ability to limit the access for calling a function to a specific EOA or smart contract account is vital for most systems. The core logic for the access control of a smart contract has a great importance as it is usually the main security risk a contract may have, and if compromised, it can cause fatal issue for the entire system.\r\nThere is a vast number of use cases requiring access management for smart contracts. A few popular examples can be:\r\n\r\n- Ownable - This is probably the most popular access control mechanism used in the Ethereum space. OpenZeppelin's implementation can be found [here](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol).\r\n\r\n- Membership Management - There are much efforts for managing membership on the Ethereum blockchain. A full detailed rationale for that can be found on [EIP-1261 - Membership Verification Token](https://eips.ethereum.org/EIPS/eip-1261). However, this creates a duplication of effort as membership management is just a single aspect of access control. In addition, the current effort lacks some basic properties such as expiration and transferability of memberships.\r\n\r\n- DAO operations - There are multiple teams working in the DAO space, all facing the problem of access control in a DAO. Thus, there is a lot of duplicated work on the subject with each having its own pros and cons. However, non of them has found a mechanism generalized enough to answer all possible future needs of DAOs.\r\n\r\nThere is a strong need for an effective generalized way of managing access rights, most importantly in a trustless manner. We would like to propose a generalized mechanism for access control in smart contracts to provide easier interoperability, reduce security risks, and minimize the duplicated effort of teams working in the subject.\r\n\r\n## Specification\r\n\r\n<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->\r\n\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\r\n\r\n**Every ERC-1480 compliant contract MUST implement the `ERC1480` and `ERC165` interfaces** (subject to \"caveats\" below):\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/// @title ERC1480Interface - Access Control Interface\r\n/// @dev basic inteface for access control mechanism\r\n/// Note: the ERC-165 identifier for this interface is 0x33f9cb64.\r\ninterface ERC1480Interface {\r\n\r\n    event AssignKey(\r\n        bytes32 indexed _id,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        bool _assignable,\r\n        uint _start,\r\n        uint _expiration,\r\n        uint _uses\r\n    );\r\n\r\n    event RevokeKey(bytes32 indexed _id, address indexed _owner);\r\n\r\n    /// @dev assign partial or all capabilities from the sender to an account\r\n    /// @param _id lock id\r\n    /// @param _to recipient\r\n    /// @param _assignable can the recipient further assign capabilities to other accounts?\r\n    /// @param _start the key's start time (block number)\r\n    /// @param _expiration the key's expiration time (block number)\r\n    /// @param _uses number of times this key can be used (in `unlock(..)`)\r\n    function assignKey(\r\n        bytes32 _id,\r\n        address _to,\r\n        bool _assignable,\r\n        uint _start,\r\n        uint _expiration,\r\n        uint _uses\r\n        ) external;\r\n\r\n    /// @dev assign all capabilities from the sender to an account\r\n    /// @param _id lock id\r\n    /// @param _to recipient\r\n    function assignFullKey(bytes32 _id, address _to) external;\r\n\r\n    /// @dev revoke the sender's key\r\n    /// @param _id lock id\r\n    function revokeKey(bytes32 _id) external;\r\n\r\n    /// @dev does the owner have a valid key for the lock id\r\n    /// @param _id lock id\r\n    /// @param _owner owner address\r\n    function unlockable(bytes32 _id, address _owner) external view returns (bool);\r\n\r\n    /// @dev does the owner have a valid key for the lock id\r\n    /// @param _id lock id\r\n    /// @param _owner owner address\r\n    /// @return the properties of the requested key as a tuple\r\n    function getKey(bytes32 _id, address _owner) external view returns (bool, bool, uint, uint, uint);\r\n}\r\n\r\n/// @title ERC1480 - Access Control Interface\r\n/// @dev contract for access control mechanism\r\ncontract ERC1480 is ERC165, ERC1480Interface {\r\n    struct Key {\r\n        bool exists;\r\n        bool assignable;\r\n        uint start;\r\n        uint expiration;\r\n        uint uses;\r\n    }\r\n\r\n    /// @dev Grant capabilities to account (overwrites existing key)\r\n    /// @param _id lock id\r\n    /// @param _to recipient\r\n    /// @param _assignable can the recipient further assignKey his capabilities to other accounts?\r\n    /// @param _start the key's start time (block timestamp)\r\n    /// @param _expiration the key's expiration time (block timestamp)\r\n    /// @param _uses number of times this key can be used (in `unlock(..)`)\r\n    function grantKey(\r\n        bytes32 _id,\r\n        address _to,\r\n        bool _assignable,\r\n        uint _start,\r\n        uint _expiration,\r\n        uint _uses\r\n        ) internal;\r\n\r\n    /// @dev Grant full capabilities to account (assignable, no start time, no expiration, infinite uses)\r\n    /// @param _id lock id\r\n    /// @param _to recipient\r\n    function grantFullKey(bytes32 _id, address _to) internal;\r\n\r\n    /// @dev unlock a lock if sender has a valid key.\r\n    /// @param _id lock id\r\n    function unlock(bytes32 _id) internal returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n```\r\n\r\nThe _storage extention_ is RECOMMENDED for ERC-1480 smart contracts (see \"caveats\", below). This contains the RECOMMENDED data structure for storing the access \"keys\".\r\n\r\n```solidity\r\n/// @title ERC1480Storage - Access Control, RECOMMENDED data structure\r\ncontract ERC1480Storage is ERC1480 {\r\n    mapping(bytes32 => mapping(address => Key)) public keys;\r\n}\r\n```\r\n\r\n### Caveats\r\n\r\nThe 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1480 standard. A contract which complies with ERC-1480 MUST also abide by the following:\r\n\r\n- Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: `payable`, implicit nonpayable, `view`, and `pure`. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a `payable` function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.24 is that you can edit this interface to add stricter mutability before inheriting from your contract.\r\n- Solidity issue #2330: If a function is shown in this specification as `external` then a contract will be compliant if it uses `public` visibility. As a workaround for version 0.4.20, you can edit this interface to switch to `public` before inheriting from your contract.\r\n\r\n_If a newer version of Solidity allows the caveats to be expressed in code, then this EIP MAY be updated and the caveats removed, such will be equivalent to the original specification._\r\n\r\n## Rationale\r\n\r\n<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->\r\n\r\nThere are many approaches which were developed to create an access control mechanism, but each focuses on a relatively specific use case. We tried to create a generalized mechanism allowing for all uses cases to be implemented, while keeping the gas efficiency similar to a more dedicated solution.\r\nWe chose to use the concept of \"Keys\" with the certain properties of: uses limit, expiration time, and (re-)assignablity. This approach allows the use of complex boolean expressions for limiting access to a function such as allowing an account to call a certain function (or multiple functions) 2 times until the end of next month and possibly assign that right to another account.\r\nA more concrete example could be for \"Ownership\" of a contract. A common use case for the (\"Ownable\" contract)[https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol] are \"safty backdoors\" - functions which enable the \"owner\" of the contract do controversial changes in crisis times. Most teams promise to eliminate their access to those backdoors after their project gets mature enogh, but this requires to trust the team to stand up for this promise. The \"Ownable\" contract pattern, thus, could benefit from the addition of a trustless expiration date, removing the need of trusting the teams to give up on their \"safety backdoors\" access when their project matures.\r\n\r\nThe proposed interface contains functions to allow utilizing the full capabilities of the properties of a key. Which are the ability to grant (by the contract), assign to other account, revoke, and use a key. This also keeps the option for implementations to have their own characteristics and suitable behaviour. For example, it is possible for an implementation to use block number for keys expiration, instead of timestamps. For gas optimizations, we also used 0 values to \"disable\" the use of certain features, this makes keys which doesn't have, for example, expiration time to have similar gas consumption to another solution with no expiration parameter at all.\r\n\r\n## Backwards Compatibility\r\n\r\n<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->\r\n\r\nThere are no backwards compatibility concerns.\r\n\r\n## Test Cases\r\n\r\n<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->\r\n\r\nDAOstack ERC-1480 implementation includes test cases written using Truffle.\r\n\r\n## Implementation\r\n\r\n<!--The implementations must be completed before any EIP is given status \"Final\", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \"rough consensus and running code\" is still useful when it comes to resolving many discussions of API details.-->\r\n\r\nDAOstack full implementation is available [here](https://github.com/daostack/access_control).\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1481/reactions",
    "total_count": 6,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986093271",
    "html_url": "https://github.com/ethereum/EIPs/issues/1481#issuecomment-986093271",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481",
    "id": 986093271,
    "node_id": "IC_kwDOAq426M46xpbX",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-04T21:10:29Z",
    "updated_at": "2021-12-04T21:10:29Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986093271/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997285260",
    "html_url": "https://github.com/ethereum/EIPs/issues/1481#issuecomment-997285260",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1481",
    "id": 997285260,
    "node_id": "IC_kwDOAq426M47cV2M",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-18T21:11:27Z",
    "updated_at": "2021-12-18T21:11:27Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997285260/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
