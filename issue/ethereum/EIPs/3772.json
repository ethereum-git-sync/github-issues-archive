{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3772",
  "id": 981398007,
  "node_id": "MDU6SXNzdWU5ODEzOTgwMDc=",
  "number": 3772,
  "title": "ERC: Compressed Integers",
  "user": {
    "login": "zemse",
    "id": 22412996,
    "node_id": "MDQ6VXNlcjIyNDEyOTk2",
    "avatar_url": "https://avatars.githubusercontent.com/u/22412996?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/zemse",
    "html_url": "https://github.com/zemse",
    "followers_url": "https://api.github.com/users/zemse/followers",
    "following_url": "https://api.github.com/users/zemse/following{/other_user}",
    "gists_url": "https://api.github.com/users/zemse/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/zemse/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/zemse/subscriptions",
    "organizations_url": "https://api.github.com/users/zemse/orgs",
    "repos_url": "https://api.github.com/users/zemse/repos",
    "events_url": "https://api.github.com/users/zemse/events{/privacy}",
    "received_events_url": "https://api.github.com/users/zemse/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2021-08-27T16:15:08Z",
  "updated_at": "2022-08-23T14:43:20Z",
  "closed_at": "2022-08-23T14:43:20Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "# Compressed Integers\r\n\r\nUsing lossy compression on uint256 to improve gas costs, ideally by a factor up to 4x.\r\n\r\n## Abstract \r\n\r\nThis document specifies compression of `uint256` to smaller data structures like  `uint64`, `uint96`, `uint128`, for optimizing costs for storage in Ethereum Smart Contracts. The smaller data structure (represented as `cintx`) is divided into two parts, in the first one we store `significant` bits and in the other number of left `shift`s needed on the significant bits to decompress. This document also includes two specifications for decompression due to the nature of compression being lossy, i.e. it causes underflow.\r\n\r\n## Motivation\r\n\r\n- Storage is costly, each storage slot costs almost $0.8 to initialize and $0.2 to update (20 gwei, 2000 ETHUSD). \r\n- Usually, we store money amounts in uint256 which takes up one entire slot. \r\n- If it's DAI value, the range we work with most is 0.001 DAI to 1T DAI (or 10<sup>12</sup>). If it's ETH value, the range we work with most is 0.000001 ETH to 1B ETH. Similarly, any token of any scale has a reasonable range of 10<sup>15</sup> amounts that we care/work with.\r\n- However, uint256 type allows us to represent $10<sup>-18</sup> to $10<sup>58</sup>, and most of it is a waste. In technical terms, we have the probability distribution for values larger than $10<sup>15</sup> and smaller than $10<sup>-3</sup> as negligible (i.e. P[val > 10<sup>15</sup>] ≈ 0 and P[val < 10<sup>-3</sup>] ≈ 0).\r\n- Number of bits required to represent 10<sup>15</sup> values = log<sub>2</sub>(10<sup>15</sup>) = 50 bits. So just 50 bits are reasonably enough to represent a practical range of money, causing a very negligible difference.\r\n\r\n## Specification\r\n\r\nIn this specification, the structure for representing a compressed value is represented using `cintx`, where x is the number of bits taken by the entire compressed value. (On the implementation level, an `uintx` can be used for storing a `cintx` value).\r\n\r\n### Compression\r\n\r\n#### uint256 into cint64 (upto cint120)\r\n\r\nThe rightmost or least significant 8 bits in `cintx` are reserved for storing the shift and the rest available bits are used to store the significant bits starting from the first `1` bit in `uintx`.\r\n\r\n```solidity\r\nstruct cint64 { uint56 significant; uint8 shift; }\r\n\r\n// ...\r\n\r\nstruct cint120 { uint112 significant; uint8 shift; }\r\n```\r\n\r\n#### uint256 into cint128 (upto cint248)\r\n\r\nThe rightmost or least significant 7 bits in `cintx` are reserved for storing the shift and the rest available bits are used to store the significant bits starting from the first on bit in `uintx`.\r\n\r\n\r\n> In the following code example, `uint7` is used just for representation purposes only, but it should be noted that uints in Solidity are in multiples of 8.\r\n\r\n```solidity\r\nstruct cint128 { uint121 significant; uint7 shift; }\r\n\r\n// ...\r\n\r\nstruct cint248 { uint241 significant; uint7 shift; }\r\n```\r\n\r\nExamples: \r\n```\r\nExample: \r\nuint256 value: 2**100, binary repr: 1000000...(hundred zeros)\r\ncint64 { significant: 10000000...(55 zeros), shift: 00101101 (45 in decimal)}\r\n\r\nExample: \r\nuint256 value: 2**100-1, binary repr: 111111...(hundred ones)\r\ncint64 { significant: 11111111...(56 ones), shift: 00101100 (44 in decimal) }\r\n```\r\n\r\n### Decompression\r\n\r\nTwo decompression methods are defined: a normal `decompress` and a `decompressRoundingUp`.\r\n\r\n```solidity\r\nlibrary CInt64 {\r\n    // packs the uint256 amount into a cint64\r\n    function compress(uint256) internal returns (cint64) {}\r\n    \r\n    // unpacks cint64, by shifting the significant bits left by shift\r\n    function decompress(cint64) internal returns (uint256) {}\r\n    \r\n    // unpacks cint64, by shifting the significant bits left by shift\r\n    // and having 1s in the shift bits\r\n    function decompressRoundingUp(cint64) internal returns (uint256) {}\r\n} \r\n```\r\n\r\n#### Normal Decompression\r\n\r\nThe `significant` bits in the `cintx` are moved to a `uint256` space and shifted left by `shift`.\r\n\r\n> NOTE: In the following example, cint16 is used for visual demonstration purposes. But it should be noted that it is definitely not safe for storing money amounts because its significant bits capacity is 8, while at least 50 bits are required for storing money amounts.\r\n\r\n\r\n```\r\nExample: \r\ncint16{significant:11010111, shift:00000011}\r\ndecompressed uint256: 11010111000 // shifted left by 3\r\n\r\nExample:\r\ncint64 { significant: 11111111...(56 ones), shift: 00101100 (44 in decimal) }\r\ndecompressed uint256: 1111...(56 ones)0000...(44 zeros)\r\n```\r\n\r\n#### Decompression along with rounding up\r\n\r\nThe `significant` bits in the `cintx` are moved to a `uint256` space and shifted left by `shift` and the least significant `shift` bits are `1`s.\r\n\r\n```\r\nExample: \r\ncint16{significant:11011110, shift:00000011}\r\ndecompressed rounded up value: 11011110111 // shifted left by 3 and 1s instead of 0s\r\n\r\nExample:\r\ncint64 { significant: 11111111...(56 ones), shift: 00101100 (44 in decimal) }\r\ndecompressed uint256: 1111...(100 ones)\r\n```\r\n\r\nThis specification is to be used by a new smart contract for managing its internal state so that any state mutating calls to it can be cheaper. These compressed values on a smart contract's state are something that should not be exposed to the external world (other smart contracts or clients). A smart contract should expose a decompressed value if needed.\r\n\r\n\r\n## Rationale \r\n\r\n- The `significant` bits are stored in the most significant part of `cintx` while `shift` bits in the least significant part, to help prevent obvious dev mistakes. For e.g. a number smaller than 2<sup>56</sup>-1 its compressed `cint64` value would be itself if the arrangement were to be opposite than specified. If a developer forgets to uncompress a value before using it, this case would still pass if the compressed value is the same as decompressed value.\r\n- It should be noted that using `cint64` doesn't render gas savings automatically. The solidity compiler needs to pack more data into the same storage slot.\r\n- Also the packing and unpacking adds some small cost too.\r\n- Though this design can also be seen as a binary floating point representation, however using floating point numbers on EVM is not in the scope of this ERC. The primary goal of floating point numbers is to be able to represent a wider range in an available number of bits, while the goal of compression in this ERC is to keep as much precision as possible. Hence, it specifies for the use of minimum exponent/shift bits (i.e 8 up to `uint120` and 7 up to `uint248`).\r\n\r\n```solidity\r\n// uses 3 slots\r\nstruct UserData1 {\r\n    uint64 amountCompressed;\r\n    bytes32 hash;\r\n    address beneficiary;\r\n}\r\n\r\n// uses 2 slots\r\nstruct UserData2 {\r\n    uint64 amountCompressed;\r\n    address beneficiary;\r\n    bytes32 hash;\r\n}\r\n```\r\n\r\n## Backwards Compatibility\r\n\r\nThere are no known backward-incompatible issues.\r\n\r\n\r\n## Reference Implementation\r\n\r\nUsing structs for `cintx` as of Solidity 0.8.6 does not yet serve the purpose of saving gas, (see [solidity#11691](https://github.com/ethereum/solidity/issues/11691), requires some backward-incompatible changes in storage layout in Solidity). Hence on the implementation level `uint64` can be used directly.\r\n\r\n```soldity\r\nfunction compress(uint256 full) public pure returns (uint64 cint) {\r\n    uint8 bits = mostSignificantBitPosition(full);\r\n    if (bits <= 55) {\r\n        cint = uint64(full) << 8;\r\n    } else {\r\n        bits -= 55;\r\n        cint = (uint64(full >> bits) << 8) + bits;\r\n    }\r\n}\r\n\r\nfunction decompress(uint64 cint) public pure returns (uint256 full) {\r\n    uint8 bits = uint8(cint % (1 << 9));\r\n    full = uint256(cint >> 8) << bits;\r\n}\r\n\r\nfunction decompressRoundingUp(uint64 cint) public pure returns (uint256 full) {\r\n    uint8 bits = uint8(cint % (1 << 9));\r\n    full = uint256(cint >> 8) << bits + ((1 << bits) - 1);\r\n}\r\n```\r\n\r\nGist: https://gist.github.com/zemse/0ea19dd9b4922cd68f096fc2eb4abf93\r\n\r\nThe above gist has `library CompressedMath64` that contains demonstrative logic for compression, decompression, and arithmetic for `cint64`, however, we utilize `uint64` data structure due to a present storage layout limitation on nested structs in Solidity. The gist also has an example contract that uses the library for demonstration purposes.\r\n\r\n### Some related work\r\n\r\nSome engineers have realized that using `uint256` entirely for storing value/money is not optimal in view of storage costs, and some of the bits in the slot could be better utilized with other data stored in its place.\r\n\r\n- Sushiswap's MasterChefV2: ([code ref](https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChefV2.sol#L198), they are casting `uint256` values to `uint128`, to make some room for other data. No lossy compression).\r\n- Compound's GovernorAlpha ([code ref](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol#L88), they use `uint96`)\r\n- Rollups ([Using about 3 bytes or 24 bits for representing ETH value](https://vitalik.ca/general/2021/01/05/rollup.html#how-does-compression-work))\r\n\r\n> TODO Find more projects and add links here\r\n\r\n## Security Considerations\r\n\r\nThe following security considerations are discussed:\r\n\r\n1. Effects due to lossy compression\r\n    - Error estimation for `cint64`\r\n    - Handeling the error\r\n2. Losing precision due to incorrect use of `cintx`\r\n3. Compressing something other than money `uint256`s.\r\n\r\n### 1. Effects due to lossy compression\r\n\r\nWhen a value is compressed, it causes underflow, i.e. some less significant bits are sacrificed. This results in a `cintx` value whose decompressed value is less than or equal to the actual `uint256` value.\r\n\r\n```solidity\r\nuint a = 2**100 - 1; // 100 # of 1s in binary format\r\nuint c = a.compress().decompress();\r\n\r\na > c; // true\r\na - (2**(100 - 56) - 1) == c; // true\r\n\r\n// Visual example:\r\n// before: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\r\n// after:  1111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000\r\n```\r\n\r\n#### Error estimation for cint64\r\n\r\nLet's consider we have a `value` of the order 2<sup>m</sup> (less than 2<sup>m</sup> and greater than or equal to 2<sup>m-1</sup>).\r\n\r\nFor all values such that 2<sup>m</sup> - 1 - (2<sup>m-56</sup> - 1) <= `value` <=  2<sup>m</sup> - 1, the compressed value `cvalue` is 2<sup>m</sup> - 1 - (2<sup>m-56</sup> - 1).\r\n\r\nThe maximum error is 2<sup>m-56</sup> - 1, approximating it to decimal: 10<sup>n-17</sup> (log<sub>2</sub>(56) is 17). Here `n` is number of decimal digits + 1.\r\n\r\nFor e.g. compressing a value of the order $1,000,000,000,000 (or 1T or 10<sup>12</sup>) to `cint64`, the maximum error turns out to be 10<sup>12+1-17</sup> = $10<sup>-4</sup> = $0.0001. This means the precision after 4 decimal places is lost, or we can say that the uncompressed value is at maximum $0.0001 smaller. Similarly, if someone is storing $1,000,000 into `cint64`, the uncompressed value would be at maximum $0.0000000001 smaller. In comparision, the storage costs are almost $0.8 to initialize and $0.2 to update (20 gwei, 2000 ETHUSD).\r\n\r\n#### Handling the error\r\n\r\nNote that compression makes the value slightly smaller (underflow). But we also have another operation that also does that. In integer math, the division is a lossy operation (causing underflow). For instance,\r\n\r\n```solidity\r\n10000001 / 2 == 5000000 // true\r\n```\r\n\r\nThe result of the division operation is not always exact, but it's smaller than the actual value, in some cases as in the above example. Though, most engineers try to reduce this effect by doing all the divisions at the end.\r\n\r\n```\r\n1001 / 2 * 301 == 150500 // true\r\n1001 * 301 / 2 == 150650 // true\r\n```\r\n\r\nThe division operation has been in use in the wild, and plenty of lossy integer divisions have taken place, causing DeFi users to get very very slightly less withdrawal amounts, which they don't even notice. If been careful, then the risk is very negligible. Compression is similar, in the sense that it is also a division by 2<sup>shift</sup>. If been careful with this too, the effects are minimized.\r\n\r\nIn general, one should follow the rule:\r\n1. When a smart contract has to transfer a compressed amount to a user, they should use a rounded down value (by using `amount.decompress()`).\r\n2. When a smart contract has to transferFrom a compressed amount from a user to itself, i.e charging for some bill, they should use a rounded up value (by using `amount.decompressUp()`).\r\n\r\nThe above ensures that smart contract does not loose money due to the compression, it is the user who receives less funds or pays more funds. The extent of rounding is something that is negligible enough for the user. Also just to mention, this rounding up and down pattern is observed in many projects including [UniswapV3](https://github.com/Uniswap/uniswap-v3-core/blob/f03155670ec1667406b83a539e23dcccf32a03bc/contracts/libraries/SqrtPriceMath.sol#L118).\r\n\r\n### 2. Losing precision due to incorrect use of `cintx`\r\n\r\nThis is an example where dev errors while using compression can be a problem.\r\n\r\nUsual user amounts mostly have an max entropy of 50, i.e. 10<sup>15</sup> (or 2<sup>50</sup>) values in use, that is the reason why we find uint56 enough for storing significant bits. However, let's see an example:\r\n\r\n```solidity\r\nuint64 sharesC = // reading compressed value from storage;\r\nuint64 price = // CALL;\r\nuint64 amountC = sharesC.cmuldiv(price, PRICE_UNIT);\r\nuser.transfer(amountC.uncompress());\r\n```\r\n\r\nThe above code results in a serious precision loss. `sharesC` has an entropy of 50, as well as `priceC` also has an entropy of 50. When we multiply them, we get a value that contains entropies of both, and hence, an entropy of 100. After multiplication is done, `cmul` compresses the value, which drops the entropy of `amountC` to 56 (as we have uint56 there to store significant bits).\r\n\r\nTo prevent entropy/precision from dropping, we get out from compression.\r\n\r\n```solidity\r\nuint64 sharesC = shares.compress();\r\nuint64 priceC = price.compress();\r\nuint256 amount = sharesC.uncompress() * price / PRICE_UNIT;\r\nuser.transfer(amount);\r\n```\r\n\r\nCompression is only useful when writing to storage while doing arithmetic with them should be done very carefully.\r\n\r\n### 3. Compressing something other than money `uint256`s.\r\n\r\nCompressed Integers is intended to only compress money amount. Technically there are about 10<sup>77</sup> values that a `uint256` can store but most of those values have a flat distribution i.e. the probability is 0 or extremely negligible. (What is a probability that a user would be depositing 1000T DAI or 1T ETH to a contract? In normal circumstances it doesn't happen, unless someone has full access to the mint function). Only the amounts that people work with have a non-zero distribution ($0.001 DAI to $1T or 10<sup>15</sup> to 10<sup>30</sup> in uint256). 50 bits are enough to represent this information, just to round it we use 56 bits for precision.\r\n\r\nUsing the same method for compressing something else which have a completely different probability distribution will likely result in a problem. It's best to just not compress if you're not sure about the distribution of values your `uint256` is going to take. And also, for things you think you are sure about using compression for, it's better to give more thought if compression can result in edge cases (e.g. in previous multiplication example).\r\n\r\n### 4. Compressing Stable vs Volatile money amounts\r\n\r\nSince we have a dynamic `uint8 shift` value that can move around. So even if you wanted to represent 1 Million [SHIBA INU](https://etherscan.io/token/0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce) tokens or 0.0002 WBTC (both $10 as of this writing), cint64 will pick its top 56 significant bits which will take care of the value representation.\r\n\r\nIt can be a problem for volatile tokens if the coin is extremely volatile wrt user's native currency. Imagine a very unlikely case where a coin goes 2<sup>56</sup>x up (price went up by 10<sup>16</sup> lol). In such cases `uint56` might not be enough as even its least significant bit is very valuable. If such insanely volatile tokens are to be stored, you should store more significant bits, i.e. using `cint96` or `cint128`.\r\n\r\n`cint64` has 56 bits for storing significant, when only 50 were required. Hence there are 6 extra bits, which means that it is fine if the $ value of the cryptocurrency stored in cint64 increases by 2<sup>6</sup> or 64x. If the value goes down it's not a problem.",
  "closed_by": {
    "login": "Pandapip1",
    "id": 45835846,
    "node_id": "MDQ6VXNlcjQ1ODM1ODQ2",
    "avatar_url": "https://avatars.githubusercontent.com/u/45835846?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Pandapip1",
    "html_url": "https://github.com/Pandapip1",
    "followers_url": "https://api.github.com/users/Pandapip1/followers",
    "following_url": "https://api.github.com/users/Pandapip1/following{/other_user}",
    "gists_url": "https://api.github.com/users/Pandapip1/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Pandapip1/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Pandapip1/subscriptions",
    "organizations_url": "https://api.github.com/users/Pandapip1/orgs",
    "repos_url": "https://api.github.com/users/Pandapip1/repos",
    "events_url": "https://api.github.com/users/Pandapip1/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Pandapip1/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3772/reactions",
    "total_count": 5,
    "+1": 5,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/907608017",
    "html_url": "https://github.com/ethereum/EIPs/issues/3772#issuecomment-907608017",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
    "id": 907608017,
    "node_id": "IC_kwDOAq426M42GP_R",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-28T10:41:21Z",
    "updated_at": "2021-08-28T10:41:21Z",
    "author_association": "MEMBER",
    "body": "Why not just use floating point numbers?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/907608017/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/907702864",
    "html_url": "https://github.com/ethereum/EIPs/issues/3772#issuecomment-907702864",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
    "id": 907702864,
    "node_id": "IC_kwDOAq426M42GnJQ",
    "user": {
      "login": "zemse",
      "id": 22412996,
      "node_id": "MDQ6VXNlcjIyNDEyOTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22412996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zemse",
      "html_url": "https://github.com/zemse",
      "followers_url": "https://api.github.com/users/zemse/followers",
      "following_url": "https://api.github.com/users/zemse/following{/other_user}",
      "gists_url": "https://api.github.com/users/zemse/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zemse/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zemse/subscriptions",
      "organizations_url": "https://api.github.com/users/zemse/orgs",
      "repos_url": "https://api.github.com/users/zemse/repos",
      "events_url": "https://api.github.com/users/zemse/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zemse/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-28T23:34:29Z",
    "updated_at": "2021-08-29T11:44:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Why not just use floating point numbers?\r\n\r\n- The idea is using a floating point form / compressed form only for storage purposes internally (and then converting it to uint256 with `roundUp` or `roundDown` based on the use, which is a very security-critical requirement and something that is not much of a common practice in usual floating-point numbers) and it does not suggest replacing uint256 entirely.\r\n- The primary goal of “floating point” numbers is to be able to represent a wider range in an available number of bits. While primary goal of “compression” is just to keep as much precision as possible. The shift value in the ERC is the exponent in the floating point and one could use more exponent/shift bits but when 8 exponent/shift bits are just enough for compressing ERC20 balances of varying decimals, why use more? \r\n- Using floating points that could represent a wider range is not in the scope of this ERC. Instead this ERC attempts to standardize a niche case, e.g. when an engineer is writing a solidity struct and they are left with 96 bits or 72 bits or 128 bits of free space in a slot and they also have a uint256 next to it and wish to optimize it somehow. Currently, we can see the use of [SafeCast](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol): (`amount.toUint128()`) in live projects. But since SafeCast would revert for overflowing cases, it might not be very allowing to use on 96 or 72 or 64. As in this ERC, one could allow underflow, by getting rid of some least significant bits which are negligible enough that it saves a magnitude more in fees. There are plenty of ways one can implement that, which could result in friction while auditing code as well as security risks. If there could exist a community-reviewed standard, it may add some value.\r\n\r\nDoes this make sense?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/907702864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/947184662",
    "html_url": "https://github.com/ethereum/EIPs/issues/3772#issuecomment-947184662",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
    "id": 947184662,
    "node_id": "IC_kwDOAq426M44dOQW",
    "user": {
      "login": "outdoteth",
      "id": 37438950,
      "node_id": "MDQ6VXNlcjM3NDM4OTUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/37438950?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/outdoteth",
      "html_url": "https://github.com/outdoteth",
      "followers_url": "https://api.github.com/users/outdoteth/followers",
      "following_url": "https://api.github.com/users/outdoteth/following{/other_user}",
      "gists_url": "https://api.github.com/users/outdoteth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/outdoteth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/outdoteth/subscriptions",
      "organizations_url": "https://api.github.com/users/outdoteth/orgs",
      "repos_url": "https://api.github.com/users/outdoteth/repos",
      "events_url": "https://api.github.com/users/outdoteth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/outdoteth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-19T23:34:36Z",
    "updated_at": "2021-10-19T23:35:52Z",
    "author_association": "NONE",
    "body": "This is a very exciting avenue to go down. ERC20 transfers account for a significant amount of eth usage.\r\n\r\nanother point; a lot of addresses hold the exact same token balance. E.g most addresses hold 1 token, 5 tokens, 10 tokens, 100 tokens etc. It’s pointless storing these same amounts thousands of times. There is probably some kind of uint8 reference that can be used which points an address to a common token amount if it holds it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/947184662/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1026939310",
    "html_url": "https://github.com/ethereum/EIPs/issues/3772#issuecomment-1026939310",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
    "id": 1026939310,
    "node_id": "IC_kwDOAq426M49Ndmu",
    "user": {
      "login": "greenlucid",
      "id": 40367733,
      "node_id": "MDQ6VXNlcjQwMzY3NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/40367733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/greenlucid",
      "html_url": "https://github.com/greenlucid",
      "followers_url": "https://api.github.com/users/greenlucid/followers",
      "following_url": "https://api.github.com/users/greenlucid/following{/other_user}",
      "gists_url": "https://api.github.com/users/greenlucid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/greenlucid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/greenlucid/subscriptions",
      "organizations_url": "https://api.github.com/users/greenlucid/orgs",
      "repos_url": "https://api.github.com/users/greenlucid/repos",
      "events_url": "https://api.github.com/users/greenlucid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/greenlucid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-01T15:03:53Z",
    "updated_at": "2022-02-01T15:10:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "I thought about something very close to this. Myself, I was way more ruthless and thought that compressing values in 16 bits instead (1 byte for shift, 1 byte for the amount) was acceptable in many circumstances. That means you have \"256 levels of precision\", which isn't great but means you can get up to 99.6% accuracy to your intended value (if you have to floor or ceil) or 99.8% accuracy (if you can choose floor or ceil to get to the closest value).\r\nAlso, a dapp designed around this is just going to orbit around those values anyway so the frontend can make sure to not waste fractions.\r\nFor things like a regular market, that precision should be enough. But, for things like an AMM it'd be way too drastic.\r\nFor the dapp I'm developing, I got bits to spare, so for now so I'll just use 32 bits instead.\r\n\r\nOh, if you want example projects that compress amounts, you can check out [Slot Curate](https://github.com/kleros/slot-curate/blob/master/contracts/SlotCurate.sol#L64),  which never launched but uses `uint80` everywhere that are shifted and unshifted as needed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1026939310/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1200540767",
    "html_url": "https://github.com/ethereum/EIPs/issues/3772#issuecomment-1200540767",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3772",
    "id": 1200540767,
    "node_id": "IC_kwDOAq426M5Hjsxf",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-08-01T00:22:00Z",
    "updated_at": "2022-08-01T00:22:00Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for six months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1200540767/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
