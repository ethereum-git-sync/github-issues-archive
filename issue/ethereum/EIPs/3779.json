{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3779",
  "id": 982403695,
  "node_id": "MDU6SXNzdWU5ODI0MDM2OTU=",
  "number": 3779,
  "title": "Safer Control Flow for the EVM",
  "user": {
    "login": "gcolvin",
    "id": 16827129,
    "node_id": "MDQ6VXNlcjE2ODI3MTI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gcolvin",
    "html_url": "https://github.com/gcolvin",
    "followers_url": "https://api.github.com/users/gcolvin/followers",
    "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
    "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
    "organizations_url": "https://api.github.com/users/gcolvin/orgs",
    "repos_url": "https://api.github.com/users/gcolvin/repos",
    "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gcolvin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2021-08-30T05:24:11Z",
  "updated_at": "2021-12-16T22:47:23Z",
  "closed_at": "2021-09-09T22:27:41Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 3779\r\ntitle: Safer Control Flow for the EVM\r\ndescription: Ensure an essential level of safety for EVM code.\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: Core\r\nauthor: Greg Colvin (@gcolvin), Greg Colvin <greg@colvin.org>, Brooklyn Zelenka (@expede)\r\ndiscussions-to: https://ethereum-magicians.org/t/eip-3779-safe-control-flow-for-the-evm/6975\r\ncreated: 2021-08-30\r\nrequires: 2315, 3540, 3670, 4200\r\n---\r\n\r\n## Abstract\r\n\r\nWe define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.\r\n\r\nThis EIP specifies validity rules that ensure that:\r\n> Valid contracts will not halt with an exception unless they either\r\n> * throw `out of gas` or\r\n> * recursively overflow stack.\r\n\r\nThis EIP does not introduce any new opcodes.  Rather, it restricts the use of existing and proposed control-flow instructions.  The restrictions must be validated at contract initialization time – not at runtime – by the provided algorithm or its equivalent. This algorithm must take time and space linear in the size of the contract, so as not to be a denial of service vulnerability.\r\n\r\nThis specification is entirely semantic.  It imposes no further syntax on bytecode, as none is required to ensure the specified level of safety.  Ethereum Virtual Machine bytecode is just that -- a sequence of bytes that when executed causes a sequence of changes to the machine state.  The safety we seek here is simply to not, as it were, jam up the gears.\r\n\r\n## Motivation\r\n\r\n### Safety\r\n\r\nFor our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state.  From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain.  Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.\r\n\r\nUnsafe contracts are exploits waiting to happen.\r\n\r\nValidating contract safety requires traversing the contract code.  So in order to prevent denial of service attacks all jumps, including the existing `JUMP`, `JUMPI` and the other proposed jumps -- `RJUMP`, `RJUMPI`, `RJUMPV`, `RJUMPSUB` and `RETURNSUB` -- must be validated at initialization time, and in time and space linear in the size of the code  \r\n\r\nDynamic jumps, where the destination of a `JUMP` or `JUMPI` is not known until runtime, are an obstacle to proving validity in linear time -- any jump can be to any destination in the code, potentially requiring time quadratic in the size of code. We use a linear-time, linear-space symbolic execution of the _code_ to treat some of them as static, and treat the rest as invalid.\r\n\r\n#### Dynamic Jumps, Static Jumps, and Subroutines\r\n\r\nDynamic jumps need not always impede control-flow analysis.  In the simplest and most common case\r\n```\r\nPUSH address\r\nJUMP\r\n```\r\nis effectively a static jump.\r\n\r\nAnother important use of `JUMP` is to implement the return jump from a subroutine. So consider this example of calling and returning from a minimal subroutine:\r\n```\r\nTEST_SQUARE:\r\n    jumpdest\r\n    push RTN_SQUARE \r\n    0x02\r\n    push SQUARE\r\n    jump\r\nRTN_SQUARE\r\n    jumpdest\r\n    swap1\r\n    jump\r\n\r\nSQUARE:\r\n    jumpdest\r\n    dup1\r\n    mul\r\n    swap1\r\n    jump\r\n```\r\nThe return address -`RTN_SQUARE` - and the destination address - `SQUARE` - are pushed on the stack as constants and remain unchanged as they move on the stack, such that only those constants are passed to each `JUMP`. They are effectively static. *We do not need unconstrained dynamic jumps to implement subroutines.*\r\n\r\nEven where jumps are dynamic it is possible to statically constrain their range by enumerating valid destinations in advance, as per the proposed `RJUMPV` instruction.\r\n\r\nFinally, the static relative jumps of [EIP-4200](./eip-4200) and the simple subroutines of [EIP-2315](./eip-2315) provide static jumps directly. \r\n\r\nSo we can validate the safety of contracts with a static analysis that takes time and space linear in the size of the *code*, as shown below.  And since we can, we should.\r\n\r\n### Performance\r\n\r\nValidating safe control flow at initialization time has  potential performance advantages.\r\n* Static jumps do not need to be checked at runtime.\r\n* Stack underflow does not need to be checked for at runtime.\r\n\r\n## Specification\r\n\r\n### Validity\r\n\r\nWe validate _safety_ at instialisazion time.  We define a _safe_ EVM contract as one that cannot encounter an exceptional halting state.\r\n\r\n#### Exceptional Halting States\r\n\r\nThe *execution* of each instruction is defined in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) as a change to the EVM state that preserves the invariants of EVM state.  At runtime, if the execution of an instruction would violate an invariant the EVM is in an exceptional halting state.  The Yellow Paper defines five such states.\r\n1. Insufficient gas\r\n2. More than 1024 stack items\r\n3. Insufficient stack items\r\n4. Invalid jump destination\r\n5. Invalid instruction\r\n\r\nWe would like to consider EVM programs valid iff no execution of the *code* can lead to an exceptional halting state.\r\n\r\nHowever, we must be able to validate *code* in linear time to avoid denial of service attacks. And we must support dynamically-priced instructions, loops, and recursion.  \r\n\r\nThus our validation cannot consider concrete computations -- it only performs a limited symbolic execution of the _code_.  This means we will reject programs if we detect any invalid execution paths, even if those paths are not reachable at runtime.  And we will count as valid programs that do not in fact produce correct results.  So in theory, theory and practice are the same. But in practice, they're not.\r\n\r\nWe can detect only _non-recursive_ stack overflows at *validation time*, so at _runtime_ we must check for the first two states:\r\n* `out of gas` and\r\n* stack overflow.\r\n\r\nAt *validation time* we can detect the remaining three states:\r\n* stack underflow,\r\n* invalid jump, and\r\n* invalid instruction.\r\n\r\nThat is to say (again):\r\n> *Valid code cannot halt with an exception unless it either*\r\n>* *throws `out of gas` or*\r\n>* *recursively overflows stack*.\r\n\r\n#### Constraints on Valid Code\r\n\r\n* Every instruction is valid.\r\n* Every jump is valid:\r\n   * Every`JUMP` and `JUMPI` is `static`.\r\n   * No `JUMP`, `JUMPI`, `RJUMP`, `RJUMPI`, `RJUMPV`, or `RJUMPSUB` addresses immediate data.\r\n* The stacks are always valid:\r\n   * The _number_ of items on the `data stack` is always positive, and at most 1024.\r\n   * The _number_ of items on the `return stack` is always positive, and at most 1024.\r\n* The data stack is consistently available:\r\n   * The `available items` on the `data stack` are always positive, and the same for every _execution_ of an _instruction_.\r\n\r\nWe define a `JUMP` or `JUMPI` instruction to be `static` if its `jumpsrc` argument was first placed on the stack via a `PUSH…` and that value has not changed since, though it may have been copied via a `DUP…` or `SWAP…`.\r\n\r\nThe `RJUMP`, `RJUMPI` and `RJUMPSUB`instructions take a _jumpdst_ as an immediate agument, so they are `static`. The `RJUMPV` instructions take an index on the stack at runtime, and proceeds via the `jumpdest` indexed in the jump vector, or else via its first, default `jumpdest`. In this way `RJUMPV` is constrained to be _static_, as the programmer must provide a default case, and all cases are validated.\r\n\r\nThe Yellow Paper has the `stack pointer` (`SP`) pointing just past the top item on the `data stack`.   We define the `available items` as the number of stack items between the current `SP` and the `SP` on entry to the most recent basic block.\r\n\r\nTaken together, these rules allow for code to be validated by traversing the control-flow graph, in time and space linear in the size of the code, following each edge only once. \r\n\r\n## Rationale\r\n\r\nDemanding static destinations for all jumps means that all jump destinations can be validated at initialization time, not runtime.\r\n\r\nBounding the stack pointers catches all `data stack` and non-recursive`return stack` overflows.\r\n\r\nRequiring consistently available stack items prevents stack underflow. It can also catch such errors as misaligned stacks due to irreducible control flows, and calls to subroutines with the wrong number of arguments.\r\n\r\nAnd relative rather than absolute jump destinations are consistent with the other `RJUMP` instructions, so that code remains position-independent.\r\n\r\n_Note: The definition of `static` here is the bare minimum needed to implement subroutines.  Constants can be propagated to validate a larger and probably more useful set of jumps, at the cost of more expensive (but still linear) validation._\r\n\r\n_Note: Requiring the valid destinations of dynamic jumps to be enumerated at every jump instruction allows for tractable bytecode validation: a jump vector takes up space proportional to the number of destinations, so attempting to attack the validation algorithm with large numbers of jumps will also reduce the available space for jumps to be validated._\r\n\r\n## Reference Implementation \r\n\r\nThis section specifies an algorithm for validating EVM contracts. An equivalent algorithm must be run at initialization time.\r\n\r\nIt performs a symbolic execution of the program that recursively traverses the _code_, emulating its control flow and stack use and checking for violations of the rules above.\r\n\r\nThis algorithm runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_ -- thus the algorithm takes time proportional to the size of the _code_.\r\n\r\n_Note: Because valid code has a control-flow graph that can be traversed in linear time there are other programs that might otherwise require quadratic time that can also be written to run in linear time, including compilers._  \r\n\r\n### Validation Algorithm \r\n\r\nThe following is a pseudo-Go implementation of an algorithm for predicating code validity.  It uses an auxiliary stacks to track constant stack slots, and from which to pop the `JUMP` and `JUMPI` destinations to validate during analysis.\r\n\r\nFor simplicity's sake we assume that _jumpdest analysis_ has been done and that we have a few helper functions.\r\n* `is_valid_instruction(pc)` returns true if `pc` points at valid instruction\r\n* `is_immediate_data(pc)` returns true if `pc` points at immediate data\r\n* `immediate_data(pc)` returns the immediate data for an instruction.\r\n* `advance_pc()` advances the pc,  skipping any immediate data.\r\n* `removed_items(pc)`returns the number of items removed from the `data_stack` by an instruction.\r\n* `added_items(pc)` returns the number of items added to the `data_stack` by an instruction.\r\n```\r\nvar code        [code_len]byte\r\nvar avail_items [code_len]int\r\nvar return_stack[1024]int = { -1 }\r\nvar data_stack  [1024]uint256 = { INVALID }\r\n\r\n// return the maximum stack used or else the PC and an error\r\nfunc validate(pc := 0, sp := 0, bp := 0, rp := 0) int, error {\r\n   used_items := 0 \r\n   for pc < code_len {\r\n      if !is_valid_instruction(pc) {\r\n         return pc, invalid_instruction\r\n      }\r\n      \r\n      // if available items on stack for `pc` are non-zero\r\n      //    we have been here before\r\n      //    so return to break cycle\r\n      if avail_items[pc] != 0 {\r\n\r\n          // invalid if available items not the same\r\n          if avail_items[pc] != sp - bp {\r\n            return pc, invalid_stack\r\n          }\r\n          return used_items, nil\r\n\r\n      }\r\n      avail_items[pc] = sp - bp\r\n      if avail_items[pc] < 0 {\r\n         return pc, stack_underflow\r\n      }\r\n      \r\n      switch code[pc] {\r\n\r\n      // successful termination\r\n      case STOP:\r\n         return true\r\n      case RETURN:\r\n         return true\r\n      case SUICIDE:\r\n         return true\r\n\r\n      // track constants on stack\r\n      case PUSH1 <= code[pc] && code[pc] <= PUSH32 {\r\n         sp++\r\n         if (sp > 1023) {\r\n            return pc, stack_overflow\r\n         }\r\n         data_stack[sp] = immediate_data(pc)\r\n         advance_pc()\r\n         continue\r\n      \r\n      case JUMP:\r\n\r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // pop jump destination\r\n         jumpdest = data_stack[--sp]\r\n         if !valid_jumpdest(jumpdest) {\r\n            return false\r\n         }\r\n         continue;\r\n         \r\n      case JUMPI:\r\n\r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // pop jump destination and conditional\r\n         jumpdest = data_stack[--sp]\r\n         jumpif = data_stack[--sp]\r\n         if sp < 0 {}\r\n            return pc, stack_underflow\r\n         }\r\n         if !valid_jumpdest(jumpdest) {\r\n            return pc, invalid_destination\r\n         }\r\n\r\n         // recurse to validate true side of conditional\r\n         if is_immediate_data(jumpdest) {\r\n            return pc, invalid_destination\r\n         }\r\n         left_used, err = validate(jumpdest, sp, bp, rp)\r\n         if err {\r\n            return pc, err\r\n         }\r\n         \r\n         // recurse to validate false side of conditional\r\n         pc = advance_pc(pc)\r\n         right_used, err = validate(pc, sp, bp, rp)\r\n         if err {\r\n            return pc, err\r\n         }\r\n         \r\n         // both sides valid, check stack and return used_items\r\n         used_items += max(left_used, right_used)\r\n         sp += used_items\r\n         if (sp > 1023) {\r\n            return pc, stack_overflow\r\n         }\r\n         return used_items, nil\r\n    \r\n      case RJUMP:\r\n      \r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // check for valid jump destination\r\n         if is_immediate_data(jumpdest) {\r\n            return pc, invalid_destination\r\n         }\r\n         \r\n         // reset pc to destination of jump\r\n         pc += immediate_data(pc)\r\n\r\n      case RJUMPI:\r\n      \r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // recurse to validate true side of conditional\r\n         jumpdest := pc + immediate_data(pc)\r\n         if is_immediate_data(jumpdest) {\r\n            return pc, invalid_destination\r\n         }\r\n         left_used, err = validate(jumpdest, sp, bp, rp)\r\n         if err {\r\n            return pc, err\r\n         }\r\n         \r\n         // recurse to validate false side of conditional\r\n         pc = advance_pc(pc)\r\n         right_used, err = validate(pc, sp, bp, rp)\r\n         if err {\r\n            return pc, err\r\n         }\r\n         \r\n         // both sides valid, check stack and return used_items\r\n         used_items += max(left_used, right_used)\r\n         if (sp += used_items > 1023) {\r\n            return pc, stack_overflow\r\n         }\r\n         return used_items, nil\r\n\r\n      case RJUMPSUB:\r\n\r\n         // check for valid jump destination\r\n         jumpdest = imm_data(pc)\r\n         if is_immediate_data(pc + jumpdest) {\r\n            return pc, invalid_destination\r\n         }\r\n\r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // push return address and reset pc to destination\r\n         return_stack[rp++] = pc + 1\r\n         pc += jumpdest\r\n\r\n      case RETURNSUB:\r\n      \r\n         // will enter basic block at destination\r\n         bp = sp\r\n\r\n         // check for valid return destination\r\n         pc = return_stack[--rp]\r\n         if !code[pc - 1] == JUMPSUB {\r\n            return pc, invalid_destination\r\n\r\n          sp++\r\n          data_stack[sp++] = immediate_data(pc)\r\n          pc = advance_pc(pc)\r\n\r\n      default:\r\n         pc = advance_pc(pc)\r\n\r\n         // apply other instructions to stack pointer\r\n         // removed and added items are filled with INVALID\r\n         used_items -= removed_items(pc)\r\n         used_items += added_items(pc)\r\n         sp += used_items\r\n         if (sp > 1023) {\r\n            return pc, stack_overflow\r\n         }\r\n      }\r\n   }\r\n\r\n   // successful termination\r\n   return used_items, nil\r\n}\r\n```\r\n\r\n## Backwards Compatibility\r\n\r\nThese changes affect the semantics of EVM code – the use of `JUMP`, `JUMPI`, and the stack are restricted, such that some *code* that would otherwise run correctly will nonetheless be invalid EVM *code*. \r\n\r\n## Security Considerations\r\n\r\nThis EIP is intended to ensure an essential level of safety for EVM code deployed on the blockchain.\r\n\r\n## References\r\n\r\nGreg Colvin, Martin Holst Swende, Brooklyn Zelenka, \"EIP-2315: Simple Subroutines for the EVM [DRAFT],\" Ethereum Improvement Proposals, no. 2315, October 2019. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-2315.\r\n\r\nAlex Beregszaszi, Paweł Bylica, Andrei Maiboroda, \"EIP-3540: EVM Object Format (EOF) v1,\" Ethereum Improvement Proposals, no. 3540, March 2021. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3540..\r\n\r\nAlex Beregszaszi, Andrei Maiboroda, Paweł Bylica, \"EIP-3670: EOF - Code Validation,\" Ethereum Improvement Proposals, no. 3670, June 2021. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3670.\r\n\r\nAlex Beregszaszi, Andrei Maiboroda, Paweł Bylica, \"EIP-4200: Static relative jumps [DRAFT],\" Ethereum Improvement Proposals, no. 4200, July 2021. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-4200.\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "gcolvin",
    "id": 16827129,
    "node_id": "MDQ6VXNlcjE2ODI3MTI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gcolvin",
    "html_url": "https://github.com/gcolvin",
    "followers_url": "https://api.github.com/users/gcolvin/followers",
    "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
    "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
    "organizations_url": "https://api.github.com/users/gcolvin/orgs",
    "repos_url": "https://api.github.com/users/gcolvin/repos",
    "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gcolvin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3779/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/908039788",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-908039788",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 908039788,
    "node_id": "IC_kwDOAq426M42H5Zs",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-08-30T05:24:48Z",
    "updated_at": "2021-08-30T05:24:48Z",
    "author_association": "NONE",
    "body": "Since this is your first issue, we kindly remind you to check out [EIP-1](https://eips.ethereum.org/EIPS/eip-1) for guidance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/908039788/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909109601",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-909109601",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 909109601,
    "node_id": "IC_kwDOAq426M42L-lh",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-31T10:30:06Z",
    "updated_at": "2021-08-31T10:30:06Z",
    "author_association": "MEMBER",
    "body": "@alita-moore Any idea why the bot notified here?  This is definitely not Greg's first issue.  😁 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909109601/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909318323",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-909318323",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 909318323,
    "node_id": "IC_kwDOAq426M42Mxiz",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-31T14:59:42Z",
    "updated_at": "2021-08-31T14:59:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've been having issues my whole life @MicahZoltu ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909318323/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 2,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909435636",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-909435636",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 909435636,
    "node_id": "IC_kwDOAq426M42NOL0",
    "user": {
      "login": "alita-moore",
      "id": 26529820,
      "node_id": "MDQ6VXNlcjI2NTI5ODIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/26529820?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alita-moore",
      "html_url": "https://github.com/alita-moore",
      "followers_url": "https://api.github.com/users/alita-moore/followers",
      "following_url": "https://api.github.com/users/alita-moore/following{/other_user}",
      "gists_url": "https://api.github.com/users/alita-moore/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alita-moore/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alita-moore/subscriptions",
      "organizations_url": "https://api.github.com/users/alita-moore/orgs",
      "repos_url": "https://api.github.com/users/alita-moore/repos",
      "events_url": "https://api.github.com/users/alita-moore/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alita-moore/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-31T17:23:28Z",
    "updated_at": "2021-08-31T17:23:28Z",
    "author_association": "MEMBER",
    "body": "ha! I'll investigate!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909435636/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909570867",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-909570867",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 909570867,
    "node_id": "IC_kwDOAq426M42NvMz",
    "user": {
      "login": "poojaranjan",
      "id": 29681685,
      "node_id": "MDQ6VXNlcjI5NjgxNjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/29681685?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/poojaranjan",
      "html_url": "https://github.com/poojaranjan",
      "followers_url": "https://api.github.com/users/poojaranjan/followers",
      "following_url": "https://api.github.com/users/poojaranjan/following{/other_user}",
      "gists_url": "https://api.github.com/users/poojaranjan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/poojaranjan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/poojaranjan/subscriptions",
      "organizations_url": "https://api.github.com/users/poojaranjan/orgs",
      "repos_url": "https://api.github.com/users/poojaranjan/repos",
      "events_url": "https://api.github.com/users/poojaranjan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/poojaranjan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-31T19:56:40Z",
    "updated_at": "2021-08-31T19:59:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @gcolvin,  \r\n\r\nIf this \"Issue#3779\" is intended to be a \"discussion-to\" place for a future EIP-3779, may I request to create a discussion thread at the Fellowship of Ethereum Magicians and close this issue?\r\n\r\nI know historically, this section of the EIPs GitHub has been used as a place for discussing ideas. It's been observed that the issue is left open forever. This has increased the number of open issues significantly and it is difficult to find any actual issue that people might have created in hope of getting help. \r\n\r\nWe discussed this in the last EIPIP meeting, and trying to bring some change to the process making this a place to report \"real issues\".\r\n\r\nWe're hoping \r\n- to make FEM the central place for all EIPs discussion \r\n- EIP numbers assigned based on the Pull Request, \r\n- use EIPs/Issue for general issues/questions/concerns related to EIPs. \r\n\r\nIf that's okay with you, the discussion can be moved to the FEM because the pull request has been recently submitted. \r\nThanks!\r\n\r\n**Edits**: I see that there is already a FEM link and a separate PR for the proposal. I wonder what is the purpose of this issue?\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909570867/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909730754",
    "html_url": "https://github.com/ethereum/EIPs/issues/3779#issuecomment-909730754",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3779",
    "id": 909730754,
    "node_id": "IC_kwDOAq426M42OWPC",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-31T23:36:43Z",
    "updated_at": "2021-09-09T22:27:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "The discussions-to thread already exists on Magicians, appears in the header, and points here for EIP text to discuss.  I'll close this Issue and point the discussion at the EIP repository once the EIP is there.\r\n\r\n>EIP numbers assigned based on the Pull Request\r\n\r\nIt's long been a useful fact that Issue and PR numbers come from the same sequence, so that EIPs that start as issues can have a number assigned right away, and discussion can begin under that number before the EIP editors get it merged.  If ever I write another EIP I'll reconsider.\r\n\r\nEdit: FEM thread now points at EIP repository.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/909730754/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
