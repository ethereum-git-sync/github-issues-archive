{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/26/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/26/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/26/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/26",
  "id": 118115933,
  "node_id": "MDU6SXNzdWUxMTgxMTU5MzM=",
  "number": 26,
  "title": "ERC: Default Ethereum Name Registrar",
  "user": {
    "login": "alexvandesande",
    "id": 112898,
    "node_id": "MDQ6VXNlcjExMjg5OA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alexvandesande",
    "html_url": "https://github.com/alexvandesande",
    "followers_url": "https://api.github.com/users/alexvandesande/followers",
    "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
    "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
    "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
    "repos_url": "https://api.github.com/users/alexvandesande/repos",
    "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 86,
  "created_at": "2015-11-20T20:02:58Z",
  "updated_at": "2023-10-26T00:03:59Z",
  "closed_at": "2017-07-03T14:23:32Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "<pre>\n  ERC: 26 (based on issue number) or 3 (based on ERC)\n  Title: Default Mist Name Registrar\n  Author: Alex Van de Sande (avsa@ethdev.com)\n  Status: Draft\n  Type: Informational\n  Created: 20-11.2015\n</pre>\n\n## Abstract\n\nAn important aspect of making ethereum √êapps easily accessible is a name registry that will connect a human readable name to a hash for usage in IPFS/SWARM or any DHT system. \n\nThe name registrar is not meant to be the one and only name registrar on ethereum but rather a default registrar to be used by Mist to resolve names. It will be an user configurable setting.\n## Motivation\n\nThe goal of this contract is:\n- To find the optimal price for names: create a strategy where the nash equilibrium for each player is to simply put down the maximum amount they are willing to pay for a name, and not create incentives for names to be overpaid\n- To allow optimal usage of names: allow good names to circulate among those who want have better usages for it, while keeping smaller brands reasonably protected\n- To make name markets as transparent as possible. Currently domain squatting is a very sneaky business that utilizes information asymmetry to sell names. This proposal, while still allows names to be sold or transferred outside this market, will create a last resort market where name prices are transparent and optimal\n- Registering names should have an optimal cost, cheap enough to be inclusive, but not too much to allow excessive name squatting. This intends to describe the design and parts of the proposed system.\n- Privacy by obscurity: give unpopular and niche domain holders a reasonable privacy expectation while making the most popular names evaluations transparent. Creating a spider that crawls all name markets is exponentially expensive.\n## Specification\n\nThe system will consist of 4 main parts:\n### Hash Registrar\n\nThe registrar itself is the contract that stores the basic data. If more data is needed it can be stored in other contracts, using this one as the reference. It doesn't use the name directly to reference the registry but its data. Keeping the names as hashes instead of plaintext has two advantages: first it allows _privacy by obscurity_, meaning that if the name isn't known enough to be in a rainbow table then you can't really know who the information is about. Second, it allows a more general purpose and future proofing use of the contract, as it can be used to claim ownership on anything that can be translated into hash, like devices, files, texts and other uses we haven't thought about now. \n\n``` js\nfunction getAuction() constant returns (address auction)\nfunction getElection() constant returns (address election)\nfunction getCollector() constant returns (address collector)\nfunction setCollector(address _newCollector) returns (bool success)\n```\n\nThe registry is set at startup with the address of three other contracts, the **Collector contract**, **Election Contract** and **Auction contract**, that have special rights. Only the **Election contract** can change the collector. The others are unchangeable.\n\n``` js\nfunction getRegistry(bytes32 _hash) constant returns (address _owner, uint _renewalDate,  uint feesPaid, string _redirectAddress)\n```\n\nIt uses a hash as an index and attributes these informations to it: an address that owns it; the expiration date of the registration; the amount of ether that the owner effectively paid to the registrar address as the process of renewal; a string which is the http, buzz or ipfs address of the app.\n\nOther contracts might extend this functionality by simply creating a registry of extra information about a hash and then only allowing edits to it by checking this master contract for the owner address. For example, the wallet app might want to make a registry where a name is associated to an address (different from the owner), or if you want to have a secondary content hash for http links then a secondary contract could be deployed, only allowing edit access to the addresses on marked as `owner` on this contract.\n\n``` js\nfunction editRegistry(bytes32 _hash)\n```\n\nAll the information on that hash can be edited by the owner of the address up to 48h before the renewal Date, and at that time the information is locked. After the expiration date, only the **Auction Contract** can change the owner of the hash. \n\n``` js\nfunction newRegistry(bytes32 _hash, string _redirectAddress, address _owner)\n```\n\nOnly the **Auction Contract** can add new registries.\n\n``` js\nfunction ()\n```\n\nAll funds given to the Registrar contract are redirected to the **Collector Contract**. These will not count towards the `feesPaid`.\n\n``` js\nfunction invalidateEntry(string _name)\n```\n\nThe disadvantage of hashes as identifiers is that it literally allows anything, therefore making it impossible to create restrictions such as **\"names shorter than 6 letters can only be registered after 2017\"**. This could be avoided by creating validity rules that need to be reported and if true will delete the entry, but this would require all those rules to be set at the first setup. Another way to do it is to grant the **Collector Contract** power to invalidate entries, but this would open the possibility of an evil collector contract censoring entries. Another solution is simply to allow any entries, but simply enforce those rules on the client: mist could be programmed to look at other contracts for special names\n\n I'm open to more elegant solutions.\n### Auction Contract\n\nThe auction contract is set at startup of the Hash registrar, but since they are separated it is possible to clone a copy of the registrar contract and just change these variables. \n\nThe purpose of the auction contract is to receive bids for hashes and select a winner. \n\n``` js\nfunction startBid(bytes32 _newHash)\n```\n\nIf  `_newHash` is not registered to anyone this will create a new register, owned by `0x000` with a renewal date exactly 7 days after this function was executed. This allows a short time in which a Vickrey Auction can decide who is the first owner of the name.\n\nThe cost of start a bid can be defined by the **collectorContract**, but otherwise is kept at free.\n\n``` js\nfunction putSealedBid(bytes32 _sealedBid)\n```\n\nA sealed bid is just a message with the hash of the bid and some ether. The amount of ether sent on this step is also recorded, as long as the time in which the bid was put. The amount of ether can and should be higher than the amount bid, to protect the privacy of the bid. For the same reason, the bidder doesn't need to be the future owner.\n\nThe **collectorContract**, might define a deposit value that needs to be added on top of the put, but if it doesn't implement it then it's free.\n\n``` js\nfunction revealBid(bytes32 _sealedBid, bytes32 _biddedHash, address _owner, uint _bidPrice, uint _duration, string _salt)\n```\n\n`_sealedBid` is the hash saved on _sealedBid\n`_biddedHash` is the hash that the bidder wants to own\n`_owner` is the future owner of the hash, if the bid is successful. The bidder and the owner need not to be the same person\n`_bidPrice` is the maximum price the bidder is willing to pay for it\n`_duration` is the length of time (in days) the owner wants to renew it for. Must be longer than 180 and smaller than 3660. If this is the first time this hash is being bidder on then the _duration cannot be longer than 366, if it has been registered before then the _duration cannot be longer than twice the length of time that has passed since it was first registered, as to avoid very long registrations during the first years.\n\n`_salt` is just a random string to prevent deanonimization of sealed bids by brute force\n\nThis action can be done by anyone. If the _sealedBid doesn't match the hash of all other parameters put together then the bid is not revealed, otherwise it's saved on the revealed bids. **Collection contract**.  \n\nOnce a bid is revealed, the proposed setup is a closed bid Vickrey auction, where the highest bidder becomes the owner but only pays the second highest bid:\n- If the new prospective owner is not the current owner then his `bidPrice` will be the parameter on `_bidPrice`. If the owner is bidding to renew the name then his bid will be calculated as `_bidPrice` \\* `K`/ `_duration`. In practice this means that the owner is appraising his own name at that price and is putting down a _Fee_ that is a percentage of the total appraised value of his name, proportional to the renewal period. That percentage is the same for all names and is decided by the _Collector Contract_\n- If the expiration date is on the past, then the bid is deleted and the funds sent to it are sent to the **Collector Contract**\n- Else if the duration is outside the bounds of minimum and maximum durations OR if the ether amount sent during the sealed bid isn't enough to cover his price and fees OR if the sealed bid has been sent less than 48h before the renewal period then the bid is considered **invalid**, it is deleted and the ether amount sent back to the bidder.\n- If the `bidPrice` it's the highest yet then it should be saved as such and the price to be paid should be set at the asking price of the previous highest bid (or 0 if there are none). The second highest bid should be deleted and its ether sent back to its bidder. If the bid new owner is not the current owner, K is 1, otherwise (if it's the owner renewing the ownership) then K is a factor set by the **Collector Contract**.\n- Else if the bid is lower than the highest bid but bigger than the price to be paid of the highest bid, then the price to be paid is set at the this bid asking price. This bid is deleted and its ether sent back to its bidder.\n\n_Should a bid be considered invalid if it's revealed earlier than 48h of the renewal date?_\n\nBids revealed too early might affect the game strategy and will influence the price to be paid. In the other hand a deleted bid might mean that someone will lose his property without the correct asking price. Since losing a domain name is harsher than someone overpaying for it, then I suggest that there should not be an obligatory reveal period, only a suggested 24h window.\n\nThe collector contract can set a function that will determine a fee to be paid by the bidders, but otherwise it will default to free.\n\n``` js\nfunction revealBid(bytes32 _sealedBid, bytes32 _biddedHash, address _owner, uint _bidPrice, uint _duration, string _salt)\n```\n\nA bid can only be removed by the original owner and only earlier than 48 hours before the renewal date.\n\n``` js\nfunction finalizeAuction(bytes32 _biddedHash)\n```\n\nThis action can be only executed after the renewalDate has passed. Anyone can call it, so it could be scheduled with the alarm clock. \n\nIf owner has not changed, then an amount of ether equivalent to `_bidPrice`/ `_duration` \\* `K` will be sent to the **Collectors Contract** and the remaining amount will be sent back to the original bidder. The amount paid will be registered at `feesPaid`. The renewal date will be set at the last renewal data + `_duration`.\n\nIf the owner has changed then amount of `priceToBePaid` will be sent to the previous owner, and a fee calculated by `priceToBePaid` \\* `K` / `_duration` will be sent to the collectors contract and registered as `feesPaid`. Otherwise a user could keep a name indefinitely by simply selling it to itself. The renewal date will be set at the last renewal data + `_duration`.\n\n``` js\nfunction cleanOldBids()\n```\n\nDeletes any unsealed bids that are older than the maximum duration time that any name can accept and forwards the ether to the Collector.\n### Collector contract\n\nThe Collector Address is an address that receives all the funds collected in auctions and has a special right to change the `K` factor. The purpose of the name registry auction is not to make a profit but to allow the optimal distribution of names, to prevent name squatting while still allowing cheap and easy access to registering a name. The cost of the renewal is given by the market price of the total price, divided by K. If K is too low it might allow name squatting, but if it's too high it can make keeping names too expensive. \n\nThe collector contract can also define fees related to bidding, in order to fight spam. The collector contract can determine which rules are broken in order to consider a registry invalid (short names could only be registered after a few years, etc)\n\nHow exactly the Collector contract changes the K factor or spends its funds is not defined here, as the contract itself is a changeable parameter elected by the **Election Contract**.\n\nMy proposal is that the first Collector contract be just a _\"Boomerang contract\"_, a contract that simply keeps all ether sent to it and then send them back after 1 year. This will allow the funds to be safely kept for a period while the community build tools and DAOs for the collector contract for the first election. Since they can always elect the 0x address, then if the community wants to do so they can still vote to burn all the ether collected during the first year.\n### Election Contract\n\nThe election contract has the special right to change the collector address. The exact workings of the election, as well as their frequency is not yet defined here and is open to discussions.\n\nOne important issue is that it's impossible to tell which are the entities behind each name, if they coordinate with each other or if they are owned by other entities, therefore the concept of anti-sybil (and to a point anti-coercion) mechanisms does not really apply here.  Also, the job of the Collector Contract is basically to define the use of it's own funds and how to raise or lower the \"tax rate\" on new names, therefore it's only natural that the weights of the votes should be based barely on the amount of funds each name has sent to the contract during their last renewing period. \n\nA user that bought four names four 1 ether each and a user that bought a single name for 4 ethers have contributed the same amount to the collector contract and therefore should have the same right to decide how the funds are spent. If the system favours the former (like quadratic voting does) will stimulate users to buy tons of small names they are not going to use, a system that favours the latter will stimulate users to double bid on their own names to pay higher taxes and therefore get more voting power. Both will would be contrary to the whole purpose of the name registrar.\n\nThe suggested voting mechanism is a mix of [approved voting](https://en.wikipedia.org/wiki/Approval_voting) with Liquid democracy, as follows:\n\n``` js\nfunction setDelegate(string32 _ownedHash, address _delegate)\n```\n\nInstead of voting directly, a voter instead can decide to appoint a delegate. The contract verifies that the `msg.sender` is the owner of the `_ownedHash` and then moves his voter weight ('feesPaid') to the new `_delegate`\n\n``` js\nfunction unsetDelegate(string32 _ownedHash)\n```\n\nThe voter removes his vote to his delegate and states that wants to vote himself.\n\n``` js\nfunction setVote(address[] approvedCandidates)\n```\n\nThe voter selects an array of contracts he approves for the job of **Collector Contract**. These remain static and can be changed anytime. If you\n\n``` js\nfunction tallyVotes()\n```\n\nInstead of a fixed election cycle, votes can be counted at anytime if someone feels voter's preference have changed enough. The cost of counting the votes is paid by the function caller. First the function will calculate the voter's weight by the sum of his 'feesPaid' and the weight of all voters that delegate their vote into him. Votes can be delegated forward a finite number of time (3, 5 or 7, depending on gas costs).\n\nThen all addresses the voter approved will be receive an equal number of votes as his weight. The Address with a higher number of approvals will be selected as the new **Collector Contract**, effectively immediately.\n#### Acknowledgements\n\nPeople who contributed to this proposal, in no particular order: @nagydani & @zelig (with their research for the swarm name registrar), @vbuterin (for insights in elections), @gavofyork (who designed the [first name registrar](https://github.com/alexvandesande/dapp-bin/tree/master/registrar) ), @yann300  and @arkpar (who implemented the current name registrar), @pipermerriam & @nmushegian (for their great insights at DevCon1) and  @ryepdx (that is implementing the maker registry) and @danielnovy  (auctions √êapp at consensys)\n",
  "closed_by": {
    "login": "alexvandesande",
    "id": 112898,
    "node_id": "MDQ6VXNlcjExMjg5OA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alexvandesande",
    "html_url": "https://github.com/alexvandesande",
    "followers_url": "https://api.github.com/users/alexvandesande/followers",
    "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
    "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
    "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
    "repos_url": "https://api.github.com/users/alexvandesande/repos",
    "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/26/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/26/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158521868",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158521868",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158521868,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODUyMTg2OA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-20T20:58:12Z",
    "updated_at": "2015-11-20T20:58:21Z",
    "author_association": "NONE",
    "body": "Question: How are the names bought in the first place in this system? It seems that if it's an auction with sealed bids it ends up first-come-first-serve.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158521868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158523870",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158523870",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158523870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODUyMzg3MA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-20T21:08:36Z",
    "updated_at": "2015-11-20T21:08:36Z",
    "author_association": "NONE",
    "body": "@Smithgift good point. One way to do it would simply be that if a bid was unsealed for a new name then a registry is created with no owner and with a renewal date set for 7 days after that. This would make all new names go to a normal vickrey auction.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158523870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158545894",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158545894",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158545894,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU0NTg5NA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-20T22:40:07Z",
    "updated_at": "2015-11-20T22:40:07Z",
    "author_association": "NONE",
    "body": "@alexvandesande That seems logical, yes. Perhaps there should be a simple function to just start a function for a new name, because you might as well bid just a tiny amount to start the auction and make the true bid later.\n\nMy concern with bidding on hashes as hashes is that the value of, say, 0xcfe33df56932be08b97194721e1d28638ed2f677728b2ffd617bd710fec0952d is not obvious to the average user. As it is, that's the sha3 hash of \"wedding-shoes.eth\", which I expect (should ethereum become popular and .eth become a TLD) to go for thousands of dollars. Being a Vickrey auction, this is a lesser issue, as you might as well bid the maximum amount you'd pay whether or not someone else will enter.\n\nMaking rainbow tables of potentially valuable hashes from dictionaries, web scraping, and Markov chains, then going after any auction with that hash is a potential strategy under this system.\n\nI'm more concerned that random troll-bidding on new auctions will lead to unpleasantness for the actual bidder. If I want some odd new domain name now, I can just buy it. But if I have to fight a troll who's just bidding for the sake of taking whatever it is from me, it certainly feels worse, even if I may effectively pay less. The obvious counter-strategy is to spam the auction contract with new hashes until the trolls are bankrupt.\n\nAlso, the fixed election schedule could be broken by the current beneficiaries of the collector voting to transfer the collector to... an identical collector. That would reset the election time.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158545894/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158551415",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158551415",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158551415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU1MTQxNQ==",
    "user": {
      "login": "pirapira",
      "id": 44281,
      "node_id": "MDQ6VXNlcjQ0Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/44281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pirapira",
      "html_url": "https://github.com/pirapira",
      "followers_url": "https://api.github.com/users/pirapira/followers",
      "following_url": "https://api.github.com/users/pirapira/following{/other_user}",
      "gists_url": "https://api.github.com/users/pirapira/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pirapira/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pirapira/subscriptions",
      "organizations_url": "https://api.github.com/users/pirapira/orgs",
      "repos_url": "https://api.github.com/users/pirapira/repos",
      "events_url": "https://api.github.com/users/pirapira/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pirapira/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-20T22:59:36Z",
    "updated_at": "2015-11-20T23:00:04Z",
    "author_association": "MEMBER",
    "body": "For imposing certain rules on entries (\"short names only after 2017\"), how about asking the Collector Contract every time an entry is edited or added?  Then, `newRegistry` and `editRegistry` would call `collector.request_entry(string _hash, string _new_redirectAddres, bool _edit) returns (bool allowed)` to see if the new entry is allowed.  The Collector can even redirect `request_entry` call to a dynamically specified another contract, and change rules from time to time, but once an entry is registered, the Collector cannot invalidate the entry freely.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158551415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158570957",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158570957",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158570957,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU3MDk1Nw==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T01:11:25Z",
    "updated_at": "2015-11-21T01:11:25Z",
    "author_association": "NONE",
    "body": "@pirapira But how would the Collector know whether, say, 0x78ec64bb8319a432962e79252a373554ecd3cec759e53c41c3111c40b45127b3 is the hash of a short name or a long name?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158570957/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158577681",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158577681",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158577681,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU3NzY4MQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T02:22:45Z",
    "updated_at": "2015-11-21T02:22:45Z",
    "author_association": "NONE",
    "body": "@smithgift Thais What I mean by \"privacy by obscurity\", of course everyone can figure out the market price of the \"Apple\" name, I don't see that as a problem. They just can't spider and know the price of all obscure names. \n\nAlso, notice that there would be no dots. In this case you'd be buying just the name wedding-shoes and you can use any subdomain for that. This rule is easy to enforce because most will simply not honor any name with a dot, always looking for the top level domain first. \n\nWe are still discussing what \"top level domain\" even means in this content which is why I prefer not even register short names for the time being. Will it be .eth? Will anyone be able to register whatever? \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158577681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158580002",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158580002",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158580002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU4MDAwMg==",
    "user": {
      "login": "rabbit",
      "id": 241264,
      "node_id": "MDQ6VXNlcjI0MTI2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/241264?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rabbit",
      "html_url": "https://github.com/rabbit",
      "followers_url": "https://api.github.com/users/rabbit/followers",
      "following_url": "https://api.github.com/users/rabbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/rabbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rabbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rabbit/subscriptions",
      "organizations_url": "https://api.github.com/users/rabbit/orgs",
      "repos_url": "https://api.github.com/users/rabbit/repos",
      "events_url": "https://api.github.com/users/rabbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rabbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T03:02:06Z",
    "updated_at": "2015-11-21T03:02:06Z",
    "author_association": "NONE",
    "body": "This would be easier for me to analyze if I understood the goals of the effort better; what use cases must be covered, what use cases are intentionally not covered. Is privacy a goal here? It's stated that human readable names are a goal in the abstract but is that possible without sanitizing inputs? Why is reverse lookup not a goal?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158580002/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158592283",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158592283",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158592283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODU5MjI4Mw==",
    "user": {
      "login": "ryepdx",
      "id": 691597,
      "node_id": "MDQ6VXNlcjY5MTU5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/691597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryepdx",
      "html_url": "https://github.com/ryepdx",
      "followers_url": "https://api.github.com/users/ryepdx/followers",
      "following_url": "https://api.github.com/users/ryepdx/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryepdx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryepdx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryepdx/subscriptions",
      "organizations_url": "https://api.github.com/users/ryepdx/orgs",
      "repos_url": "https://api.github.com/users/ryepdx/repos",
      "events_url": "https://api.github.com/users/ryepdx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryepdx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T05:48:15Z",
    "updated_at": "2015-11-21T06:23:00Z",
    "author_association": "NONE",
    "body": "Good proposal. Thanks for writing that up!\n\n> If the bid new owner is not the current owner, K is 1, otherwise (if it's\n> the owner renewing the ownership) then K is a factor set by the\n> **Collector Contract**.\n\nIt might be better to make K=100 in the new owner case and adjust the\nformula to be (`K` \\* `_bidPrice` / `_duration`) / 100. This would allow\nfor a scenario where the **Collector Contract** wants to make it cheaper\nfor the current owner to keep their domain than for a new owner to take it.\n\n> My proposal is that the first Collector contract be just a _\"Boomerang\n> contract\"_, a contract that simply keeps all ether sent to it and then send\n> them back after 1 year... Since they can always elect the 0x address,\n> then if the community wants to do so they can still vote to burn all the\n> ether collected during the first year.\n\nJust a point of clarification: when a new collector contract is voted\nin, I assume the old one sends its balance on to the new one. Is that\ncorrect?\n\nAlso, is this namereg to have support for parsing paths at all, akin to\nthe ENS system previously proposed? I see that this proposal handles\nauctioning TLDs, which is great, but I don't see anything to suggest how\nstructured data might be handled.\n\nFinally, it's a minor pet peeve of mine that domains as they are now\nhave their elements arranged in order of reverse importance, contrary to\nthe rest of any given URL. (E.g., http://google.com should be\nhttp://com/google and http://ether.fund/tool/converter should be\nhttp://fund/ether/tool/converter). This seems to me like an opportunity\nto correct that error. I imagine this is probably an unpopular opinion,\nof course, but I figured I might as well voice it.\n\nThanks again for starting this conversation. It's good to have all this\nwritten out.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158592283/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158614169",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158614169",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158614169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODYxNDE2OQ==",
    "user": {
      "login": "janx",
      "id": 5958,
      "node_id": "MDQ6VXNlcjU5NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5958?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/janx",
      "html_url": "https://github.com/janx",
      "followers_url": "https://api.github.com/users/janx/followers",
      "following_url": "https://api.github.com/users/janx/following{/other_user}",
      "gists_url": "https://api.github.com/users/janx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/janx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/janx/subscriptions",
      "organizations_url": "https://api.github.com/users/janx/orgs",
      "repos_url": "https://api.github.com/users/janx/repos",
      "events_url": "https://api.github.com/users/janx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/janx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T09:02:36Z",
    "updated_at": "2015-11-29T06:22:24Z",
    "author_association": "MEMBER",
    "body": "> _Should a bid be considered invalid if it's revealed earlier than 48h of the renewal date?_\n> \n> Bids revealed too early might affect the game strategy and will influence the price to be paid. In the other  hand a deleted bid might mean that someone will lose his property without the correct asking price. Since  losing a domain name is harsher than someone overpaying for it, then I suggest that there should not be an obligatory reveal period, only a suggested 24h window.\n\nWhat if 'early revealer' needs to pay some penalty? In such case the value of `putSealedBid` transaction would be at least `_bidPrice + fees + deposit`, where `deposit` calculation is another question.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158614169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158618889",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158618889",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158618889,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODYxODg4OQ==",
    "user": {
      "login": "pirapira",
      "id": 44281,
      "node_id": "MDQ6VXNlcjQ0Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/44281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pirapira",
      "html_url": "https://github.com/pirapira",
      "followers_url": "https://api.github.com/users/pirapira/followers",
      "following_url": "https://api.github.com/users/pirapira/following{/other_user}",
      "gists_url": "https://api.github.com/users/pirapira/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pirapira/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pirapira/subscriptions",
      "organizations_url": "https://api.github.com/users/pirapira/orgs",
      "repos_url": "https://api.github.com/users/pirapira/repos",
      "events_url": "https://api.github.com/users/pirapira/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pirapira/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T10:00:30Z",
    "updated_at": "2015-11-21T10:00:30Z",
    "author_association": "MEMBER",
    "body": "@Smithgift \n\n> But how would the Collector know whether, say, 0x78ec64bb8319a432962e79252a373554ecd3cec759e53c41c3111c40b45127b3 is the hash of a short name or a long name?\n\nUm, maybe by computing hashes of the shortest names and keeping them (at least we can cover one-character names).  Now I see the trade-off between \"enforcing policy\" and \"privacy by obscurity\".  I have no good answer.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158618889/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158660776",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158660776",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158660776,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODY2MDc3Ng==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T16:35:49Z",
    "updated_at": "2015-11-21T16:41:17Z",
    "author_association": "NONE",
    "body": "@rabbit the I expanded the text with a \"motivation\" section\n\n@ryepdx I realised that I'm actually doing the K calculation completely wrong: the duration you want to keep your domain until renewal should not have an influence on the price you pay to buy it , only to renew it. So I think the correct way would be to have the renewal calculation that th e\"bid\" of the current owner should be calculated as bid = fee paid \\* K / duration.  This means that if you would sell your name at 1000 ether, would like to renew it for 3 years and the current fee is set at 0.5% per year, then you need to send 15 ether to renew it. Anyone who bids more than that will buy it from you, independently of his duration. Maybe whenever a domain changes owners the duration should be always set at 1 year and then can be renewed for up to twice the previous amount every time. \n\n> when a new collector contract is voted in, I assume the old one sends its balance on to the new one.\n\nSince any contract can be elected, that cannot be controlled. The new one simply starts receiving the fees from the renewal. The advantage of using a boomerang is that the new one would also be getting any revenue that was sent from a year previously\n\n> Also, is this namereg to have support for parsing paths at all, akin to the ENS system previously proposed? \n\nWatching your talk you mention a lot of great extra information that you will need for many use cases, including how to parse sub registries, some of which I don't understand them myself. The needs of swarm/ipfs also require other kinds of extra information attached to a name, like a hash of the content in cases that the address doesn't provide that. \n\nSo I thought that instead of trying to cover all possible use cases it would make more sense to be minimal: the \"master\" registry only saves a few basic information like the current owner, the renewal data and how much he paid in fees, etc. If you need extra information you can create a contract with extra fields that reads the owner from the master contract and then gives them the right to edit and add information about his owned hash.\n\n> Finally, it's a minor pet peeve of mine that domains as they are now have their elements arranged in order of reverse importance, contrary to the rest of any given URL.\n\nYou are not the first one to bring that up, actually @gavofyork wanted to put domains exactly as you describe. I see the point and like the idea, but there are some limitations: a slash cannot be used as a separator, since it's important for the browser to differentiate between subdomains and subfolders. Also, inverting the domain subdomain order requires some modification of the core chromium server that we are using. Also I'm a bit afraid of creating user confusion and risk of phishing attack for a user that would see  **secure.bankofamerica.com** and even a tech savvy user might think that this page belonged to bank of america.\n\nIn Mist I am using a compromise solution: Im separating the display of the url from the editing. When you click and mouse over the url, the text displays the url bar exactly as traditional web (`http://ether.fund/tool/converter`). In all other moments the url bar displays it in the hierarchical order using triangles as separators: `fund ‚Ä£ ether ‚Ä£ tool ‚Ä£ converter`\n\nI think it's a good compromise of usability and security.\n\n@Smithgift all possible six letter names are in the order of billions, this would make the contract incredibly expensive.\n\nAnother solution is simply to ignore it and enforce that on the client, but this is a permanent solution. For example, if you type a name with a dot in mist, it would automatically detect the top level domain and look into that, so mist effectively ignores all names with a dot in the middle. This doesn't mean you can't register them, just means that they aren't used. The trouble with fewer letters is that I'd like to use the same system to names with 6, 5 or even a single letter in the future (if we don't come up with a better solution by then) but if that's the case we would have to use a second contract to store those as the contract will accept them no matter what.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158660776/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158663438",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158663438",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158663438,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODY2MzQzOA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T17:25:56Z",
    "updated_at": "2015-11-21T17:25:56Z",
    "author_association": "NONE",
    "body": "@alexvandesande That was what I was getting at. There's no practical way for the contract to go.\n\nI've decided to call the \"bid on any new hash that's auctioned in the hope someone wants it\" strategy bobcatting. It's like wildcatting in the oil industry, except you have no idea what you actually bought and you might have gotten hit by a countertroll's nonsense hash. (\"INSTEAD OF VALUABLE HASH, RECEIVED BOBCAT.\")\n\nOn more thought, a sophisticated bobcatter would examine the transaction history of the account that started the auction. If it's a seemingly independent account buying one or two hashes, it's possibly someone's username or something, so go for it. A sophisticated countertroll would attempt to create more \"independent\" accounts to fool bobcatters, which is in turn an incentive for superior bobcatter algorithms (i.e. if it's funded from a mixer, it's more likely to be a countertroll.) There's probably interesting game-theoretical analysis behind all this which I am not qualified to do.\n\nThis all said, an auction like this is far better, troll-feline-wise, than a first-come-first-serve system, because you can at least outbid the bobcatter. In first-come-first-serve, the bobcatter just tries to preempt your transaction with higher gas prices or the like, and if he does he wins.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158663438/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158680710",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158680710",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158680710,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODY4MDcxMA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-21T21:07:03Z",
    "updated_at": "2015-11-21T21:07:03Z",
    "author_association": "MEMBER",
    "body": "Please use `bytes32` as the type of a (256 bit) hash. `string` is reserved for utf-8 encoded data - if you need to store variable-length binary data, use `bytes`.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158680710/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158753804",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158753804",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158753804,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODc1MzgwNA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T12:20:10Z",
    "updated_at": "2015-11-22T12:20:10Z",
    "author_association": "NONE",
    "body": "@chriseth  thanks, updated it!\n\n@Smithgift Great point.\n\nLet's say that a _BobCatter_ would bid 10 ethers on random new bids being put. Since bidding is free, they would be able to own a bunch of new names for a year for less than 10.1 ether each, and they would be able to renew them for another year always for 0.1 ether (assuming a 1% per year fee), while being guaranteed that these names would alway sell for at least 10 ether each. The next year he can pay only 0.1 ether more and then these names will have twice the initial asking price and by analysing traffic coming to these names they could probably figure out the original name or at least its popularity.\n\nThe main issue I see here isn't even the name squatter holding a lot of popular names, but a worse consequence is that by bidding on all new names he is guaranteeing to make it more difficult for people who just want their own name for cheap to own it, and increasing the price for those who get it successfully: suddenly you can't get a uncommon name for free like originally envisioned, since all auctions are being bid on.\n\nA potential solution would probably come from making bids non free, specially if you are bidding completely outside the market price: having deposits that you get back under certain conditions, incurring costs if you put the second bid (therefore increasing the price paid), etc.\n\nMaybe a solution would be, instead of trying to come up with a solution to these problems right now, **parametrize** all these options as functions controlled by the collector contract. So for example, the secondary bid might pay a fee of X, which is a function of the total price made on the collector contract. If the collector contract doesn't implement that function then the fee is 0, but its up to them.\n\nThis gives the collector contract more power, but I believe that as long as it's controlling some limited auction parameters and cannot take names away, then it's a controlled power..\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158753804/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158762555",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158762555",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158762555,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODc2MjU1NQ==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T14:16:43Z",
    "updated_at": "2015-11-22T14:16:43Z",
    "author_association": "NONE",
    "body": "@alexvandesande \n\nI think penalizing a second bid hurts spiders but helps bobcatters. If a bobcatter sees some random account unseal a bid to start an auction, the bobcatter knows exactly how much to bid to win, and the legitimate user will have to pay a second-bid penalty. \n\nSuppose that the cost to start an auction is miniscule. Say, a new auction starts simply by calling a function, no bid necessary. Counterintuitively, the bobcatters will be at a disadvantage against a countertroll force, because the countertrolls could start absurd numbers of auctions to screen auctions by true users, and if the bobcatters go after every auction they go bankrupt. Unfortunately, this may lead to severe network spam, depending on how big the bobcat-countertroll conflict grows. \n\nNINJA EDIT: But in that situation, spider-squatters are probably going to spam the network with starting auctions on valuable names before anyone realizes that they're valuable.\n\nI realized there's an additional stumbling block to the countertrolls. They have to spend as much ETH on a new auction as a true user would, or the bobcatter instantly knows it's a countertroll. The true user strategy is then to spend less on a bid so that they look like a countertroll, but then there's a disincentive to bid what the name is actually worth.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158762555/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158792494",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158792494",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158792494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODc5MjQ5NA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T19:36:32Z",
    "updated_at": "2015-11-22T19:36:32Z",
    "author_association": "NONE",
    "body": "@smithgift bobcats, counter trolls, spiders, our fauna is getting richer!\n\nI agree that to initiate a new bid should be a different function, with no information on price. I edited the proposal to reflect that. \n\nNow the other points I would still keep the principle appointed earlier: parametricize all those fees, prices, taxes, deposits, etc so that these can be experimented by the collector contract. \n\n> On Nov 22, 2015, at 12:16, Smithgift notifications@github.com wrote:\n> \n> @alexvandesande\n> \n> I think penalizing a second bid hurts spiders but helps bobcatters. If a bobcatter sees some random account unseal a bid to start an auction, the bobcatter knows exactly how much to bid to win, and the legitimate user will have to pay a second-bid penalty.\n> \n> Suppose that the cost to start an auction is miniscule. Say, a new auction starts simply by calling a function, no bid necessary. Counterintuitively, the bobcatters will be at a disadvantage against a countertroll force, because the countertrolls could start absurd numbers of auctions to screen auctions by true users, and if the bobcatters go after every auction they go bankrupt. Unfortunately, this may lead to severe network spam, depending on how big the bobcat-countertroll conflict grows.\n> \n> NINJA EDIT: But in that situation, spider-squatters are probably going to spam the network with starting auctions on valuable names before anyone realizes that they're valuable.\n> \n> I realized there's an additional stumbling block to the countertrolls. They have to spend as much ETH on a new auction as a true user would, or the bobcatter instantly knows it's a countertroll. The true user strategy is then to spend less on a bid so that they look like a countertroll, but then there's a disincentive to bid what the name is actually worth.\n> \n> ‚Äî\n> Reply to this email directly or view it on GitHub.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158792494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158792707",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158792707",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158792707,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODc5MjcwNw==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T19:39:09Z",
    "updated_at": "2015-11-22T19:39:09Z",
    "author_association": "NONE",
    "body": "About valuables names being quickly auctioned by spiders: there's no way to prevent it, there will be a gold rush of the best valid names. The reason duration is measured in days not years is so users can change their renewal date so most of them won't be having an anniversary at the same time. \n\nSent from my iPhone\n\n> On Nov 22, 2015, at 12:16, Smithgift notifications@github.com wrote:\n> \n> @alexvandesande\n> \n> I think penalizing a second bid hurts spiders but helps bobcatters. If a bobcatter sees some random account unseal a bid to start an auction, the bobcatter knows exactly how much to bid to win, and the legitimate user will have to pay a second-bid penalty.\n> \n> Suppose that the cost to start an auction is miniscule. Say, a new auction starts simply by calling a function, no bid necessary. Counterintuitively, the bobcatters will be at a disadvantage against a countertroll force, because the countertrolls could start absurd numbers of auctions to screen auctions by true users, and if the bobcatters go after every auction they go bankrupt. Unfortunately, this may lead to severe network spam, depending on how big the bobcat-countertroll conflict grows.\n> \n> NINJA EDIT: But in that situation, spider-squatters are probably going to spam the network with starting auctions on valuable names before anyone realizes that they're valuable.\n> \n> I realized there's an additional stumbling block to the countertrolls. They have to spend as much ETH on a new auction as a true user would, or the bobcatter instantly knows it's a countertroll. The true user strategy is then to spend less on a bid so that they look like a countertroll, but then there's a disincentive to bid what the name is actually worth.\n> \n> ‚Äî\n> Reply to this email directly or view it on GitHub.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158792707/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158798408",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158798408",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158798408,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODc5ODQwOA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T20:46:15Z",
    "updated_at": "2015-11-22T20:46:15Z",
    "author_association": "NONE",
    "body": "I think the collector setting parameters like that is a good idea, too. \"Collector\" seems to be a less accurate name, but I'm not sure what else it could be called without sounding centralized.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158798408/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158804984",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-158804984",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 158804984,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODgwNDk4NA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-22T21:50:46Z",
    "updated_at": "2015-11-22T21:50:46Z",
    "author_association": "NONE",
    "body": "Comes from tax collector. It's not a manager or Administrador as it can't change name owners or ban people. Accepting suggestions. \n\n> On Nov 22, 2015, at 18:46, Smithgift notifications@github.com wrote:\n> \n> I think the collector setting parameters like that is a good idea, too. \"Collector\" seems to be a less accurate name, but I'm not sure what else it could be called without sounding centralized.\n> \n> ‚Äî\n> Reply to this email directly or view it on GitHub.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/158804984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159090708",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159090708",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159090708,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTA5MDcwOA==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-23T22:40:56Z",
    "updated_at": "2015-11-23T22:40:56Z",
    "author_association": "MEMBER",
    "body": "I still believe that a two layer system may be better, namely to have a Hash-to-Hash registrar (which maps sha(domain_name) to sha(content)) and a Hash-to-URLhint map which maps to URL hints.\nThe url hint can just be a scheme name (or even one byte schemecode`), this is enough for content (hash) addressed systems like IPFS or swarm which can simply update content by only resetting the hash map. To save even more, one could even have a default scheme so that say if a content hash has no URLhint entry, it is interpreted as a swarm hash. \nYou may not want to commit to the content hash. So if a domain has no content hash but has a urlhint it is considered an insecure redirect. This allows`wedding-shoes`to redirect to`augur/markets/is-the-wedding-shoes-worth-more-than-USD1000` :)\nNot entirely clear to me what information the distinction between registering namehash->urlhint or contenthash->urlhint should convey.\n\nMy more general reservation is that both IPFS and Swarm already supports name resolution, both could use (the same) contract on the blockchain, and http provides DNS, so I am not entirely convinced having a mist central resolution is even necessary. \nI would just register protocol schemes (bzz, ipns) with electron url handler and simply pass the url to the scheme handler as is leaving the scheme do their preferred name reg lookups. The namereg for a scheme could use an ethereum smart contract (an instance of the registry template contract). This is obviously the case with swarm. In my view this is cleaner and more modular. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159090708/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159092000",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159092000",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159092000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTA5MjAwMA==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-23T22:46:51Z",
    "updated_at": "2015-11-23T22:46:51Z",
    "author_association": "MEMBER",
    "body": "> Also, is this namereg to have support for parsing paths at all, akin to the ENS system previously proposed? I see that this proposal handles auctioning TLDs, which is great, but I don't see anything to suggest how structured data might be handled. \n\n@ryepdx They do not need to be handled, in fact they should not be. Only domains should register on the blockchain. The domains point to a manifest file (routing table of sorts) with all your paths mapped to hashes (arranged in a trie for a recursive lookup in case of huge indexes). Since the manifest contains the hashes and itself is content addressed, an entire webservers all static routes can be integrity protected with a single entry in the registry.  \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159092000/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159095001",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159095001",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159095001,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTA5NTAwMQ==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-23T23:00:10Z",
    "updated_at": "2015-11-23T23:01:07Z",
    "author_association": "MEMBER",
    "body": "@rabbit I agree. The usecase of reverse lookups are important. However, those that want to be in the phonebook so to say, can register their names with the string sent as a parameter in the transaction. This can then be logged with `NewEntry(name, name_hash)`, which is cheaper. Then any off chain service can process the logs and create a phonebook (index of namehashes or content hashes), the most uptodate version is always registered as say `bzz://phonebook`. Note that it is trivial to verify that a reverse lookup entry is correct so if they are phony phone books, they will soon lose reputation.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159095001/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159100318",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159100318",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159100318,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTEwMDMxOA==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-23T23:22:03Z",
    "updated_at": "2015-11-23T23:22:03Z",
    "author_association": "MEMBER",
    "body": "If we keep the standard that we use this same namereg to register contract info belonging to a contract then the best way to do it is to index by contract code as name (as it is currently done in geth natspec implementation, see https://github.com/ethereum/go-ethereum/blob/develop/common/natspec/natspec.go#L107) (and see swarm dns-oid: https://github.com/ethersphere/go-ethereum/blob/bzz/bzz/api.go#L393). A consequence of this is that your browser will automatically serve as contract code reverse lookup. `bzz://<contract_code_hex>` will resolve to the contract info json file (showing the source, compiler version and params which allows contract source verification for instance)\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159100318/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159102485",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159102485",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159102485,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTEwMjQ4NQ==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-23T23:27:28Z",
    "updated_at": "2015-11-23T23:27:28Z",
    "author_association": "MEMBER",
    "body": "i think subdomain ordering is silly but i would suggest conforming to url standard so  that existing url parsing libs can be used on our addresses in dapps. pragmatic decisions like this matter a lot in adoption\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159102485/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159208354",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159208354",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159208354,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTIwODM1NA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T09:37:24Z",
    "updated_at": "2015-11-24T09:38:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "I see it as follows:\n- `file://` === `bzz://` - will only lookup swarm hashes/content (where you can also add the path, which is resolved by the manifest file). This way you're sure that `bzz://` will only access swarm content, as with the `file://` protocol you're sure it only access local files.\n- `http://` === `eth://` - will look up things in the registry (done in Mist, so not every node needs to implement the same registry behaviour [though debateable]). This can  point to a swarm hash, or HTTP link.\n  If it points to a swarm hash you can add a path on the end, which is then resolved through the manifest file and not the registry. The registry only resolves domain names.\n\nSpecial links like contract addresses, should be prefixed with `contract:`, like currently for emails, bitcoin  or skype numbers (`mailto:`, `bitcoin:`, `skype:`). So it would be:  \n`eth://contract:0x123456789098765432...`\n\nThis would show a JSON with all the necessary stored information about a contract (Interface, natspec, source)\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159208354/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159232111",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159232111",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159232111,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTIzMjExMQ==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T11:09:31Z",
    "updated_at": "2015-11-24T11:11:19Z",
    "author_association": "MEMBER",
    "body": "> done in Mist, so not every node needs to implement the same registry behaviour [though debateable]\n\nyes I debate this. As I said if they support IPNS or Swarm anyway, their resolver is already supported\nIn fact duplicating the resolvers code in mist is a bad idea. \nBut defining a great scheme specific namereg template contract is very important.\n\nSo once again. If I use IPFS and have a name already registered with methods other than the ethereum contract, I still want it to be available in mist, so we will need to proxy the name to IPFS scheme handler anyway (which, in geth, will probably be done by swarm as well) unless you reimplement the entire IPFS name resolution in mist. Conversely if i register my ipfs hash with the ethereum namereg, I also want other (non-ethereum) users of IPFS to see this, which means ethereum-IPFS name resolution should be implemented as part of IPFS anyway. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159232111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159235011",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159235011",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159235011,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTIzNTAxMQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T11:20:54Z",
    "updated_at": "2015-11-24T11:20:54Z",
    "author_association": "NONE",
    "body": "@zelig \nContract names, url hints and content hashes: I think all of those should be separate contracts. Maybe I'll remove all info from registry except owner and renewal date and let all use cases be handled by their own contract. \n\nSo you can have a contract that pairs hashes > hashes and another for hashes > url hints and another for hashes > eth address and so on. Those entries can only be edited by the owner account held on the main registry contract. \n\nThis allows greater extensibility but at the cost of the user having to do more transactions to register basic information. \n\nI don't understand the point of name register duplication: if you have already registered a name in IPFS or swarm that uses a completely different set of rules you'll **obviously** need to register again, there's no going around it. \n\nI don't particularly like the structure eth://contract:0xdeadbeef but this isn't the place to have this discussion in my opinion. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159235011/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159236668",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159236668",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159236668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTIzNjY2OA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T11:28:18Z",
    "updated_at": "2015-11-24T11:28:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "@zelig  Why is it done twice?\n`bzz://` then shouldn't lookup a namereg, as it only needs to resolve the given hashes to a file.\nWe could also add a `ipfs://` which only resolves to ifs hashes. This was the only real namereg is used in `eth://` and all other protocols are protocol specific to one transport layer, like swarm or ipfs.\n\nThis is exactly what we should want it we want to be modular. Each module (bzz, eth) has its specifies a way to resolve things, and `bzz://` shouldn't be the all in one solution. the `eth://` registry is that (like `http://`, which can resolve to many things)\n\n@alexvandesande concerning the `contract:`, this is to follow the browsers standard for specific actions. So click gin a link like this could actually open a specific mist popup, showing information about this contract.\n\nWe should follow the browsers standards, because thats the tools we have available and we have a lady a great way to extend them.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159236668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159259691",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159259691",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159259691,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTI1OTY5MQ==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T12:56:21Z",
    "updated_at": "2015-11-24T12:56:21Z",
    "author_association": "MEMBER",
    "body": "@frozeman we are going round and round. Please sit back and read my arguments again please.\n\n> bzz:// then shouldn't lookup a namereg\n> well it does, and so does ipns \n\n@alexvandesande \n\n> I don't understand the point of name register duplication: if you have already registered a name in IPFS or swarm that uses a completely different set of rules you'll obviously need to register again, there's no going around it. \n\n? in order for what to happen? for my dapp to be displayed in Mist? Why? That would be rather unkind. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159259691/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159269681",
    "html_url": "https://github.com/ethereum/EIPs/issues/26#issuecomment-159269681",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/26",
    "id": 159269681,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTI2OTY4MQ==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-24T13:38:29Z",
    "updated_at": "2015-11-24T13:39:50Z",
    "author_association": "NONE",
    "body": "@zelig \n\n> for my dapp to be displayed in Mist? Why? \n\nBecause namereg has a very specific auction model for resolving names. You can't circumvent it by registering it elsewhere.\n\nIf Bob registers _\"foobar\"_ in swarm, Alice registers it on the Mist name reg and Eve registers it on ipfs, who owns it? From Mist's perspective, Alice, obviously, because it's the only one that it looks for.\n\nMaybe we are talking about registering something else?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159269681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
