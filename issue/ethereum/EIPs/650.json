{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/650/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/650/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/650/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/650",
  "id": 237766208,
  "node_id": "MDU6SXNzdWUyMzc3NjYyMDg=",
  "number": 650,
  "title": "Istanbul Byzantine Fault Tolerance",
  "user": {
    "login": "yutelin",
    "id": 1516485,
    "node_id": "MDQ6VXNlcjE1MTY0ODU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/yutelin",
    "html_url": "https://github.com/yutelin",
    "followers_url": "https://api.github.com/users/yutelin/followers",
    "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
    "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
    "organizations_url": "https://api.github.com/users/yutelin/orgs",
    "repos_url": "https://api.github.com/users/yutelin/repos",
    "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/yutelin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 65,
  "created_at": "2017-06-22T08:18:24Z",
  "updated_at": "2023-01-08T11:17:40Z",
  "closed_at": "2022-03-09T17:09:23Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Change log:\r\n- Aug 8, 2017: \r\n    - Add gossip network\r\n- Jul 24, 2017: \r\n\t- Add block locking mechanism.\r\n\t- Performance/bug fixes.\r\n- Jun 26, 2017:\r\n\t- Add `extraData` tools.\r\n\t- Update notes and discussions on zero gas price transaction\r\n- Jun 22, 2017:\r\n\t- Initial proposal of Istanbul BFT consensus protocol.\r\n\r\n## Pull request\r\nhttps://github.com/ethereum/go-ethereum/pull/14674\r\n\r\n## Istanbul byzantine fault tolerant consensus protocol \r\n_Note, this work is deeply inspired by [Clique POA](https://github.com/ethereum/EIPs/issues/225). We've tried to design as similar a mechanism as possible in the protocol layer, such as with validator voting. We've also followed its EIP style of putting the background and rationale behind the proposed consensus protocol to help developers easily find technical references. This work is also inspired by [Hyperledger's SBFT](https://github.com/hyperledger), [Tendermint](https://github.com/tendermint/tendermint), [HydraChain](https://github.com/HydraChain/hydrachain), and [NCCU BFT](https://github.com/NCCUCS-PLSM/NCCU-BFT-for-Go-Ethereum/)._\r\n\r\n### Terminology\r\n- **Validator**: Block validation participant.\r\n- **Proposer**: A block validation participant that is chosen to propose block in a consensus round.\r\n- **Round**: Consensus round. A round starts with the proposer creating a block proposal and ends with a block commitment or round change.\r\n- **Proposal**: New block generation proposal which is undergoing consensus processing.\r\n- **Sequence**:  Sequence number of a proposal. A sequence number should be greater than all previous sequence numbers. Currently each proposed block height is its associated sequence number.\r\n- **Backlog**: The storage to keep future consensus messages.\r\n- **Round state**: Consensus messages of a specific sequence and round, including pre-prepare message, prepare message, and commit message.\r\n- **Consensus proof**: The commitment signatures of a block that can prove the block has gone through the consensus process.\r\n- **Snapshot**: The validator voting state from last epoch.\r\n\r\n### Consensus\r\n\r\nIstanbul BFT is inspired by Castro-Liskov 99 [paper](http://pmg.csail.mit.edu/papers/osdi99.pdf). However, the original PBFT needed quite a bit of tweaking to make it work with blockchain. First off, there is no specific \"client\" which sends out requests and waits for the results. Instead, all of the validators can be seen as clients. Furthermore, to keep the blockchain progressing, a proposer will be continuously selected in each round to create block proposal for consensus. Also, for each consensus result, we expect to generate a verifiable new block rather than a bunch of read/write operations to the file system. \r\n\r\nIstanbul BFT inherits from the original PBFT by using 3-phase consensus, `PRE-PREPARE`, `PREPARE`, and `COMMIT`. The system can tolerate at most of `F` faulty nodes in a `N` validator nodes network, where `N = 3F + 1`. Before each round, the validators will pick one of them as the proposer, by default, in a round robin fashion. The proposer will then propose a new block proposal and broadcast it along with the `PRE-PREPARE` message. Upon receiving the `PRE-PREPARE` message from the proposer, validators enter the state of `PRE-PREPARED` and then broadcast `PREPARE` message. This step is to make sure all validators are working on the same sequence and the same round.  While receiving `2F + 1` of `PREPARE` messages, the validator enters the state of `PREPARED` and then broadcasts `COMMIT` message. This step is to inform its peers that it accepts the proposed block and is going to insert the block to the chain. Lastly, validators wait for `2F + 1` of `COMMIT` messages to enter `COMMITTED` state and then insert the block to the chain.\r\n\r\nBlocks in Istanbul BFT protocol are final, which means that there are no forks and any valid block must be somewhere in the main chain. To prevent a faulty node from generating a totally different chain from the main chain, each validator appends `2F + 1` received `COMMIT` signatures to `extraData` field in the header before inserting it into the chain. Thus blocks are self-verifiable and light client can be supported as well. However, the dynamic `extraData` would cause an issue on block hash calculation. Since the same block from different validators can have different set of `COMMIT` signatures, the same block can have different block hashes as well. To solve this, we calculate the block hash by excluding the `COMMIT` signatures part. Therefore, we can still keep the block/block hash consistency as well as put the consensus proof in the block header.\r\n\r\n#### Consensus states\r\nIstanbul BFT is a state machine replication algorithm. Each validator maintains a state machine replica in order reach block consensus. \r\n\r\nStates:\r\n\r\n- `NEW ROUND`: Proposer to send new block proposal. Validators wait for `PRE-PREPARE` message.\r\n- `PRE-PREPARED`: A validator has received `PRE-PREPARE` message and broadcasts `PREPARE` message. Then it waits for `2F + 1` of `PREPARE` or `COMMIT` messages.\r\n- `PREPARED`: A validator has received `2F + 1` of `PREPARE` messages and broadcasts `COMMIT` messages. Then it waits for `2F + 1` of `COMMIT` messages.\r\n- `COMMITTED`: A validator has received `2F + 1` of `COMMIT` messages and is able to insert the proposed block into the blockchain.\r\n- `FINAL COMMITTED`: A new block is successfully inserted into the blockchain and the validator is ready for the next round.\r\n- `ROUND CHANGE`: A validator is waiting for `2F + 1` of `ROUND CHANGE` messages on the same proposed round number.\r\n\r\n#### State transitions:\r\n![State transition diagram](https://user-images.githubusercontent.com/1516485/41951806-4824998c-79ff-11e8-99f0-153fca7708a4.jpg \"State transition diagram\")\r\n\r\n\r\n\r\n- `NEW ROUND` -> `PRE-PREPARED`:\r\n\t- **Proposer** collects transactions from txpool.\r\n\t- **Proposer** generates a block proposal and broadcasts it to validators. It then enters the `PRE-PREPARED` state.\r\n\t- Each **validator** enters `PRE-PREPARED` upon receiving the `PRE-PREPARE` message with the following conditions:\r\n\t\t- Block proposal is from the valid proposer.\r\n\t\t- Block header is valid.\r\n\t\t- Block proposal's sequence and round match the **validator**'s state.\r\n\t- **Validator** broadcasts `PREPARE` message to other validators.\r\n- `PRE-PREPARED` -> `PREPARED`:\r\n\t- **Validator** receives `2F + 1` of valid `PREPARE` messages to enter `PREPARED` state. Valid messages conform to the following conditions:\r\n\t\t- Matched sequence and round.\r\n\t\t- Matched block hash.\r\n\t\t- Messages are from known validators.\r\n\t- **Validator** broadcasts `COMMIT` message upon entering `PREPARED` state.\r\n- `PREPARED` -> `COMMITTED`:\r\n\t- **Validator** receives `2F + 1` of valid `COMMIT` messages to enter `COMMITTED` state. Valid messages conform to the following conditions:\r\n\t\t- Matched sequence and round.\r\n\t\t- Matched block hash.\r\n\t\t- Messages are from known validators.\r\n- `COMMITTED` -> `FINAL COMMITTED`:\r\n\t- **Validator** appends `2F + 1` commitment signatures to `extraData` and tries to insert the block into the blockchain.\r\n\t- **Validator** enters `FINAL COMMITTED` state when insertion succeeds.\r\n- `FINAL COMMITTED` -> `NEW ROUND`:\r\n\t- **Validators** pick a new **proposer** and starts a new round timer.\r\n\r\n#### Round change flow\r\n- There are three conditions that would trigger `ROUND CHANGE`:\r\n\t- Round change timer expires.\r\n\t- Invalid `PREPREPARE` message.\r\n\t- Block insertion fails.\r\n- When a validator notices that one of the above conditions applies, it broadcasts a `ROUND CHANGE` message along with the proposed round number and waits for `ROUND CHANGE` messages from other validators. The proposed round number is selected based on following condition:\r\n\t- If the validator has received `ROUND CHANGE` messages from its peers, it picks the largest round number which has `F + 1` of `ROUND CHANGE` messages.\r\n\t- Otherwise, it picks `1 + current round number` as the proposed round number.\r\n- Whenever a validator receives `F + 1` of `ROUND CHANGE` messages on the same proposed round number, it compares the received one with its own. If the received is larger, the validator broadcasts `ROUND CHANGE` message again with the received number.\r\n- Upon receiving `2F + 1` of `ROUND CHANGE` messages on the same proposed round number, the **validator** exits the round change loop, calculates the new **proposer**, and then enters `NEW ROUND` state.\r\n- Another condition that a validator jumps out of round change loop is when it receives verified block(s) through peer synchronization.\r\n\r\n#### Proposer selection\r\nCurrently we support two policies: **round robin** and **sticky proposer**.\r\n\r\n- Round robin: in a round robin setting, proposer will change in every block and round change.\r\n- Sticky proposer: in a sticky proposer setting, propose will change only when a round change happens.\r\n\r\n#### Validator list voting\r\nWe use a similar validator voting mechanism as Clique and copy most of the content from Clique [EIP](https://github.com/ethereum/EIPs/issues/225). Every epoch transaction resets the validator voting, meaning if an authorization or de-authorization vote is still in progress, that voting process will be terminated. \r\n\r\nFor all transactions blocks:\r\n\r\n- Proposer can cast one vote to propose a change to the validators list.\r\n- Only the latest proposal per target beneficiary is kept from a single validator.\r\n- Votes are tallied live as the chain progresses (concurrent proposals allowed).\r\n- Proposals reaching majority consensus `VALIDATOR_LIMIT` come into effect immediately.\r\n- Invalid proposals are not to be penalized for client implementation simplicity.\r\n- A proposal coming into effect entails discarding all pending votes for that proposal (both for and against) and starts with a clean slate.\r\n\r\n#### Future message and backlog\r\nIn an asynchronous network environment, one may receive future messages which cannot be processed in the current state. For example, a validator can receive `COMMIT` messages on `NEW ROUND`. We call this kind of message a \"future message.\" When a validator receives a future message, it will put the message into its **backlog** and try to process later whenever possible. \r\n\r\n#### Optimization\r\nTo speed up the consensus process, a validator that received `2F + 1` of `COMMIT` messages prior to receiving `2F + 1` of `PREPARE` message will jump to the `COMMITTED` state so that it is not necessary to wait for further `PREPARE` messages.\r\n\r\n#### Constants\r\nWe define the following constants:\r\n\r\n- `EPOCH_LENGTH`: Number of blocks after which to checkpoint and reset the pending votes.\r\n\t- Suggested `30000` for the testnet to remain analogous to the main net `ethash` epoch.\r\n- `REQUEST_TIMEOUT`: Timeout for each consensus round before firing a round change in millisecond.\r\n- `BLOCK_PERIOD`:  Minimum timestamp difference in seconds between two consecutive blocks.\r\n- `PROPOSER_POLICY`: Proposer selection policy, defaults to round robin.\r\n- `ISTANBUL_DIGEST`: Fixed magic number `0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365` of `mixDigest` in block header for Istanbul block identification.\r\n- `DEFAULT_DIFFICULTY`: Default block difficulty, which is set to `0x0000000000000001` .\r\n- `EXTRA_VANITY`: Fixed number of extra-data prefix bytes reserved for proposer vanity.\r\n\t- Suggested `32 bytes` to retain the current extra-data allowance and/or use.\r\n- `NONCE_AUTH`: Magic nonce number `0xffffffffffffffff `to vote on adding a validator.\r\n- `NONCE_DROP`: Magic nonce number `0x0000000000000000` to vote on removing a validator.\r\n- `UNCLE_HASH`: Always `Keccak256(RLP([]))` as uncles are meaningless outside of PoW.\r\n- `PREPREPARE_MSG_CODE`: Fixed number `0`. Message code for `PREPREPARE` message.\r\n- `COMMIT_MSG_CODE`: Fixed number `1`. Message code for `COMMIT` message.\r\n- `ROUND_CHANGE_MSG_CODE`: Fixed number `2`. Message code for `ROUND CHANGE` message.\r\n\r\nWe also define the following per-block constants:\r\n\r\n- `BLOCK_NUMBER`: Block height in the chain, where the height of the genesis block is 0.\r\n- `N`: Number of authorized validators.\r\n- `F`: Number of allowed faulty validators.\r\n- `VALIDATOR_INDEX`: Index of the block validator in the sorted list of current authorized validators.\r\n- `VALIDATOR_LIMIT`: Number of validators to pass an authorization or de-authorization proposal.\r\n\t- Must be `floor(N / 2) + 1` to enforce majority consensus on a chain.\r\n\r\n#### Block header\r\nWe didn't invent a new block header for Istanbul BFT. Instead, we follow Clique in repurposing the `ethash` header fields as follows: \r\n\r\n- `beneficiary`: Address to propose modifying the list of validator with.\r\n\t- Should be filled with zeroes normally, modified only while voting.\r\n\t- Arbitrary values are permitted nonetheless (even meaningless ones such as voting out non validators) to avoid extra complexity in voting mechanics implementation.\r\n- `nonce`: Proposer proposal regarding the account defined by the beneficiary field.\r\n\t- Should be `NONCE_DROP` to propose deauthorizing beneficiary as a existing validator.\r\n\t- Should be `NONCE_AUTH` to propose authorizing beneficiary as a new validator.\r\n\t- **Must** be filled with zeroes, `NONCE_DROP` or `NONCE_AUTH`\r\n- `mixHash`: Fixed magic number `0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365` for Istanbul block identification.\r\n- `ommersHash`: **Must** be `UNCLE_HASH` as uncles are meaningless outside of PoW.\r\n- `timestamp`: **Must** be at least the parent timestamp + `BLOCK_PERIOD`\r\n- `difficulty`: **Must** be filled with `0x0000000000000001`.\t\r\n- `extraData`: Combined field for signer vanity and RLP encoded Istanbul extra data, where Istanbul extra data contains validator list, proposer seal, and commit seals. Istanbul extra data is defined as follows:\r\n\t```golang\r\n\ttype IstanbulExtra struct {\r\n    \tValidators    []common.Address \t//Validator addresses\r\n    \tSeal          []byte\t\t\t//Proposer seal 65 bytes\r\n    \tCommittedSeal [][]byte\t\t\t//Committed seal, 65 * len(Validators) bytes\r\n\t}\r\n\t```\r\n\tThus the `extraData` would be in the form of `EXTRA_VANITY | ISTANBUL_EXTRA` where `|` represents a fixed index to separate vanity and Istanbul extra data (not an actual character for separator). \r\n\r\n\t- First `EXTRA_VANITY` bytes (fixed) may contain arbitrary proposer vanity data.\r\n\t- `ISTANBUL_EXTRA` bytes are the RLP encoded Istanbul extra data calculated from `RLP(IstanbulExtra)`, where `RLP()` is RLP encoding function, and `IstanbulExtra` is the Istanbul extra data. \r\n\t\t- `Validators`: The list of validators, which **must** be sorted in ascending order.\r\n\t\t- `Seal`: The proposer's signature sealing of the header.\r\n\t\t- `CommittedSeal`: The list of commitment signature seals as consensus proof.\r\n\r\n### Block hash, proposer seal, and committed seals\r\nThe Istanbul block hash calculation is different from the `ethash` block hash calculation due to the following reasons:\r\n\r\n1. The proposer needs to put proposer seal in `extraData` to prove the block is signed by the chosen proposer.\r\n2. The validators need to put `2F + 1` of committed seals as consensus proof in `extraData` to prove the block has gone through consensus.\r\n\r\nThe calculation is still similar to the `ethash` block hash calculation, with the exception that we need to deal with `extraData`. We calculate the fields as follows:\r\n\r\n##### Proposer seal calculation\r\nBy the time of proposer seal calculation, the committed seals are still unknown, so we calculate the seal with those unknowns empty. The calculation is as follows:\r\n\r\n- `Proposer seal`: `SignECDSA(Keccak256(RLP(Header)), PrivateKey)`\r\n- `PrivateKey`: Proposer's private key.\r\n- `Header`: Same as `ethash` header only with a different `extraData`.\r\n- `extraData`: `vanity | RLP(IstanbulExtra)`, where in the `IstanbulExtra`, `CommittedSeal` and `Seal` are empty arrays.\r\n\r\n##### Block hash calculation\r\nWhile calculating block hash, we need to exclude committed seals since that data is dynamic between different validators. Therefore, we make `CommittedSeal` an empty array while calculating the hash. The calculation is:\r\n\r\n- `Header`: Same as ethash header only with a different `extraData`.\r\n- `extraData`: `vanity | RLP(IstanbulExtra)`, where in the `IstanbulExtra`, `CommittedSeal` is an empty array.\r\n\r\n##### Consensus proof\r\nBefore inserting a block into the blockchain, each validator needs to collect `2F + 1` of committed seals from other validators to compose a consensus proof. Once it receives enough committed seals, it will fill the `CommittedSeal` in `IstanbulExtra`, recalculate the `extraData`, and then insert the block into the blockchain. **Note** that since committed seals can differ by different sources, we exclude that part while calculating the block hash as in the previous section.\r\n\r\nCommitted seal calculation: \r\n\r\nCommitted seal is calculated by each of the validator signing the hash along with `COMMIT_MSG_CODE` message code of its private key. The calculation is as follows:\r\n\r\n- `Committed seal`: `SignECDSA(Keccak256(CONCAT(Hash, COMMIT_MSG_CODE)), PrivateKey)`.\r\n- `CONCAT(Hash, COMMIT_MSG_CODE)`: Concatenate block hash and `COMMIT_MSG_CODE` bytes.\r\n- `PrivateKey`: Signing validator's private key.\r\n\r\n### Block locking mechanism\r\n\r\nLocking mechanism is introduced to resolve safety issues. In general, when a proposer is locked at certain height `H` with a block `B`, it can only propose `B` for height `H`. On the other hand, when a validator is locked, it can only vote on `B` for height `H`.\r\n\r\n#### Lock\r\nA lock `Lock(B, H)` contains a block and its height, which means its belonging validator is currently locked at certain block `B` and height `H`. In the following, we also use `+` to denote more than and `-` to denote less than. For example `+2/3` validators denotes more than two-thirds of validators, while `-1/3` validators denotes less than one-third of validators.\r\n\r\n#### Lock and unlock\r\n\r\n- Lock: A validator is locked when it receives `2F + 1` `PREPARE` messages on a block `B` at height `H`.\r\n- Unlock: A validator is unlocked at height `H` and block `B` when it fails to insert block `B` to blockchain.\r\n\r\n#### Protocol (`+2/3` validators are locked with `Lock(B,H)`)\r\n\r\n- `PRE-PREPARE`:\r\n    - **Proposer**: \r\n        - Case 1, proposer is locked: Broadcasts `PRE-PREPARE` on `B`, and enters `PREPARED` state.\r\n        - Case 2, proposer is not locked: Broadcasts `PRE-PREPARE` on block `B'`.\r\n    - **Validator**: \r\n        - Case 1, received `PRE-PREPARE` on existing block: Ignore.\r\n\t\t\t- Note: It will eventually lead to a round change, and the proposer will get the old block through synchronization.\r\n        - Case 2, validator is locked:\r\n            - Case 2.1, received `PRE-PREPARE` on `B`: Broadcasts `PREPARE` on `B`.\r\n            - Case 2.2, received `PRE-PREPARE` on `B'`: Broadcasts `ROUND CHANGE`.\r\n        - Case 3, validator is not locked:\r\n            - Case 3.1, received `PRE-PREPARE` on `B`: Broadcasts `PREPARE` on `B`. \r\n            - Case 3.2, received `PRE-PREPARE` on `B'`: Broadcasts `PREPARE` on `B'`.\r\n                - Note: This consensus round will eventually get into round change since `+2/3` are locked at `B` and which would lead to round change.\r\n\r\n- `PREPARE`:\r\n    - Case 1, validator is locked:\r\n        - Case 1.1, received `PREPARE` on `B`: Broadcasts `COMMIT` on `B`, and enters `PREPARED` state.\r\n            - Note: This shouldn't happen though, it should have skipped this step and entered `PREPARED` in `PRE-PREPARE` stage.\r\n        - Case 1.2, received `PREPARE` on `B'`: Ignore.\r\n            - Note: There shouldn't be `+1/3` `PREPARE` on `B'` since `+2/3` are locked at `B`. Thus the consensus round on `B'` will cause round change. Validator cannot broadcast `ROUND CHANGE` directly here since this `PREPARE` message can possibly from a faulty node.\r\n    - Case 2, validator is not locked:\r\n        - Case 2.1, received `PREPARE` on `B`: Waits for `2F + 1` `PREPARE` messages on `B`. \r\n            - Note: Most likely it will receive `2F + 1` `COMMIT` messages prior to receiving `2F + 1` `PREPARE` messages since there are `+2/3` validators being locked at `B`. In this case, it will jump to `COMMITTED` state directly.\r\n        - Case 2.2, received `PREPARE` on `B'`: Waits for `2F + 1` `PREPARE` message on `B'`. \r\n            - Note: This consensus will eventually get into round change since `+2/3` validators are locked on `B` and which would lead to round change.\r\n\r\n- `COMMIT`:\r\n    - Validator must be locked:\r\n        - Case 1, received `COMMIT` on `B`: Waits for `2F + 1` `COMMIT` messages.\r\n        - Case 2, received `COMMIT` on `B'`: Shouldn't happen.\r\n\r\n#### Locking cases\r\n\r\n- Round change:\r\n    - Case 1, `+2/3` are locked: \r\n        - If proposer is locked, it'd propose `B`.\r\n        - Else it'd propose `B'`, but which will lead to another round change.\r\n        - Conclusion: eventually `B` will be committed by honest validators.\r\n    - Case 2, `+1/3 ~ 2/3` are locked: \r\n        - If proposer is locked, it'd propose `B`.\r\n        - Else it'd propose `B'`. However, since `+1/3` are locked at `B`, no validators can ever receive `2F + 1` `PREPARE` on `B'`, meaning no validators can be locked at `B'`. Also those `+1/3` locked validators will not response to `B'` and eventually lead to round change.\r\n        - Conclusion: eventually `B` will be committed by honest validators.\r\n    - Case 3, `-1/3` are locked:\r\n        - If propose is locked, it'd propose `B`.\r\n        - Else it'd propose `B'`. If `+2/3` reach consensus on `B'`, those locked `-1/3` will get `B'` through synchronization and move to next height. Otherwise, there will be another round change.\r\n        - Conclusion: it can be `B` or other block `B'` be finally committed. \r\n\r\n- Round change caused by insertion failure:\r\n    - It will fall in one of the above round change cases. \r\n        - If the block is actually bad (cannot be inserted to blockchain), eventually `+2/3` validators will unlock block `B` at `H` and try to propose a new block `B'`. \r\n        - If the block is good (can be inserted to blockchain), then it would still be one of the above round change cases.\r\n\r\n- `-1/3` validators insert the block successfully, but others successfully trigger round change, meaning `+1/3` are still locked at `Lock(B,H)`\r\n    - Case 1, proposer has inserted `B`: Proposer will propose `B'` at `H'`, but `+1/3` are locked at `B`, so `B'` won't pass the consensus, which will eventually lead to round change. Other validators will either perform consensus on `B` or get `B` through synchronization.\r\n    - Case 2, proposer hasn't inserted `B`:\r\n        - Case 2.1, proposer is locked: Proposer proposes `B`.\r\n        - Case 2.2, proposer is not locked: Proposer will propose `B'` at `H`. The rest is the same as above case 1.\r\n\r\n- `+1/3` validators insert the block successfully, `-2/3` are trying to trigger round change at `H`.\r\n    - Case 1, proposer has inserted `B`: Proposer will propose `B'` at `H'`, but won't pass the consensus until `+1/3` get `B` through synchronization.\r\n    - Case 2, proposer has not inserted `B`:\r\n        - Case 2.1, proposer is locked: Proposer proposes `B`.\r\n        - Case 2.2, proposer is not locked: Proposer proposes `B'` at `H`. The rest is the same as above case 1.\r\n\r\n- `+2/3` validators insert the block successfully, `-1/3` are trying to trigger round change at `H`.\r\n    - Case 1, proposer has inserted `B`: proposer will propose `B'` at `H'`, which may lead to a successful consensus. Then those `-1/3` need to get `B` through synchronization.\r\n    - Case 2, proposer has not inserted `B`:\r\n        - Case 2.1, proposer is locked: Proposer proposes `B`.\r\n        - Case 2.2, proposer is not locked: Proposer proposes `B'` at `H`. Since `+2/3` have `B` at `H` already, this round would cause round change.\r\n\r\n### Gossip network\r\nTraditionally, validators need to be strongly connected in order to reach stable consensus results, which means all validators need to be connected directly to each other; however, in practical network environment, stable and constant p2p connections are hard to achieve. To resolve this issue, Istanbul BFT implements gossip network to overcome this constrain. In a gossip network environment, all validators only need to be weakly connected, which means any two validators are seen connected when either they are directly connected or they are connected with one or more validators in between. Consensus messages will be relayed between validators.\r\n\r\n### How to run\r\nRunning Istanbul BFT validators and nodes is similar to running the official node in a private chain. First of all, you need to initialize the data folder as:\r\n```\r\ngeth  --datadir \"/eth\" init \"/eth/genesis.json\"\r\n```\r\n\r\nThen,\r\nfor validators:\r\n```\r\ngeth --datadir \"/eth\" --mine --minerthreads 1 --syncmode \"full\"\r\n```\r\n\r\nfor regular nodes:\r\n```\r\ngeth --datadir \"/eth\"\r\n```\r\n\r\n**Note on `syncmode`**:\r\n`--syncmode  \"full\"` is required for the first set of validators to initialize a new network. Since we are using fetcher to insert blocks, if we don't set it to full mode, the fetcher cannot insert the first block. Please refer the following code in `eth/handler.go`.\r\n\r\n```go\r\ninserter := func(blocks types.Blocks) (int, error) {\r\n\t\t// If fast sync is running, deny importing weird blocks\r\n\t\tif atomic.LoadUint32(&manager.fastSync) == 1 {\r\n\t\t\tlog.Warn(\"Discarded bad propagated block\", \"number\", blocks[0].Number(), \"hash\", blocks[0].Hash())\r\n\t\t\treturn 0, nil\r\n\t\t}\r\n\t\tatomic.StoreUint32(&manager.acceptTxs, 1) // Mark initial sync done on any fetcher import\r\n\t\treturn manager.blockchain.InsertChain(blocks)\r\n}\r\n```\r\n\r\nThe sync mode affects only if there are some existing blocks, so there is no impact for initializing a new network.\r\n\r\nFor the later joined validators, we don't need to use full mode as they can get blocks by downloader. After the first sync from peers, they will automatically switch to full mode.\r\n\r\n#### Command line options\r\n```\r\n$geth help\r\n\r\nISTANBUL OPTIONS:\r\n  --istanbul.requesttimeout value  Timeout for each Istanbul round in milliseconds (default: 10000)\r\n  --istanbul.blockperiod value     Default minimum difference between two consecutive block's timestamps in seconds (default: 1)\r\n```\r\n\r\n#### Nodekey and validator\r\nTo be a validator, a node needs to meet the following conditions:\r\n\r\n- Its account (the address derived from its nodekey) needs to be listed in `extraData`'s validators section.\r\n- Use its nodekey as its private key to sign consensus messages.\r\n\r\n#### genesis.json\r\nTo run the Istanbul BFT chain, the `config` field is required, and the `pbft` subfield must present. Example as the following:\r\n```Javascript\r\n{\r\n  \"config\": {\r\n    \"chainId\": 2016,\r\n    \"istanbul\": {\r\n\t\t\"epoch\": 30000,\r\n\t\t\"policy\" 0,\r\n\t}\r\n  },\r\n  \"timestamp\": \"0x0\",\r\n  \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\r\n  \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f89af85494475cc98b5521ab2a1335683e7567c8048bfe79ed9407d8299de61faed3686ba4c4e6c3b9083d7e2371944fe035ce99af680d89e2c4d73aca01dbfc1bd2fd94dc421209441a754f79c4a4ecd2b49c935aad0312b8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\",\r\n  \"gasLimit\": \"0x47e7c4\",\r\n  \"mixhash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\",\r\n  \"coinbase\": \"0x3333333333333333333333333333333333333333\",\r\n  \"nonce\": \"0x0\",\r\n  \"difficulity\": \"0x0\",\r\n  \"alloc\": {}\r\n}\r\n```\r\n#### `extraData` tools\r\nWe've create a set of `extraData` coding tools in [istanbul-tools](https://github.com/getamis/Istanbul-tools) repository to help developers to manually generate `genesis.json`. \r\n\r\n**Encoding:**\r\nBefore encoding you need to define a toml file with `vanity` and `validators` fields to define proposer vanity and validator set. Please refer to [example.toml](https://raw.githubusercontent.com/getamis/istanbul-tools/master/cmd/istanbul/example/config.toml) for the example. The output would be a hex string which can be put into `extraData` field directly.\r\n\r\nCommand:\r\n```\r\nistanbul encode --config ./config.toml\r\n```\r\n\r\n**Decoding:**\r\nUse `--extradata` option to give the `extraData` hex string. The output would show the following if presents: vanity, validator set, seal, and committed seal.\r\n\r\nCommand:\r\n```\r\nistanbul decode --extradata <EXTRA_DATA_HEX_STRING>\r\n```\r\n\r\n### Ottoman testnet\r\nWe have setup a testnet for public testing. There are initially 4 validators and no designated faulty nodes. In the future, we want to extend it to 22 validators and setup few faulty nodes amongst them.\r\n\r\n#### Run testnet node\r\n\r\n```\r\ngeth --ottoman\r\n```\r\n\r\n#### Faulty node\r\nWe have implemented a simple [faulty node](https://github.com/getamis/go-ethereum/pull/99/) that can make a validator run faulty behaviors during consensus. There are five behaviors included in this implementation:\r\n\r\n- `NotBroadcast`: The validator doesn't broadcast any message.\r\n- `SendWrongMsg`: The validator sends out messages with wrong message codes.\r\n- `ModifySig`:  The validator modifies the message signatures.\r\n- `AlwaysPropose`: The validator always sends out proposals.\r\n- `AlwaysRoundChange`: The validator always sends `ROUND CHANGE` while receiving messages.\r\n- `BadBlock`: The validator proposes a block with bad body\r\n\r\nRun following command to enable faulty node:\r\n\r\n```\r\ngeth --istanbul.faultymode <MODE>\r\n```\r\n\r\nWhere the `<MODE>` can be the following number:\r\n\r\n- `0`: Disable faulty behaviors.\r\n- `1`: Randomly run any faulty behaviors.\r\n- `2`: `NotBroadcast`.\r\n- `3`: `SendWrongMsg`.\r\n- `4`: `ModifySig`.\r\n- `5`: `AlwaysPropose`.\r\n- `6`: `AlwaysRoundChange`.\r\n- `7`: `BadBlock`.\r\n\r\n\r\n## Background\r\n\r\nThe idea of implementing a byzantine fault tolerance (BFT) consensus came from the challenges we faced while building blockchain solutions for banks. We chose ethereum as the baseline protocol mostly because of its smart contract capability. However, the built-in consensus, proof of work or ethash, is not the ideal choice when settlement finality and minimum latency is required.\r\n\r\nBanking systems tend to form a private chain or consortium chain to run their applications. PBFT is ideal for these settings. These environments require a higher degree of manageability and higher throughput. In terms of scalability, validator scalability is not required. Many of the decentralization benefits of PoW in public chains become drawbacks in a private/consortium chain. On the other hand, designated validators in a PBFT environment maps well to private/consortium chains.\r\n\r\n## Remaining Tasks\r\n\r\n- **Testnet**: Currently the *Ottoman* testnet only has 4 validators. We'd like to extend it to 22 validator nodes and setup some faulty nodes amongst them (fewer than 7 faulty nodes).\r\n- **Weighted round robin**: This will require a redesign of the `extraData` field, but should be fairly straightforward.\r\n- **Remove or make block period configurable**: In certain setups, it may make sense to generate as many blocks as possible. Currently, the default value is 1 second. To remove this limitation, we will also need to adjust the original `worker.go` code.\r\n- **Benchmarking and stress testing**:  \r\n\t- Validator scalability.\r\n\t- Node scalability.\r\n\t- Transaction per second.\r\n- **Smarter way to detect faulty proposer**: A proposer can always generate empty blocks or small blocks without being acting faulty; however, this would impact the throughput of the network. We need to design better round change criteria to take into consideration those kind of performance related faulty behaviors.\r\n- **Formal proof of safety and liveness**.\r\n\r\n## Notes and discussions\r\n\r\n### Does it still make sense to use gas?\r\nYes. We still need gas to prevent infinite loops and any kind of EVM exhaustion. \r\n\r\n### Does it make sense to charge gas in a consortium chain?\r\nThe network would be vulnerable if every account has unlimited gas or unlimited transaction sending power. However, to enable so, one can run all validators with gas price flag `--gasprice 0` to accept gas price at zero.\r\n\r\n### Put consensus proof in the next block?\r\nCurrently our block header can be varied in `extraData` depending on its source validator because of the need to put consensus proof in the block header (by each validator). One way to resolve this is to put the proof in the next block. Therefore, in the proposing stage, the proposer can select `2F + 1` of commitment signatures of the previous block and put them in the current proposed block header. However, it would require each block to have one confirmation to reach finality (not instant finality). \r\n\r\n### Proof of lock\r\nInspired by *Tendermint*. We are still considering whether to add it to this EIP. Further efficiency benefits can be realized by reusing a current proposed block in a round change situation.\r\n\r\n## Contribution\r\nThe work was initiated and open sourced by the [Amis](https://am.is) team. We're looking for developers around the world to contribute. Please feel free to contact us: \r\n\r\n- [@alanchchen](https://github.com/alanchchen)\r\n- [@bailantaotao](https://github.com/bailantaotao)\r\n- [@markya0616](https://github.com/markya0616)\r\n- [@tailingchen](https://github.com/tailingchen)\r\n- [@yutelin](https://github.com/yutelin)\r\n## Forked repository (and original implementation branch)\r\n[https://github.com/getamis/go-ethereum/tree/feature/pbft](https://github.com/getamis/go-ethereum/tree/feature/pbft)\r\n\r\n## Clarifications and feedback\r\nTBD",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/650/reactions",
    "total_count": 65,
    "+1": 45,
    "-1": 0,
    "laugh": 0,
    "hooray": 3,
    "confused": 0,
    "heart": 17,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/650/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310873678",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-310873678",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 310873678,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDg3MzY3OA==",
    "user": {
      "login": "bobsummerwill",
      "id": 3788156,
      "node_id": "MDQ6VXNlcjM3ODgxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3788156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bobsummerwill",
      "html_url": "https://github.com/bobsummerwill",
      "followers_url": "https://api.github.com/users/bobsummerwill/followers",
      "following_url": "https://api.github.com/users/bobsummerwill/following{/other_user}",
      "gists_url": "https://api.github.com/users/bobsummerwill/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bobsummerwill/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bobsummerwill/subscriptions",
      "organizations_url": "https://api.github.com/users/bobsummerwill/orgs",
      "repos_url": "https://api.github.com/users/bobsummerwill/repos",
      "events_url": "https://api.github.com/users/bobsummerwill/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bobsummerwill/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-25T00:16:10Z",
    "updated_at": "2017-06-25T00:16:10Z",
    "author_association": "NONE",
    "body": "Fantastic work, guys!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310873678/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310972427",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-310972427",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 310972427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDk3MjQyNw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-26T06:17:15Z",
    "updated_at": "2017-06-26T06:17:15Z",
    "author_association": "MEMBER",
    "body": "Great work!\r\n\r\n> Block insertion fails\r\n\r\nCan you explain when block insertion might fail? I'm struggling to see why block insertion would ever fail for a valid proposal.\r\n\r\n>  Return transaction fee to sender\r\n\r\nWhy not just accept zero-gasprice transactions?\r\n\r\n> We have implemented a simple faulty node that can make a validator run faulty behaviors during consensus.\r\n\r\nHave you tried running the network with >=1/3 faulty nodes? If so, what does the result look like; what kinds of failures do you see in practice?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/310972427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311014169",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311014169",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311014169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTAxNDE2OQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-26T09:51:07Z",
    "updated_at": "2017-06-26T10:10:27Z",
    "author_association": "NONE",
    "body": "Thanks @vbuterin \r\n\r\n> Block insertion fails\r\n\r\nBefore actually inserting the block into the chain, the consensus only validates the block header. Inserting will do more checks so it can fail with other reasons.\r\n\r\n> Return transaction fee to sender\r\n\r\nYou're right. We've updated the EIP according.\r\n\r\n> testing >=1/3 faulty nodes?\r\n\r\nYes. \r\n- If there are more than 2/3 of faulty nodes, those faulty nodes can control the consensus. They can generate faulty blocks or keep running round change. \r\n- If there are more than 1/3 and less than 2/3 of faulty nodes, it will keep running round change and no consensus can be reached.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311014169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311030390",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311030390",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311030390,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTAzMDM5MA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-26T11:12:34Z",
    "updated_at": "2017-06-26T11:12:34Z",
    "author_association": "MEMBER",
    "body": "> If there are more than 1/3 and less than 2/3 of faulty nodes, it will keep running round change and no consensus can be reached.\r\n\r\nTheoretically it's also possible to finalize two conflicting blocks, if the proposer is one of the Byzantine nodes and makes two proposals and each get 2/3 prepares+commits. Though I guess that's fairly unlikely to happen in practice and so won't appear in that many random tests.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311030390/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311080050",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311080050",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311080050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTA4MDA1MA==",
    "user": {
      "login": "deanstef",
      "id": 29693466,
      "node_id": "MDQ6VXNlcjI5NjkzNDY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/29693466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/deanstef",
      "html_url": "https://github.com/deanstef",
      "followers_url": "https://api.github.com/users/deanstef/followers",
      "following_url": "https://api.github.com/users/deanstef/following{/other_user}",
      "gists_url": "https://api.github.com/users/deanstef/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/deanstef/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/deanstef/subscriptions",
      "organizations_url": "https://api.github.com/users/deanstef/orgs",
      "repos_url": "https://api.github.com/users/deanstef/repos",
      "events_url": "https://api.github.com/users/deanstef/events{/privacy}",
      "received_events_url": "https://api.github.com/users/deanstef/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-26T14:42:43Z",
    "updated_at": "2017-06-26T14:42:43Z",
    "author_association": "NONE",
    "body": "> Each validator enters PRE-PREPARED upon receiving the PRE-PREPARE message with the following conditions:\r\nBlock proposal is from the valid proposer.\r\n_**Block header is valid.**_\r\nBlock proposal's sequence and round match the validator's state.\r\n\r\nI know the meaning of block validity, but outside the PoW this is a little bit ambiguous. \r\nWhen a block is defined Valid or not without the proof-of-work?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311080050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311139609",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311139609",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311139609,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTEzOTYwOQ==",
    "user": {
      "login": "ice09",
      "id": 2828581,
      "node_id": "MDQ6VXNlcjI4Mjg1ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2828581?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ice09",
      "html_url": "https://github.com/ice09",
      "followers_url": "https://api.github.com/users/ice09/followers",
      "following_url": "https://api.github.com/users/ice09/following{/other_user}",
      "gists_url": "https://api.github.com/users/ice09/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ice09/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ice09/subscriptions",
      "organizations_url": "https://api.github.com/users/ice09/orgs",
      "repos_url": "https://api.github.com/users/ice09/repos",
      "events_url": "https://api.github.com/users/ice09/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ice09/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-26T18:17:00Z",
    "updated_at": "2017-06-26T18:17:00Z",
    "author_association": "NONE",
    "body": "> sequence number should be greater than all pervious sequence numbers.\r\n\r\npervious -> previous\r\n\r\nI like the structure, but for someone not accustomed to the terminology, `2F + 1` not defining up to section `constants` makes it more difficult to understand. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311139609/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311341721",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311341721",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311341721,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTM0MTcyMQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-27T12:22:39Z",
    "updated_at": "2017-06-27T12:22:39Z",
    "author_association": "NONE",
    "body": "@vbuterin\r\n\r\n> Theoretically it's also possible to finalize two conflicting blocks, if the proposer is one of the Byzantine nodes and makes two proposals and each get 2/3 prepares+commits. Though I guess that's fairly unlikely to happen in practice and so won't appear in that many random tests.\r\n\r\nYes, I think you are right. Suppose there are f+1 faulty nodes, f+f good nodes, and the propose is among the faulty nodes. The proposer can send first f good nodes A block and second f good nodes B block. Then both groups can receive 2f+1 of prepares+commits for block A and B respectively. Thus two conflicting blocks can be finalized.\r\n\r\n@deanstef\r\n> I know the meaning of block validity, but outside the PoW this is a little bit ambiguous. When a block is defined Valid or not without the proof-of-work?\r\n\r\nEach validator puts `2F+1` committed seals into the `extraData` field in block header before inserting the block into the chain, which is seen as the consensus proof of the associated block. `extraData` also contains proposer seal for validators to verify the block source during consensus (same mechanism as in Clique).\r\n\r\n@ice09\r\nThanks, we've updated this EIP accordingly.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311341721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311402164",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311402164",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311402164,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTQwMjE2NA==",
    "user": {
      "login": "deanstef",
      "id": 29693466,
      "node_id": "MDQ6VXNlcjI5NjkzNDY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/29693466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/deanstef",
      "html_url": "https://github.com/deanstef",
      "followers_url": "https://api.github.com/users/deanstef/followers",
      "following_url": "https://api.github.com/users/deanstef/following{/other_user}",
      "gists_url": "https://api.github.com/users/deanstef/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/deanstef/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/deanstef/subscriptions",
      "organizations_url": "https://api.github.com/users/deanstef/orgs",
      "repos_url": "https://api.github.com/users/deanstef/repos",
      "events_url": "https://api.github.com/users/deanstef/events{/privacy}",
      "received_events_url": "https://api.github.com/users/deanstef/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-27T15:53:38Z",
    "updated_at": "2017-06-27T15:53:38Z",
    "author_association": "NONE",
    "body": "> Each validator puts 2F+1 committed seals into the extraData field in block header before inserting the block into the chain, which is seen as the consensus proof of the associated block. extraData also contains proposer seal for validators to verify the block source during consensus (same mechanism as in Clique).\r\n\r\nGreat! I was a little confuse through Valid block and Consensus Proof, your response is helpful also for the meaning of validation in Clique. Thank you.\r\nNice work guys ! ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311402164/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311836076",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311836076",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311836076,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTgzNjA3Ng==",
    "user": {
      "login": "ebuchman",
      "id": 2300911,
      "node_id": "MDQ6VXNlcjIzMDA5MTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2300911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ebuchman",
      "html_url": "https://github.com/ebuchman",
      "followers_url": "https://api.github.com/users/ebuchman/followers",
      "following_url": "https://api.github.com/users/ebuchman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ebuchman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ebuchman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ebuchman/subscriptions",
      "organizations_url": "https://api.github.com/users/ebuchman/orgs",
      "repos_url": "https://api.github.com/users/ebuchman/repos",
      "events_url": "https://api.github.com/users/ebuchman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ebuchman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-29T01:23:05Z",
    "updated_at": "2017-06-29T01:23:05Z",
    "author_association": "NONE",
    "body": "> Round change timer expires.\r\n\r\nCan you clarify when this timer starts? Is there one timer for the whole round, like in PBFT (well, in PBFT the timer starts once the client request is received), or is there a new timer at each phase (pre-prepared, prepared, etc.) as the figure seems to suggest?\r\n\r\nUnless there is additional mechanism not described above (or perhaps I am just missing something), I think this protocol may have safety issues across round changes, as there does not seem to be anything stopping validators from committing a new block in a new round after others have committed in the previous round. This is what the \"locking\" mechanism in Tendermint addresses. In PBFT it's handled by broadcasting much more information during the round change. When you \"blockchainify\" PBFT, you can do away with this extra information if you're careful to introduce something like Tendermint's locking mechanism. I suspect that if you address these issues, you will end up with a protocol that is roughly identical (if not exactly identical) to Tendermint. Happy to discuss further and collaborate on this - great initiative!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311836076/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311932426",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-311932426",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 311932426,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTkzMjQyNg==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-29T10:55:25Z",
    "updated_at": "2017-06-29T10:55:25Z",
    "author_association": "NONE",
    "body": "@ebuchman\r\n> Can you clarify when this timer starts?\r\n\r\nYes, there is only one timer which is reset/triggered in every beginning of a new round.\r\n\r\n> safety issues across round changes\r\n\r\nYes, in some extreme cases there might be safety issues.  For example, say there is only one validator which receives `2F+1` commits but all the others do not. Then that validator would insert a valid block in to its chain while others would start a new round on the same block height. Eventually that might lead to conflict blocks.. We've put locking mechanism in the remaining tasks section. And yeah, we're looking forward to collaboration with Tendermint!\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/311932426/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312352847",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-312352847",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 312352847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjM1Mjg0Nw==",
    "user": {
      "login": "kumavis",
      "id": 1474978,
      "node_id": "MDQ6VXNlcjE0NzQ5Nzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1474978?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kumavis",
      "html_url": "https://github.com/kumavis",
      "followers_url": "https://api.github.com/users/kumavis/followers",
      "following_url": "https://api.github.com/users/kumavis/following{/other_user}",
      "gists_url": "https://api.github.com/users/kumavis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kumavis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kumavis/subscriptions",
      "organizations_url": "https://api.github.com/users/kumavis/orgs",
      "repos_url": "https://api.github.com/users/kumavis/repos",
      "events_url": "https://api.github.com/users/kumavis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kumavis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-30T19:22:19Z",
    "updated_at": "2017-06-30T19:22:19Z",
    "author_association": "MEMBER",
    "body": "Sticky proposer seems like it would be able to submit empty blocks or censorship transactions if it never passed through the RoundChange state. As long as they submit valid blocks, they can hold their Proposer role indefinitely.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312352847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312353809",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-312353809",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 312353809,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjM1MzgwOQ==",
    "user": {
      "login": "kumavis",
      "id": 1474978,
      "node_id": "MDQ6VXNlcjE0NzQ5Nzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1474978?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kumavis",
      "html_url": "https://github.com/kumavis",
      "followers_url": "https://api.github.com/users/kumavis/followers",
      "following_url": "https://api.github.com/users/kumavis/following{/other_user}",
      "gists_url": "https://api.github.com/users/kumavis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kumavis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kumavis/subscriptions",
      "organizations_url": "https://api.github.com/users/kumavis/orgs",
      "repos_url": "https://api.github.com/users/kumavis/repos",
      "events_url": "https://api.github.com/users/kumavis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kumavis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-30T19:27:09Z",
    "updated_at": "2017-06-30T19:27:09Z",
    "author_association": "MEMBER",
    "body": "> Blocks in Istanbul BFT protocol are final, which means that there are no forks and any valid block must be somewhere in the main chain.\r\n\r\nSeems like a strong claim considering there is no penalty to being a faulty node (e.g. voting on multiple forks)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312353809/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312401149",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-312401149",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 312401149,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjQwMTE0OQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-01T01:02:41Z",
    "updated_at": "2017-07-01T01:02:41Z",
    "author_association": "NONE",
    "body": "@kumavis\r\n\r\n> Faulty sticky proposer can keep generating empty valid blocks.\r\n\r\nYes, sticky proposer policy can lead to this issue. We've listed \"faulty propose detection\" in the remaining tasks section aiming to resolve it. One possible way is to switch to round robin policy whenever a validator sees an empty block. However, sticky proposer can still hack it by generating very small block every round.\r\n\r\n> Block finality and penalty on faulty node.\r\n\r\nDetecting faulty node deterministically is hard which makes penalize faulty nodes even harder. For simplicity, this PR doesn't dive into this topic. It might be worth looking in the follow up EIP and research.\r\nBlock finality is indeed a strong claim. In some rare case as @ebuchman pointed out, there might be safety issues. We listed it in remaining tasks section as well, and are looking to resolve it by introducing some kind of locking mechanism.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312401149/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312746668",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-312746668",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 312746668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjc0NjY2OA==",
    "user": {
      "login": "epoquehu",
      "id": 2750228,
      "node_id": "MDQ6VXNlcjI3NTAyMjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2750228?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/epoquehu",
      "html_url": "https://github.com/epoquehu",
      "followers_url": "https://api.github.com/users/epoquehu/followers",
      "following_url": "https://api.github.com/users/epoquehu/following{/other_user}",
      "gists_url": "https://api.github.com/users/epoquehu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/epoquehu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/epoquehu/subscriptions",
      "organizations_url": "https://api.github.com/users/epoquehu/orgs",
      "repos_url": "https://api.github.com/users/epoquehu/repos",
      "events_url": "https://api.github.com/users/epoquehu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/epoquehu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T22:58:04Z",
    "updated_at": "2017-07-03T22:58:20Z",
    "author_association": "NONE",
    "body": "Awesome work! Can you give us a sense of performance benchmark in terms of throughput and latency? Thanks!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312746668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312762428",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-312762428",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 312762428,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjc2MjQyOA==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T01:59:35Z",
    "updated_at": "2017-07-04T01:59:35Z",
    "author_association": "NONE",
    "body": "@epoquehu \r\n\r\n> Throughput and latency\r\n\r\nIn our preliminary testing result with 4 validators setup, the consensus time took around 10ms ~ 100ms, depending on how many transactions per block. In our testing, we allow each block to contain up to 2000 transactions.\r\nRegarding throughput, the transaction per second (TPS) ranges from 400 ~ 1200; however, there are still too many Geth factors that significantly affect the result. We are trying to fix some of them and workaround some of them as well.\r\nMore comprehensive benchmarking and stress testing is still in progress. Stay tuned!\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312762428/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317337871",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-317337871",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 317337871,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzMzNzg3MQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-24T07:11:11Z",
    "updated_at": "2017-07-24T07:11:11Z",
    "author_association": "NONE",
    "body": "Update: [68cbcf](https://github.com/ethereum/go-ethereum/pull/14674/commits/68cbcf98e0d25dc504e0d2ab7d9a9b30cf3a0e8e)\r\n- Add block locking mechanism.\r\n- Performance/bug fixes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317337871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319559781",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-319559781",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 319559781,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTU1OTc4MQ==",
    "user": {
      "login": "mawenpeng",
      "id": 6083011,
      "node_id": "MDQ6VXNlcjYwODMwMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083011?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mawenpeng",
      "html_url": "https://github.com/mawenpeng",
      "followers_url": "https://api.github.com/users/mawenpeng/followers",
      "following_url": "https://api.github.com/users/mawenpeng/following{/other_user}",
      "gists_url": "https://api.github.com/users/mawenpeng/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mawenpeng/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mawenpeng/subscriptions",
      "organizations_url": "https://api.github.com/users/mawenpeng/orgs",
      "repos_url": "https://api.github.com/users/mawenpeng/repos",
      "events_url": "https://api.github.com/users/mawenpeng/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mawenpeng/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-02T03:48:11Z",
    "updated_at": "2017-08-02T03:48:11Z",
    "author_association": "NONE",
    "body": "Is there any way to keep the nodekey (account private key) secured? Seems like it's left there unencrypted.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319559781/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/320838155",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-320838155",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 320838155,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDgzODE1NQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-08T03:11:50Z",
    "updated_at": "2017-08-08T03:11:50Z",
    "author_association": "NONE",
    "body": "Update: [0f066fb](https://github.com/ethereum/go-ethereum/pull/14674/commits/0f066fb0e5977635e543b2c8d008405c5abb734b)\r\n- Add gossip network",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/320838155/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/321491931",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-321491931",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 321491931,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTQ5MTkzMQ==",
    "user": {
      "login": "mikesmo",
      "id": 2193601,
      "node_id": "MDQ6VXNlcjIxOTM2MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2193601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mikesmo",
      "html_url": "https://github.com/mikesmo",
      "followers_url": "https://api.github.com/users/mikesmo/followers",
      "following_url": "https://api.github.com/users/mikesmo/following{/other_user}",
      "gists_url": "https://api.github.com/users/mikesmo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mikesmo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mikesmo/subscriptions",
      "organizations_url": "https://api.github.com/users/mikesmo/orgs",
      "repos_url": "https://api.github.com/users/mikesmo/repos",
      "events_url": "https://api.github.com/users/mikesmo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mikesmo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-10T08:51:41Z",
    "updated_at": "2017-08-10T08:51:41Z",
    "author_association": "NONE",
    "body": "Great work on developing Istanbul!\r\n\r\nOne comment on \"Does it still make sense to use gas?\"\r\n\r\nI've developed a testnet (using Ethermint) and modified the client to not charge gas. I wanted to bounce this idea of others to see whether this it is valid... \r\n\r\nTo avoid the infinite loop problem, the validators ensure the that smart contracts being published to the blockchain are sent from a small set of white-listed accounts. \r\n\r\nThese accounts are trusted by the consortium to only publish smart contracts that have gone through a strict review process.\r\n\r\nI suppose in the extreme edge case that a computationally expensive slipped through and was published by mistake, then the validators stop and rollback to before the event.\r\n\r\nDoes this sound reasonable? \r\n\r\nAppreciate any feedback on the faults with such an implementation.\r\n\r\nThanks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/321491931/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360085474",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-360085474",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 360085474,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDA4NTQ3NA==",
    "user": {
      "login": "stevenroose",
      "id": 853468,
      "node_id": "MDQ6VXNlcjg1MzQ2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stevenroose",
      "html_url": "https://github.com/stevenroose",
      "followers_url": "https://api.github.com/users/stevenroose/followers",
      "following_url": "https://api.github.com/users/stevenroose/following{/other_user}",
      "gists_url": "https://api.github.com/users/stevenroose/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stevenroose/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
      "organizations_url": "https://api.github.com/users/stevenroose/orgs",
      "repos_url": "https://api.github.com/users/stevenroose/repos",
      "events_url": "https://api.github.com/users/stevenroose/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stevenroose/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-24T10:20:37Z",
    "updated_at": "2018-01-24T10:20:37Z",
    "author_association": "NONE",
    "body": "The current implementation (as found in Quorum) breaks the concept of the \"pending\" block, used in several calls, but most notably in `eth_getTransactionCount` ([`PendingNonceAt`](https://godoc.org/github.com/obscuren/go-ethereum/ethclient#Client.PendingNonceAt) in `ethclient`):\r\n\r\nIn Ethereum, the pending block means the latest confirmed block + all pending transactions the node is aware of. This means that directly after a transaction is sent to the node (through RPC), the transaction count (aka nonce) in the \"pending\" block is increased. A lot of tools, like abigen in this repo or any other tool where tx signing occurs at the application level instead of in geth, rely on this for making multiple transactions at once. After the first one, the result of `eth_getTransactionCount` will increase so that a valid second tx can be crafted.\r\n\r\nWith the current implementation of Istanbul, the definition of the \"pending block\" seem to be different. When submitting a transaction, the result for `eth_getTransactionCount` for the sender in the \"pending\" block does not change. When a new block is confirmed (not containing this tx), it does change however (while the value for \"latest\" doesn't). Then, on the next block confirmation, the \"latest\" also changes because the tx is in the confirmed block.\r\n\r\nSo this seems to mean that the \"pending block\" definition changed from \"latest block + pending txs\" to \"the block that is currently being voted on\". I consider this a bug; if this is done on purpose, it breaks with a lot of existing applications (all users of abigen, f.e.) and should be reconsidered.\r\n\r\nI originally reported about this issue [in the Quorum repo](https://github.com/jpmorganchase/quorum/issues/247), but there doesn't seem to be a good place to report bugs in Istanbul other than here.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360085474/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362602334",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-362602334",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 362602334,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjYwMjMzNA==",
    "user": {
      "login": "Matthalp-zz",
      "id": 1238969,
      "node_id": "MDQ6VXNlcjEyMzg5Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1238969?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthalp-zz",
      "html_url": "https://github.com/Matthalp-zz",
      "followers_url": "https://api.github.com/users/Matthalp-zz/followers",
      "following_url": "https://api.github.com/users/Matthalp-zz/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthalp-zz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthalp-zz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthalp-zz/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthalp-zz/orgs",
      "repos_url": "https://api.github.com/users/Matthalp-zz/repos",
      "events_url": "https://api.github.com/users/Matthalp-zz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthalp-zz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-02T14:33:59Z",
    "updated_at": "2018-02-02T14:33:59Z",
    "author_association": "NONE",
    "body": "I'm sorry to disrupt the technical discussion here with a non-technical question: What is the intention for including this in the EIP repository? In particular I was wondering:\r\n\r\n(1) Is this proposal seeking public protocol adoption (it seems private chain focused, really at extending `quorum` with the aims of also moving upstream to `geth`)?\r\n(2) Does the scope of EIPs in this repository extend beyond public chain protocol improvements?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362602334/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/383017946",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-383017946",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 383017946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4MzAxNzk0Ng==",
    "user": {
      "login": "renuseabhaya",
      "id": 31244178,
      "node_id": "MDQ6VXNlcjMxMjQ0MTc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/31244178?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/renuseabhaya",
      "html_url": "https://github.com/renuseabhaya",
      "followers_url": "https://api.github.com/users/renuseabhaya/followers",
      "following_url": "https://api.github.com/users/renuseabhaya/following{/other_user}",
      "gists_url": "https://api.github.com/users/renuseabhaya/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/renuseabhaya/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/renuseabhaya/subscriptions",
      "organizations_url": "https://api.github.com/users/renuseabhaya/orgs",
      "repos_url": "https://api.github.com/users/renuseabhaya/repos",
      "events_url": "https://api.github.com/users/renuseabhaya/events{/privacy}",
      "received_events_url": "https://api.github.com/users/renuseabhaya/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-20T08:06:29Z",
    "updated_at": "2018-04-20T08:06:29Z",
    "author_association": "NONE",
    "body": "I have used set of extraData coding tools in istanbul-tools repository  to manually generate genesis.json & defined toml file too, but when i starts nodes, it throws error as \"Failed to decode message from payload\", err=\"unauthorized address\"",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/383017946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/385782111",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-385782111",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 385782111,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NTc4MjExMQ==",
    "user": {
      "login": "cvkonduru",
      "id": 27721208,
      "node_id": "MDQ6VXNlcjI3NzIxMjA4",
      "avatar_url": "https://avatars.githubusercontent.com/u/27721208?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cvkonduru",
      "html_url": "https://github.com/cvkonduru",
      "followers_url": "https://api.github.com/users/cvkonduru/followers",
      "following_url": "https://api.github.com/users/cvkonduru/following{/other_user}",
      "gists_url": "https://api.github.com/users/cvkonduru/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cvkonduru/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cvkonduru/subscriptions",
      "organizations_url": "https://api.github.com/users/cvkonduru/orgs",
      "repos_url": "https://api.github.com/users/cvkonduru/repos",
      "events_url": "https://api.github.com/users/cvkonduru/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cvkonduru/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-01T20:35:55Z",
    "updated_at": "2018-05-01T20:35:55Z",
    "author_association": "NONE",
    "body": "Fantastic work",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/385782111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399461869",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-399461869",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 399461869,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTQ2MTg2OQ==",
    "user": {
      "login": "osouza-de",
      "id": 7597013,
      "node_id": "MDQ6VXNlcjc1OTcwMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7597013?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osouza-de",
      "html_url": "https://github.com/osouza-de",
      "followers_url": "https://api.github.com/users/osouza-de/followers",
      "following_url": "https://api.github.com/users/osouza-de/following{/other_user}",
      "gists_url": "https://api.github.com/users/osouza-de/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osouza-de/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osouza-de/subscriptions",
      "organizations_url": "https://api.github.com/users/osouza-de/orgs",
      "repos_url": "https://api.github.com/users/osouza-de/repos",
      "events_url": "https://api.github.com/users/osouza-de/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osouza-de/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-22T14:29:11Z",
    "updated_at": "2018-06-22T14:29:11Z",
    "author_association": "NONE",
    "body": "Thank you guys very much for this great contribuition.\r\nI would like to know about the progress on it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399461869/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406907766",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-406907766",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 406907766,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjkwNzc2Ng==",
    "user": {
      "login": "michaelkunzmann-sap",
      "id": 37387267,
      "node_id": "MDQ6VXNlcjM3Mzg3MjY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/37387267?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelkunzmann-sap",
      "html_url": "https://github.com/michaelkunzmann-sap",
      "followers_url": "https://api.github.com/users/michaelkunzmann-sap/followers",
      "following_url": "https://api.github.com/users/michaelkunzmann-sap/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelkunzmann-sap/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelkunzmann-sap/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelkunzmann-sap/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelkunzmann-sap/orgs",
      "repos_url": "https://api.github.com/users/michaelkunzmann-sap/repos",
      "events_url": "https://api.github.com/users/michaelkunzmann-sap/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelkunzmann-sap/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T00:05:48Z",
    "updated_at": "2018-07-23T00:05:48Z",
    "author_association": "NONE",
    "body": "@renuseabhaya I had the same issue. My problem was that with Istanbul, you do not use a \"regular\" account (meaning, an account that you generate using ```geth account new```) to makes nodes validators. You need to use the node key and create an account from the node key.\r\n\r\n@yutelin Can you explain what the rationale was behind using an account address, derived from the node key, to identify validators instead of using the regular enode ID that is already being used for identifying nodes?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406907766/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406929769",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-406929769",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 406929769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjkyOTc2OQ==",
    "user": {
      "login": "yutelin",
      "id": 1516485,
      "node_id": "MDQ6VXNlcjE1MTY0ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1516485?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yutelin",
      "html_url": "https://github.com/yutelin",
      "followers_url": "https://api.github.com/users/yutelin/followers",
      "following_url": "https://api.github.com/users/yutelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/yutelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yutelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yutelin/subscriptions",
      "organizations_url": "https://api.github.com/users/yutelin/orgs",
      "repos_url": "https://api.github.com/users/yutelin/repos",
      "events_url": "https://api.github.com/users/yutelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yutelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T03:34:01Z",
    "updated_at": "2018-07-23T03:34:01Z",
    "author_association": "NONE",
    "body": "@michaelkunzmann-sap enode id is from node key.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406929769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407142580",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-407142580",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 407142580,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzE0MjU4MA==",
    "user": {
      "login": "michaelkunzmann-sap",
      "id": 37387267,
      "node_id": "MDQ6VXNlcjM3Mzg3MjY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/37387267?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelkunzmann-sap",
      "html_url": "https://github.com/michaelkunzmann-sap",
      "followers_url": "https://api.github.com/users/michaelkunzmann-sap/followers",
      "following_url": "https://api.github.com/users/michaelkunzmann-sap/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelkunzmann-sap/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelkunzmann-sap/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelkunzmann-sap/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelkunzmann-sap/orgs",
      "repos_url": "https://api.github.com/users/michaelkunzmann-sap/repos",
      "events_url": "https://api.github.com/users/michaelkunzmann-sap/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelkunzmann-sap/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T17:45:39Z",
    "updated_at": "2018-07-23T17:47:29Z",
    "author_association": "NONE",
    "body": "@yutelin Yes, correct. So currently we are using\r\n```\r\nistanbul.propose(\"0x23971dab0b29c27fa0de9226c45bef04d9f39156\", true)\r\n```\r\nWhere ```0x23971dab0b29c27fa0de9226c45bef04d9f39156``` is the \"address\" of the node to be permitted. As far as I understand, this address does not represent a regular account like we create with ```geth account new```, since it is derived from the node key: \r\n```\r\nnode_address = address(pub(node_key))\r\n```\r\n\r\nSince the enode id is also derived from the private node key (in its original purpose), is it possible to use the enode id instead of the address? This would save the extra step of generating an address from node key. \r\n```\r\nistanbul.propose(\"6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0\", true)\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407142580/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410983656",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-410983656",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 410983656,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDk4MzY1Ng==",
    "user": {
      "login": "drandreaskrueger",
      "id": 7796035,
      "node_id": "MDQ6VXNlcjc3OTYwMzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7796035?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/drandreaskrueger",
      "html_url": "https://github.com/drandreaskrueger",
      "followers_url": "https://api.github.com/users/drandreaskrueger/followers",
      "following_url": "https://api.github.com/users/drandreaskrueger/following{/other_user}",
      "gists_url": "https://api.github.com/users/drandreaskrueger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/drandreaskrueger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/drandreaskrueger/subscriptions",
      "organizations_url": "https://api.github.com/users/drandreaskrueger/orgs",
      "repos_url": "https://api.github.com/users/drandreaskrueger/repos",
      "events_url": "https://api.github.com/users/drandreaskrueger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/drandreaskrueger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T08:51:08Z",
    "updated_at": "2018-08-07T08:51:08Z",
    "author_association": "NONE",
    "body": "> Ottoman testnet\r\n> We have setup a testnet for public testing. There are initially 4 validators and no designated faulty nodes. In the future, we want to extend it to 22 validators and setup few faulty nodes amongst them.\r\n> Run testnet node\r\n> `geth --ottoman`\r\n\r\nI have tried that with the newest geth\r\n\r\n> geth version\r\n> Version: 1.8.14-unstable\r\n> Architecture: amd64\r\n> Go Version: go1.10.3\r\n> Operating System: linux\r\n\r\n\r\nbut I get a\r\n   \r\n> flag provided but not defined: -ottoman\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410983656/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410985581",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-410985581",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 410985581,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDk4NTU4MQ==",
    "user": {
      "login": "drandreaskrueger",
      "id": 7796035,
      "node_id": "MDQ6VXNlcjc3OTYwMzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7796035?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/drandreaskrueger",
      "html_url": "https://github.com/drandreaskrueger",
      "followers_url": "https://api.github.com/users/drandreaskrueger/followers",
      "following_url": "https://api.github.com/users/drandreaskrueger/following{/other_user}",
      "gists_url": "https://api.github.com/users/drandreaskrueger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/drandreaskrueger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/drandreaskrueger/subscriptions",
      "organizations_url": "https://api.github.com/users/drandreaskrueger/orgs",
      "repos_url": "https://api.github.com/users/drandreaskrueger/repos",
      "events_url": "https://api.github.com/users/drandreaskrueger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/drandreaskrueger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T08:57:31Z",
    "updated_at": "2018-08-07T08:57:31Z",
    "author_association": "NONE",
    "body": "So it is not yet part of vanilla geth? Only quorum?\r\n\r\nIn quorum the switch `--ottoman` is recognized:\r\n\r\n```\r\ngeth_quorum --ottoman\r\n\r\nWARN [08-07|09:50:51] No etherbase set and no accounts found as default \r\nINFO [08-07|09:50:51] Starting peer-to-peer node               instance=Geth/v1.7.2-stable-df4267a2/linux-amd64/go1.9.3\r\nINFO [08-07|09:50:51] Allocated cache and file handles         database=~/.ethereum/ottoman/geth/chaindata cache=128 handles=1024\r\nINFO [08-07|09:50:51] Writing custom genesis block \r\nINFO [08-07|09:50:51] Initialised chain configuration          config=\"{ChainID: 5 Homestead: 1 DAO: <nil> DAOSupport: true EIP150: 2 EIP155: 3 EIP158: 3 Byzantium: 9223372036854775807 IsQuorum: false Engine: istanbul}\"\r\nINFO [08-07|09:50:51] Initialising Ethereum protocol           versions=\"[63 62]\" network=5\r\nINFO [08-07|09:50:51] Loaded most recent local header          number=0 hash=22919a…075196 td=1\r\nINFO [08-07|09:50:51] Loaded most recent local full block      number=0 hash=22919a…075196 td=1\r\nINFO [08-07|09:50:51] Loaded most recent local fast block      number=0 hash=22919a…075196 td=1\r\nINFO [08-07|09:50:51] Regenerated local transaction journal    transactions=0 accounts=0\r\nINFO [08-07|09:50:51] Starting P2P networking \r\nINFO [08-07|09:50:53] UDP listener up                          self=enode://fe329f4395d30db66cced5d750fd4395993f66ccd08c703ea2653b78cdd364b76938e13d2ab8cc5129a295fdc0d43ecc1dfb9c408b24639bbe42dd1091333251@[::]:30303\r\nINFO [08-07|09:50:53] RLPx listener up                         self=enode://fe329f4395d30db66cced5d750fd4395993f66ccd08c703ea2653b78cdd364b76938e13d2ab8cc5129a295fdc0d43ecc1dfb9c408b24639bbe42dd1091333251@[::]:30303\r\nINFO [08-07|09:50:53] IPC endpoint opened: ~/.ethereum/ottoman/geth.ipc \r\n```\r\n\r\nbut then it does not sync. \r\n\r\nPlease update the hardcoded IP addresses of the bootnodes, or publish a script / list of current bootnodes. Thanks.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410985581/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413297784",
    "html_url": "https://github.com/ethereum/EIPs/issues/650#issuecomment-413297784",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/650",
    "id": 413297784,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzI5Nzc4NA==",
    "user": {
      "login": "alejoloaiza",
      "id": 26807886,
      "node_id": "MDQ6VXNlcjI2ODA3ODg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/26807886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alejoloaiza",
      "html_url": "https://github.com/alejoloaiza",
      "followers_url": "https://api.github.com/users/alejoloaiza/followers",
      "following_url": "https://api.github.com/users/alejoloaiza/following{/other_user}",
      "gists_url": "https://api.github.com/users/alejoloaiza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alejoloaiza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alejoloaiza/subscriptions",
      "organizations_url": "https://api.github.com/users/alejoloaiza/orgs",
      "repos_url": "https://api.github.com/users/alejoloaiza/repos",
      "events_url": "https://api.github.com/users/alejoloaiza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alejoloaiza/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-15T18:51:22Z",
    "updated_at": "2018-08-15T19:13:17Z",
    "author_association": "NONE",
    "body": "Hi, have some issues with block creation (Mining) using IBFT, I'm testing with 7 validator nodes, when I bring 4 nodes up wait some time (around 30 minutes) and then bring the 5th node up, there is no block creation after more than half an hour (another 30 minutes). now, if I bring all 5 nodes up at the same time block creation is happening normally.  What might be the issue? \r\n\r\nI have given more details here https://github.com/getamis/istanbul-tools/issues/113",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413297784/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
