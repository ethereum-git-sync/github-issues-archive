{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/48/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/48/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/48/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/48",
  "id": 123566680,
  "node_id": "MDU6SXNzdWUxMjM1NjY2ODA=",
  "number": 48,
  "title": "EVM 2/wasm 105",
  "user": {
    "login": "wanderer",
    "id": 158211,
    "node_id": "MDQ6VXNlcjE1ODIxMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wanderer",
    "html_url": "https://github.com/wanderer",
    "followers_url": "https://api.github.com/users/wanderer/followers",
    "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
    "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
    "organizations_url": "https://api.github.com/users/wanderer/orgs",
    "repos_url": "https://api.github.com/users/wanderer/repos",
    "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wanderer/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 16,
  "created_at": "2015-12-22T22:17:11Z",
  "updated_at": "2019-05-28T15:11:45Z",
  "closed_at": "2018-09-04T19:32:07Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# EVM 2.0\n## Abstract\n\nThis EIP proposes upgrading the VM by converting to use a subset of Webassembly (Wasm). Wasm is a new Assembly standard being built for the web. The main advantage of using wasm is performance (both speed and size). The main disadvantage would be the need to port our existing infrastructure to use a new ISA. Most of this EIP is taken from Wasm's [design docs](https://github.com/WebAssembly/design) which should be referenced for futher details.\n## Motivation\n\nTo truly distinguish Ethereum as the World Computer we need to have a performant VM. The current architecture of the VM is one of the greatest blockers to raw performance. Being stack-based and the 256-bit word size make translation from EVM opcodes to hardware instructions more difficult than needed.\n\nWith an architecture that provides a closer mapping to hardware the VM will have a considerably enhanced performance which will effectively open the door to a much wider array of uses that require a much higher performance/throughput. Also, by choosing a common and more standardized architecture anyone will be able to compile C/C++, Solidity (, etc.) once, and the compiled code will run in multiple environments. Using the new Assembly standard will make running a program either directly on Ethereum, on a cloud hosting environment, or on one's local machine - a friction-less process.\n## Specification\n\nWasm is a kin to LLVM IR and Low Level Instruction Set Architectures (ISAs).  It is an defined as an Abstract Syntax Tree (AST) which has a [textual representation using s-expressions](https://github.com/WebAssembly/design/blob/master/TextFormat.md#official-text-format).  As an  AST it has some higher level semantics than pure hardware ISAs. Including functions and basic flow control. Wasm is not finished a specification and still in flux. This EIP suggest using a subset of wasm to allow us to tailor the semantics to Ethereum. This spec is designed so that the minimum amount of changes a wasm VM would need to be implemented. This should make existing implementations of wasm easy to integrate and provide a way to run Ethereum flavored wasm on a unmodified wasm VM.\n\nA Wasm  module expressed in  s-expressions looks like\n\n```\n(module\n  (func $add (param $x i64) (param $y i64) (result i64) (i64.add (get_local $x) (get_local $y)))\n  (func $sub (param $x i64) (param $y i64) (result i64) (i64.sub (get_local $x) (get_local $y)))\n\n  (export \"add\" $add)\n  (export \"sub\" $sub)\n  )\n```\n\nEth Flavored wasm\n\n```\n(module\n  (func $add (param $x) (param $y) (result) (add (get_local $x) (get_local $y)))\n  (func $sub (param $x) (param $y) (result) (sub (get_local $x) (get_local $y)))\n\n  (export \"add\" $add)\n  (export \"sub\" $sub)\n)\n```\n\nFor Ethereum we can  consider each contract as a module therefore we can have an intrinsic modules and we do not need to specify the module’s closure (we leave it now for clarity). Furthermore if we restrict the types to 64 bit then we can eliminate the type information from the locals definition. \n### Difference from WASM\n- A local variable limit\n- Metering\n- Shared memory for `call` returns\n- Limit types and functions to i64\n- No Datatype conversion\n- No select op\n- No comma op\n- No conditional op\n- No need for a explicit module definition\n### Metering\n\nMetering can initial be accomplished by injecting the counting code into the AST then passing the modified AST to a wasm VM. Modifying the AST is done by traversing the AST and adding a gas check immediately after each branch condition and at the start of functions and loops. For a more performant  version gas counting could possibly be done at the VM directly. But from [initial trials](https://github.com/wanderer/eth2wasm) injecting gas at the AST level does not greatly affect performance. Since the gas counting code must be protected it would have to be implemented in a separate module. \n### Ethereum Specific Opcodes\n- call_delegate\n- call_code\n- create \n- gas\n- logs \n- suicide\n- environmental information (blockhash, coinbase, etc)\n- general module imports\n\nThe above opcodes should be used with WASM's call.  `call_delegate` would become `call $call_delegate <params>` and so on.\n\n> The open-ended nature of module imports allow them to be used to expose arbitrary host environment functionality to WebAssembly code, similar to a native syscall. For example, a shell environment could define a builtin stdio module with an export puts. [referance](https://github.com/WebAssembly/design/blob/87bf5b62988eb500583b61b04803264e6c796264/Modules.md#imports-and-exports)\n\nWhether the module system could be used for contracts in general is an open questions. For now we will not use it in favor of using the `CALL`, `CALLCODE` and `CALLDELEGATE` semantics. This could be revisited once wasm has support for runtime `dlopen` like [dynamic linking](https://github.com/WebAssembly/design/blob/f8227ec6a139ca46f6570343cce583e4a0c51ad6/DynamicLinking.md).\n### Modified Ethereum operations\n\nElimination of `PUSH`, `DUP`, `SWAP`, `POP`, `PUSH`, `JUMP`, `JUMPI`\n\n`SUICIDE`, `CALL`, `CALLCODE`, `CALLDELEGATE` now gets the `to` address from memory and are expressions.\n### note on CALLs\n\nThe module loading system can’t yet support `call` since exported function are only allowed to return one  value and do not have shared memory access. When implementing `SUICIDE`, `CALL`, `CALLCODE`, `CALLDELEGATE` the host environment will have to load the return values into the specified location in linear memory. \n## Abstract Syntax Tree Semantics\n\nFor the current full definition [see here](https://github.com/WebAssembly/design/blob/master/AstSemantics.md) I’m only going to post here the core semantics that we are intersted in. For more details see the accompanying wiki. A formal spec such for each opcode will be  worked  out if this EIP  gains Momentum. Currently this EIP suggests limiting the functions to only 64 bit Integer operations.\n### Internal Function Calls\n\nEach function has a signature, which consists of: Return types, which are a sequence of value types Argument types, which are a sequence of value types \n\nWebAssembly doesn't support variable-length argument lists (aka varargs). Compilers targeting WebAssembly can instead support them through explicit accesses to linear memory. The length of the return types sequence may only be 0 or 1\n\nDirect calls to a function specify the callee by index into a main function table.\n- call_func: call function directly\n  A direct call to a function with a mismatched signature is a module verification error.\n### Integer Operations\n- `add`: sign-agnostic addition\n- `sub`: sign-agnostic subtraction\n- `mul`: sign-agnostic multiplication (lower 32-bits)\n- `div_s`: signed division (result is truncated toward zero)\n- `div_u`: unsigned division (result is floored)\n- `rem_s`: signed remainder (result has the sign of the dividend)\n- `rem_u`: unsigned remainder\n- `and`: sign-agnostic bitwise and\n- `or`: sign-agnostic bitwise inclusive or\n- `xor`: sign-agnostic bitwise exclusive or\n- `shl`: sign-agnostic shift left\n- `shr_u`: zero-replicating (logical) shift right\n- `shr_s`: sign-replicating (arithmetic) shift right\n- `eq`: sign-agnostic compare equal\n- `ne`: sign-agnostic compare unequal\n- `lt_s`: signed less than\n- `le_s`: signed less than or equal\n- `lt_u`: unsigned less than\n- `le_u`: unsigned less than or equal\n- `gt_s`: signed greater than\n- `ge_s`: signed greater than or equal\n- `gt_u`: unsigned greater than\n- `ge_u`: unsigned greater than or equal\n- `clz`: sign-agnostic count leading zero bits (All zero bits are considered leading if the value is zero)\n- `ctz`: sign-agnostic count trailing zero bits (All zero bits are considered trailing if the value is zero)\n- `popcnt`: sign-agnostic count number of one bits\n### Flow Control\n- `block`: a fixed-length sequence of expressions with a label at the end. \n- `loop`: a block with an additional label at the beginning which may be used to form loops\n- `br`: branch to a given label in an enclosing construct\n- `br_if`: conditionally branch to a given label in an enclosing construct\n- `get_reg`: gets a register. We constrain registers to be one byte. Therefor we have 255 registers\n- `store_reg`: stores a register.\n\nThe `br` and `br_if` constructs express low-level branching. Branches that exit a block or loop may take a subexpression that yields a value for the exited construct. Branches may only reference labels defined by an outer enclosing construct. This means that, for example, references to a block's label can only occur within the block's body. In practice, outer blocks can be used to place labels for any given branching pattern, except for one restriction: one can't branch into the middle of a loop from outside it. This restriction ensures all control flow graphs are well-structured\n- `unreachable`: An expression which can take on any type, and which, if executed, always traps. It is intended to be used for example after calls to functions which are known by the producer not to return (otherwise the producer would have to create another expression with an unused value to satisfy the type check). This trap is intended to be impossible for user code to catch or handle, even in the future when it may be possible to handle some other kinds of traps or exceptions.\n### [Linear Memory](https://github.com/WebAssembly/design/blob/master/AstSemantics.md#linear-memory)\n\nThe main storage of a WebAssembly instance, called the _linear memory_, is a contiguous, byte-addressable range of memory spanning from offset `0` and extending for `memory_size` bytes which can be dynamically grown by [`grow_memory`](https://github.com/WebAssembly/design/blob/master/AstSemantics.md#resizing). The linear memory can be considered to be an untyped array of bytes, and it is unspecified how embedders map this array into their process' own [virtual memory](https://en.wikipedia.org/wiki/Virtual_memory). The linear memory is sandboxed; it does not alias the execution engine's internal data structures, the execution stack, local variables, or other process memory. The initial state of linear memory is specified by the [module](https://github.com/WebAssembly/design/blob/master/Modules.md#linear-memory-section).\n### Linear Memory Accesses\n\nLinear memory access is accomplished with explicit load and store operators. Integer loads can specify a storage size which is smaller than the result type as well as a signedness which determines whether the bytes are sign- or zero- extended into the result type.\n- `load8_s`: load 1 byte and sign-extend i8 to i32\n- `load8_u`: load 1 byte and zero-extend i8 to i32\n- `load16_s`: load 2 bytes and sign-extend i16 to i32\n- `load16_u`: load 2 bytes and zero-extend i16 to i32\n- `load`: load 4 bytes as i32\n\nStores have an additional input operand which is the value to store to memory. Like loads, integer stores may specify a smaller storage size than the operand size in which case integer wrapping is implied.\n- `store8`: wrap i64 to i8 and store 1 byte\n- `store16`: wrap i64 to i16 and store 2 bytes\n- `store32`: wrap i64 to i32 and store 4 bytes\n- `store`: (no conversion) store 8 bytes\n### Local variables\n\nEach function has a fixed, pre-declared number of local variables which occupy a single index space local to the function. Parameters are addressed as local variables. Local variables do not have addresses and are not aliased by linear memory. Local variables have value types and are initialized to the appropriate zero value for their type at the beginning of the function, except parameters which are initialized to the values of the arguments passed to the function. Local variables can be  thought of as registers\n- `get_local`: read the current value of a local variable\n- `set_local`: set the current value of a local variable\n### [Module start function](https://github.com/WebAssembly/design/blob/master/Modules.md#module-start-function)\n\nIf the module has a start node defined, the function it refers should be called\nby the loader after the instance is initialized and before the exported functions\nare called.\n- The start function must not take any arguments or return anything\n- The function can also be exported\n- There can only be at most one start node per module\n\nFor example, a start node in a module will be:\n\n`(start $start_function)`\n\nor\n\n`(start 0)`\n\nIn the first example, the environment is expected to call the function $start_function\nbefore calling any other module function. In the second case, the environment is\nexpected to call the module function indexed 0.\n\nA module can:\n- Only have at most a start node\n- If a module contains a start node, the function must be defined in the module\n- The start function will be called after module loading and before any call to the module\n  function is done\n### Binary Specification\n\nFurther attention to the binary encode can be tracked here. Currently wasm only has an early [binary encoding spec](https://docs.google.com/document/d/1-G11CnMA0My20KI9D7dBR6ZCPOBCRD0oCH6SHCPFGx0/edit?pref=2&pli=1).\nIts ends up being fairly easy to follow. But not all of the features are relevant to Ethereum so some iteration can be done there. An overview of binary encoding can be seen [here](https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md).\n## Rationale\n- Faster. [Here are the benchmarks results](https://github.com/wanderer/wasm-to-llvm-prototype/blob/master/results.md). The benchmarks are based of off [wasm-to-llvm-prototype](https://github.com/WebAssembly/wasm-to-llvm-prototype). It compares a Wasm JIT based on LLVM to a EVM JIT which is also uses LLVM.\n- Maybe Smaller.  Using the code from the benchmarks I compared the binary size. The results are that WASM was 29% smaller. But there is not enough real world data to be confident of this result. Also It compares handwritten WASM to EVM generated by solidity. \n- Toolchain Compatibility. LLVM front-end.\n- A large development base. It is being developed by Mozilla, Google, Microsoft, and Apple. Wasm is already in the Chromium's code base and is targeted to be deployed in all the major web browsers. Which would result in it being one of the most widely deployed VM architecture.\n- Furthermore some of Wasm's top [design goals](https://github.com/WebAssembly/design/blob/master/HighLevelGoals.md) are largely applicable to Ethereum  \n\n> Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.\n### Detailed Rationale\n#### Rationale For Registered Based ISA.\n- Register-based virtual machines are more like actual hardware.\n- Easier to JIT\n- Although most early computers used stack or accumulator-style architectures, virtually every new architecture designed after 1980 uses a load-store register architecture. The major reasons for the emergence of general-purpose register (GPR) computers are twofold. First, registers—like other forms of storage internal to the processor—are faster than memory. Second, registers are more efficient for a compiler to use than other forms of internal storage. For example, on a register computer the expression (A \\* B) – (B \\* C) – (A \\* D) may be evaluated by doing the multiplications in any order, which may be more efficient because of the location of the operands or because of pipelining concerns. Nevertheless, on a stack computer the hardware must evaluate the expression in only one order, since operands are hidden on the stack, and it may have to load an operand multiple times. More importantly, registers can be used to hold variables. When variables are allocated to registers, the memory traffic reduces, the program speeds up (since registers are faster than memory), and the code density improves (since a register can be named with fewer bits than can a memory location). [Reference](http://www.cpp.edu/~kding/materials/Computer%20Architecture%20A%20Quantitative%20Approach%20%285th%20edition%29.pdf) \n-  (Java is stack based.) \"Java byte-codes have additional disadvantages. Directly mapping byte-codes onto the underlying architecture is much more difficult than generating machine instructions from an abstract syntax-tree. Code generators that are based on a high-level representation do not have to deal with unfavorable peculiarities of Java byte-codes but can tailor their output towards advanced and specific processor features, such as special purpose instructions, size of register sets, and cache architectures. This is especially true for today's most common RISC processors which are less suited for byte-code's heavily used stack operations. Reference ftp://ftp.cis.upenn.edu/pub/cis700/public_html/papers/Kistler96.pdf\n- [The design of the Inferno virtual machine](http://herpolhode.com/rob/hotchips.html)\n- [Virtual Machine Showdown: Stack Versus Registers](http://static.usenix.org/events/vee05/full_papers/p153-yunhe.pdf)\n#### AST\n- compression benefits \"use predictive compression algorithm that allows to encode recurring sub expressions in a program space efficiently while facilitating also fast decoding with simultaneous code-generation. Our compression scheme is based on adaptive methods such as LZW but has been tailored towards encoding abstract syntax trees rather than character streams. It takes advantage of the limited scope of variables in programming languages,which allows to deterministically prune entries from the compression dictionary, and uses prediction heuristics to achieve a denser encoding.\" Reference ftp://ftp.cis.upenn.edu/pub/cis700/public_html/papers/Franz97b.pdf\n- JITing benefits.\n- [Notes on better JIT compilers using AST](http://central.kaserver5.org/Kasoft/Typeset/JavaTree/Pt06.html#Head363)\n#### 64-bit vs 256-bit\n\nA 64 bit word size would map to real world hardware. Most the time we don’t need 256 bit arithmetic. 256 was chosen to work with 256-bit hashes but we can easily store hash results in memory. Some opcodes such as CALL would have to load the to address from memory. \n## Implementation\n\nWhile the complete EIP is not implemented many pieces of it are. \n- [EVM vs C vs wasm Benchmarks](https://github.com/wanderer/wasm-to-llvm-prototype)\n- [Test Gas injection script](https://github.com/wanderer/eth2wasm). \n\nThere are several Wasm implementations; here are a few.\n- [wasm-to-llvm-prototype](https://github.com/WebAssembly/wasm-to-llvm-prototype)\n- [wasm-jit-prototype; Another LLVM based prototype](https://github.com/WebAssembly/wasm-jit-prototype)\n- [the reference implemention in Ocmal](https://github.com/WebAssembly/spec)\n## References\n- [wams's design docs](https://github.com/WebAssembly/design)\n- [chrome's binary encoding](https://docs.google.com/document/d/1-G11CnMA0My20KI9D7dBR6ZCPOBCRD0oCH6SHCPFGx0/edit?pref=2&pli=1)\n- A Tree-Based Alternative to Java Byte-Code - ftp://ftp.cis.upenn.edu/pub/cis700/public_html/papers/Kistler96.pdf\n- [JavaTrees](http://central.kaserver5.org/Kasoft/Typeset/JavaTree/Pt06.html#Head363)\n- Adaptive Compression of Syntax Trees and Iterative Dynamic Code Optimization: Two Basic Technologies for Mobile-Object Systems -ftp://ftp.cis.upenn.edu/pub/cis700/public_html/papers/Franz97b.pdf\n- [Virtual Machine Showdown: Stack Versus Registe](http://static.usenix.org/events/vee05/full_papers/p153-yunhe.pdf)\n- [Computer Architecture A Quantitative Approach (5th edition)](http://www.cpp.edu/~kding/materials/Computer%20Architecture%20A%20Quantitative%20Approach%20%285th%20edition%29.pdf)\n",
  "closed_by": {
    "login": "Souptacular",
    "id": 3460120,
    "node_id": "MDQ6VXNlcjM0NjAxMjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3460120?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Souptacular",
    "html_url": "https://github.com/Souptacular",
    "followers_url": "https://api.github.com/users/Souptacular/followers",
    "following_url": "https://api.github.com/users/Souptacular/following{/other_user}",
    "gists_url": "https://api.github.com/users/Souptacular/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Souptacular/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Souptacular/subscriptions",
    "organizations_url": "https://api.github.com/users/Souptacular/orgs",
    "repos_url": "https://api.github.com/users/Souptacular/repos",
    "events_url": "https://api.github.com/users/Souptacular/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Souptacular/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/48/reactions",
    "total_count": 2,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/48/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/166751898",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-166751898",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 166751898,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Njc1MTg5OA==",
    "user": {
      "login": "CJentzsch",
      "id": 8452011,
      "node_id": "MDQ6VXNlcjg0NTIwMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8452011?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CJentzsch",
      "html_url": "https://github.com/CJentzsch",
      "followers_url": "https://api.github.com/users/CJentzsch/followers",
      "following_url": "https://api.github.com/users/CJentzsch/following{/other_user}",
      "gists_url": "https://api.github.com/users/CJentzsch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CJentzsch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CJentzsch/subscriptions",
      "organizations_url": "https://api.github.com/users/CJentzsch/orgs",
      "repos_url": "https://api.github.com/users/CJentzsch/repos",
      "events_url": "https://api.github.com/users/CJentzsch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CJentzsch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-22T22:32:09Z",
    "updated_at": "2015-12-22T22:32:09Z",
    "author_association": "NONE",
    "body": "All upgrades must be downwardly compatible. How do you ensure that old contracts will still run the same way?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/166751898/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/166754723",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-166754723",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 166754723,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Njc1NDcyMw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-22T22:46:48Z",
    "updated_at": "2015-12-22T22:46:48Z",
    "author_association": "MEMBER",
    "body": "@CJentzsch You would have to transcompile all the existing EVM code to WASM.  Something like this has been done before with the EVM JIT. Except that it targeted LLVM IR. There are a couple of opcodes that are not backwards compatible. `gas` and `PC` might have a different expected values  \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/166754723/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/167975466",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-167975466",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 167975466,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Nzk3NTQ2Ng==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-30T10:43:23Z",
    "updated_at": "2015-12-30T10:43:23Z",
    "author_association": "MEMBER",
    "body": "Although this idea does have its merits, I honestly don't think this will ever happen. We've just launched Ethereum and the EVM, and even getting a single opcode added to it is a horribly painful and error prone procedure. By replacing the entire EVM we might as well just launch a new network from scratch. I don't think we could rationalize any speed increases with the enormous costs associated with implementing the proposed WASM based VM in all official languages, battle testing that they work and also potentially having them audited.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/167975466/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/168014527",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-168014527",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 168014527,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODAxNDUyNw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-30T14:53:55Z",
    "updated_at": "2015-12-30T14:53:55Z",
    "author_association": "MEMBER",
    "body": "@karalabe yep that is the key question. C++ wouldn't have much to implement since they would just have to wrap Intel's JIT. But it might be a lot of work for go and Python. Lucky WASM is taking a similar approach to testing as us. They have a standalone test repo that all implementation must pass. We wouldn't be doing everything from scratch.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/168014527/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/168900536",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-168900536",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 168900536,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODkwMDUzNg==",
    "user": {
      "login": "bobsummerwill",
      "id": 3788156,
      "node_id": "MDQ6VXNlcjM3ODgxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3788156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bobsummerwill",
      "html_url": "https://github.com/bobsummerwill",
      "followers_url": "https://api.github.com/users/bobsummerwill/followers",
      "following_url": "https://api.github.com/users/bobsummerwill/following{/other_user}",
      "gists_url": "https://api.github.com/users/bobsummerwill/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bobsummerwill/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bobsummerwill/subscriptions",
      "organizations_url": "https://api.github.com/users/bobsummerwill/orgs",
      "repos_url": "https://api.github.com/users/bobsummerwill/repos",
      "events_url": "https://api.github.com/users/bobsummerwill/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bobsummerwill/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-05T05:15:46Z",
    "updated_at": "2016-01-05T05:15:46Z",
    "author_association": "NONE",
    "body": "@wanderer Is there something specific to WASM which makes it a better fit than just using LLVM IR, which is already defined, and becoming very close to being a universal AST standard?\n\nIf it was feasible to use LLVM IR as the target then all the numerous existing LLVM backends could be used off-the-shelf (C++, C#, JS, and many more) right now, and you would still be able to target WASM as-and-when that settles down.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/168900536/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169019813",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-169019813",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 169019813,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTAxOTgxMw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-05T14:44:19Z",
    "updated_at": "2016-01-05T21:20:44Z",
    "author_association": "MEMBER",
    "body": "@bobsummerwill I actually compiled some notes on this subject. Here the are. Let me know if you have anymore questions!\n\nFrom LLVM Language Reference:\n\n> The LLVM code representation is designed to be used in three different forms: as an in-memory compiler IR, as an on-disk bitcode representation (suitable for fast loading by a Just-In-Time compiler), and as a human readable assembly language representation.\n\nGood\n- very tested \n- large community\n- was used by googles PNACL\n- widely deployed\n\nBad\n- not intrinsically portable\n- not stable\n- lage surface (ISA) that VM implementors would have to deal with\n\nResponse from Derek Schuff (one of the engineers for pNACL) from google on WASM vs LLVM\n\n> I'm guessing you are unfamiliar with PNaCl. This is more or less the approach taken by PNaCl; i.e. use LLVM as the starting point for a wire format. It turns out that LLVM IR/bitcode by itself is neither portable nor stable enough to be used for this purpose, and  it is designed for compiler optimizations, it has a huge surface area, much more than is needed for this purpose. PNaCl solves these problems by defining a portable target triple (an architecture called \"le32\" used instead of e.g. i386 or arm), a subset of LLVM IR, and a stable frozen wire format based on LLVM's bitcode. So this approach (while not as simple as \"use LLVM-IR directly\") does work. However LLVM's IR and bitcode formats were designed (respectively) for use as a compiler IR and for temporary file serialization for link-time optimization. They were not designed for the goals we have, in particular a small compressed distribution format and fast decoding. We think we can do much better for wasm, with the experience we've gained from PNaCl\n\nFurther research on LLVM\nLLVM IR is meant to make compiler optimizations easy to implement, and to represent the constructs and semantics required by C, C++, and other languages on a large variety of operating systems and architectures. This means that by default the IR is not portable (the same program has different representations for different architectures) or stable (it changes over time as optimization and language requirements change). It has representations for a huge variety of information that is useful for implementing mid-level compiler optimizations but is not useful for code generation (but which represents a large surface area for codegen implementers to deal with). It also has undefined behavior (largely similar to that of C and C++) which makes some classes of optimization feasible or more powerful, but which can lead to unpredictable behavior at runtime. LLVM's binary format (bitcode) was designed for temporary on-disk serialization of the IR for link-time optimization, and not for stability or compressibility (although it does have some features for both of those).\n\nNone of these problems are insurmountable. For example PNaCl defines a small portable subset of the IR with reduced undefined behavior, and a stable version of the bitcode encoding. It also employs several techniques to improve startup performance. However, each customization, workaround, and special solution means less benefit from the common infrastructure\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169019813/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169135268",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-169135268",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 169135268,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTEzNTI2OA==",
    "user": {
      "login": "bobsummerwill",
      "id": 3788156,
      "node_id": "MDQ6VXNlcjM3ODgxNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3788156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bobsummerwill",
      "html_url": "https://github.com/bobsummerwill",
      "followers_url": "https://api.github.com/users/bobsummerwill/followers",
      "following_url": "https://api.github.com/users/bobsummerwill/following{/other_user}",
      "gists_url": "https://api.github.com/users/bobsummerwill/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bobsummerwill/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bobsummerwill/subscriptions",
      "organizations_url": "https://api.github.com/users/bobsummerwill/orgs",
      "repos_url": "https://api.github.com/users/bobsummerwill/repos",
      "events_url": "https://api.github.com/users/bobsummerwill/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bobsummerwill/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-05T21:12:01Z",
    "updated_at": "2016-01-05T21:12:01Z",
    "author_association": "NONE",
    "body": "Thanks for the excellently detailed answer, @wanderer!\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169135268/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169742520",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-169742520",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 169742520,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTc0MjUyMA==",
    "user": {
      "login": "chfast",
      "id": 573380,
      "node_id": "MDQ6VXNlcjU3MzM4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573380?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chfast",
      "html_url": "https://github.com/chfast",
      "followers_url": "https://api.github.com/users/chfast/followers",
      "following_url": "https://api.github.com/users/chfast/following{/other_user}",
      "gists_url": "https://api.github.com/users/chfast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chfast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chfast/subscriptions",
      "organizations_url": "https://api.github.com/users/chfast/orgs",
      "repos_url": "https://api.github.com/users/chfast/repos",
      "events_url": "https://api.github.com/users/chfast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chfast/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-07T17:23:34Z",
    "updated_at": "2016-01-07T17:23:34Z",
    "author_association": "MEMBER",
    "body": "I agree LLVM IR is not a choice. It is huge and unstable (intentionally). Even LLVM does not have any proper interpreter for LLVM IR (they used to have it but it stopped being maintained some time ago). \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/169742520/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/190845573",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-190845573",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 190845573,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MDg0NTU3Mw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-03-01T18:37:19Z",
    "updated_at": "2016-03-01T18:37:42Z",
    "author_association": "MEMBER",
    "body": "update, the binary encoding has now been speficied https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/190845573/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/193593925",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-193593925",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 193593925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MzU5MzkyNQ==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-03-08T04:02:09Z",
    "updated_at": "2016-03-08T04:02:09Z",
    "author_association": "MEMBER",
    "body": "Future discussion should go here https://github.com/ethereum/ewasm-design\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/193593925/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/238078565",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-238078565",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 238078565,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzODA3ODU2NQ==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-07T12:01:23Z",
    "updated_at": "2016-08-07T12:01:23Z",
    "author_association": "MEMBER",
    "body": "Would it make sense closing this issue and reopening it or opening a new issue, once an actual proposal can be made? The content here is really outdated, especially given eWASM depends on a final/stable version of WASM.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/238078565/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357249985",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-357249985",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 357249985,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzI0OTk4NQ==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-12T14:19:54Z",
    "updated_at": "2018-01-12T14:19:54Z",
    "author_association": "MEMBER",
    "body": "@wanderer as agreed on AllCoreDev#31, can you please close this?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357249985/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490031",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-418490031",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 418490031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODQ5MDAzMQ==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-04T19:31:27Z",
    "updated_at": "2018-09-04T19:31:27Z",
    "author_association": "MEMBER",
    "body": "@Arachnid @Souptacular @nicksavers in January it was agreed to close this outdated issue. Can an editor please do that?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490031/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490230",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-418490230",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 418490230,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODQ5MDIzMA==",
    "user": {
      "login": "Souptacular",
      "id": 3460120,
      "node_id": "MDQ6VXNlcjM0NjAxMjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3460120?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Souptacular",
      "html_url": "https://github.com/Souptacular",
      "followers_url": "https://api.github.com/users/Souptacular/followers",
      "following_url": "https://api.github.com/users/Souptacular/following{/other_user}",
      "gists_url": "https://api.github.com/users/Souptacular/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Souptacular/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Souptacular/subscriptions",
      "organizations_url": "https://api.github.com/users/Souptacular/orgs",
      "repos_url": "https://api.github.com/users/Souptacular/repos",
      "events_url": "https://api.github.com/users/Souptacular/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Souptacular/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-04T19:32:07Z",
    "updated_at": "2018-09-04T19:32:07Z",
    "author_association": "MEMBER",
    "body": "Done!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490230/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490967",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-418490967",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 418490967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODQ5MDk2Nw==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-04T19:34:32Z",
    "updated_at": "2018-09-04T19:34:32Z",
    "author_association": "MEMBER",
    "body": "Thanks!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418490967/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/496559642",
    "html_url": "https://github.com/ethereum/EIPs/issues/48#issuecomment-496559642",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/48",
    "id": 496559642,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjU1OTY0Mg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-28T15:11:45Z",
    "updated_at": "2019-05-28T15:11:45Z",
    "author_association": "MEMBER",
    "body": "Anyone looking at this issue after 2016: the proposal described here does not reflect the current state and specification of Ewasm. Please refer to https://github.com/ewasm instead for up to date information.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/496559642/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
