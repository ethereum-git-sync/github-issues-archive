{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/909/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/909/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/909/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/909",
  "id": 301224946,
  "node_id": "MDU6SXNzdWUzMDEyMjQ5NDY=",
  "number": 909,
  "title": "EIP 909: New opcode STORREVERT (Draft)",
  "user": {
    "login": "SilentCicero",
    "id": 9806174,
    "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/SilentCicero",
    "html_url": "https://github.com/SilentCicero",
    "followers_url": "https://api.github.com/users/SilentCicero/followers",
    "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
    "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
    "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
    "repos_url": "https://api.github.com/users/SilentCicero/repos",
    "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
    "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 25,
  "created_at": "2018-02-28T23:33:49Z",
  "updated_at": "2022-01-01T23:11:51Z",
  "closed_at": "2022-01-01T23:11:51Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Preamble\r\n```\r\nEIP: 909\r\nTitle: New opcode STORREVERT - Revert contract state back to specific block\r\nAuthor: Nick Dodson <thenickdodson@gmail.com>\r\nCategory: EVM\r\nCreated: 2018-02-28\r\nUpdated: 2018-02-28\r\n```\r\n\r\n## Abstract\r\nThe following EIP describes an opcode which would revert a contracts memory storage and layout (state) back to a specific block.\r\n\r\n## Motivation\r\nMany contract systems are growing in complexity and will want a simple way to revert and reset contractual changes or upgrades. Having a simple opcode which can do this would greatly increase the capability of the Ethereum virtual machine. This would also allow Ethereum contracts to be extremely amorphic in nature (if used in tandem with delegatecall like functionality).\r\n\r\n## Specification\r\nIntroduce a new `STORREVERT` (memory revert) flag to the virtual machine. This opcode has no default values. It has one required parameter which is the block number to revert contract memory to.\r\n\r\nOpcode: `0xfc`\r\n\r\nThe single parameter, block number, is invalid if it is set past the contract deployment block or ahead of the current block number.\r\n\r\n## Example\r\n1) A delegate proxy is deployed with memory storage slot `master` (which defines the delegatecall target) at block A\r\n2) The delegate proxy P defines it's master variable to contract Y at block B\r\n3) Now the delegate proxy P is effectively contract Y\r\n--- The proxy owner now wants to change P's `master` to contract Z\r\n3) The delegate proxy P calls `STORREVERT A` and then assigns the `master` to contract address of Z\r\n4) The delegate proxy P is now effectively contract Z\r\n\r\n## Rational\r\nThis allows contracts to easily reset and revert memory / storage slots back to a specific block in time with relative ease.\r\n\r\n## Implementation\r\nWhen processing this opcode, the client would simply ignore all state changes between the STORREVERT block number and the current transaction block number in which the opcode was processed.\r\n\r\n## Alternatives\r\nIf this is far to complex to implement in the client, an alternative would be to have a STORREVERT, whereby the memory of a contract is simply reset to the memory layout / state when it was deployed (which would take no parameters). \r\n\r\nIt seems after learning more about VM processing, the above proposal would be very computationally heavy, as VM's are not required to hold historical state transitions. Another alternative would be a complete wipe of all contract state and storage layout. This would definitely put it in the class of SUICIDE and other similar calls to it. I do believe for upgrade purposes it would be useful.\r\n\r\n## Test Cases\r\nTo be written.\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/909/reactions",
    "total_count": 6,
    "+1": 4,
    "-1": 1,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/909/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369427821",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369427821",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369427821,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTQyNzgyMQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-01T00:07:15Z",
    "updated_at": "2018-03-02T16:59:03Z",
    "author_association": "NONE",
    "body": "I see the reasons to have both the options of opcodes described above (MEMBLOCK and MEMREVERT) but favor an initial implementation of MEMREVERT.\r\n\r\nAlso, I‚Äôd recommend changing all the verbatim to use the term `storage` instead of `memory` since the latter gets reset per each transaction and there‚Äôs no _block_ reference to revert it to.\r\n\r\nAn awesome proposal! Love it, @SilentCicero! üëèüôå\r\n\r\n_Edit_: I just realized that according to my reason for the verbatim change above the opcodes might as well be named differently! How do you feel about doing a find & replace of `MEM` for `STORE`?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369427821/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369533542",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369533542",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369533542,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTUzMzU0Mg==",
    "user": {
      "login": "izqui",
      "id": 447328,
      "node_id": "MDQ6VXNlcjQ0NzMyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/447328?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/izqui",
      "html_url": "https://github.com/izqui",
      "followers_url": "https://api.github.com/users/izqui/followers",
      "following_url": "https://api.github.com/users/izqui/following{/other_user}",
      "gists_url": "https://api.github.com/users/izqui/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/izqui/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/izqui/subscriptions",
      "organizations_url": "https://api.github.com/users/izqui/orgs",
      "repos_url": "https://api.github.com/users/izqui/repos",
      "events_url": "https://api.github.com/users/izqui/events{/privacy}",
      "received_events_url": "https://api.github.com/users/izqui/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-01T09:34:09Z",
    "updated_at": "2018-03-01T09:34:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "> gets reset per each transaction and there‚Äôs no block reference to revert it to \r\n\r\nActually per execution context :) I point this out because think there is a lot of value in having volatile memory that can be shared between contexts but dies at the end of the transaction execution. I think @chriseth made some comments about this in some EIP but I cannot find it right now!\r\n\r\nAlso great EIP @SilentCicero, I imagine this being a pain to implement in clients but it would be a great tool!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369533542/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369541816",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369541816",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369541816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTU0MTgxNg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-01T10:04:59Z",
    "updated_at": "2018-03-01T10:04:59Z",
    "author_association": "MEMBER",
    "body": "I think the naming is misleading, you are talking about replacing storage with an earlier versions. Memory is never persisted.\r\n\r\nThe current proposal seem to put all the work on the clients and it doesn't seem to be compatible too much with light clients.\r\n\r\nHow about having explicit checkpointing and loading from those checkpoints? It could be done via a contract similarly how to the blockhash refactoring is proposed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369541816/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369576125",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369576125",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369576125,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTU3NjEyNQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-01T12:26:34Z",
    "updated_at": "2018-03-01T12:26:34Z",
    "author_association": "NONE",
    "body": "+1 for explicit checkpointing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369576125/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369624398",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369624398",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369624398,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTYyNDM5OA==",
    "user": {
      "login": "SilentCicero",
      "id": 9806174,
      "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SilentCicero",
      "html_url": "https://github.com/SilentCicero",
      "followers_url": "https://api.github.com/users/SilentCicero/followers",
      "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
      "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
      "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
      "repos_url": "https://api.github.com/users/SilentCicero/repos",
      "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-01T15:17:36Z",
    "updated_at": "2018-03-01T15:31:25Z",
    "author_association": "NONE",
    "body": "@izqui I agree this would be a huge load to implement client side, but I think this would be extremely useful on the VM side.\r\n@GNSPS thanks! On the naming point:\r\n\r\nCurrently I chose this name as I sometimes conflate memory and state, when I'm sure in client/evm/metaphysical terms it is called/identified as something else.\r\n\r\nI'd be open to change the name to `STATEREVERT` or `STORREVERT`\r\n\r\n@axic the name can be adjusted, as I mention above.\r\n\r\nRe: lightclients, I agree, this would challenges most lightclient design right now. If we used checkpointing, I think that is an interesting middleground. But I would still like to clean out existing storage slots / pointers before reverting to a checkpoint.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369624398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369841507",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-369841507",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 369841507,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTg0MTUwNw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-02T07:11:28Z",
    "updated_at": "2018-03-02T07:11:28Z",
    "author_association": "MEMBER",
    "body": "As you note in the proposal, this isn't really practical: it would require all nodes to be archive nodes.\r\n\r\nCheckpoints would be possible, but a major engineering effort; personally I'm skeptical about the value of doing that when you can implement equivalent functionality at the contract later if desired.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369841507/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370037759",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370037759",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370037759,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDAzNzc1OQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-02T20:06:05Z",
    "updated_at": "2018-03-02T20:06:05Z",
    "author_association": "NONE",
    "body": "How do you feel about the \"erasing all storage\" part, tough, @Arachnid ?\r\n\r\nYou can't achieve that in the EVM without **a lot** of overhead, currently.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370037759/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370081074",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370081074",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370081074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDA4MTA3NA==",
    "user": {
      "login": "ivica7",
      "id": 17837189,
      "node_id": "MDQ6VXNlcjE3ODM3MTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/17837189?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ivica7",
      "html_url": "https://github.com/ivica7",
      "followers_url": "https://api.github.com/users/ivica7/followers",
      "following_url": "https://api.github.com/users/ivica7/following{/other_user}",
      "gists_url": "https://api.github.com/users/ivica7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ivica7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ivica7/subscriptions",
      "organizations_url": "https://api.github.com/users/ivica7/orgs",
      "repos_url": "https://api.github.com/users/ivica7/repos",
      "events_url": "https://api.github.com/users/ivica7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ivica7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-02T23:05:01Z",
    "updated_at": "2018-03-02T23:16:38Z",
    "author_association": "NONE",
    "body": "Not sure, but wouldn't this be too powerful? Allowing developers to \"hack\" too much. It could be also a smart contract trust killer from the user's perspective, if it's potentially possible to revert the storage (thinking about a token contract).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370081074/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370139967",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370139967",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370139967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDEzOTk2Nw==",
    "user": {
      "login": "SilentCicero",
      "id": 9806174,
      "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SilentCicero",
      "html_url": "https://github.com/SilentCicero",
      "followers_url": "https://api.github.com/users/SilentCicero/followers",
      "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
      "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
      "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
      "repos_url": "https://api.github.com/users/SilentCicero/repos",
      "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-03T11:20:15Z",
    "updated_at": "2018-03-03T11:20:15Z",
    "author_association": "NONE",
    "body": "I also think explicit check pointing would be worth it here. Even if the checkpoint is simple \"bring me back to the initial deployment state\" to start.\n\nA clear out of all storage layout and pointers would be another option, to enable the proxy example I stated above, but with no revert to block functionality.\n\nAs for things being too powerful, contracts can already be whipped, and manipulated to no end with delegate call. If your worried about consumer trust, those calls are equally dangerous in their own way.\n\nReverting to checkpoint could be very useful for efficient storage handling situations. However, it would involve a major engineering effort on the part of the client. And so some middle ground to achieve the wiping of contract storage completely could be a nice compromise.\n\nSent from my iPhone\n\n> On Mar 2, 2018, at 11:05 PM, ivica7 <notifications@github.com> wrote:\n> \n> Not sure, but wouldn't this be too powerful? Allowing developers to \"hack\" too much. Could be a smart contract trust killer from the user's perspective if it's potentially possible to revert the storage (thinking about a token contract).\n> \n> ‚Äî\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370139967/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370151288",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370151288",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370151288,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDE1MTI4OA==",
    "user": {
      "login": "nateawelch",
      "id": 706153,
      "node_id": "MDQ6VXNlcjcwNjE1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/706153?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nateawelch",
      "html_url": "https://github.com/nateawelch",
      "followers_url": "https://api.github.com/users/nateawelch/followers",
      "following_url": "https://api.github.com/users/nateawelch/following{/other_user}",
      "gists_url": "https://api.github.com/users/nateawelch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nateawelch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nateawelch/subscriptions",
      "organizations_url": "https://api.github.com/users/nateawelch/orgs",
      "repos_url": "https://api.github.com/users/nateawelch/repos",
      "events_url": "https://api.github.com/users/nateawelch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nateawelch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-03T14:27:12Z",
    "updated_at": "2018-03-03T14:27:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Reverting to checkpoint could be very useful for efficient storage handling situations. However, it would involve a major engineering effort on the part of the client. And so some middle ground to achieve the wiping of contract storage completely could be a nice compromise.\r\n\r\nI'm not sure explicit check pointing is the most useful method to achieve full state reversion. More useful in my opinion would be a SSTORE-like op that takes a memory start/length and a storage location that stores a range in memory to a range in storage. You can then have your initial state as push/mstore opcodes in the contract code itself. I'm not sure how efficient this would be for large ranges (maybe price it depending on range size?). There's also the issue of what to do about hash based indices in the storage.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370151288/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370159839",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370159839",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370159839,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDE1OTgzOQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-03T16:21:18Z",
    "updated_at": "2018-03-03T16:21:18Z",
    "author_association": "NONE",
    "body": "> I'm not sure explicit check pointing is the most useful method to achieve full state reversion. More useful in my opinion would be a SSTORE-like op that takes a memory start/length and a storage location that stores a range in memory to a range in storage.\r\n\r\nAlthough helpful, this wouldn't really solve the same problem that completely resetting or restoring the whole storage to some point in time does.\r\nSimply because of, and I believe that's what you mean when you say this:\r\n\r\n> There's also the issue of what to do about hash based indices in the storage.\r\n\r\nthe way storage is handled in the EVM and data structures like mappings are implemented in Solidity. \r\n\r\nThese make data sparse and scattered all throughout the addressable space making a variable length SSTORE be as ineffective as the current 32-bytes-sized one making you have to define iterable support structures like arrays to erase all the storage sections already written (which is unfeasible and the whole point we're trying to avoid üòÑ).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370159839/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370189788",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370189788",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370189788,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDE4OTc4OA==",
    "user": {
      "login": "nateawelch",
      "id": 706153,
      "node_id": "MDQ6VXNlcjcwNjE1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/706153?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nateawelch",
      "html_url": "https://github.com/nateawelch",
      "followers_url": "https://api.github.com/users/nateawelch/followers",
      "following_url": "https://api.github.com/users/nateawelch/following{/other_user}",
      "gists_url": "https://api.github.com/users/nateawelch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nateawelch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nateawelch/subscriptions",
      "organizations_url": "https://api.github.com/users/nateawelch/orgs",
      "repos_url": "https://api.github.com/users/nateawelch/repos",
      "events_url": "https://api.github.com/users/nateawelch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nateawelch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-04T00:01:21Z",
    "updated_at": "2018-03-04T00:04:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "> These make data sparse and scattered all throughout the addressable space making a variable length SSTORE be as ineffective as the current 32-bytes-sized one making you have to define iterable support structures like arrays to erase all the storage sections already written (which is unfeasible and the whole point we're trying to avoid üòÑ).\r\n\r\nIt's also unfeasible for clients to store entire snapshots of the storage as checkpoints üòâ Maybe this could be avoided by having a storage clear opcode as well, no need to reset all the values at random indices. Either way, I'm not sure of a proper use for checkpointing (or emulating checkpoints). Do you (or anyone else) have a use case having it done in the evm instead of at the contract level?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370189788/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370434502",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-370434502",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 370434502,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDQzNDUwMg==",
    "user": {
      "login": "SilentCicero",
      "id": 9806174,
      "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SilentCicero",
      "html_url": "https://github.com/SilentCicero",
      "followers_url": "https://api.github.com/users/SilentCicero/followers",
      "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
      "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
      "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
      "repos_url": "https://api.github.com/users/SilentCicero/repos",
      "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-05T14:24:06Z",
    "updated_at": "2018-03-05T14:24:06Z",
    "author_association": "NONE",
    "body": "I think I'm leaning on more of a wipe everything opcode, as that would solve the initial example use case / problem of \"resetting\" a contract and turning it into something else. Which is very relevant for contract proxy designs and how we construct upgradable contractual systems.\r\n\r\nThe hope of this discussion was to settle on what is reasonable and achievable at the client level to solve some of the use cases listed above.\r\n\r\nAlso, I am renaming this to STORREVERT as that name seems most relevant now, over the original and somewhat misleading MEMREVERT.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370434502/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371022800",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371022800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371022800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTAyMjgwMA==",
    "user": {
      "login": "ivica7",
      "id": 17837189,
      "node_id": "MDQ6VXNlcjE3ODM3MTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/17837189?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ivica7",
      "html_url": "https://github.com/ivica7",
      "followers_url": "https://api.github.com/users/ivica7/followers",
      "following_url": "https://api.github.com/users/ivica7/following{/other_user}",
      "gists_url": "https://api.github.com/users/ivica7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ivica7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ivica7/subscriptions",
      "organizations_url": "https://api.github.com/users/ivica7/orgs",
      "repos_url": "https://api.github.com/users/ivica7/repos",
      "events_url": "https://api.github.com/users/ivica7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ivica7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T04:56:30Z",
    "updated_at": "2018-03-07T04:58:54Z",
    "author_association": "NONE",
    "body": "@SilentCicero did you take a look on #905 ? It would allow you to make a snapshot of the state at any time and revert it later. Moreover, it would allow to clone the storage for upgrade purposes. It's also very easy to implement in the EVM, because it's working only on the storageHash of active contracts (no need to know the history state from previous blocks).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371022800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371074981",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371074981",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371074981,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTA3NDk4MQ==",
    "user": {
      "login": "SilentCicero",
      "id": 9806174,
      "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SilentCicero",
      "html_url": "https://github.com/SilentCicero",
      "followers_url": "https://api.github.com/users/SilentCicero/followers",
      "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
      "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
      "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
      "repos_url": "https://api.github.com/users/SilentCicero/repos",
      "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T09:19:01Z",
    "updated_at": "2018-03-07T09:19:01Z",
    "author_association": "NONE",
    "body": "My only issue with this is two fold, one, sometimes you don't know when the right snapshot time is and secondly, if I could just wipe out all storage in a contract, like a full refresh, it would serve the similar purpose for upgrading. I don't believe we actually need a revert per say to fork daos or contracts. I think Aragon would agree as well. You can just take state from the last set of contracts and implement new state and logic in the new dao. The MiniMe token is a good example.\n\nSent from my iPhone\n\n> On Mar 7, 2018, at 5:56 AM, ivica7 <notifications@github.com> wrote:\n> \n> @SilentCicero did you take a look on #905 ? It would allow you to make a snapshot of the state at any time and revert it later. Moreover, it would allow to clone the storage for upgrade purposes.\n> \n> ‚Äî\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371074981/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371080677",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371080677",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371080677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTA4MDY3Nw==",
    "user": {
      "login": "ivica7",
      "id": 17837189,
      "node_id": "MDQ6VXNlcjE3ODM3MTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/17837189?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ivica7",
      "html_url": "https://github.com/ivica7",
      "followers_url": "https://api.github.com/users/ivica7/followers",
      "following_url": "https://api.github.com/users/ivica7/following{/other_user}",
      "gists_url": "https://api.github.com/users/ivica7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ivica7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ivica7/subscriptions",
      "organizations_url": "https://api.github.com/users/ivica7/orgs",
      "repos_url": "https://api.github.com/users/ivica7/repos",
      "events_url": "https://api.github.com/users/ivica7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ivica7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T09:39:19Z",
    "updated_at": "2018-03-07T09:39:19Z",
    "author_association": "NONE",
    "body": "Not sure if I understand exactly what you're trying to achieve... if you wish to wipe out all data with the machanism from #905 , you could ``SCLONE`` storage from a contract like ``contract Empty {}``. If you wish to revert to the state after the initialisation of the contract, you could make a snapshot with ``SCLONE`` directly after the initialisation and reset it later with ``SCLONE`` again to this snapshot. Sure you're not flexible like if you could select arbitrary blocks for the revert, but that's the tradeoff for simplifying the implementation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371080677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371482429",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371482429",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371482429,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTQ4MjQyOQ==",
    "user": {
      "login": "rmi7",
      "id": 15264239,
      "node_id": "MDQ6VXNlcjE1MjY0MjM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/15264239?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmi7",
      "html_url": "https://github.com/rmi7",
      "followers_url": "https://api.github.com/users/rmi7/followers",
      "following_url": "https://api.github.com/users/rmi7/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmi7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmi7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmi7/subscriptions",
      "organizations_url": "https://api.github.com/users/rmi7/orgs",
      "repos_url": "https://api.github.com/users/rmi7/repos",
      "events_url": "https://api.github.com/users/rmi7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmi7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T13:12:04Z",
    "updated_at": "2018-03-08T13:12:25Z",
    "author_association": "NONE",
    "body": "This would \"in a way\" break the _promise_ of the blockchain only moving **forward**, not by undoing entire blocks, but by undoing state changes included in the last `X` blocks of a given smart contract `Y`? Still feels like going back in time, no no üí£ \r\n\r\nFor example: I wouldn't trust ERC20 tokens that have this feature in some `onlyOwner` accessible methods..they could just revert the ERC20 token balances, while still retaining the ETH balance of the contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371482429/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371489054",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371489054",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371489054,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTQ4OTA1NA==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T13:40:05Z",
    "updated_at": "2018-03-08T13:40:05Z",
    "author_association": "NONE",
    "body": "I think you‚Äôre kind of missing the point.\r\nThe capability to change storage contents  from a deployed smart contract have always been there.\r\nIf what you‚Äôre worried is that some contract developer does revert storage in the first place then you can already do that today.\r\n\r\nLack of _trustlessness_ in the development phase shouldn‚Äôt be an argument against this proposal.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371489054/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371511324",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371511324",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371511324,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTUxMTMyNA==",
    "user": {
      "login": "nateawelch",
      "id": 706153,
      "node_id": "MDQ6VXNlcjcwNjE1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/706153?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nateawelch",
      "html_url": "https://github.com/nateawelch",
      "followers_url": "https://api.github.com/users/nateawelch/followers",
      "following_url": "https://api.github.com/users/nateawelch/following{/other_user}",
      "gists_url": "https://api.github.com/users/nateawelch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nateawelch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nateawelch/subscriptions",
      "organizations_url": "https://api.github.com/users/nateawelch/orgs",
      "repos_url": "https://api.github.com/users/nateawelch/repos",
      "events_url": "https://api.github.com/users/nateawelch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nateawelch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T14:57:17Z",
    "updated_at": "2018-03-08T14:57:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "@ivica7 SCLONE (EIP905) might be pointless and is at least dangerous. Since SCLEAR refunds gas, a contract could clone a contracts storage and just delete state from itself to save the calling tx gas. So, to bypass this issue, SCLONE would have to be at least as expensive as 20,000 * (the number of non-zero storage locations in source contract), making the opcode pointless anyway since it isn't really saving gas. \r\n\r\nSTORREVERT would only work if it was snapshot based (because non-snapshot based would mean all nodes are archive nodes) **and** would have the same issue (reverting to checkpoint with extra non-zero storage slots and then deleting storage slots to save gas) unless you charged for the checkpoint and revert based on the same 20,000 * (the number of non-zero storage locations in source snapshot), at which point it is also pointless because it is, again, not saving anyone gas.\r\n\r\nThe only way SCLONE or STORREVERT would work to save gas is if we switched from just SSET/SRESET/SCLEAR charging of state to also include rent collection based storage.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371511324/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371515171",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371515171",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371515171,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTUxNTE3MQ==",
    "user": {
      "login": "ivica7",
      "id": 17837189,
      "node_id": "MDQ6VXNlcjE3ODM3MTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/17837189?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ivica7",
      "html_url": "https://github.com/ivica7",
      "followers_url": "https://api.github.com/users/ivica7/followers",
      "following_url": "https://api.github.com/users/ivica7/following{/other_user}",
      "gists_url": "https://api.github.com/users/ivica7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ivica7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ivica7/subscriptions",
      "organizations_url": "https://api.github.com/users/ivica7/orgs",
      "repos_url": "https://api.github.com/users/ivica7/repos",
      "events_url": "https://api.github.com/users/ivica7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ivica7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T15:09:16Z",
    "updated_at": "2018-03-08T15:09:23Z",
    "author_association": "NONE",
    "body": "> The only way SCLONE or STORREVERT would work to save gas is if we switched from just SSET/SRESET/SCLEAR charging of state to also include rent collection based storage.\r\n\r\nThat's an interesting point. Have there been proposals for this (rent collection based storage)? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371515171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371647052",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-371647052",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 371647052,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTY0NzA1Mg==",
    "user": {
      "login": "nateawelch",
      "id": 706153,
      "node_id": "MDQ6VXNlcjcwNjE1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/706153?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nateawelch",
      "html_url": "https://github.com/nateawelch",
      "followers_url": "https://api.github.com/users/nateawelch/followers",
      "following_url": "https://api.github.com/users/nateawelch/following{/other_user}",
      "gists_url": "https://api.github.com/users/nateawelch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nateawelch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nateawelch/subscriptions",
      "organizations_url": "https://api.github.com/users/nateawelch/orgs",
      "repos_url": "https://api.github.com/users/nateawelch/repos",
      "events_url": "https://api.github.com/users/nateawelch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nateawelch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T22:30:06Z",
    "updated_at": "2018-03-08T22:30:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "There have been a couple EIPs, but I don't think there have been any that have gotten real transaction. It adds a lot of complexity to contract/dapp developers since it means contracts would have to keep Ether in their balance that slowly gets used or they would lose their state, which means users either have to fund this themselves or trust that the developers keep it funded.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371647052/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372373952",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-372373952",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 372373952,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjM3Mzk1Mg==",
    "user": {
      "login": "fulldecent",
      "id": 382183,
      "node_id": "MDQ6VXNlcjM4MjE4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/382183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fulldecent",
      "html_url": "https://github.com/fulldecent",
      "followers_url": "https://api.github.com/users/fulldecent/followers",
      "following_url": "https://api.github.com/users/fulldecent/following{/other_user}",
      "gists_url": "https://api.github.com/users/fulldecent/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fulldecent/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fulldecent/subscriptions",
      "organizations_url": "https://api.github.com/users/fulldecent/orgs",
      "repos_url": "https://api.github.com/users/fulldecent/repos",
      "events_url": "https://api.github.com/users/fulldecent/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fulldecent/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-12T16:32:14Z",
    "updated_at": "2018-03-12T16:32:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "This EIP lacks a very strong and specific use case. That makes it impossible to evaluate the merits of the things we are discussing.\r\n\r\nSimply on the basis that this makes my job much harder when auditing a contract, I think the potential gain is not worth it.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372373952/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372403999",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-372403999",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 372403999,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjQwMzk5OQ==",
    "user": {
      "login": "SilentCicero",
      "id": 9806174,
      "node_id": "MDQ6VXNlcjk4MDYxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9806174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SilentCicero",
      "html_url": "https://github.com/SilentCicero",
      "followers_url": "https://api.github.com/users/SilentCicero/followers",
      "following_url": "https://api.github.com/users/SilentCicero/following{/other_user}",
      "gists_url": "https://api.github.com/users/SilentCicero/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SilentCicero/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SilentCicero/subscriptions",
      "organizations_url": "https://api.github.com/users/SilentCicero/orgs",
      "repos_url": "https://api.github.com/users/SilentCicero/repos",
      "events_url": "https://api.github.com/users/SilentCicero/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SilentCicero/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-12T17:54:02Z",
    "updated_at": "2018-03-12T17:54:02Z",
    "author_association": "NONE",
    "body": "The primary use-case is for upgradable contract systems, namely, proxy contracts. Aragon, Colony, Harbour and others working on upgradable governance systems will and already do desire a mechanism to either wipe contracts clear of storage or bring them back to a specific state along the upgrade process of a contract. This EIP is the start of a discussion toward that aim of clean upgradable contracts. I believe that this kind of mechanism should exist, at least in the storage clearing form. \n\nSent from my iPhone\n\n> On Mar 12, 2018, at 5:32 PM, William Entriken <notifications@github.com> wrote:\n> \n> This EIP lacks a very strong and specific use case. That makes it impossible to evaluate the merits of the things we are discussing.\n> \n> Simply on the basis that this makes my job much harder when auditing a contract, I think the potential gain is not worth it.\n> \n> ‚Äî\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372403999/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997291771",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-997291771",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 997291771,
    "node_id": "IC_kwDOAq426M47cXb7",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-18T22:11:23Z",
    "updated_at": "2021-12-18T22:11:23Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997291771/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003634064",
    "html_url": "https://github.com/ethereum/EIPs/issues/909#issuecomment-1003634064",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/909",
    "id": 1003634064,
    "node_id": "IC_kwDOAq426M470j2Q",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-01T23:11:50Z",
    "updated_at": "2022-01-01T23:11:50Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003634064/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
