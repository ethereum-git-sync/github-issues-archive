{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1495",
  "id": 370177711,
  "node_id": "MDU6SXNzdWUzNzAxNzc3MTE=",
  "number": 1495,
  "title": "ERC-1484: Digital Identity Aggregator",
  "user": {
    "login": "NoahZinsmeister",
    "id": 3760414,
    "node_id": "MDQ6VXNlcjM3NjA0MTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3760414?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/NoahZinsmeister",
    "html_url": "https://github.com/NoahZinsmeister",
    "followers_url": "https://api.github.com/users/NoahZinsmeister/followers",
    "following_url": "https://api.github.com/users/NoahZinsmeister/following{/other_user}",
    "gists_url": "https://api.github.com/users/NoahZinsmeister/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/NoahZinsmeister/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/NoahZinsmeister/subscriptions",
    "organizations_url": "https://api.github.com/users/NoahZinsmeister/orgs",
    "repos_url": "https://api.github.com/users/NoahZinsmeister/repos",
    "events_url": "https://api.github.com/users/NoahZinsmeister/events{/privacy}",
    "received_events_url": "https://api.github.com/users/NoahZinsmeister/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 45,
  "created_at": "2018-10-15T14:00:26Z",
  "updated_at": "2021-12-18T21:11:26Z",
  "closed_at": "2021-12-18T21:11:26Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "# Official ERC-1484 Discussion Forum\r\n\r\n- The full text of this EIP follows, and is also [available as a markdown file](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1484.md)\r\n- The [reference implementation is available here](https://github.com/NoahZinsmeister/ERC-1484)\r\n- Documentation on [best practices for this ERC can be found here](https://github.com/NoahZinsmeister/ERC-1484/tree/master/best-practices)\r\n\r\n|||\r\n|--------------------|-|\r\n| **EIP**            | 1484 |\r\n| **Title**          | Digital Identity Aggregator |\r\n| **Author**         | Anurag Angara <anurag.angara@gmail.com><br>Andy Chorlian <andychorlian@gmail.com><br>Shane Hampton <shanehampton1@gmail.com><br>Noah Zinsmeister <noahwz@gmail.com> |\r\n| **Discussions-To** | #1495 |\r\n| **Status**         | Draft |\r\n| **Type**           | Standards Track |\r\n| **Category**       | ERC |\r\n| **Created**        | 2018-10-12 |\r\n| **Requires**       | 191 |\r\n\r\n## Simple Summary\r\nA protocol for aggregating digital identity information that's broadly interoperable with existing, proposed, and hypothetical future digital identity standards.\r\n\r\n## Abstract\r\nThis EIP proposes an identity management and aggregation framework on the Ethereum blockchain. It allows entities to claim an `Identity` via a singular `Identity Registry` smart contract, associate it with Ethereum addresses in a variety of meaningful ways, and use it to interact with smart contracts. This enables arbitrarily complex identity-related functionality. Notably (among other features) ERC-1484 `Identities`: are self-sovereign, can natively support [ERC-725](https://github.com/NoahZinsmeister/ERC-1484/tree/master/contracts/examples/Resolvers/ERC725) and [ERC-1056](https://github.com/NoahZinsmeister/ERC-1484/tree/master/contracts/examples/Resolvers/ERC1056) identities, are [DID compliant](https://github.com/NoahZinsmeister/ERC-1484/blob/master/best-practices/DID-Method.md), and can be fully powered by [meta-transactions](https://github.com/NoahZinsmeister/ERC-1484/tree/master/contracts/examples/Providers/MetaTransactions).\r\n\r\n## Motivation\r\nEmerging identity standards and related frameworks proposed by the Ethereum community (including ERCs/EIPs [725](https://github.com/ethereum/EIPs/issues/725), [735](https://github.com/ethereum/EIPs/issues/735), [780](https://github.com/ethereum/EIPs/issues/780), [1056](https://github.com/ethereum/EIPs/issues/1056), etc.) define and instrumentalize digital identity in a variety of ways. As existing approaches mature, new standards emerge, and isolated, non-standard approaches to identity develop, coordinating on identity will become increasingly burdensome for blockchain users and developers, and involve the unnecessary duplication of work.\r\n\r\nThe proliferation of on-chain identity solutions can be traced back to the fact that each codifies a notion of identity and links it to specific aspects of Ethereum (claims protocols, per-identity smart contracts, signature verification schemes, etc.). This proposal eschews that approach, instead introducing a protocol layer in between the Ethereum network and individual identity applications. This solves identity management and interoperability challenges by enabling any identity-driven application to leverage an un-opinionated identity management protocol.\r\n\r\n## Definitions\r\n- `Identity Registry`: A single smart contract which is the hub for all `Identities`. The primary responsibility of the `Registry` is to define and enforce the rules of a global namespace for `Identities`, which are individually denominated by Ethereum Identification Numbers (EINs).\r\n\r\n- `Identity`: A data structure containing all the core information relevant to an identity, namely: a `Recovery Address`, an `Associated Addresses` set, a `Providers` set, and a `Resolvers` set. `Identities` are denominated by EINs (incrementing `uint` identifiers starting at 1), which are unique but otherwise uninformative. Each `Identity` is a Solidity struct:\r\n\r\n```solidity\r\nstruct Identity {\r\n    address recoveryAddress;\r\n    AddressSet.Set associatedAddresses;\r\n    AddressSet.Set providers;\r\n    AddressSet.Set resolvers;\r\n}\r\n```\r\n\r\n- `Associated Address`: An Ethereum address publicly associated with an `Identity`. In order for an address to become an `Associated Address`, an `Identity` must either transact from or produce an appropriately signed message from the candidate address and an existing `Associated Address`, indicating intent to associate. An `Associated Address` can be removed from an `Identity` by transacting/producing a signature indicating intent to disassociate. A given address may only be an `Associated Address` for one `Identity` at any given time.\r\n\r\n- `Provider`: An Ethereum address (typically but not by definition a smart contract) authorized to act on behalf of `Identities` who have authorized them to do so. This includes but is not limited to managing the `Associated Address`, `Provider`, and `Resolver` sets for an `Identity`. `Providers` exist to facilitate user adoption by making it easier to manage `Identities`.\r\n\r\n- `Resolver`: A smart contract containing arbitrary information pertaining to `Identities`. A resolver may implement an identity standard, such as ERC-725, or may consist of a smart contract leveraging or declaring identifying information about `Identities`. These could be simple attestation structures or more sophisticated financial dApps, social media dApps, etc. Each `Resolver` added to an `Identity` makes the `Identity` more informative.\r\n\r\n- `Recovery Address`: An Ethereum address (either an account or smart contract) that can be used to recover lost `Identities` as outlined in the [Recovery](#recovery) section.\r\n\r\n- `Destruction`: In the event of irrecoverable loss of control of an `Identity`, `Destruction` is a contingency measure to permanently disable the `Identity`. It removes all `Associated Addresses`, `Providers`, and optionally `Resolvers` while preserving the `Identity`. Evidence of the existence of the `Identity` persists, while control over the `Identity` is nullified.\r\n\r\n## Specification\r\nA digital identity in this proposal can be viewed as an omnibus account, containing more information about an identity than any individual identity application could. This omnibus identity is resolvable to an unlimited number of sub-identities called `Resolvers`. This allows an atomic entity, the `Identity`, to be resolvable to abstract data structures, the `Resolvers`. `Resolvers` recognize `Identities` by any of their `Associated Addresses`, or by their `EIN`.\r\n\r\nThe protocol revolves around claiming an `Identity` and managing `Associated Addresses`, `Providers` and `Resolvers`. Identities can delegate much or all of this responsibility to one or more `Providers`, or perform it directly from an `Associated Address`. `Associated Addresses`/`Providers` may add and remove `Resolvers` and `Providers` indiscriminately. `Associated Addresses` may only be added or removed with the appropriate permission.\r\n\r\n### Identity Registry\r\nThe `Identity Registry` contains functionality to create new `Identities` and for existing `Identities` to manage their `Associated Addresses`, `Providers`, and `Resolvers`. It is important to note that this registry fundamentally requires transactions for every aspect of building out an `Identity`. However, recognizing the importance of accessibility to dApps and identity applications, we empower `Providers` to build out `Identities` on the behalf of users, without requiring users to pay gas costs. An example of this pattern, often referred to as a meta transactions, can be [seen in the reference implementation](https://github.com/NoahZinsmeister/ERC-1484/tree/master/contracts/examples/Providers/MetaTransactions).\r\n\r\nDue to the fact that multiple addresses can be associated with a given identity (though not the reverse), `Identities` are denominated by `EIN`. This `uint` identifier can be encoded in QR format or mapped to more user-friendly formats, such as a `string`, in registries at the `Provider` or `Resolver` level.\r\n\r\n### Address Management\r\nThe address management function consists of trustlessly connecting multiple user-owned `Associated Addresses` to an `Identity`. It does not give special status to any particular `Associated Address`, rather leaving this (optional) specification to identity applications built on top of the protocol - for instance, `management`, `action`, `claim` and `encryption` keys denominated in the ERC-725 standard, or `identifiers` and `delegates` as denominated in ERC-1056. This allows a user to access common identity data from multiple wallets while still:\r\n\r\n- retaining the ability to interact with contracts outside of their identity\r\n- taking advantage of address-specific permissions established at the application layer of a user's identity.\r\n\r\nTrustlessness in the address management function is achieved through a robust permissioning scheme. To add an `Associated Address` to an `Identity`, implicit permission from a transaction sender or explicit permission from a signature is required from 1) an address already within the registry and 2) an address to be claimed. Importantly, the transaction need not come from any particular address, as long as permission is established, which allows not only users but third parties (companies, governments, etc.) to bear the overhead of managing identities. To prevent a compromised `Associated Address` from unilaterally removing other `Associated Addresses`, it's only possible to remove an `Associated Address` by transacting or producing a signature from it.\r\n\r\nAll signatures required in ERC-1484 are designed per the [ERC-191](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md) v0 specification. To avoid replay attacks, all signatures must include a timestamp within a rolling lagged window of the current `block.timestamp`. For more information, see this [best practices document](https://github.com/NoahZinsmeister/ERC-1484/blob/master/best-practices/VerifyingSignatures.md) in the reference implementation.\r\n\r\n### Provider Management\r\nWhile the protocol allows users to directly call identity management functions, it also aims to be more robust and future-proof by allowing `Providers`, typically smart contracts, to perform identity management functions on a user's behalf. A `Provider` set by an `Identity` can perform address management and resolver management functions by passing a user's `EIN` in function calls.\r\n\r\n### Resolver Management\r\nA `Resolver` is any smart contract that encodes information which resolves to an `Identity`. We remain agnostic about the specific information that can be encoded in a resolver and the functionality that this enables. The existence of `Resolvers` is primarily what makes this ERC an identity *protocol* rather than an identity *application*. `Resolvers` resolve abstract data in smart contracts to an atomic entity, the `Identity`.\r\n\r\n### Recovery\r\nIf users lose control over an `Associated Address`, the `Recovery Address` provides a fallback mechanism. Upon `Identity` creation, a `Recovery Address` is passed as a parameter by the creator. Recovery functionality is triggered in three scenarios:\r\n\r\n**1. Changing Recovery Address**: If a recovery key is lost, an `Associated Address`/`Provider` can [triggerRecoveryAddressChange](#triggerRecoveryAddressChange)/[triggerRecoveryAddressChangeFor](#triggerRecoveryAddressChangeFor). To prevent malicious behavior from someone who has gained control of an `Associated Address` or `Provider` and is changing the `Recovery Address` to one under their control, this action triggers a 14 day challenge period during which the old `Recovery Address` may reject the change by [triggering recovery](#triggerRecovery). If the `Recovery Address` does not reject the change within 14 days, the `Recovery Address` is changed.\r\n\r\n**2. Recovery**: Recovery occurs when a user recognizes that an `Associated Address` or the `Recovery Address` belonging to the user is lost or stolen. In this instance the `Recovery Address` must call [triggerRecovery](#triggerRecovery). This removes all `Associated Addresses` and `Providers` from the corresponding `Identity` and replaces them with an address passed in the function call. The `Identity` and associated `Resolvers` maintain integrity. The user is now responsible for adding the appropriate un-compromised addresses back to their `Identity`.\r\n\r\n*Importantly, the `Recovery Address` can be a user-controlled wallet or another address, such as a multisig wallet or smart contract. This allows for arbitrarily sophisticated recovery logic! This includes the potential for recovery to be fully compliant with standards such as [DID](https://decentralized.id/).*\r\n\r\n**3. Destruction**\r\nThe Recovery scheme offers considerable power to a `Recovery Address`; accordingly, `Destruction` is a nuclear option to combat malicious control over an `Identity` when a `Recovery Address` is compromised. If a malicious actor compromises a user's `Recovery Address` and triggers recovery, any address removed in the `Recovery` process can call [triggerDestruction](#triggerDestruction) within 14 days to permanently disable the `Identity`. The user would then need to create a new `Identity`, and would be responsible for engaging in recovery schemes for any identity applications built in the `Resolver` or `Provider` layers.\r\n\r\n#### Alternative Recovery Considerations\r\nWe considered many possible alternatives when devising the Recovery process outlined above. We ultimately selected the scheme that was most un-opinionated, modular, and consistent with the philosophy behind the `Associated Address`, `Provider`, and `Resolver` components. Still, we feel that it is important to highlight some of the other recovery options we considered, to provide a rationale as to how we settled on what we did.\r\n\r\n**High Level Concerns**\r\nFundamentally, a Recovery scheme needs to be resilient to a compromised address taking control of a user's `Identity`. A secondary concern is preventing a compromised address from maliciously destroying a user's identity due to off-chain utility, which is not an optimal scenario, but is strictly better than if they've gained control.\r\n\r\n**Alternative 1: Nuclear Option**\r\nThis approach would allow any `Associated Address` to destroy an `Identity` whenever another `Associated Address` is compromised. While this may seem severe, we strongly considered it because this ERC is an identity *protocol*, not an identity *application*. This means that though a user's compromised `Identity` is destroyed, they should still have recourse to whatever restoration mechanisms are available in each of their actual identities at the `Resolver` and/or `Provider` level. We ultimately dismissed this approach for two main reasons:\r\n\r\n- It is not robust in cases where a user has only one `Associated Address`\r\n- It would increase the frequency of recovery requests to identity applications due to its unforgiving nature.\r\n\r\n**Alternative 2: Unilateral Address Removal via Providers**\r\nThis would allow `Associated Addresses`/`Providers` to remove `Associated Addresses` without a signature from said address. This implementation would allow `Providers` to include arbitrarily sophisticated schemes for removing a rogue address - for instance, multi-sig requirements, centralized off-chain verification, user controlled master addresses, deferral to a jurisdictional contract, and more. To prevent a compromised `Associated Address` from simply setting a malicious `Provider` to remove un-compromised addresses, it would have required a waiting period between when a `Provider` is set and when they would be able to remove an `Associated Address`. We dismissed this approach because we felt it placed too high of a burden on `Providers`. If a `Provider` offered a sophisticated range of functionality to a user, but post-deployment a threat was found in the Recovery logic of the provider, `Provider`-specific infrastructure would need to be rebuilt. We also considered including a flag that would allow a user to decide whether or not a `Provider` may remove `Associated Addresses` unilaterally. Ultimately, we concluded that only allowing removal of `Associated Addresses` via the `Recovery Address` enables equally sophisticated recovery logic while separating the functionality from `Providers`, leaving less room for users to relinquish control to potentially flawed implementations.\r\n\r\n## Rationale\r\nWe find that at a protocol layer, identities should not rely on specific claim or attestation structures, but should instead be a part of a trustless framework upon which arbitrarily sophisticated claim and attestation structures may be built.\r\n\r\nThe main criticism of existing identity solutions is that they're overly restrictive. We aim to limit requirements, keep identities modular and future-proof, and remain un-opinionated regarding any functionality a particular identity component may have. This proposal gives users the option to interact on the blockchain using an robust `Identity` rather than just an address.\r\n\r\n## Implementation\r\n**The reference implementation for ERC-1484 may be found in [NoahZinsmeister/ERC-1484](https://github.com/NoahZinsmeister/ERC-1484).**\r\n\r\n#### identityExists\r\n\r\nReturns a `bool` indicating whether or not an `Identity` denominated by the passed `EIN` exists.\r\n\r\n```solidity\r\nfunction identityExists(uint ein) public view returns (bool);\r\n```\r\n\r\n#### hasIdentity\r\n\r\nReturns a `bool` indicating whether or not the passed `_address` is associated with an `Identity`.\r\n\r\n```solidity\r\nfunction hasIdentity(address _address) public view returns (bool);\r\n```\r\n\r\n#### getEIN\r\n\r\nReturns the `EIN` associated with the passed `_address`. Throws if the address is not associated with an `EIN`.\r\n\r\n```solidity\r\nfunction getEIN(address _address) public view returns (uint ein);\r\n```\r\n\r\n#### isAssociatedAddressFor\r\n\r\nReturns a `bool` indicating whether or not the passed `_address` is associated with the passed `EIN`.\r\n\r\n```solidity\r\nfunction isAssociatedAddressFor(uint ein, address _address) public view returns (bool);\r\n```\r\n\r\n#### isProviderFor\r\n\r\nReturns a `bool` indicating whether or not the passed `provider` has been set by the passed `EIN`.\r\n\r\n```solidity\r\nfunction isProviderFor(uint ein, address provider) public view returns (bool);\r\n```\r\n\r\n#### isResolverFor\r\n\r\nReturns a `bool` indicating whether or not the passed `resolver` has been set by the passed `EIN`.\r\n\r\n```solidity\r\nfunction isResolverFor(uint ein, address resolver) public view returns (bool);\r\n```\r\n\r\n#### getIdentity\r\n\r\nReturns the `recoveryAddress`, `associatedAddresses`, `providers` and `resolvers` of the passed `EIN`.\r\n\r\n```solidity\r\nfunction getIdentity(uint ein) public view\r\n    returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n```\r\n\r\n#### createIdentity\r\n\r\nCreates an `Identity`, setting the `msg.sender` as the sole `Associated Address`. Returns the `EIN` of the new `Identity`.\r\n\r\n```solidity\r\nfunction createIdentity(address recoveryAddress, address[] memory providers, address[] memory resolvers)\r\n    public returns (uint ein);\r\n```\r\n\r\nTriggers event: [IdentityCreated](#identitycreated)\r\n\r\n#### createIdentityDelegated\r\n\r\nPreforms the same logic as `createIdentity`, but can be called by any address. This function requires a signature from the `associatedAddress` to ensure their consent.\r\n\r\n```solidity\r\nfunction createIdentityDelegated(\r\n    address recoveryAddress, address associatedAddress, address[] memory providers, address[] memory resolvers,\r\n    uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n)\r\n    public returns (uint ein);\r\n```\r\n\r\nTriggers event: [IdentityCreated](#identitycreated)\r\n\r\n#### addAssociatedAddress\r\n\r\nAdds the `addressToAdd` to the `EIN` of the `approvingAddress`. The `msg.sender` must be either of the `approvingAddress` or the `addressToAdd`, and the signature must be from the other one.\r\n\r\n```solidity\r\nfunction addAssociatedAddress(\r\n    address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n)\r\n    public\r\n```\r\n\r\nTriggers event: [AssociatedAddressAdded](#associatedaddressadded)\r\n\r\n#### addAssociatedAddressDelegated\r\n\r\nAdds the `addressToAdd` to the `EIN` of the `approvingAddress`. Requires signatures from both the `approvingAddress` and the `addressToAdd`.\r\n\r\n```solidity\r\nfunction addAssociatedAddressDelegated(\r\n    address approvingAddress, address addressToAdd,\r\n    uint8[2] memory v, bytes32[2] memory r, bytes32[2] memory s, uint[2] memory timestamp\r\n)\r\n    public\r\n```\r\n\r\nTriggers event: [AssociatedAddressAdded](#associatedaddressadded)\r\n\r\n#### removeAssociatedAddress\r\n\r\nRemoves the `msg.sender` as an `Associated Address` from its `EIN`.\r\n\r\n```solidity\r\nfunction removeAssociatedAddress() public;\r\n```\r\n\r\nTriggers event: [AssociatedAddressRemoved](#associatedaddressremoved)\r\n\r\n\r\n#### removeAssociatedAddressDelegated\r\n\r\nRemoves the `addressToRemove` from its associated `EIN`. Requires a signature from the `addressToRemove`.\r\n\r\n```solidity\r\nfunction removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n    public;\r\n```\r\n\r\nTriggers event: [AssociatedAddressRemoved](#associatedaddressremoved)\r\n\r\n#### addProviders\r\n\r\nAdds an array of `Providers` to the `Identity` of the `msg.sender`.\r\n\r\n```solidity\r\nfunction addProviders(address[] memory providers) public;\r\n```\r\n\r\nTriggers event: [ProviderAdded](#provideradded)\r\n\r\n#### addProvidersFor\r\n\r\nPreforms the same logic as `addProviders`, but must be called by a `Provider`.\r\n\r\n```solidity\r\nfunction addProvidersFor(uint ein, address[] memory providers) public;\r\n```\r\n\r\nTriggers event: [ProviderAdded](#provideradded)\r\n\r\n#### removeProviders\r\n\r\nRemoves an array of `Providers` from the `Identity` of the `msg.sender`.\r\n\r\n```solidity\r\nfunction removeProviders(address[] memory providers) public;\r\n```\r\n\r\nTriggers event: [ProviderRemoved](#providerremoved)\r\n\r\n\r\n#### removeProvidersFor\r\n\r\nPreforms the same logic as `removeProviders`, but is called by a `Provider`.\r\n\r\n```solidity\r\nfunction removeProvidersFor(uint ein, address[] memory providers) public;\r\n```\r\n\r\nTriggers event: [ProviderRemoved](#providerremoved)\r\n\r\n\r\n#### addResolvers\r\n\r\nAdds an array of `Resolvers` to the `EIN` of the `msg.sender`.\r\n\r\n```solidity\r\nfunction addResolvers(address[] memory resolvers) public;\r\n```\r\n\r\nTriggers event: [ResolverAdded](#resolveradded)\r\n\r\n#### addResolversFor\r\n\r\nPreforms the same logic as `addResolvers`, but must be called by a `Provider`.\r\n\r\n```solidity\r\nfunction addResolversFor(uint ein, address[] memory resolvers) public;\r\n```\r\n\r\nTriggers event: [ResolverAdded](#resolveradded)\r\n\r\n#### removeResolvers\r\n\r\nRemoves an array of `Resolvers` from the `EIN` of the `msg.sender`.\r\n\r\n```solidity\r\nfunction removeResolvers(address[] memory resolvers) public;\r\n```\r\n\r\nTriggers event: [ResolverRemoved](#resolverremoved)\r\n\r\n#### removeResolversFor\r\n\r\nPreforms the same logic as `removeResolvers`, but must be called by a `Provider`.\r\n\r\n```solidity\r\nfunction removeResolversFor(uint ein, address[] memory resolvers) public;\r\n```\r\n\r\nTriggers event: [ResolverRemoved](#resolverremoved)\r\n\r\n#### triggerRecoveryAddressChange\r\n\r\nInitiates a change in the current `recoveryAddress` for the `EIN` of the `msg.sender`.\r\n\r\n```solidity\r\nfunction triggerRecoveryAddressChange(address newRecoveryAddress) public;\r\n```\r\n\r\nTriggers event: [RecoveryAddressChangeTriggered](#RecoveryAddressChangeTriggered)\r\n\r\n#### triggerRecoveryAddressChangeFor\r\n\r\nInitiates a change in the current `recoveryAddress` for a given `EIN`.\r\n\r\n```solidity\r\nfunction triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) public;\r\n```\r\n\r\nTriggers event: [RecoveryAddressChangeTriggered](#RecoveryAddressChangeTriggered)\r\n\r\n#### triggerRecovery\r\n\r\nTriggers `EIN` recovery from the current `recoveryAddress`, or the old `recoveryAddress` if changed within the last 2 weeks.\r\n\r\n```solidity\r\nfunction triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public;\r\n```\r\n\r\nTriggers event: [RecoveryTriggered](#RecoveryTriggered)\r\n\r\n#### triggerDestruction\r\n\r\nTriggers destruction of an `EIN`. This renders the `Identity` permanently unusable.\r\n\r\n```solidity\r\nfunction triggerDestruction(uint ein, address[] memory firstChunk, address[] memory lastChunk, bool clearResolvers)\r\n  public;\r\n```\r\n\r\nTriggers event: [IdentityDestroyed](#IdentityDestroyed)\r\n\r\n### Events\r\n\r\n#### IdentityCreated\r\n\r\nMUST be triggered when an `Identity` is created.\r\n\r\n```solidity\r\nevent IdentityCreated(\r\n    address indexed initiator, uint indexed ein,\r\n    address recoveryAddress, address associatedAddress, address[] providers, address[] resolvers, bool delegated\r\n);\r\n```\r\n\r\n#### AssociatedAddressAdded\r\n\r\nMUST be triggered when an address is added to an `Identity`.\r\n\r\n```solidity\r\nevent AssociatedAddressAdded(\r\n    address indexed initiator, uint indexed ein, address approvingAddress, address addedAddress, bool delegated\r\n);\r\n```\r\n\r\n#### AssociatedAddressRemoved\r\n\r\nMUST be triggered when an address is removed from an `Identity`.\r\n\r\n```solidity\r\nevent AssociatedAddressRemoved(address indexed initiator, uint indexed ein, address removedAddress, bool delegated);\r\n```\r\n\r\n#### ProviderAdded\r\n\r\nMUST be triggered when a provider is added to an `Identity`.\r\n\r\n```solidity\r\nevent ProviderAdded(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n```\r\n\r\n#### ProviderRemoved\r\n\r\nMUST be triggered when a provider is removed.\r\n\r\n```solidity\r\nevent ProviderRemoved(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n```\r\n\r\n#### ResolverAdded\r\n\r\nMUST be triggered when a resolver is added.\r\n\r\n```solidity\r\nevent ResolverAdded(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\r\n```\r\n\r\n#### ResolverRemoved\r\n\r\nMUST be triggered when a resolver is removed.\r\n\r\n```solidity\r\nevent ResolverRemoved(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\r\n```\r\n\r\n#### RecoveryAddressChangeTriggered\r\n\r\nMUST be triggered when a recovery address change is triggered.\r\n\r\n```solidity\r\nevent RecoveryAddressChangeTriggered(\r\n    address indexed initiator, uint indexed ein,\r\n    address oldRecoveryAddress, address newRecoveryAddress, bool delegated\r\n);\r\n```\r\n\r\n#### RecoveryTriggered\r\n\r\nMUST be triggered when recovery is triggered.\r\n\r\n```solidity\r\nevent RecoveryTriggered(\r\n    address indexed initiator, uint indexed ein, address[] oldAssociatedAddresses, address newAssociatedAddress\r\n);\r\n```\r\n\r\n#### IdentityDestroyed\r\n\r\nMUST be triggered when an `Identity` is destroyed.\r\n\r\n```solidity\r\nevent IdentityDestroyed(address indexed initiator, uint indexed ein, address recoveryAddress, bool resolversReset);\r\n```\r\n\r\n### Solidity Interface\r\n```solidity\r\ninterface IdentityRegistryInterface {\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        external pure returns (bool);\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n    function identityExists(uint ein) external view returns (bool);\r\n    function hasIdentity(address _address) external view returns (bool);\r\n    function getEIN(address _address) external view returns (uint ein);\r\n    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\r\n    function isProviderFor(uint ein, address provider) external view returns (bool);\r\n    function isResolverFor(uint ein, address resolver) external view returns (bool);\r\n    function getIdentity(uint ein) external view returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\r\n        external returns (uint ein);\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function removeAssociatedAddress() external;\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function addProviders(address[] calldata providers) external;\r\n    function addProvidersFor(uint ein, address[] calldata providers) external;\r\n    function removeProviders(address[] calldata providers) external;\r\n    function removeProvidersFor(uint ein, address[] calldata providers) external;\r\n    function addResolvers(address[] calldata resolvers) external;\r\n    function addResolversFor(uint ein, address[] calldata resolvers) external;\r\n    function removeResolvers(address[] calldata resolvers) external;\r\n    function removeResolversFor(uint ein, address[] calldata resolvers) external;\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function triggerDestruction(\r\n        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\r\n    ) external;\r\n\r\n    // Events //////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    event IdentityCreated(\r\n        address indexed initiator, uint indexed ein,\r\n        address recoveryAddress, address associatedAddress, address[] providers, address[] resolvers, bool delegated\r\n    );\r\n    event AssociatedAddressAdded(\r\n        address indexed initiator, uint indexed ein, address approvingAddress, address addedAddress\r\n    );\r\n    event AssociatedAddressRemoved(address indexed initiator, uint indexed ein, address removedAddress);\r\n    event ProviderAdded(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n    event ProviderRemoved(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n    event ResolverAdded(address indexed initiator, uint indexed ein, address resolvers);\r\n    event ResolverRemoved(address indexed initiator, uint indexed ein, address resolvers);\r\n    event RecoveryAddressChangeTriggered(\r\n        address indexed initiator, uint indexed ein, address oldRecoveryAddress, address newRecoveryAddress\r\n    );\r\n    event RecoveryTriggered(\r\n        address indexed initiator, uint indexed ein, address[] oldAssociatedAddresses, address newAssociatedAddress\r\n    );\r\n    event IdentityDestroyed(address indexed initiator, uint indexed ein, address recoveryAddress, bool resolversReset);\r\n}\r\n```\r\n\r\n## Backwards Compatibility\r\n`Identities` established under this standard consist of existing Ethereum addresses; accordingly, there are no backwards compatibility issues. Deployed, non-upgradeable smart contracts that wish to become `Resolvers` for `Identities` will need to write wrapper contracts that resolve addresses to `EIN`-denominated `Identities`.\r\n\r\n## Additional References\r\n- [ERC-1484 Reference Implementation](https://github.com/NoahZinsmeister/ERC-1484)\r\n- [ERC-191 Signatures](https://github.com/ethereum/EIPs/issues/191)\r\n- [ERC-725 Identities](https://github.com/ethereum/EIPs/issues/725)\r\n- [ERC-1056 Identities](https://github.com/ethereum/EIPs/issues/1056)\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1495/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/430866516",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-430866516",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 430866516,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMDg2NjUxNg==",
    "user": {
      "login": "tyleryasaka",
      "id": 6504519,
      "node_id": "MDQ6VXNlcjY1MDQ1MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6504519?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tyleryasaka",
      "html_url": "https://github.com/tyleryasaka",
      "followers_url": "https://api.github.com/users/tyleryasaka/followers",
      "following_url": "https://api.github.com/users/tyleryasaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tyleryasaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tyleryasaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tyleryasaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tyleryasaka/orgs",
      "repos_url": "https://api.github.com/users/tyleryasaka/repos",
      "events_url": "https://api.github.com/users/tyleryasaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tyleryasaka/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T03:51:34Z",
    "updated_at": "2018-10-18T03:51:34Z",
    "author_association": "NONE",
    "body": "First of all, I appreciate the spirit of this as I also have [written about the shortcomings of existing identity standards](https://medium.com/@tyleryasaka/erc725-proposed-changes-ea2dc221136e).\r\n\r\nHowever, I will make a contention: Ethereum already has identity built in. It's called an address, and it's already fully supported by the entire ecosystem. I just published [a medium post explaining this argument](https://medium.com/@tyleryasaka/the-3-essentials-of-identity-in-ethereum-51fba7e1dd32).\r\n\r\nSo we don't need to standardize identity. That said, there may be specific problems related to identity that can benefit from standards. For example, I think that universal login is a problem that could benefit from a standard. (See the blog post above or see [my repo exploring a standard around this](https://github.com/tyleryasaka/identity-proposals).) Claims are also a related problem, for which we already have [ERC780](https://github.com/ethereum/EIPs/issues/780). Some have criticized 780 for not being quite flexible enough, so I am also exploring a more flexible claims standard that is fully backwards compatible with 780 (again, see [my repo](https://github.com/tyleryasaka/identity-proposals) if you're interested in this).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/430866516/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431052728",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-431052728",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 431052728,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTA1MjcyOA==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T15:25:02Z",
    "updated_at": "2018-10-18T15:25:02Z",
    "author_association": "NONE",
    "body": "@tyleryasaka thanks for the response - reading through your articles, it's great to see a shared mindset of future-proofing the concept of identity management while remaining un-opinionated about its particular execution. \r\n\r\nI do think that the challenge around relying on a single user-controlled address is that an address is really optimized for one function, which is governance - signing messages for state changes to the ethereum blockchain. It's not natively optimized to resolve an `Identity` as an entity to multiple data structures in a meaningful way. \r\n\r\nWhat we're aiming to do here is to allow user-controlled \"first-class citizenship\" in application of the essentials you outline in your second article while allowing identity applications flexibility for customized solutions to the challenges mentioned in your first article: namely, implementation-specific coupled or decoupled address management functions, claims approaches, or even broader identification schemes such as reputation-driven ones. \r\n\r\nThe real purpose of a standardized scheme for Identity interoperability is to bridge the gap between what recognizing an entity by an `Identity` provides versus what recognizing an entity by a given `address` provides in terms of usability, multiple address linkage, and recovery.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431052728/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431185897",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-431185897",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 431185897,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTE4NTg5Nw==",
    "user": {
      "login": "alexandermuehle",
      "id": 1909723,
      "node_id": "MDQ6VXNlcjE5MDk3MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1909723?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexandermuehle",
      "html_url": "https://github.com/alexandermuehle",
      "followers_url": "https://api.github.com/users/alexandermuehle/followers",
      "following_url": "https://api.github.com/users/alexandermuehle/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexandermuehle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexandermuehle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexandermuehle/subscriptions",
      "organizations_url": "https://api.github.com/users/alexandermuehle/orgs",
      "repos_url": "https://api.github.com/users/alexandermuehle/repos",
      "events_url": "https://api.github.com/users/alexandermuehle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexandermuehle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T22:30:18Z",
    "updated_at": "2018-10-18T22:30:18Z",
    "author_association": "NONE",
    "body": "Why did you introduce EINs instead of using DIDs? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431185897/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431207694",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-431207694",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 431207694,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTIwNzY5NA==",
    "user": {
      "login": "morelazers",
      "id": 2966123,
      "node_id": "MDQ6VXNlcjI5NjYxMjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2966123?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morelazers",
      "html_url": "https://github.com/morelazers",
      "followers_url": "https://api.github.com/users/morelazers/followers",
      "following_url": "https://api.github.com/users/morelazers/following{/other_user}",
      "gists_url": "https://api.github.com/users/morelazers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morelazers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morelazers/subscriptions",
      "organizations_url": "https://api.github.com/users/morelazers/orgs",
      "repos_url": "https://api.github.com/users/morelazers/repos",
      "events_url": "https://api.github.com/users/morelazers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morelazers/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-19T00:34:56Z",
    "updated_at": "2018-10-19T00:34:56Z",
    "author_association": "NONE",
    "body": "@alexandermuehle I believe that current DID proposals treat a single Ethereum address as a single identity, which is what this proposal is attempting to avoid.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431207694/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431286141",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-431286141",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 431286141,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTI4NjE0MQ==",
    "user": {
      "login": "alexandermuehle",
      "id": 1909723,
      "node_id": "MDQ6VXNlcjE5MDk3MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1909723?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexandermuehle",
      "html_url": "https://github.com/alexandermuehle",
      "followers_url": "https://api.github.com/users/alexandermuehle/followers",
      "following_url": "https://api.github.com/users/alexandermuehle/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexandermuehle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexandermuehle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexandermuehle/subscriptions",
      "organizations_url": "https://api.github.com/users/alexandermuehle/orgs",
      "repos_url": "https://api.github.com/users/alexandermuehle/repos",
      "events_url": "https://api.github.com/users/alexandermuehle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexandermuehle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-19T08:27:39Z",
    "updated_at": "2018-10-19T08:27:39Z",
    "author_association": "NONE",
    "body": "@morelazers I'm not quite sure I get your point, while there should be only one authoritative DID Document per DID, that document can include various public keys of different types and purposes, including Ethereum addresses or what do you mean by treating an Ethereum address as a single identity?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431286141/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431406622",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-431406622",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 431406622,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTQwNjYyMg==",
    "user": {
      "login": "AndyHydro",
      "id": 30632620,
      "node_id": "MDQ6VXNlcjMwNjMyNjIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/30632620?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AndyHydro",
      "html_url": "https://github.com/AndyHydro",
      "followers_url": "https://api.github.com/users/AndyHydro/followers",
      "following_url": "https://api.github.com/users/AndyHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AndyHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AndyHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AndyHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AndyHydro/orgs",
      "repos_url": "https://api.github.com/users/AndyHydro/repos",
      "events_url": "https://api.github.com/users/AndyHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AndyHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-19T15:41:22Z",
    "updated_at": "2018-10-19T15:41:22Z",
    "author_association": "NONE",
    "body": "@alexandermuehle we are currently working on the DID specification for this ERC and have an initial draft that we plan to publish soon. This implementation still allows for DIDs to exist. We believe that using a persistent, non-address identifier (EIN) as the core of an ERC-1484 DID document makes more sense than an address. The DID is generated through the `recovery address` and would look something like `did:erc1484:2F2B37C890824242Cb9B0FE5614fA2221B79901E#225` where the address is the checksummed `recovery address` and the 225 is the users EIN.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/431406622/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432615400",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-432615400",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 432615400,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjYxNTQwMA==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-24T11:16:12Z",
    "updated_at": "2018-10-24T11:16:12Z",
    "author_association": "NONE",
    "body": "@AndyHydro I do see EINs as a better representation for IDs than addresses, and I can see one or more DID methods could be implemented on top of this protocol. However, I don't quite understand why is the `recovery address` a part of the DID. Since recovery addresses can be rotated for a single identity, that would defeat the persistence feature of DIDs... Wouldn't it make more sense to make it dependable only on the EIN? e.g. `did:erc1484:225` (or a fixed-size hex representation of the EIN)?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432615400/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432702842",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-432702842",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 432702842,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjcwMjg0Mg==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-24T15:19:14Z",
    "updated_at": "2018-10-25T14:14:08Z",
    "author_association": "NONE",
    "body": "@cbruguera that's a good point - since the EIN is globally unique, I think a hex-encoded EIN is the most straightforward and persistent DID representation. I've updated the [DID method](https://github.com/hydrogen-dev/ERC-1484/blob/master/best-practices/DID-Method.md) to reflect this. Let us know if you've got any further thoughts on this! ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432702842/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432940096",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-432940096",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 432940096,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjk0MDA5Ng==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T07:13:11Z",
    "updated_at": "2018-10-25T07:13:56Z",
    "author_association": "NONE",
    "body": "@AnuragHydro Another arising thought is that an EIN is \"globally\" unique in the universe pertaining to the EIN registry contract. This assumes there is only one global ERC1484 implementation up and running on the network, which might be ideal but apparently not enforceable. I can't come up now with a good reason, but what if there are multiple contract instances (or versions), each one with its own EIN counter?... Would it then make sense to have the contract address (or some other distinctive feature) take part in corresponding DID generation? \r\n\r\nExamples:\r\n\r\na. A keccak hash of: the contract address concatenated with (a fixed hex representation of the) EIN\r\nb. A composite DID in the form: did:erc1484:<contract_address>:<_EIN>\r\n\r\n(At first, it looks like option b would be more practical, since it provides useful info that would be obfuscated in the first option)\r\n\r\n...Any thoughts on this?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432940096/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433074283",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433074283",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433074283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzA3NDI4Mw==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T14:31:06Z",
    "updated_at": "2018-10-25T14:31:06Z",
    "author_association": "NONE",
    "body": "@cbruguera That's a reasonable concern (although it would certainly be ideal to standardize usage of a single deployment of the IdentityRegistry). I also don't see a reason to hash the contract address, but I do like the idea of using `did:erc1484:<network>:<contract_address>:<_EIN>` (option b). I've updated the [DID Method](https://github.com/hydrogen-dev/ERC-1484/blob/master/best-practices/DID-Method.md) again to reflect this convention 👍 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433074283/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433111677",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433111677",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433111677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzExMTY3Nw==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T16:09:09Z",
    "updated_at": "2018-10-25T16:09:09Z",
    "author_association": "NONE",
    "body": "For those following the reference implementation, it has now been updated to include [best practices](https://github.com/hydrogen-dev/ERC-1484/tree/master/best-practices) for resolvers recognizing EINs, [example resolvers](https://github.com/hydrogen-dev/ERC-1484/tree/master/contracts/examples/Resolvers) under the ERC 725 and 1056 standards, and an [example meta-transactions provider](https://github.com/hydrogen-dev/ERC-1484/tree/master/contracts/examples/Providers)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433111677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433692578",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433692578",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433692578,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzY5MjU3OA==",
    "user": {
      "login": "xrn",
      "id": 8377768,
      "node_id": "MDQ6VXNlcjgzNzc3Njg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8377768?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/xrn",
      "html_url": "https://github.com/xrn",
      "followers_url": "https://api.github.com/users/xrn/followers",
      "following_url": "https://api.github.com/users/xrn/following{/other_user}",
      "gists_url": "https://api.github.com/users/xrn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/xrn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/xrn/subscriptions",
      "organizations_url": "https://api.github.com/users/xrn/orgs",
      "repos_url": "https://api.github.com/users/xrn/repos",
      "events_url": "https://api.github.com/users/xrn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/xrn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-28T10:23:12Z",
    "updated_at": "2018-10-28T13:47:55Z",
    "author_association": "NONE",
    "body": "@AnuragHydro  I have the question maybe I am wrong but we will see... A universal login idea has one very powerful feature this means user funds are stored on smart contract balance and then owners (multiple - checked via signatures) can sign requests to spent this money (eth, tokens). The idea with relayers is pretty good too - even if do not have any funds on wallet we still can make some transactions.\r\n\r\nYou know this topic probably best then I but this is very useful (from other hands very trackable). A user can connect many devices to 1 contract and do not have to remember about private key backups etc. A user has access to all my funds assigned to given wallet from any place.\r\n\r\nTo summarize - what do you think to add one more array of actors like \"treasury\" to existing \"providers\" and \"resolvers\" which have access to spent money from special contracts deployed per user?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433692578/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433738439",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433738439",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433738439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzczODQzOQ==",
    "user": {
      "login": "NoahZinsmeister",
      "id": 3760414,
      "node_id": "MDQ6VXNlcjM3NjA0MTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3760414?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NoahZinsmeister",
      "html_url": "https://github.com/NoahZinsmeister",
      "followers_url": "https://api.github.com/users/NoahZinsmeister/followers",
      "following_url": "https://api.github.com/users/NoahZinsmeister/following{/other_user}",
      "gists_url": "https://api.github.com/users/NoahZinsmeister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NoahZinsmeister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NoahZinsmeister/subscriptions",
      "organizations_url": "https://api.github.com/users/NoahZinsmeister/orgs",
      "repos_url": "https://api.github.com/users/NoahZinsmeister/repos",
      "events_url": "https://api.github.com/users/NoahZinsmeister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NoahZinsmeister/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-28T20:26:59Z",
    "updated_at": "2018-11-02T20:43:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "We'd like to request some specific feedback on the signature scheme in 1484, specifically the form of requested signatures and the steps taken to prevent replay attacks. This [best-practices document](https://github.com/hydrogen-dev/ERC-1484/blob/master/best-practices/VerifyingSignatures.md) is suggested reading.\r\n\r\n## Format\r\nRight now, signatures are formatted per [ERC191](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md) v0. This means that addresses are required to sign the hash of <standard 191 data, an authorization string, authorization-specific variables> to perform various identity-related actions (see the [identity creation code](https://github.com/hydrogen-dev/ERC-1484/blob/master/contracts/IdentityRegistry.sol#L186) for an example). While there are many reasons we prefer this v0 scheme, some community members prefer v1, which is fleshed out in ERC #721. Other alternatives are also possible.\r\n\r\n## Preventing Replay Attacks\r\nTo prevent replay attacks, the implementation requires that all signatures include a timestamp which is enforced to be within a day of the current block timestamp. This ensures that there is a one day timeout for (properly) signed messages to retain their ability to authorize identity-related actions. For more context, see the Signature Timeout section of [this comment](https://github.com/ethereum/EIPs/issues/1495#issuecomment-435501890).\r\n\r\n**Are there any thoughts or opinions on either of these issues?**",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433738439/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433739677",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433739677",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433739677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzczOTY3Nw==",
    "user": {
      "login": "NoahZinsmeister",
      "id": 3760414,
      "node_id": "MDQ6VXNlcjM3NjA0MTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3760414?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NoahZinsmeister",
      "html_url": "https://github.com/NoahZinsmeister",
      "followers_url": "https://api.github.com/users/NoahZinsmeister/followers",
      "following_url": "https://api.github.com/users/NoahZinsmeister/following{/other_user}",
      "gists_url": "https://api.github.com/users/NoahZinsmeister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NoahZinsmeister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NoahZinsmeister/subscriptions",
      "organizations_url": "https://api.github.com/users/NoahZinsmeister/orgs",
      "repos_url": "https://api.github.com/users/NoahZinsmeister/repos",
      "events_url": "https://api.github.com/users/NoahZinsmeister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NoahZinsmeister/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-28T20:43:11Z",
    "updated_at": "2018-10-28T20:43:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "@xrn thanks for the suggestion! We discussed this issue, and ultimately decided to remain agnostic about these specific types of issues at the Registry level, for the following reasons.\r\n\r\nOne specific use of the Associated Addresses data structure might be to treat each as a joint owner of a common repository of ETH/tokens/etc. This way, a Resolver could incorporate the ability for any Associated Address to transact value on behalf of its associated Identity.\r\n\r\nWe also fully expect more sophisticated delegation/treasury patterns to spring up on a per-Provider level. For example, [a Provider that we have been working on](https://github.com/hydrogen-dev/smart-contracts/blob/ERC1484-dev/snowflake/contracts/Snowflake.sol) includes the ability for 1484 Identities to deposit tokens to their identities, and offers functions to Resolvers that allow them to manipulate these token balances (with the proper authorization).\r\n\r\nSince these types of patterns and more may or may not require Resolvers/Providers to store additional per-Identity information, we view the current structure as appropriately balancing a) storing enough useful and generic information centrally in the Registry while b) enabling arbitrarily sophisticated use cases in the future.\r\n\r\nDoes that address your concerns?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433739677/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433798673",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-433798673",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 433798673,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzc5ODY3Mw==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-29T06:12:32Z",
    "updated_at": "2018-10-29T06:12:32Z",
    "author_association": "NONE",
    "body": "I agree that the identity protocol should remain agnostic with regard to token/ETH dynamics. \r\n\r\nThe aforementioned functionality can be achieved through new token contract protocols, or via custom Resolver/Provider implementations as pointed out by @NoahZinsmeister. Moreover, my personal take on the matter is that the capability of shared holding of ETH/tokens in this way is not as valuable as being able to associate \"claims\" to multiple addresses. i.e. if you control multiple addresses, you already control the ETH/tokens held among them, it's a trivial matter to transfer money among addreses, but signed claims about a subject cannot (or shouldn't) be \"transferred\" in such a way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433798673/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435501890",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-435501890",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 435501890,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTUwMTg5MA==",
    "user": {
      "login": "NoahZinsmeister",
      "id": 3760414,
      "node_id": "MDQ6VXNlcjM3NjA0MTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3760414?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NoahZinsmeister",
      "html_url": "https://github.com/NoahZinsmeister",
      "followers_url": "https://api.github.com/users/NoahZinsmeister/followers",
      "following_url": "https://api.github.com/users/NoahZinsmeister/following{/other_user}",
      "gists_url": "https://api.github.com/users/NoahZinsmeister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NoahZinsmeister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NoahZinsmeister/subscriptions",
      "organizations_url": "https://api.github.com/users/NoahZinsmeister/orgs",
      "repos_url": "https://api.github.com/users/NoahZinsmeister/repos",
      "events_url": "https://api.github.com/users/NoahZinsmeister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NoahZinsmeister/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T20:38:27Z",
    "updated_at": "2018-11-03T19:49:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "In addition to [requesting feedback on signatures](https://github.com/ethereum/EIPs/issues/1495#issuecomment-433738439), we'd also like to solicit opinions on the value of the constants in ERC-1484.\r\n\r\n## Max Associated Addresses\r\n```solidity\r\nuint public maxAssociatedAddresses = 50;\r\n```\r\n\r\nThis constant controls the maximum number of `associatedAddresses` an `Identity` can have at any given time. The reason this limit must exist is because when calling `triggerRecovery`, the current members of the `associatedAddress` set are [operated on](https://github.com/hydrogen-dev/ERC-1484/blob/master/contracts/IdentityRegistry.sol#L417) to facilitate the `triggerPoisonPill` process. \r\n\r\n- This is because to call `triggerPoisonPill`, a user needs to know the ordered list of `associatedAddresses` at the time of last recovery. Logging the addresses straightforwardly addresses this problem. Some gas could be saved by omitting this logging, at the expense of usability, since the `associatedAddress` array would then have to be reconstructed from prior event logs.\r\n\r\nIn order to ensure that `triggerRecovery` never fails, we need to ensure that the number of `associatedAddresses` is never so high that these operations hit the block gas limit. Based on preliminary calculations, the increased cost per address is ~36k gas, with a fixed cost of ~175k gas. This means that triggering recovery from an `Identity` with 50 addresses would cost ~2 million gas, which seems reasonably within expected future gas block limits.\r\n\r\n**We would love for someone to externally validate these calculations.**\r\n\r\n## Signature Timeout\r\n```solidity\r\nuint public signatureTimeout = 1 days;\r\n```\r\n\r\nThis constant controls the amount of time that a timestamped signature remains valid for. This must be low enough that the probability of replay attacks within the window is acceptably low, and high enough to ensure that the number of blocks for which a signature is valid is high enough such that transactions can be broadcast and confirmed reliably.\r\n\r\n**We would love feedback on this, specifically around potential replay attacks within the window for each instance in which ERC-1484 requires a signature.**\r\n\r\n## Recovery Timeout\r\n```solidity\r\nuint public recoveryTimeout = 2 weeks;\r\n```\r\n\r\nThis constant controls the amount of time which must elapse between:\r\n- Changes in `recoveryAddress`. This timeout is necessary to give the old `recoveryAddress` enough time to be able to dispute malicious changes in `recoveryAddress` by calling `triggerRecovery`.\r\n- Triggered Recoveries. This timeout is necessary so that if a malicious address ends up calling `triggerRecovery`, any of the removed `associatedAddresses` have enough time to be able to irrevocably dispute this recovery by calling `triggerPoisonPill`.\r\n\r\n**We would love feedback on these two scenarios.**",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435501890/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 2,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435754686",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-435754686",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 435754686,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTc1NDY4Ng==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T04:51:38Z",
    "updated_at": "2018-11-05T04:51:38Z",
    "author_association": "NONE",
    "body": "@AnuragHydro I have a few questions with regard to current work on ERC1484:\r\n\r\n- In the reference implementation, what's the purpose of storing recovery address change structs in `RecoveryAddressChangeLogs` (why not rely on emitting events as a method for logging)?\r\n- Are existing instances of ERC1056 or ERC725 able to be integrated as Resolvers for ERC1484 identities, or do these specific identity solutions have to be re-implemented with specific logic that allows them to function as ERC1484 resolvers?\r\n- Is there a work being done for implementing a DID resolver for ERC1848?\r\n\r\n@NoahZinsmeister I pretty much agree on the constants proposal. Yet I think in order to be as least restrictive as possible, we should maximize the `maxAssociatedAddresses` to a point closer to hitting the maximum block gas limit for the involved methods. For example, current maximum block gas limit is about 8 million, if my googling is correct, so there's still significant room for a higher number of addresses.\r\n\r\nWith regard to recovery timeout, I'm thinking 1 week could be enough, but there's no concrete reasoning behind that number, more than just an intuitive guess. Looking forward to know other opinions on the matter.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435754686/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435998138",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-435998138",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 435998138,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTk5ODEzOA==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T19:11:23Z",
    "updated_at": "2018-11-05T19:11:23Z",
    "author_association": "NONE",
    "body": "@cbruguera \r\n> In the reference implementation, what's the purpose of storing recovery address change structs in `RecoveryAddressChangeLogs` (why not rely on emitting events as a method for logging)?\r\n\r\nThe `recoveryAddressChangeLog` is to enable recourse if a compromised `Associated Address` attempts to change the `Recovery Address`. This enables the [check within the recovery function](https://github.com/hydrogen-dev/ERC-1484/blob/94fb23c5134b3768b79ec626d4e7ce76309d6105/contracts/IdentityRegistry.sol#L71) to ensure that Recovery can be called within `recoveryTimeout`. \r\n> Are existing instances of ERC1056 or ERC725 able to be integrated as Resolvers for ERC1484 identities, or do these specific identity solutions have to be re-implemented with specific logic that allows them to function as ERC1484 resolvers?\r\n\r\n@AndyHydro - can you elaborate in more detail regarding methods in the [725 and 1056 examples](https://github.com/hydrogen-dev/ERC-1484/tree/master/contracts/examples/Resolvers) to port existing instances of each respective resolver? \r\n\r\n> Is there a work being done for implementing a DID resolver for ERC1848?\r\n\r\nAt the moment, we only have the DID method - we can look into creating a DID resolver to fetch data from the DID method - do you have any specific considerations on this front? \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435998138/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436134101",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-436134101",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 436134101,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjEzNDEwMQ==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T05:19:11Z",
    "updated_at": "2018-11-06T05:19:11Z",
    "author_association": "NONE",
    "body": "@AnuragHydro With regard to DID methods, I think it'd be more precise to ask what is the role of a DID method for this proposal... Since this is sort of an abstraction layer that can encompass existing Ethereum-based identity schemes such as ERC1056 and ERC725 (as far as I understand), how does ERC1484 integrate or substitute (DID-wise) these other platforms? \r\n\r\nThere are DID methods for ERC725 and ERC1056. Does enveloping these identities through an ERC1484 EIN make these other DID methods unnecessary? Or is there any reason for these multiple DID methods to coexist or hold any relationship among them?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436134101/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436433171",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-436433171",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 436433171,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjQzMzE3MQ==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T22:30:52Z",
    "updated_at": "2018-11-06T22:30:52Z",
    "author_association": "NONE",
    "body": "@cbruguera I don't think that any particular DID method replaces the need for another - they are just used to locate their corresponding on-chain identifiers and construct any associated identity information accordingly. It's true that an `EIN` is informative about a 725 or 1056 identity; for instance, using `did:erc1484:<contract-address>:<ein>`, you can get the `EIN`'s corresponding 725 or 1056 public profiles from the respective registry and construct the DID that way, but I think it's better for each identity application to maintain an authoritative DID method independent of ERC 1484 for two main reasons:\r\n\r\n1) Static DID Method: If the 1484 DID method were to assume the role of a universal Ethereum DID, it would need to be dynamic, with a mechanism to update nonstandard information to the DID doc with each aggregated identity application. Since these docs are constructed off-chain, the DID method would need to include centralized update procedures for each new aggregated identity application to remain authoritative.\r\n\r\n2) Independent Identity Application Services: certain DIDs leverage service endpoints with off-chain customized functionality that may not directly tie to ERC 1484 functionality. Forcing these service endpoints into an ERC 1484 DID method may prove restrictive.\r\n\r\nInstead, I'd posit that the 1484 DID method is useful for making non-Ethereum-based DIDs resolvable to the Ethereum blockchain. For instance, an identity application built on non-ethereum structure may have a service endpoint accepting a signature from an `Associated Address` in order to authoritatively add the corresponding `EIN` into its own DID doc. This would allow an off-chain digital identity structure to remain resolvable to an `EIN` insofar as the service endpoint and off-chain infrastructure is trusted. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436433171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436492839",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-436492839",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 436492839,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjQ5MjgzOQ==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-07T03:31:41Z",
    "updated_at": "2018-11-07T03:31:41Z",
    "author_association": "NONE",
    "body": "@AnuragHydro It makes total sense not to try turning the ERC1484 DID method into an \"all-encompassing\" method, for the reasons provided. However, I'm having a bit of trouble understanding your last example. Can you expand it further?... In this scenario is the identity owner the \"controller\" of both the ERC1484 EIN and the off-chain service? Does the off-chain service have a DID that is resolvable to an EIN of its own? Or is this about delegating \"keys\" among different DID methods? What does \"adding the corresponding EIN into its own DID doc\" mean exactly?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436492839/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436494169",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-436494169",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 436494169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjQ5NDE2OQ==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-07T03:40:41Z",
    "updated_at": "2018-11-07T03:40:41Z",
    "author_association": "NONE",
    "body": "On a different topic, I've been thinking of the potential limitations of having the EIN be a simple and (predictably) incremental counter. Although at this time no specific privacy-threat scenario comes to mind, certainly in the current proposal an EIN by itself reveals a minimum degree of information (i.e. chronological order). I was wondering if it makes sense to \"randomize\" the generation of EINs, so that there's no explicit order relationship among them. For example: the counter can still be used as a \"nonce\", and EINs could be generated as a 32-byte hash of that nonce concatenated with some other info (such as the caller's address, etc.)\r\n\r\nThat would ensure uniqueness of identifiers, plus a bit more of privacy (I guess anyone can still resolve the EINs and obtain public info such as date of creation, yet the identifiers _per se_ reveal nothing). I'd just like to know what is the overall view on this matter, and if it's considered actually relevant or not.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436494169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437086666",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-437086666",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 437086666,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA4NjY2Ng==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:28:35Z",
    "updated_at": "2018-11-08T17:28:35Z",
    "author_association": "NONE",
    "body": "@cbruguera \r\n> In this scenario is the identity owner the \"controller\" of both the ERC1484 EIN and the off-chain service?\r\n\r\nYes - the off-chain service would use an `Associated Address` signature to prove this.\r\n\r\n>Does the off-chain service have a DID that is resolvable to an EIN of its own? Or is this about delegating \"keys\" among different DID methods? What does \"adding the corresponding EIN into its own DID doc\" mean exactly?\r\n\r\nOff-chain service can be as opinionated or unopinionated as it chooses. An example would be building an identity profile on hyperledger indy; with an `Associated Address` signature, all of the functionality for the identity would maintain integrity on \"non-ethereum\" service while remaining resolvable to an Ethereum EIN, proving a persistent user (insofar as the off-chain infrastructure is trusted). I hope that makes more sense!\r\n\r\n> On a different topic, I've been thinking of the potential limitations of having the EIN be a simple and (predictably) incremental counter. Although at this time no specific privacy-threat scenario comes to mind, certainly in the current proposal an EIN by itself reveals a minimum degree of information (i.e. chronological order). I was wondering if it makes sense to \"randomize\" the generation of EINs, so that there's no explicit order relationship among them. For example: the counter can still be used as a \"nonce\", and EINs could be generated as a 32-byte hash of that nonce concatenated with some other info (such as the caller's address, etc.) That would ensure uniqueness of identifiers, plus a bit more of privacy (I guess anyone can still resolve the EINs and obtain public info such as date of creation, yet the identifiers per se reveal nothing). I'd just like to know what is the overall view on this matter, and if it's considered actually relevant or not.\r\n\r\nPersonally, I do not see this as a big concern; since EINs are generated on-chain anyways, the order in which they were generated is already public regardless of whether uints vs random identifiers are used. Not sure if anyone else feels strongly on this. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437086666/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/438549815",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-438549815",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 438549815,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODU0OTgxNQ==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-14T06:10:55Z",
    "updated_at": "2018-11-14T06:10:55Z",
    "author_association": "NONE",
    "body": "Can I suggest considering a little less \"allegorical\" name for the \"poison pill\" functionality? Perhaps something more technically accurate such as `disable`, `destroy`, etc.?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/438549815/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441958925",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-441958925",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 441958925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTk1ODkyNQ==",
    "user": {
      "login": "zhous",
      "id": 1388904,
      "node_id": "MDQ6VXNlcjEzODg5MDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1388904?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zhous",
      "html_url": "https://github.com/zhous",
      "followers_url": "https://api.github.com/users/zhous/followers",
      "following_url": "https://api.github.com/users/zhous/following{/other_user}",
      "gists_url": "https://api.github.com/users/zhous/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zhous/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zhous/subscriptions",
      "organizations_url": "https://api.github.com/users/zhous/orgs",
      "repos_url": "https://api.github.com/users/zhous/repos",
      "events_url": "https://api.github.com/users/zhous/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zhous/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-27T07:44:14Z",
    "updated_at": "2018-11-27T07:44:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is great. And alos it's what I have being trid for months. Now I need some time to read the proposal, my English is slow. Anyway, good job!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441958925/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442213510",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-442213510",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 442213510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjIxMzUxMA==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-27T20:55:11Z",
    "updated_at": "2018-11-27T20:55:11Z",
    "author_association": "NONE",
    "body": "@cbruguera sure thing! changed to \"destroy\"",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442213510/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442263169",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-442263169",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 442263169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjI2MzE2OQ==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-27T23:50:42Z",
    "updated_at": "2018-11-27T23:50:42Z",
    "author_association": "NONE",
    "body": "Also, for anyone interested, here's a telegram chat for less formal discussion around this proposal. https://t.me/erc1484 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442263169/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442308518",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-442308518",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 442308518,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjMwODUxOA==",
    "user": {
      "login": "fulldecent",
      "id": 382183,
      "node_id": "MDQ6VXNlcjM4MjE4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/382183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fulldecent",
      "html_url": "https://github.com/fulldecent",
      "followers_url": "https://api.github.com/users/fulldecent/followers",
      "following_url": "https://api.github.com/users/fulldecent/following{/other_user}",
      "gists_url": "https://api.github.com/users/fulldecent/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fulldecent/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fulldecent/subscriptions",
      "organizations_url": "https://api.github.com/users/fulldecent/orgs",
      "repos_url": "https://api.github.com/users/fulldecent/repos",
      "events_url": "https://api.github.com/users/fulldecent/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fulldecent/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-28T03:42:34Z",
    "updated_at": "2018-11-28T03:42:34Z",
    "author_association": "CONTRIBUTOR",
    "body": "What is the actual, end-user, tell my not-tech-advanced family member use case here?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442308518/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442483770",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-442483770",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 442483770,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjQ4Mzc3MA==",
    "user": {
      "login": "ghost",
      "id": 10137,
      "node_id": "MDQ6VXNlcjEwMTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ghost",
      "html_url": "https://github.com/ghost",
      "followers_url": "https://api.github.com/users/ghost/followers",
      "following_url": "https://api.github.com/users/ghost/following{/other_user}",
      "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
      "organizations_url": "https://api.github.com/users/ghost/orgs",
      "repos_url": "https://api.github.com/users/ghost/repos",
      "events_url": "https://api.github.com/users/ghost/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ghost/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-28T15:18:25Z",
    "updated_at": "2018-11-28T15:18:25Z",
    "author_association": "NONE",
    "body": "@fulldecent In my view the real value prop is:\r\n\r\nDApp developers will be able to identify users not by address, but by unique 1484 identifier (Ethereum Identification Number/EIN). This is powerful because EINs are natively multi-address, meaning interacting with dApps on mobile, desktop, in dedicated apps, etc. gives users the same exact experience once they’ve linked these accounts to their identity. The best part is that meta-transactions are also fully supported, meaning that applications (Providers in 1484-speak) can send permissioned transactions on behalf of users who might not understand complex blockchain mechanics.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442483770/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442500826",
    "html_url": "https://github.com/ethereum/EIPs/issues/1495#issuecomment-442500826",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1495",
    "id": 442500826,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjUwMDgyNg==",
    "user": {
      "login": "AnuragHydro",
      "id": 37848473,
      "node_id": "MDQ6VXNlcjM3ODQ4NDcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37848473?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnuragHydro",
      "html_url": "https://github.com/AnuragHydro",
      "followers_url": "https://api.github.com/users/AnuragHydro/followers",
      "following_url": "https://api.github.com/users/AnuragHydro/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnuragHydro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnuragHydro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnuragHydro/subscriptions",
      "organizations_url": "https://api.github.com/users/AnuragHydro/orgs",
      "repos_url": "https://api.github.com/users/AnuragHydro/repos",
      "events_url": "https://api.github.com/users/AnuragHydro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnuragHydro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-28T16:02:08Z",
    "updated_at": "2018-11-28T23:20:26Z",
    "author_association": "NONE",
    "body": ">DApp developers will be able to identify users\r\n\r\nwith respect to \"identifying users\", since EINs aggregate identity profiles, if two applications want to take the same approach to identifying users (kind of like \"log-in with facebook\"), they're able to leverage existing identity implementations tied to an EIN. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/442500826/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
