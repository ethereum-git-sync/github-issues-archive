{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/181/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/181/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/181/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/181",
  "id": 192920807,
  "node_id": "MDU6SXNzdWUxOTI5MjA4MDc=",
  "number": 181,
  "title": "ENS support for reverse resolution of Ethereum addresses",
  "user": {
    "login": "Arachnid",
    "id": 17865,
    "node_id": "MDQ6VXNlcjE3ODY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Arachnid",
    "html_url": "https://github.com/Arachnid",
    "followers_url": "https://api.github.com/users/Arachnid/followers",
    "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
    "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
    "organizations_url": "https://api.github.com/users/Arachnid/orgs",
    "repos_url": "https://api.github.com/users/Arachnid/repos",
    "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Arachnid/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 13,
  "created_at": "2016-12-01T18:08:54Z",
  "updated_at": "2017-11-25T09:08:49Z",
  "closed_at": "2017-11-25T09:08:49Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "<pre>\r\n  EIP: draft\r\n  Title: ENS support for reverse resolution of Ethereum addresses\r\n  Author: Nick Johnson <arachnid@notdot.net>\r\n  Status: Draft\r\n  Type: Informational\r\n  Created: 2016-12-01\r\n</pre>\r\n\r\n# Abstract\r\nThis EIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question.\r\n\r\n# Motivation\r\nWhile name services are mostly used for forward resolution - going from human-readable identifiers to machine-readable ones - there are many use-cases in which reverse resolution is useful as well:\r\n\r\n - Applications that allow users to monitor accounts benefit from showing the name of an account instead of its address, even if it was originally added by address.\r\n - Attaching metadata such as descriptive information to an address allows retrieving this information regardless of how the address was originally discovered.\r\n - Anyone can configure a name to resolve to an address, regardless of ownership of that address. Reverse records allow the owner of an address to claim a name as authoritative for that address.\r\n\r\n# Specification\r\nReverse ENS records are stored in the ENS hierarchy in the same fashion as regular records, under a reserved domain, `addr.reverse`. To generate the ENS name for a given account's reverse records, convert the account to hexadecimal representation in lower-case, and append `addr.reverse`. For instance, the ENS registry's address at `0x112234455c3a32fd11230c42e7bccd4a84e02010` has any reverse records stored at `112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse`.\r\n\r\nNote that this means that contracts wanting to do dynamic reverse resolution of addresses will need to perform hex encoding in the contract.\r\n\r\n## Registrar\r\nThe owner of the `addr.reverse` domain will be a registrar that permits the caller to take ownership of \r\nthe reverse record for their own address. It provides the following method:\r\n\r\n    function claim(address owner) returns (bytes32 node);\r\n\r\nWhen called by account `x` it will instruct the ENS registry to transfer ownership of the name `hex(x) + '.addr.reverse'` to the provided address, and return the namehash of the ENS record thus transferred.\r\n\r\nAllowing the caller to specify an owner other than themselves for the relevant node facilitates contracts that need accurate reverse ENS entries delegating this to their creators with a minimum of code inside their constructor:\r\n\r\n    reverseRegistrar.claim(msg.sender)\r\n\r\n## Resolver interface\r\nA new resolver interface is defined, consisting of the following method:\r\n\r\n    function name(bytes32 node) constant returns (string);\r\n\r\nResolvers that implement this interface must return a valid ENS name for the requested node, or the empty string if no name is defined for the requested node.\r\n\r\nThe interface ID of this interface is 0x691f3431.\r\n\r\nFuture EIPs may specify more record types appropriate to reverse ENS records.\r\n\r\n# Appendix 1: Registrar implementation\r\n\r\nThis registrar, written in Solidity, implements the specifications outlined above.\r\n\r\n    pragma solidity ^0.4.0;\r\n\r\n    import 'interface.sol';\r\n\r\n    contract ReverseRegistrar {\r\n        AbstractENS public ens;\r\n        bytes32 public rootNode;\r\n        \r\n        /**\r\n         * @dev Constructor\r\n         * @param ensAddr The address of the ENS registry.\r\n         * @param node The node hash that this registrar governs.\r\n         */\r\n        function ReverseRegistrar(address ensAddr, bytes32 node) {\r\n            ens = AbstractENS(ensAddr);\r\n            rootNode = node;\r\n        }\r\n    \r\n        /**\r\n         * @dev Transfers ownership of the reverse ENS record associated with the\r\n         *      calling account.\r\n         * @param owner The address to set as the owner of the reverse record in ENS.\r\n         * @return The ENS node hash of the reverse record.\r\n         */\r\n        function claim(address owner) returns (bytes32 node) {\r\n            var label = sha3HexAddress(msg.sender);\r\n            ens.setSubnodeOwner(rootNode, label, owner);\r\n            return sha3(rootNode, label);\r\n        }\r\n    \r\n        /**\r\n         * @dev An optimised function to compute the sha3 of the lower-case\r\n         *      hexadecimal representation of an Ethereum address.\r\n         * @param addr The address to hash\r\n         * @return The SHA3 hash of the lower-case hexadecimal encoding of the\r\n         *         input address.\r\n         */\r\n        function sha3HexAddress(address addr) constant returns (bytes32 ret) {\r\n            assembly {\r\n                let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\r\n                let i := 40\r\n            loop:\r\n                i := sub(i, 1)\r\n                mstore8(i, byte(and(addr, 0xf), lookup))\r\n                addr := div(addr, 0x10)\r\n                i := sub(i, 1)\r\n                mstore8(i, byte(and(addr, 0xf), lookup))\r\n                addr := div(addr, 0x10)\r\n                jumpi(loop, i)\r\n                ret := sha3(0, 40)\r\n            }\r\n        }\r\n    }",
  "closed_by": {
    "login": "nicksavers",
    "id": 7483198,
    "node_id": "MDQ6VXNlcjc0ODMxOTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7483198?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nicksavers",
    "html_url": "https://github.com/nicksavers",
    "followers_url": "https://api.github.com/users/nicksavers/followers",
    "following_url": "https://api.github.com/users/nicksavers/following{/other_user}",
    "gists_url": "https://api.github.com/users/nicksavers/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nicksavers/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nicksavers/subscriptions",
    "organizations_url": "https://api.github.com/users/nicksavers/orgs",
    "repos_url": "https://api.github.com/users/nicksavers/repos",
    "events_url": "https://api.github.com/users/nicksavers/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nicksavers/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/181/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/181/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264439316",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264439316",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264439316,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQzOTMxNg==",
    "user": {
      "login": "maurelian",
      "id": 23033765,
      "node_id": "MDQ6VXNlcjIzMDMzNzY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23033765?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maurelian",
      "html_url": "https://github.com/maurelian",
      "followers_url": "https://api.github.com/users/maurelian/followers",
      "following_url": "https://api.github.com/users/maurelian/following{/other_user}",
      "gists_url": "https://api.github.com/users/maurelian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maurelian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maurelian/subscriptions",
      "organizations_url": "https://api.github.com/users/maurelian/orgs",
      "repos_url": "https://api.github.com/users/maurelian/repos",
      "events_url": "https://api.github.com/users/maurelian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maurelian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T12:00:34Z",
    "updated_at": "2016-12-02T12:01:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "1. How was the `eth-addr.reverse` domain chosen? Is the intent that future TLD's (say `.tld`) could also have an associated `tld-addr.reverse` registrar/resolver?\r\n2. Is there a precedent for this system on DNS?\r\n3. \"To generate the ENS name for a given account's reverse records, convert the account to hexadecimal representation in lower-case, and append `eth-addr.reverse`\". Are there any alternatives to this name generation approach? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264439316/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264441272",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264441272",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264441272,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ0MTI3Mg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T12:13:03Z",
    "updated_at": "2016-12-02T12:13:03Z",
    "author_association": "MEMBER",
    "body": "> How was the eth-addr.reverse domain chosen?\r\n\r\nIt seemed like a good idea at the time.\r\n\r\n> Is the intent that future TLD's (say .tld) could also have an associated tld-addr.reverse registrar/resolver?\r\n\r\nNo, and I agree this is a bit confusing. The 'eth' in 'eth-addr' refers to the type of address it's a reverse registry for (eg, Ethereum addresses). If we provided reverse lookups for, say, swarm addresses, that would be on 'swarm-addr.reverse', even though there wouldn't be a .swarm TLD. So, there could be a 2ld under .reverse for each type of address ENS resolves to, rather than for each TLD in a forward address.\r\n\r\n> Is there a precedent for this system on DNS?\r\n\r\nYes, this is more or less how IPv4 addresses (with `in-addr.arpa`) and IPv6 addresses (with `ip6.arpa`) are reverse-resolved, only with more hierarchal separation of the IP.\r\n\r\n> Are there any alternatives to this name generation approach?\r\n\r\nYes, instead of hex encoding the address, we could specify that the reverse record for an address is held at `sha3(namehash('eth-addr.reverse'), sha3(address))` - eg, the same approach but without hex encoding first. This would have the advantage of never needing to do onchain hex encoding, but the significant disadvantage that you can't represent the name a reverse record is hosted under as text, any longer.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264441272/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264467587",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264467587",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264467587,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ2NzU4Nw==",
    "user": {
      "login": "jpritikin",
      "id": 2002771,
      "node_id": "MDQ6VXNlcjIwMDI3NzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2002771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jpritikin",
      "html_url": "https://github.com/jpritikin",
      "followers_url": "https://api.github.com/users/jpritikin/followers",
      "following_url": "https://api.github.com/users/jpritikin/following{/other_user}",
      "gists_url": "https://api.github.com/users/jpritikin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jpritikin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jpritikin/subscriptions",
      "organizations_url": "https://api.github.com/users/jpritikin/orgs",
      "repos_url": "https://api.github.com/users/jpritikin/repos",
      "events_url": "https://api.github.com/users/jpritikin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jpritikin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T14:36:42Z",
    "updated_at": "2016-12-02T14:36:42Z",
    "author_association": "NONE",
    "body": "Do you really foresee the need to do reverse lookups on-chain? The use cases mentioned could probably be satisfied with an off-chain database (perhaps stored in swarm) that is regularly updated to match the forward mapping. An on-chain reverse database doubles the storage requirement for ENS.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264467587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264468715",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264468715",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264468715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ2ODcxNQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T14:41:38Z",
    "updated_at": "2016-12-02T14:41:38Z",
    "author_association": "MEMBER",
    "body": "> Do you really foresee the need to do reverse lookups on-chain?\r\n\r\nNo; that's why I didn't think the cost of having to hex encode the data onchain was a compelling one.\r\n\r\n> The use cases mentioned could probably be satisfied with an off-chain database (perhaps stored in swarm) that is regularly updated to match the forward mapping.\r\n\r\nCouldn't the same argument be made about forward lookups? Doing either offchain introduces significant challenges in determining how the database is located, and how it's verified to be correct, however.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264468715/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264474029",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264474029",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264474029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ3NDAyOQ==",
    "user": {
      "login": "jpritikin",
      "id": 2002771,
      "node_id": "MDQ6VXNlcjIwMDI3NzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2002771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jpritikin",
      "html_url": "https://github.com/jpritikin",
      "followers_url": "https://api.github.com/users/jpritikin/followers",
      "following_url": "https://api.github.com/users/jpritikin/following{/other_user}",
      "gists_url": "https://api.github.com/users/jpritikin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jpritikin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jpritikin/subscriptions",
      "organizations_url": "https://api.github.com/users/jpritikin/orgs",
      "repos_url": "https://api.github.com/users/jpritikin/repos",
      "events_url": "https://api.github.com/users/jpritikin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jpritikin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T15:03:31Z",
    "updated_at": "2016-12-02T15:03:31Z",
    "author_association": "NONE",
    "body": "> Couldn't the same argument be made about forward lookups?\r\n\r\nNo because the auction etc needs to be on-chain. It's useful to be able to transfer ownership of domains in a decentralized way. In contrast, the reverse mapping is merely a reorganization of the forward mapping.\r\n\r\n> significant challenges in determining how the database is located, and how it's verified to be correct\r\n\r\nThat's true, but I suggest these challenges are worth confronting to halve the on-chain storage requirement. The reverse database could be located by a well-known contract that stores a swarm hash. How trustworthy does the reverse mapping need to be? If occasional errors could be tolerated then updates could be managed in a decentralized way by using a security deposit.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264474029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264475934",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264475934",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264475934,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ3NTkzNA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T15:11:13Z",
    "updated_at": "2016-12-02T15:11:13Z",
    "author_association": "MEMBER",
    "body": "> No because the auction etc needs to be on-chain. It's useful to be able to transfer ownership of domains in a decentralized way.\r\n\r\nGood point.\r\n\r\n> That's true, but I suggest these challenges are worth confronting to halve the on-chain storage requirement. \r\n\r\nI disagree. I think that this is exactly the sort of small-but-valuable data with clearly defined update rules that blockchains are good at storing.\r\n\r\n> The reverse database could be located by a well-known contract that stores a swarm hash. \r\n\r\nThis introduces a dependency on swarm for anyone wanting to do reverse resolution, though. It also turns reverse lookup support from a fairly simple proposition into a significant undertaking all of its own. Reverse resolution is useful now, not if & when we can figure that out.\r\n\r\nOne really common use-case for reverse lookups is wallets displaying the names associated with contracts and wallet addresses in, eg, transaction histories and address books. If Swarm is required to be able to do these reverse lookups, then a lot of wallet software simply won't support this, because it would impose a significant extra dependency.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264475934/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264476343",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264476343",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264476343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ3NjM0Mw==",
    "user": {
      "login": "KillariDev",
      "id": 13102010,
      "node_id": "MDQ6VXNlcjEzMTAyMDEw",
      "avatar_url": "https://avatars.githubusercontent.com/u/13102010?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/KillariDev",
      "html_url": "https://github.com/KillariDev",
      "followers_url": "https://api.github.com/users/KillariDev/followers",
      "following_url": "https://api.github.com/users/KillariDev/following{/other_user}",
      "gists_url": "https://api.github.com/users/KillariDev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/KillariDev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/KillariDev/subscriptions",
      "organizations_url": "https://api.github.com/users/KillariDev/orgs",
      "repos_url": "https://api.github.com/users/KillariDev/repos",
      "events_url": "https://api.github.com/users/KillariDev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/KillariDev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T15:12:54Z",
    "updated_at": "2016-12-02T15:12:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "the reverse lookup is not just simple the same database backward. There can be multiple addresses pointing into different names and other way around.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264476343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264481265",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264481265",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264481265,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDQ4MTI2NQ==",
    "user": {
      "login": "jpritikin",
      "id": 2002771,
      "node_id": "MDQ6VXNlcjIwMDI3NzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2002771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jpritikin",
      "html_url": "https://github.com/jpritikin",
      "followers_url": "https://api.github.com/users/jpritikin/followers",
      "following_url": "https://api.github.com/users/jpritikin/following{/other_user}",
      "gists_url": "https://api.github.com/users/jpritikin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jpritikin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jpritikin/subscriptions",
      "organizations_url": "https://api.github.com/users/jpritikin/orgs",
      "repos_url": "https://api.github.com/users/jpritikin/repos",
      "events_url": "https://api.github.com/users/jpritikin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jpritikin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T15:32:14Z",
    "updated_at": "2016-12-02T15:32:14Z",
    "author_association": "NONE",
    "body": "> the reverse lookup is not just simple the same database backward. There can be multiple addresses pointing into different names and other way around.\r\n\r\nOh yeah. I forgot about that. Good point.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264481265/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264570209",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264570209",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264570209,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDU3MDIwOQ==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T21:42:27Z",
    "updated_at": "2016-12-02T21:42:27Z",
    "author_association": "NONE",
    "body": "Anyone can set a name to point to an address, but is not the reverse true as well? An address can claim some arbitrary name to be its authoritative address, which allows it to masquerade as another entity. This will doubtlessly confuse users, to say nothing of mindless contracts.\r\n\r\nI believe that the reverse lookup system must _verify_ that address A owns name B before allowing the reverse lookup to be claimed. Further, there should be a way for any random user to force address A to stop claiming to be the reverse of name B if B is no longer owned by A, for the same reason. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264570209/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264572944",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264572944",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264572944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDU3Mjk0NA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-02T21:55:11Z",
    "updated_at": "2016-12-02T21:55:11Z",
    "author_association": "MEMBER",
    "body": "> Anyone can set a name to point to an address, but is not the reverse true as well? An address can claim some arbitrary name to be its authoritative address, which allows it to masquerade as another entity. \r\n\r\nYes. Resolvers for which this matters (forward and reverse records make different assertions, and not everyone needs both to be true) should perform both resolutions and check they match.\r\n\r\n> I believe that the reverse lookup system must verify that address A owns name B before allowing the reverse lookup to be claimed. Further, there should be a way for any random user to force address A to stop claiming to be the reverse of name B if B is no longer owned by A, for the same reason.\r\n\r\nThis is doable, but it complicates the system a lot: when a registrar hands ownership of a name (in this case a reverse record) over, it doesn't know what resolver is going to be set for it, or what that resolver will claim the corresponding name is. The only way I can see this working is if the registrar retained ownership of the name and deployed its own resolver, which only supported the `name()` interface. This would really hurt expandibility of the system.\r\n\r\nI could well be missing another way to enforce this - so suggestions are welcome.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264572944/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264644273",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-264644273",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 264644273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDY0NDI3Mw==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-03T15:03:10Z",
    "updated_at": "2016-12-03T15:03:10Z",
    "author_association": "NONE",
    "body": "> Yes. Resolvers for which this matters (forward and reverse records make different assertions, and not everyone needs both to be true) should perform both resolutions and check they match.\r\n\r\nThis will be fine if whatever official library for ENS automatically checks this, but I'm concerned that developers will carelessly ignore this. I suppose if the standard is \"THOU SHALT CHECK THE ERROR CODE OF THINE CALL LEST THOU FOOLISHLY BELIEVE A name() IS ACCURATE!\" then it's not all that different from any other of the potential-but-avoidable landmines in Ethereumland.\r\n\r\nI suppose for contracts, one could provide an on-chain system that caches both lookups, and then a contract that cares must use that specific resolver. Unfortunately, that also is a kind of landmine. \"Hello, new developer, here's how to use the ENS within solidity! ...now here's how you actually need to do it if you're concerned about the name being accurate.\"\r\n\r\n**On the contrary, however,** there are probably legitimate uses for giving an \"incorrect\" name to an address. (i.e. you're truly claiming to be a certain entity, but it isn't convenient for you to actually set up the names just right.)\r\n\r\n> I could well be missing another way to enforce this - so suggestions are welcome.\r\n\r\nI was thinking the registrar could drop a claim if it was proven that the `name()` was incorrect, but there's nothing stopping someone from just claiming it again.\r\n\r\nSuppose the `name()`-only resolver had, as its fallback `DELEGATECALL <actual resolver>`. That is, it would always call the official `name()`, and for any other method it would call whatever the owner's contract said. This would be very complex, unfortunately, and it would be even more complex to avoid the real contract from using its DELEGATECALLed powers to mess with the storage (and therefore, the name.) You'd have to write the true name to the code itself, or call yet another contract to get the real name.\r\n\r\nI suppose the situation overall is not that weirder than being able to lie about who a name \"really\" belongs to. It's just that UX-wise, the average user's been trained to trust names. If the official message gets out that \"Hey, google.eth actually really belongs to Google, don't trust g00gle.eth,\" which is then followed by a contract which is \"named\" google.eth asking them to send 100 ETH... well...\r\n\r\nBut again, you can already perform some weird phising scam with a false name-to-address assertion. If the libraries interacting with ENS are smart enough, this will be much less of an issue.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/264644273/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/272465531",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-272465531",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 272465531,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MjQ2NTUzMQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-13T15:10:11Z",
    "updated_at": "2017-01-13T15:10:11Z",
    "author_association": "MEMBER",
    "body": "Update: I've implemented the registrar with unit-tests in the ENS repo. In response to a suggestion from @alexvandesande, I've renamed `eth-addr.reverse` to `addr.reverse` for consistency (the pattern being that the first part of the name matches the name of the function it's a reverse for).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/272465531/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/301256833",
    "html_url": "https://github.com/ethereum/EIPs/issues/181#issuecomment-301256833",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/181",
    "id": 301256833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI1NjgzMw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T15:54:22Z",
    "updated_at": "2017-05-13T15:54:22Z",
    "author_association": "MEMBER",
    "body": "I've opened a PR for this: https://github.com/ethereum/EIPs/pull/630",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/301256833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
