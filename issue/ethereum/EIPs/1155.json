[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398241330",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-398241330",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 398241330,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODI0MTMzMA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-19T01:01:52Z",
    "updated_at": "2018-06-19T01:07:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "Suggestion: Add in some detail of how to encode extra information into the _itemId to facilitate the mixing of different item/token standards.\r\n\r\nAn example strategy to mix Fungible and Non-Fungible items together in the same contract for example may be to pass the base item ID in the top 128 bits of the uint256 _itemID parameter and then use the bottom 128 bits for any extra data you wish to pass to the contract.\r\n\r\nIn the ERC-721 case individual NFTs are interacted with using an index based accessor into the contract/item data set. Therefore to access a particular item set within a mixed data contract and particular NFT within that set, _itemID could be passed as \"<uint128: base item id><uint128: index of NFT>\". \r\n\r\nInside the contract code the two pieces of data needed to access the individual NFT can be extracted with uint128(~0) and the same mask shifted by 128.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398241330/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399777037",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399777037",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399777037,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTc3NzAzNw==",
    "user": {
      "login": "coinfork",
      "id": 2774008,
      "node_id": "MDQ6VXNlcjI3NzQwMDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2774008?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coinfork",
      "html_url": "https://github.com/coinfork",
      "followers_url": "https://api.github.com/users/coinfork/followers",
      "following_url": "https://api.github.com/users/coinfork/following{/other_user}",
      "gists_url": "https://api.github.com/users/coinfork/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coinfork/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coinfork/subscriptions",
      "organizations_url": "https://api.github.com/users/coinfork/orgs",
      "repos_url": "https://api.github.com/users/coinfork/repos",
      "events_url": "https://api.github.com/users/coinfork/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coinfork/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-24T18:28:41Z",
    "updated_at": "2018-06-24T18:28:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "Added the split bits strategy to the description, thanks :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399777037/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399800676",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399800676",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399800676,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTgwMDY3Ng==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T00:17:57Z",
    "updated_at": "2018-06-27T07:59:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "Transfer made using this standard, 2 FTs (10k + 500) and 100 NFTs (100): \r\n\r\nhttps://ropsten.etherscan.io/tx/0xfc924192fb068a6326bc28a2f5762be3a4b1fb6a1ef801bf6bf02c06af929d53\r\n\r\nFT \"ENJ\" ID: 0x54e8b965cee12ac713ee58508b0d07300000000000000000000000000000000\r\nFT \"Gold\" ID: 0x3bf7ded270a4ab1d5e170cc79deb931800000000000000000000000000000000\r\nNFT \"Lots of NFTs\" ID: 0x4362b8ce48bee741861f523a3b91803c00000000000000000000000000000000\r\n\r\n10000, 500 and 100*1 sent in one transaction costing 5480196 gas (~$2.42 at time of tx).\r\n\r\nNote, this was done in an advanced solution with a lot more features than a basic impl. Basic/ref impl and gas as compared to current standards in basic form will be added soon.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399800676/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399841476",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399841476",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399841476,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTg0MTQ3Ng==",
    "user": {
      "login": "aerykk",
      "id": 156768,
      "node_id": "MDQ6VXNlcjE1Njc2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/156768?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aerykk",
      "html_url": "https://github.com/aerykk",
      "followers_url": "https://api.github.com/users/aerykk/followers",
      "following_url": "https://api.github.com/users/aerykk/following{/other_user}",
      "gists_url": "https://api.github.com/users/aerykk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aerykk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aerykk/subscriptions",
      "organizations_url": "https://api.github.com/users/aerykk/orgs",
      "repos_url": "https://api.github.com/users/aerykk/repos",
      "events_url": "https://api.github.com/users/aerykk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aerykk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T06:05:59Z",
    "updated_at": "2018-06-25T06:06:49Z",
    "author_association": "NONE",
    "body": "Hyperbridge is interested in potentially supporting this standard in our upcoming marketplace. We'd like to see where other organizations stand on this as it's an obvious problem, and if the proposed solution works for you. @coinfork I don't see source code, so I'm going to take to take it that it's currently proprietary. Is there any examples in the wild as of yet?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399841476/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399852164",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399852164",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399852164,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTg1MjE2NA==",
    "user": {
      "login": "coinfork",
      "id": 2774008,
      "node_id": "MDQ6VXNlcjI3NzQwMDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2774008?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coinfork",
      "html_url": "https://github.com/coinfork",
      "followers_url": "https://api.github.com/users/coinfork/followers",
      "following_url": "https://api.github.com/users/coinfork/following{/other_user}",
      "gists_url": "https://api.github.com/users/coinfork/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coinfork/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coinfork/subscriptions",
      "organizations_url": "https://api.github.com/users/coinfork/orgs",
      "repos_url": "https://api.github.com/users/coinfork/repos",
      "events_url": "https://api.github.com/users/coinfork/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coinfork/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T07:01:22Z",
    "updated_at": "2018-06-25T07:01:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hey @ericmuyser thanks for your interest! We currently have a deployed contract on Ropsten (please see AC0DEM0NK3Y's post above) that is specifically tailored to our gaming use-case. We'll consider adding a reference implementation to the standard.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399852164/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399926409",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399926409",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399926409,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTkyNjQwOQ==",
    "user": {
      "login": "powether",
      "id": 36596029,
      "node_id": "MDQ6VXNlcjM2NTk2MDI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/36596029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/powether",
      "html_url": "https://github.com/powether",
      "followers_url": "https://api.github.com/users/powether/followers",
      "following_url": "https://api.github.com/users/powether/following{/other_user}",
      "gists_url": "https://api.github.com/users/powether/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/powether/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/powether/subscriptions",
      "organizations_url": "https://api.github.com/users/powether/orgs",
      "repos_url": "https://api.github.com/users/powether/repos",
      "events_url": "https://api.github.com/users/powether/events{/privacy}",
      "received_events_url": "https://api.github.com/users/powether/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T11:57:57Z",
    "updated_at": "2018-06-25T11:57:57Z",
    "author_association": "NONE",
    "body": "I hope you didn't announce this like \"Biggest innovation in the manking\".  5480196 gas is unacceptably high. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399926409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399969060",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-399969060",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 399969060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTk2OTA2MA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T14:20:44Z",
    "updated_at": "2018-06-25T14:29:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "\"I hope you didn't announce this like \"Biggest innovation in the manking\". 5480196 gas is unacceptably high.\"\r\n\r\nI think you need to look at the gas cost relative to the alternatives and how this differs from them. If you average this down (even without the fungible transfers that went with it) the above transfer cost ~55K per NFT sent, which compared to many other ERC721 implementations for eg. (seeing numbers 250K+ each) this offers significant savings. A simple ETH transfer costs 21K and ERC20 tokens look to cost anywhere from 35k to 130k each tx after some quick explorer checks in the top 100. So I would say the above cost is quite reasonable.\r\n\r\nOn top of that there is also the reduction of number of contracts necessary to be deployed to the network, the transaction numbers being reduced (in this case 102 : 1) and also the possible features this would bring that wouldn't be possible with separate contracts and incompatible NFT & FT standards.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399969060/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400044803",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400044803",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400044803,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA0NDgwMw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T18:11:21Z",
    "updated_at": "2018-06-25T18:11:21Z",
    "author_association": "NONE",
    "body": "I don't have strong opinions yet, but did y'all explore the option of composing ERC721 and 20/721 to get similar functionality? As in, creating a `AllItems` contract that is 721 but fully controlled by whatever governance mechanism you'd prefer. Then, owners can create a new item set like `createNonFungible(...)` to deploy a 721 contract and add that new contract address as one of the tokens tracked by the contract (owned by the `AllItems` contract itself). Similar for fungible assets. Then clients can get the set of all items via iterating the 721 interface, ERC165 detect fungibility or non-fungibility, and either 1) directly interface with those sub-contracts to manage their items or 2) you could provide similar `multi-send` features by proxying transfer requests through the `AllItems` contract that's either an approved operator of the sub-contract or is just an all-seeing authority (deferring the access-control logic to the `AllItems` contract to verify who owns what before transferring).\r\n\r\nAnyway, it might be a little roundabout, but it _does_ avoid the creation of a new standard by extending and composing existing ones, which is neat.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400044803/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400055870",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400055870",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400055870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA1NTg3MA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T18:47:50Z",
    "updated_at": "2018-06-25T18:48:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @shrugs while not getting too far into the implementation details of a system that uses this standard, in the above example where two different fungible types and one non-fungible set were operated on what a user/creator could do is call a \"deployERCAdapter\" function on the particular type if they so wish which will deploy an adapter contract that is either fully ERC721 or ERC20 compatible depending on the base type. This means the individual set is now backwards compatible with those standards and can therefore be used in any current system that supports them.\r\nSo we get the best of both worlds, full compatibility with ERC20 and ERC721 (as an option) but also the ability to mix these two standards together by operating at the 1155 \"main level\" and so can transfer/operate on these together and on multiple of the types, in the same transaction.\r\n\r\nExtending ERC721 rather than making a new standard that can mix different fungibility (and then supporting ERC721 with backwards compatibility) wouldn't have quite worked as ERC721 mandatory standard has certain functions that only make it suitable for a single data set in a single contract such as \"balanceOf(address _owner)\" and \"isApprovedForAll(address _owner, address _operator)\" for example.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400055870/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400058221",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400058221",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400058221,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA1ODIyMQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T18:55:21Z",
    "updated_at": "2018-06-25T18:57:08Z",
    "author_association": "NONE",
    "body": "@AC0DEM0NK3Y the ERC adaptor is interesting, yeah.\r\n\r\nThe fungible/non-fungible tokens would not be tracked in a single 721; their contract addresses would be.\r\n\r\n```\r\nAllItems (ERC721, tracking contract addresses)\r\n  |__ Sword contract (ERC20)\r\n  |\r\n  |__ Legendary Armor contract (ERC721)\r\n```\r\n\r\nso each individual contract still fulfills 721 and 20 to the best of their ability, and you add additional features like multi-send and factory methods to the `AllItems` parent contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400058221/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400060404",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400060404",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400060404,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA2MDQwNA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T19:01:52Z",
    "updated_at": "2018-06-25T19:13:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "That is a way to track perhaps, but is much less user/network friendly. If I want to send you an NFT A and and NFT B and do that through your tracking contract I'd have to call approve on contract A and B separately to give the tracking contract the allowance, then call the tracking contract to do the transfer.\r\nThat is 3 individual transactions (4 if your tracking contract doesn't support arrays for transfer API).\r\n\r\nBy allowing things to be mixed together and stored in a single contract I can transfer A and B to you in a single tx.\r\n\r\nA and B contract also have to be deployed. It's more data on the chain than is needed and that is not sustainable and/or limiting imho.\r\nIf you consider use cases like a videogames that have lots of different types of NFTs and how many games there are in the market now and will be in the future, having to deploy an ERC20/ERC721 contract to support those types every time is not good for the ETH network as a whole going forward and that is just one use case.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400060404/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400069828",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400069828",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400069828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA2OTgyOA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T19:35:52Z",
    "updated_at": "2018-06-25T19:35:52Z",
    "author_association": "NONE",
    "body": "I mentioned that above as well, perhaps I wasn't clear enough; you can implement multi-send functionality by making the `AllItems` contract a designated operator (or a super user of sorts) for transferring tokens/items and then implement access control at the `AllItems` layer, allowing you to skip approvals and send multiple items with a single transaction exactly as you do in 1155. Nothing has changed here.\r\n\r\nI agree that composability does come with gas costs, and these should be measured. You can also separate logic and data using proxy patterns and cut down on duplicate logic deployments. (and before someone references the parity wallet, this is very much the same approach that 1155 uses by consolidating the logic and data into a single contract; it's still a single point of failure if there is a show-stopping bug).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400069828/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400078111",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400078111",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400078111,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA3ODExMQ==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T20:05:42Z",
    "updated_at": "2018-06-25T20:05:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "It sounds like it _could_ work, but it doesn't fix the wastage/management issue. Deploying a contract for every NFT is not future proof imho.\r\n\r\nYour pattern seems like it would work with 1155 though. The register function that you are proposing could be something someone implements and then this returns an ID to match the contract address when calling the function. The call to transfer A and B in that case would might be to call:\r\n\r\nuint aID = 1155.register(ContractOfA);\r\nuint aIndex = 12345; // NFT index I want to send from contract A\r\nuint bID = 1155.register(ContractOfB);\r\nuint bIndex = 888; // NFT index I want to send from contract B\r\nContractOfA.makeSuperUser(1155);\r\nContractOfB.makeSuperUser(1155);\r\n1155.transfer([aID, aIndex, bID, bIndex], [yourAddr,yourAddr],[1,1]);\r\n\r\nThis now needs an extension to ERC721 to append \"makeSuperUser\" function.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400078111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400086343",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400086343",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400086343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA4NjM0Mw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T20:34:26Z",
    "updated_at": "2018-06-25T20:34:26Z",
    "author_association": "NONE",
    "body": "> ((an aside: using an existing standard is the definition of futureproof))\r\n\r\nsuperuser would need to be added, yes. you could also get away with operator functionality that already exists; simply default to setting the approved operator of every token to the `AllItems` contract. users could revoke, but 1) why would they and 2) to restore previous behavior, they can simply re-approve the operator. compatible with both 20 and 721. \r\n\r\nThe data/logic separation via proxy is a well-known pattern and does indeed work. The only unknown is the gas implications, which could be measured. Having your sub-items be compatible with 20/721 by default is a very powerful effect. We've only just started the whole NFT thing, and fracturing into another standard instead of leveraging existing ones isn't really a strong move, imo. Existing indexers (Toshi, Trust Wallet, etc) would need to have extra logic to monitor this standard as well. And deploying ERC adaptors for every token just gets you back to the point I'm making; it should just be compatible with the existing standard by default.\r\n\r\nAnyway, give it a think and see if it solves the problem you're interested in solving. I'm very familiar with the space and the problems you're facing, specifically around gaming, and have thought about this at length as well. A next step would be profiling the gas costs of a composable approach, which I may mind time to do within the next week or two, but can't guarantee.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400086343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400091515",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400091515",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400091515,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDA5MTUxNQ==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T20:52:20Z",
    "updated_at": "2018-06-25T20:59:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "> an aside: using an existing standard is the definition of futureproof\r\n\r\nI would call that backwards compatible but hey :)\r\n\r\n> The data/logic separation via proxy is a well-known pattern and does indeed work. \r\n\r\nYes, we do this or sorts in our implementation. Storage contract holds all the data, then the rest is an API over the top of it. Many reasons to do this.\r\nSo in the above test, consider that a test of gas costs perhaps.\r\n\r\nThanks for the discussion @shrugs looking forward to more.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400091515/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400100947",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400100947",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400100947,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEwMDk0Nw==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T21:25:39Z",
    "updated_at": "2018-06-25T22:18:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hello! \r\n\r\nHappy to see other people working on something like this. I personally recommend the following changes ; \r\n\r\n1. Remove `transfer(...)`. It's a special case of `transferFrom()` and is less explicit, which isn't great.\r\n\r\n2. Add `safeTransferFrom(...)` instead of passing data in second 128 bits. Explicit > implicit should be favored in standards imo. \r\n\r\n3. Change arguments order of transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)nt ordering from `transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)` to `transferFrom(address[] _from, address[] _to, uint256[] _itemId, uint256[] _value)` which seems more consistent with current standards. \r\n\r\n4. Change the current approval logic to something like `setApprovalForAll()` or `setOperator()` instead of using specific approvals. Approvals are almost exclusively used to give access to your tokens to a trusted/vetted contract. I have yet to see an example of a specific approval value. Even with erc-721, I have yet to see a use case where giving approval to a single ID is useful. \r\n\r\nWhen it comes to `transfer()` and `transferFrom()`, is the reason for \"not\" throwing and return a bool instead to prevent a single transfer from breaking the entire transfer? What does it mean to return false? That at least one of them was unsuccessful? All of them? Not sure I understand the logic here and would love some extra info.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400100947/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400118883",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400118883",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400118883,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDExODg4Mw==",
    "user": {
      "login": "amittmahajan",
      "id": 689785,
      "node_id": "MDQ6VXNlcjY4OTc4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/689785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amittmahajan",
      "html_url": "https://github.com/amittmahajan",
      "followers_url": "https://api.github.com/users/amittmahajan/followers",
      "following_url": "https://api.github.com/users/amittmahajan/following{/other_user}",
      "gists_url": "https://api.github.com/users/amittmahajan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amittmahajan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amittmahajan/subscriptions",
      "organizations_url": "https://api.github.com/users/amittmahajan/orgs",
      "repos_url": "https://api.github.com/users/amittmahajan/repos",
      "events_url": "https://api.github.com/users/amittmahajan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amittmahajan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T22:42:56Z",
    "updated_at": "2018-06-25T22:47:36Z",
    "author_association": "NONE",
    "body": "Thanks for putting this together! \r\n\r\nA few folks (@petejkim (Cipher/Toshi), @lsankar4033 (PepeDapp), @pkieltyka (Horizon Games), and myself (Rare Bits/Fan Bits)) were actually bouncing around a Semi Fungible Token standard that may make sense to combine efforts on given the similarities. I've put it below for posterity. That being said, a couple ideological things that may be worth considering:\r\n\r\n1. ERC721 was just approved after a lot of deliberation and it seems like maintaining this as an evolution/superset of ERC721/ERC20 in terms of nomenclature / API compatibility will help with adoption / building to consensus quickly. We took the approach of starting with the ERC721 spec and then evolving from there to ensure we captured all of the hard work and thought that went into that standard.\r\n\r\n2. This is bigger than games and the ecosystem for NFTs is already spreading well beyond virtual items. Switching from Items to Tokens doesn't make a whole lot of sense given the existing ecosystem that exists around these standards already. \r\n\r\n3. We all agreed that having indexing/metadata functions are required versus optional makes life a lot easier for wallet providers and other indexers trying to display the data and interoperate with these contracts.\r\n\r\n```solidity\r\npragma solidity ^0.4.20;\r\n\r\n/// The goal of this spec is to handle a now-common case of having different\r\n/// token types with fungibility within each type.\r\n\r\n/// Many DApps are either using ERC721 with multiple-tokens of the same type or deploying \r\n/// multiple ERC20 contracts to create fungible tokens within a set non-fungible token types.\r\n/// An example would be a trading card game with different types but where \r\n/// each card of a given type is indistinguishable from the other. Or an art \r\n/// token where each print of an art piece is indistinguishable from any other print.\r\n\r\n/// This is a *VERY* draft spec that is modified from the (near) final\r\n/// ERC721-spec. We should evolve it as necessary from here.\r\n\r\n/// @title ERC->>>TBD<<< Semi-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-TBD.md\r\n///  Note: the ERC-165 identifier for this interface is >>>TBD<<<\r\ninterface ERCTBD /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any SFT changes by any mechanism.\r\n    ///  This event emits when SFTs are created (from == 0) and destroyed\r\n    ///  (to == 0). Exception: during contract creation, any number of SFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that SFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenType, uint256 indexed _value);\r\n\r\n    /// @dev This emits when the approved address for an SFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that SFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenType, uint256 indexed _value);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all SFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Returns the total token supply.\r\n    /// @dev Throws if '_tokenType' is not a valid SFT\r\n    /// @param _tokenType The type of SFT to get the totalSupply of. Must be less than the return value of totalTokenTypes\r\n    /// @return The total supply of the given SFT\r\n    function totalSupply(uint256 _tokenType) external view returns (uint256 totalSupply);\r\n\r\n    /// @notice Count all SFTs of a given type owned by _owner\r\n    /// @dev Throws if '_tokenType' is not a valid SFT or if _owner is set to the zero-address\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @param _tokenType The type of SFT to get the balance of. Must be less than the return value of totalTokenTypes\r\n    function balanceOf(address _owner, uint256 _tokenType) external view returns (uint256 balance);\r\n    \r\n    /// @notice Return all token types for a given _owner\r\n    /// @param _owner An address for whom to return token types for\r\n    function tokenTypesOf(address _owner) external view returns (uint256[] tokenTypes);\r\n\r\n    /// @notice Returns the total number of token types for this contract\r\n    /// @dev Can possibly be zero\r\n    /// @return The total number of token types\r\n    function totalTokenTypes() external view returns (uint256 totalTokenTypes);\r\n\r\n    /// @notice Returns the total number of distinct owners who own _tokenType\r\n    /// @dev Can possibly be zero\r\n    /// @return The total number of distinct owners owning _tokenType\r\n    function totalOwners(uint256 _tokenType) external view returns (uint256 totalOwners);\r\n\r\n    /// @notice Returns the owner of _tokenType specified by _ownerIndex\r\n    /// @param _ownerIndex Unique identifier of an owner of _tokenType\r\n    /// @return The address of the ownner of _tokenType specified by _ownerIndex\r\n    function ownerOf(uint256 _tokenType, uint256 _ownerIndex) external view returns (address owner);\r\n\r\n    /// @notice Transfers the ownership of some SFTs from one address to another address\r\n    /// @dev Throws unless 'msg.sender' is the current owner, an authorized\r\n    ///  operator, or the approved address for the SFTs. Throws if '_from' is\r\n    ///  not the current owner. Throws if '_to' is the zero address. Throws if\r\n    ///  '_tokenType' is not a valid SFT type. When transfer is complete, this function\r\n    ///  checks if '_to' is a smart contract (code size > 0). If so, it calls\r\n    ///  'onERCTBDReceived' on '_to' and throws if the return value is not\r\n    ///  'bytes4(keccak256(\"onERCTBDReceived(address,address,uint256,bytes)\"))'.\r\n    /// @param _from The current owner of the SFTs\r\n    /// @param _to The new owner\r\n    /// @param _tokenType The SFT type to transfer. Must be less than the return value of totalTokenTypes\r\n    /// @param _value Amount of SFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to '_to'\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenType, uint256 _value, bytes data) external payable;\r\n\r\n    /// @notice Transfers the ownership of some SFTs from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the SFTs\r\n    /// @param _to The new owner\r\n    /// @param _tokenType The SFT type to transfer. Must be less than the return value of totalTokenTypes\r\n    /// @param _value Amount of SFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenType, uint256 _value) external payable;\r\n\r\n    /// @notice Transfer ownership of some SFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT '_to' IS CAPABLE OF RECEIVING SFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless 'msg.sender' is the current owner, an authorized\r\n    ///  operator, or the approved address for this SFT. Throws if '_from' is\r\n    ///  not the current owner. Throws if '_to' is the zero address. Throws if\r\n    ///  '_tokenType' is not a valid SFT.\r\n    /// @param _from The current owner of the SFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenType The SFT type to transfer. Must be less than the return value of totalTokenTypes\r\n    function transferFrom(address _from, address _to, uint256 _tokenType, uint256 _value) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for some SFTs\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless 'msg.sender' is the current owner of the SFTs, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved SFT controller\r\n    /// @param _tokenType The SFT type to approve. Must be less than the return value of totalTokenTypes\r\n    /// @param _value The amount of SFT able to be withdrawn\r\n    function approve(address _approved, uint256 _tokenType, uint256 _value) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of msg.sender's assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the amount of allowance a spender has for a given owner and SFT type\r\n    /// @param _owner The address that owns the SFTs\r\n    /// @param _spender The address that is operating on behalf of the owner\r\n    /// @param _tokenType The type of SFT to find the approved address for. Must be less than the return value of totalTokenTypes\r\n    /// @return The amount able to be spent by the spender for a given owner and type\r\n    function allowance(address _owner, address _spender, uint256 _tokenType) external view returns (uint256);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the SFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if '_operator' is an approved operator for '_owner', false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n    /// @notice A descriptive name for a collection of SFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for SFTs of a given type\r\n    function symbol(uint256 _tokenType) external view returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if '_tokenType' is not a valid SFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenType) external view returns (string);    \r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return 'true' if the contract implements 'interfaceID' and\r\n    ///  'interfaceID' is not 0xffffffff, 'false' otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400118883/reactions",
      "total_count": 20,
      "+1": 7,
      "-1": 0,
      "laugh": 0,
      "hooray": 13,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400128212",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400128212",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400128212,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEyODIxMg==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T23:34:16Z",
    "updated_at": "2018-06-25T23:34:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "@amittmahajan Could you explain what `ownerOf` and `totalOwners` are referring to? It's not clear to me what the intentions are with these functions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400128212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400129013",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400129013",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400129013,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEyOTAxMw==",
    "user": {
      "login": "amittmahajan",
      "id": 689785,
      "node_id": "MDQ6VXNlcjY4OTc4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/689785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amittmahajan",
      "html_url": "https://github.com/amittmahajan",
      "followers_url": "https://api.github.com/users/amittmahajan/followers",
      "following_url": "https://api.github.com/users/amittmahajan/following{/other_user}",
      "gists_url": "https://api.github.com/users/amittmahajan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amittmahajan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amittmahajan/subscriptions",
      "organizations_url": "https://api.github.com/users/amittmahajan/orgs",
      "repos_url": "https://api.github.com/users/amittmahajan/repos",
      "events_url": "https://api.github.com/users/amittmahajan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amittmahajan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T23:39:42Z",
    "updated_at": "2018-06-25T23:39:42Z",
    "author_association": "NONE",
    "body": "@PhABC `totalOwners` is referring to the number of unique addresses that hold a given tokenType. `ownerOf` is one element of that \"owners\" array of a given tokenType. it allows you to enumerate every owner of a given tokenType.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400129013/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400130376",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400130376",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400130376,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMDM3Ng==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T23:47:52Z",
    "updated_at": "2018-06-25T23:47:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for adding that @amittmahajan and we'll discuss it internally. What first springs to mind however is that your proposal standard does not allow for approving/transferring etc. on multiple things in one shot as they do not take array arguments.\r\n\r\nAlso the functions such as @PhABC is talking about like totalOwners sound immediately to me like they would need more storage and so gas costs to maintain. I would advocate for as little as possible on chain storage and this sort of \"metadata\" instead recorded off-chain. \r\nYou could find the owners/track balance via transfer log events for eg. and store that info elsewhere. It isn't necessary for the users to have that info stored and the developers can get this info from a local node.\r\nThe less we bloat ETH while providing great features for the users the better imho.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400130376/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400130682",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400130682",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400130682,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMDY4Mg==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T23:49:50Z",
    "updated_at": "2018-06-25T23:55:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "@amittmahajan Ah I see. How do you keep track of all the owners? I can understand iterating over all token types an user owns if the totsl number of token types is somewhat low, but I can't really see a way to iterate over the owners unless you keep a big array of owners for each token types. Any insights?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400130682/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400131562",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400131562",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400131562,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMTU2Mg==",
    "user": {
      "login": "dwking2000",
      "id": 3486215,
      "node_id": "MDQ6VXNlcjM0ODYyMTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3486215?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dwking2000",
      "html_url": "https://github.com/dwking2000",
      "followers_url": "https://api.github.com/users/dwking2000/followers",
      "following_url": "https://api.github.com/users/dwking2000/following{/other_user}",
      "gists_url": "https://api.github.com/users/dwking2000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dwking2000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dwking2000/subscriptions",
      "organizations_url": "https://api.github.com/users/dwking2000/orgs",
      "repos_url": "https://api.github.com/users/dwking2000/repos",
      "events_url": "https://api.github.com/users/dwking2000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dwking2000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-25T23:55:20Z",
    "updated_at": "2018-06-25T23:55:20Z",
    "author_association": "NONE",
    "body": "Good to see this proposal. <p>Our use case is for ERC-20 tokens. We want to 'color' tokens by community while allowing them to be fungible on exchanges as a 'clear' token. Within communities transfer of colored tokens will be allowed in the community color only, but outside of communities the rest of the world will see the tokens as a single ERC-20 type token. This looks like a similar solution I came up with to solve this. <p>A standard will encourage the creation of tools and potentially wallets will that can deal with this paradigm. My question: is this EIP just for NFTs or is it intended to be used for ERC-20 tokens as well? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400131562/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400132333",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400132333",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400132333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMjMzMw==",
    "user": {
      "login": "amittmahajan",
      "id": 689785,
      "node_id": "MDQ6VXNlcjY4OTc4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/689785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amittmahajan",
      "html_url": "https://github.com/amittmahajan",
      "followers_url": "https://api.github.com/users/amittmahajan/followers",
      "following_url": "https://api.github.com/users/amittmahajan/following{/other_user}",
      "gists_url": "https://api.github.com/users/amittmahajan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amittmahajan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amittmahajan/subscriptions",
      "organizations_url": "https://api.github.com/users/amittmahajan/orgs",
      "repos_url": "https://api.github.com/users/amittmahajan/repos",
      "events_url": "https://api.github.com/users/amittmahajan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amittmahajan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T00:00:00Z",
    "updated_at": "2018-06-26T00:10:15Z",
    "author_association": "NONE",
    "body": "@PhABC @AC0DEM0NK3Y re: `totalOwners`, `ownerOf`. not married to including these because we've built out the infra already to support it but I included it with the intent of spurring the discussion if there was a more clever way to implement it / see what the community demand for such a feature would be.\r\n\r\nre: multiple token transfer, i think it's a good idea and has a lot of use cases. That being said, I wouldn't be surprised if that function is mostly called with a single type. Perhaps it makes sense to implement that as a new function (`multiTransfer`) to reduce complexity for the most basic use case of transfer. If I were to vote right now, i'd say stick with the current version (one func `transfer` that takes multiple types) but wanted to raise the topic of two funcs to be diligent.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400132333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400133589",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400133589",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400133589,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMzU4OQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T00:06:51Z",
    "updated_at": "2018-06-26T14:24:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "@amittmahajan batch transfer is critical for these types of tokens, imo, it's really what makes such an interface interesting. I personally vote for `batchTransferFrom(..)` to follow naming conventions. I do agree that some applications might favor single type transfer while others might utilize the batch transfer functionality more often.Convince me :). \r\n\r\nI personally would not include `totalOwners` & `ownerOf` as they add significant gas cost and their on-chain utility seems limited. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400133589/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400133616",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400133616",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400133616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzMzYxNg==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T00:07:00Z",
    "updated_at": "2018-06-26T01:33:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "We originally had a transfer (single) and multiTransfer (array) in the standard but after testing gas differences and usability we decided it better to just use the array version and name it transfer for simplicity.\r\n\r\nIf you pass in MEW for eg. as well as other methods, the difference in array vs non-array method is almost identical (it is identical in MEW) and the gas difference is negligible and the power of the feature is huge for gas savings and for functionaility.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400133616/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400134639",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400134639",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400134639,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzNDYzOQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T00:13:11Z",
    "updated_at": "2018-06-26T00:32:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "With my implementation, it costs around 400k gas to send 100 token types, but single transfer is about 2k gas more expensive using the `batchTransferFrom` function compared to the `transferFrom()`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400134639/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400137770",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400137770",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400137770,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDEzNzc3MA==",
    "user": {
      "login": "lsankar4033",
      "id": 451947,
      "node_id": "MDQ6VXNlcjQ1MTk0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/451947?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsankar4033",
      "html_url": "https://github.com/lsankar4033",
      "followers_url": "https://api.github.com/users/lsankar4033/followers",
      "following_url": "https://api.github.com/users/lsankar4033/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsankar4033/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsankar4033/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsankar4033/subscriptions",
      "organizations_url": "https://api.github.com/users/lsankar4033/orgs",
      "repos_url": "https://api.github.com/users/lsankar4033/repos",
      "events_url": "https://api.github.com/users/lsankar4033/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsankar4033/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T00:29:58Z",
    "updated_at": "2018-06-26T00:31:37Z",
    "author_association": "NONE",
    "body": "@AC0DEM0NK3Y one downside of a single `transfer` method (vs. separate `transfer` and `multiTransfer` methods) is that there's an additional burden on 3rd parties integrating with all standards, as they have to remember that `transfer` has different argument lists (address vs. address[]) for ERC721/20/1155. \r\n\r\nI think the simplicity cost of having two methods is worth the integration win of cleaner unification with existing standards.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400137770/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400147744",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400147744",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400147744,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDE0Nzc0NA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T01:31:33Z",
    "updated_at": "2018-06-26T01:31:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "@lsankar4033 We'll talk/test about that internally and come back on it.\r\n\r\nMy first thought is that transfer has to change even in singular form to include the token/item type:\r\n\r\n> function transfer(address _to, uint256 _value)\r\n> \r\n> vs\r\n> \r\n> function transfer(uint256 _itemId, address _to, uint256 _value)\r\n> or\r\n> function transfer(uint256[] _itemId, address[] _to, uint256[] _value)\r\n\r\nso if it has to change signature anyway, why not go for the most powerful version if it is just as easy to call, almost as cheap and provides the opportunity for much more functionality?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400147744/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400149024",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400149024",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400149024,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDE0OTAyNA==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T01:39:17Z",
    "updated_at": "2018-06-26T01:39:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "> A standard will encourage the creation of tools and potentially wallets will that can deal with this paradigm. My question: is this EIP just for NFTs or is it intended to be used for ERC-20 tokens as well?\r\n\r\n@dwking2000 we intend it for both. In our implementation we mix erc20 and erc721 style, can transfer (and lots of other ops) both types in the same tx and can deploy an adapter for each type that fully supports ERC20 and ERC721 API on the tokens if the user wishes.\r\n\r\nWe've tried to plan for the future while supporting current standards whilst also trying to keep the on-chain storage as low as possible.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400149024/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400150081",
    "html_url": "https://github.com/ethereum/EIPs/issues/1155#issuecomment-400150081",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1155",
    "id": 400150081,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDE1MDA4MQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T01:45:20Z",
    "updated_at": "2018-06-26T01:45:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "@AC0DEM0NK3Y When you say you tested the gas cost difference of using arrays by default, would you mind sharing the numbers? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400150081/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
