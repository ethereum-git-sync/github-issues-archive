{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3132",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3132",
  "id": 750636122,
  "node_id": "MDU6SXNzdWU3NTA2MzYxMjI=",
  "number": 3132,
  "title": "Discussion for EIP-3135: Exclusive Claimable Token",
  "user": {
    "login": "Ungigdu",
    "id": 55949958,
    "node_id": "MDQ6VXNlcjU1OTQ5OTU4",
    "avatar_url": "https://avatars.githubusercontent.com/u/55949958?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Ungigdu",
    "html_url": "https://github.com/Ungigdu",
    "followers_url": "https://api.github.com/users/Ungigdu/followers",
    "following_url": "https://api.github.com/users/Ungigdu/following{/other_user}",
    "gists_url": "https://api.github.com/users/Ungigdu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Ungigdu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Ungigdu/subscriptions",
    "organizations_url": "https://api.github.com/users/Ungigdu/orgs",
    "repos_url": "https://api.github.com/users/Ungigdu/repos",
    "events_url": "https://api.github.com/users/Ungigdu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Ungigdu/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3539577331,
      "node_id": "LA_kwDOAq426M7S-anz",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/discussions-to",
      "name": "discussions-to",
      "color": "20DFB1",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": true,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2020-11-25T09:13:36Z",
  "updated_at": "2023-02-24T18:41:25Z",
  "closed_at": "2022-06-10T08:35:01Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 3135\r\ntitle: Exclusive Claimable Token\r\nauthor: Zhenyu Sun (@Ungigdu)\r\ndiscussions-to: https://github.com/ethereum/EIPs/issues/3135\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2020-08-10\r\nrequires: 20\r\n---\r\n\r\n## Simple Summary\r\n\r\nThis standard defines a token which can be claimed only by token issuer with payer's signature.\r\n\r\n## Abstract\r\n\r\nThis EIP defines a set of additions to the default token standard such as ERC-20, that allows online/offline service providers establish micropayment channels with any number of users by signing and verifying messages about the consumption of token off chain. Using this mechanism will reduce interactions with blockchain to minimal for both participants, thus saving gas and improve performance.\r\n\r\n## Motivation\r\n\r\nThere are two main purposes of this EIP, one is to reduce interactions with blockchain, the second is to link Ethereum to real-world payment problems.\r\n\r\nMany small businesses want to build payment system based on blockchain but find it difficult. There are basically two ways: \r\n\r\n1. Directly pay with token. There are many wallet can receive and transfer token but transactions on Ethereum cost gas and take time to confirm.\r\n2. User lock token on payment smart contract and service provider use payment messages signed by user to release token, establishing a micropayment channel. The advantage is interactions with blockchain is reduced and the signing/verifying process is off-chain. But interact with payment contract needs service provider to build a DApp, which require resources many small businesses do not have. Even if they managed to build DApps, they are all different, not standardized. Also, user should have a wallet with DApp browser and has to learn how to use it.\r\n\r\nThis EIP helps to standardize the interactions of micropayment system, and make it possible for wallet build a universal UI in the future.\r\n\r\n## Specification\r\n\r\n```solidity\r\n\r\n/// @return Image url of this token or descriptive resources\r\nfunction iconUrl() external view returns (string memory);\r\n\r\n/// @return Issuer of this token. Only issuer can execute claim function\r\nfunction issuer() external view returns (address);\r\n\r\n/**\r\n *  @notice   Remove consumption from payer's deposite\r\n *  @dev      Check if msg.sender == issuer\r\n *  @param    from          Payer's address\r\n *  @param    consumption   How many token is consumed in this epoch, specified\r\n *  @param    epoch         Epoch increased by 1 after claim or withdraw, at the beginning of each epoch, consumption goes back to 0\r\n *  @param    signature     Signature of payment message signed by payer\r\n*/\r\nfunction claim(address from, uint256 consumption, uint256 epoch, bytes calldata signature) external;\r\n\r\nfunction transferIssuer(address newIssuer) external;\r\n\r\n/// @notice   Move amount from payer's token balance to deposite balance to ensure payment is sufficient\r\nfunction deposit(uint256 amount) external;\r\n\r\n/**\r\n *  @notice   Give remaining deposite balance back to \"to\" account, act as \"refund\" function\r\n *  @dev      In prepayment module, withdraw is executed from issuer account\r\n *            In lock-release module, withdraw is executed from user account\r\n *  @param    to            the account receiving remaining deposite\r\n *  @param    amount        how many token is returned\r\n*/\r\nfunction withdraw(address to, uint256 amount) external;\r\n\r\nfunction depositBalanceOf(address user) external view returns(uint256 depositBalance, uint256 epoch);\r\n\r\nevent Deposit(\r\n    address indexed from,\r\n    uint256 amount\r\n);\r\n\r\nevent Withdraw(\r\n    address indexed to,\r\n    uint256 amount\r\n);\r\n    \r\nevent TransferIssuer(\r\n    address indexed oldIssuer,\r\n    address indexed newIssuer\r\n);\r\n\r\nevent Claim(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 epoch,\r\n    uint256 consumption\r\n);\r\n\r\n```\r\n\r\n### signature\r\n\r\nthe pseudo code generating an ECDSA signature:\r\n```\r\nsign(keccak256(abi_encode(\r\n    \"\\x19Ethereum Signed Message:\\n32\", \r\n        keccak256(abi_encode(\r\n            token_address,\r\n            payer_address,\r\n            token_issuer,\r\n            token_consumption,        //calculated by user client\r\n            epoch\r\n        ))\r\n    ))\r\n,private_key)\r\n\r\n```\r\n\r\n### verification process\r\n\r\nthe verification contains check about both signature and token_consumption\r\n\r\nthe pseudo code run by verification server is as follows:\r\n\r\n```\r\n\r\nserving_loop:\r\n\r\n    for {\r\n        /**\r\n         * unpaied_consumption is calculated by provider\r\n         * signed_consumption is claimable amount\r\n         * tolerance allows payer \"owes\" provider to a certain degree\r\n        */\r\n        //getSignedConsumption returns amount that are already claimable \r\n        if(unpaied_consumption <  signed_consumption + tolerance){\r\n            informUser(\"user need charge\", unpaied_consumption)\r\n            interruptService() \r\n        }else{\r\n            isServing() || recoverService()\r\n        }\r\n    }\r\n\r\nverification_loop:\r\n\r\n    for {\r\n        message = incomingMessage()\r\n        if(recover_signer(message, signature) != payer_address){\r\n            informUser(\"check signature failed\", hash(message))\r\n            continue\r\n        }\r\n\r\n        /**\r\n        * optional: when using echo server to sync messages between verification servers\r\n        * more info about this in Security Considerations section\r\n        */\r\n        if(query(message) != message){\r\n            informUser(\"message outdate\", hash(message))\r\n            continue   \r\n        }\r\n\r\n        if(epoch != message.epoch || message.consumption > getDepositBalance()){\r\n            informUser(\"invalid message\", epoch, unpaied_consumption)\r\n            continue\r\n        }\r\n       \r\n        signed_consumption = message.consumption\r\n        save(message)\r\n    }\r\n    \r\nclaim_process:\r\n\r\n    if(claim()){\r\n        unpaied_consumption -= signed_consumption\r\n        signed_consumption = 0\r\n        epoch+=1\r\n    }\r\n\r\n```\r\n### About withdraw\r\n\r\nThe withdraw function is slightly different based on business models\r\n\r\n1. prepayment model\r\n\r\nIn prepayment business model such as using token as recharge card of general store, the user pays (crypto)currency to store in advance for claimable token as recharge card (with bonus or discount). When checking out, the customer signs a message with updated consumption (old consumption + consumption this time) to store and store verifies this message off chain. The shopping process loops without any blockchain involved, until the customer wants to return the card and get money back. Because the store already holds all currency, the withdraw function should be executed by token issuer (store) to return remaining deposit balance after claim. The prepayment model can easily be built into a wallet with QR-code scanning function.\r\n\r\n2. lock-release model\r\n\r\nIf we run a paid end-to-end encrypted e-mail service that accepts token as payment, we can use lock-release model. Unlike prepayment, we charge X * N token for an e-mail sent to N recipients. In this \"pay for usage\" scenario, the counting of services happens on both client and server side. The client should not trust charge amount given by server in case the it's malfunctioning or malicious. When client decide not to trust server, it stops signing messages, but some of token is taken hostage in deposit balance. To fix this problem, the withdraw function should be executed by payer account with limitation such as epoch didn't change in a month.\r\n\r\n## Rationale\r\n\r\nThis EIP targets on ERC-20 tokens due to its widespread adoption. However, this extension is designed to be compatible with other token standard.\r\n\r\nThe reason we chose to implement those functions in token contract rather than a separate record contract is as follows:\r\n- Token can transfer is more convenient and more general than interact with DApp\r\n- Token is more standardized and has better UI support\r\n- Token is equal to service, make token economy more prosperous\r\n- Remove the approve process\r\n\r\n## Backwards Compatibility\r\n\r\nThis EIP is fully backwards compatible as its implementation extends the functionality of [ERC-20](./eip-20.md).\r\n\r\n## Implementation\r\n\r\n```solidity\r\n\r\nmapping (address => StampBalance) private _depositBalance;\r\n    \r\nstruct StampBalance{\r\n    uint256 balance;\r\n    uint256 epoch;\r\n}\r\n    \r\nfunction deposit(uint256 value) override external{\r\n    require(value <= _balances[msg.sender]);\r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    _depositBalance[msg.sender].balance = _depositBalance[msg.sender].balance.add(value);\r\n    emit Deposit(msg.sender, value);\r\n}\r\n\r\nfunction withdraw(address to, uint256 value) override onlyIssuer external{\r\n    require(value <= _depositBalance[to].balance);\r\n    _depositBalance[to].balance = _depositBalance[to].balance.sub(value);\r\n    _depositBalance[to].epoch += 1;\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Withdraw(to, value);\r\n}\r\n    \r\nfunction depositBalanceOf(address user) override public view returns(uint256 depositBalance, uint256 epoch){\r\n    return (_depositBalance[user].balance, _depositBalance[user].epoch);\r\n}\r\n\r\n// prepayment model\r\nfunction claim(address from, uint credit, uint epoch, bytes memory signature) override onlyIssuer external{\r\n    require(credit > 0);\r\n    require(_depositBalance[from].epoch + 1 == epoch);\r\n    require(_depositBalance[from].balance >= credit);\r\n    bytes32 message = keccak256(abi.encode(this, from, _issuer, credit, epoch));\r\n    bytes32 msgHash = prefixed(message);\r\n    require(recoverSigner(msgHash, signature) == from);\r\n    _depositBalance[from].balance = _depositBalance[from].balance.sub(credit);\r\n    _balances[_issuer] = _balances[_issuer].add(credit);\r\n    _depositBalance[from].epoch += 1;\r\n    emit Claim(from, msg.sender, credit, epoch);\r\n}\r\n\r\nfunction prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n    return keccak256(abi.encode(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n}\r\n\r\nfunction recoverSigner(bytes32 message, bytes memory sig) internal pure  returns (address) {\r\n    (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\r\n    return ecrecover(message, v, r, s);\r\n}\r\n\r\nfunction splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n    require(sig.length == 65);\r\n    assembly {\r\n        r := mload(add(sig, 32))\r\n        s := mload(add(sig, 64))\r\n        v := byte(0, mload(add(sig, 96)))\r\n    }\r\n    return (v, r, s);\r\n}\r\n\r\n```\r\n\r\n## Security Considerations\r\n\r\nBy restricting claim function to issuer, there is no race condition on chain layer. However double spending problem may occur when the issuer use multiple verifiers and payer signs many payment messages simultaneously. Some of those messages may get chance to be checked valid though only the message with the largest consumption can be claimed. This problem can be fixed by introducing an echo server which accepts messages from verifiers, returns the message sequentially with largest consumption and biggest epoch number. If a verifier gets an answer different from the message he send, it updates the message from echo server as the last message it receives along with local storage of the status about this payer. Then the verifier asks the payer again for a new message.\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3132/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248971",
    "html_url": "https://github.com/ethereum/EIPs/issues/3132#issuecomment-950248971",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132",
    "id": 950248971,
    "node_id": "IC_kwDOAq426M44o6YL",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-10-24T02:27:32Z",
    "updated_at": "2021-10-24T02:27:32Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248971/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541436",
    "html_url": "https://github.com/ethereum/EIPs/issues/3132#issuecomment-962541436",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132",
    "id": 962541436,
    "node_id": "IC_kwDOAq426M45Xzd8",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-07T02:29:17Z",
    "updated_at": "2021-11-07T02:29:17Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541436/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1152117704",
    "html_url": "https://github.com/ethereum/EIPs/issues/3132#issuecomment-1152117704",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3132",
    "id": 1152117704,
    "node_id": "IC_kwDOAq426M5Eq-vI",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-06-10T08:35:01Z",
    "updated_at": "2022-06-10T08:35:01Z",
    "author_association": "MEMBER",
    "body": "Since this EIP has become stagnant, we are closing this discussion issue for housekeeping purposes.  You may continue discussion here on the closed issue (it won't be locked), but if you want to revive the EIP (bring it back to Draft or Review status), you will need to create a thread over at https://ethereum-magicians.org/ and update the discussions-to link in the EIP to point there instead (that is where all discussions happen now).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1152117704/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
