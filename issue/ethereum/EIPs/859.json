{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/859/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/859/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/859/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/859",
  "id": 292549143,
  "node_id": "MDU6SXNzdWUyOTI1NDkxNDM=",
  "number": 859,
  "title": "Account abstraction for main chain",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2018-01-29T20:29:06Z",
  "updated_at": "2022-01-02T03:12:37Z",
  "closed_at": "2022-01-02T03:12:37Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "The following is a copy of the account abstraction proposal discussed [here](https://ethresear.ch/t/tradeoffs-in-account-abstraction-proposals/263) but coalesced into one piece and adapted for the ethereum main chain by adding back in mandatory in-transaction nonces.\r\n\r\n### Specification\r\n\r\nA new type of transaction is allowed, with the following format:\r\n\r\n```\r\n    [\r\n        chain_id,      # 1 on mainnet\r\n        target,        # account the tx goes to\r\n        nonce,        # transaction nonce for replay protection\r\n        data,          # transaction data\r\n        start_gas,     # starting gas\r\n        code,           # initcode of the target (for account creation, most of the time should be empty)\r\n        salt,        # contract creation salt (must be 0 or 32 bytes)\r\n    ]\r\n```\r\n\r\nExecuting a transaction of this format is done according to the following rules:\r\n\r\n1. Set `exec_gas = start_gas - intrinsic_gas`, where `intrinsic_gas` is 21000 + 4 gas per zero byte in data+code + 68 gas per nonzero byte in data+code.\r\n2. If the account code of the `target` is empty, then attempt to create the account with the specified `code`. Specifically, follow these steps:\r\n    * Assert `salt` is nonempty\r\n    * Assert `sha3(salt++ code)[12:] == target`\r\n    * Attempt to create a contract with to address `target`, init code `code`, sender ENTRY_POINT (ie. 0xffff...ff), value 0, gas `remaining_gas - CONTRACT_CREATION_COST`, gasprice 0 (calldata equals init code, just like contract creations work now)\r\n    * Assert that the contract creation succeeds.\r\n    * Decrease `exec_gas` to the amount of gas remaining after the contract creation finishes.\r\n3. Assert that the transaction nonce matches the `target` account nonce. Increment the `target` account nonce by 1.\r\n4. Process a message with sender ENTRY_POINT, to address `target`, value 0, gasprice 0, gas `exec_gas`.\r\n5. Assert that the execution either succeeded, or `PAYGAS_CALLED = True` (see below). Refund unpaid gas to the `target` (ie. set `target.balance += remaining_gas * PAYGAS_GASPRICE`).\r\n\r\nIf any of the asserts fails, the transaction is invalid. Note that this includes the assert in step 5; that is, if a top-level transaction execution fails, and PAYGAS_CALLED is False, then the entire transaction is invalid.\r\n\r\n#### PAYGAS\r\n\r\nThe abstraction is simplified with a new PAYGAS opcode. PAYGAS simultaneously serves two purposes:\r\n\r\n1. Paying for gas.\r\n2. Serving as a logical demarcator of the \"verification parts of a transaction\" and the \"execution parts of a transaction\".\r\n\r\nWe add two variables to the execution context (ie. in a similar position as the selfdestructs list): PAYGAS_CALLED and PAYGAS_GASPRICE, initialized to False and 0 respectively. The PAYGAS opcode takes a single stack argument, `gasprice`. Its logic is as follows:\r\n\r\n1. Check that PAYGAS_CALLED = False; if not, then simply pop the top element off the stack, and stop and push 0 onto the stack.\r\n2. Subtract `gasprice * tx.start_gas` from the callee account's balance. If not enough funds, stop and push 0 onto the stack\r\n3. If steps (1) and (2) passed, set PAYGAS_CALLED = True, and PAYGAS_GASPRICE = gasprice, and push 1 onto the stack.\r\n\r\n### Account strategy\r\n\r\nThe owner of an account will generally want to have account code that looks something like:\r\n\r\n1. Check the signature\r\n2. Call PAYGAS\r\n3. Call the actual destination account\r\n\r\nWhere the _transaction data_ encodes the signature as well as the destination, value, gasprice and data of the intended message that is to be sent from an account.\r\n\r\nIt will be possible to send ETH to not-yet-created accounts by simply computing their address from the hash of the init code, and initializing the code for such an account would be done at the same time as sending the first transaction.\r\n\r\n### Miner strategy\r\n\r\nWe note that any transaction whose execution reaches the PAYGAS opcode is guaranteed to pay for gas, even if the execution exits with an exception after that point, and any transaction that exits with an exception before reaching PAYGAS will not be includeable into a block.\r\n\r\nMiners can use the following strategy to accept transactions. Every miner can set a private value, CHECK_LIMIT, eg. to 200000. When a miner or network node sees a transaction, they execute it on top of the current head state for a maximum of CHECK_LIMIT gas (the 200-per-byte cost of creating a new contract does NOT count toward the limit). If the transaction execution hits PAYGAS before this limit, then the miner or network node accepts the transaction and acts as though the gasprice called with PAYGAS is the transaction's gasprice; if it does not, then the miner or network node rejects the transaction.\r\n\r\nWhen a miner actually includes transactions in a block, PAYGAS may pay a different gasprice than when the miner first saw it, for example if the argument to PAYGAS depends on state; in this case, throw out the transaction if the gasprice is lower than it was during the first scan.\r\n\r\nSetting CHECK_LIMIT is a simple tradeoff: if CHECK_LIMIT is higher, miners can accept transactions from accounts that make more complex checks before calling PAYGAS (eg. Lamport sigs, threshold sigs), but setting CHECK_LIMIT higher also makes miners more vulnerable to DoS attacks. Miners may want to start off with high CHECK_LIMIT but dynamically adjust it downwards if they detect a DoS attack to keep CPU usage below some threshold.\r\n\r\n### Specification version 1.1\r\n\r\n* Add a PAYGAS_CALLER parameter; if/when PAYGAS is called successfully, set the value to equal the address of the current executing account (ie. `msg.to`)\r\n* Refund the PAYGAS_CALLER instead of the transaction `target`\r\n\r\n### What does this abstract and what does it not abstract?\r\n\r\n* It will be possible for accounts to use whatever signature scheme they want\r\n* Nonces will remain mandatory; this is a compromise to preserve the \"each transaction can only appear once in the chain\" invariant\r\n* It will be possible for verification conditions to be more complex, saving gas in a variety of scenarios. One particularly interesting usecase is capped ICOs. For example, if there are 10000 transactions going into an ICO but the cap can only accept 2000, then currently all 10000 would get included with the last 8000 being no-ops, but with this scheme one could make a setup where the 8000 transactions that fail all cannot be included in the chain\r\n* It will continue to be difficult to use ERC20s to pay for gas",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/859/reactions",
    "total_count": 8,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 2,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/859/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362924811",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-362924811",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 362924811,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjkyNDgxMQ==",
    "user": {
      "login": "sohkai",
      "id": 4166642,
      "node_id": "MDQ6VXNlcjQxNjY2NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4166642?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sohkai",
      "html_url": "https://github.com/sohkai",
      "followers_url": "https://api.github.com/users/sohkai/followers",
      "following_url": "https://api.github.com/users/sohkai/following{/other_user}",
      "gists_url": "https://api.github.com/users/sohkai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sohkai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sohkai/subscriptions",
      "organizations_url": "https://api.github.com/users/sohkai/orgs",
      "repos_url": "https://api.github.com/users/sohkai/repos",
      "events_url": "https://api.github.com/users/sohkai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sohkai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-04T17:41:34Z",
    "updated_at": "2018-02-04T17:41:34Z",
    "author_association": "NONE",
    "body": "> Refund unpaid gas to the `target` (ie. set `target.balance += remaining_gas * PAYGAS_GASPRICE`).\r\n\r\nWhat is the rationale behind \"refunding\" the gas to the `target` rather than the callee? Since the callee's paying for the gas, shouldn't it also get the refund?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/362924811/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363392054",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-363392054",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 363392054,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MzM5MjA1NA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-06T11:17:14Z",
    "updated_at": "2018-02-06T11:17:14Z",
    "author_association": "MEMBER",
    "body": "Good point! Added that option to the specification.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363392054/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363416801",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-363416801",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 363416801,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MzQxNjgwMQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-06T13:07:47Z",
    "updated_at": "2018-02-06T13:08:32Z",
    "author_association": "MEMBER",
    "body": "My notes after reading through this, and asking @vbuterin about some points.\r\n\r\n> Set `exec_gas = start_gas - intrinsic_gas`, where `intrinsic_gas` is 21000 + 4 gas per zero byte in `data+code` + 68 gas per nonzero byte in `data+code`.\r\n\r\nNote, this is the same as `Gtxdatanonzero` and `Gtxdatazero` from YP, no change.\r\n\r\nNotable differences: \r\n\r\n* Contract creation does not 'just happen' when `to` is missing. Instead, whenever sending tx to an `empty` target, the contract creation process is started.\r\n* The new contract-creation is a two-step thing, where first there's a contract creation (load init-code, execute init-code), followed by a second `CALL` into the newly created contract. This is new, and possibly introduces new complexities in the execution/revertal process.  \r\n\r\n\r\n> * Attempt to create a contract with to address target, init code code, sender ENTRY_POINT (ie. 0xffff...ff), value 0, gas remaining_gas - CONTRACT_CREATION_COST, gasprice 0\r\n\r\nDuring this step, `CALLDATALOAD` will return `code` -- the initcode of the contract, and __not__ the `data`. \r\n\r\n> 4. Process a message with sender ENTRY_POINT, to address `target`, value 0, gasprice 0, gas exec_gas\r\n\r\nThis is the step where `data` is actually used -- this step does not have access to the `code`-part of the transaction: a `CALLDATALOAD` will load `data` into memory. \r\n\r\n\r\nThe differences here are important; since `data` is _not_ take part of the address calculation, whereas `code` does. If a user wants to create a multisig, and set himself as `owner`, the actual constructor argument would have to be part of `code` (since there's no point in using `ORIGIN` or `CALLER` (since they're `0xFF..F`)). This means that the reorg-attack[1] is avoided. \r\n\r\n- Q:If in step 2, the account code of `target` is __non-empty__, what happens? \r\n* A: If code && salt are empty -> non-creating transaction to `target`. Otherwise, there are two options: \r\n  1. If code|salt are non-empty -> tx is `invalid`\r\n  2. if code|salt are non-empty -> just ignore `code` and `salt`\r\n\r\nNote: Vitalik preferred option 2, reasoning there might be situations where a user submits multiple transactions, and it's difficult to know which will make it in first. \r\n\r\nClarification, if a transaction `throw`s after `PAYGAS`, what happens? Two options\r\n\r\n* The `state` is rolled back to the point where `PAYGAS` was invoked, and exits with `0`. \r\n* The `state`is rolled back to start of tx, and the full `start_gas` is paid by the `target`. This options requires checking that the `target` holds sufficient funds. \r\n\r\n\r\n\r\n[1]: Reorg-attack in brief: When a user creates a contract A (perhaps his own multisig-wallet), a reorg (perhaps created by a malicious contract), can create a replica contract at A. Any transactions the user then makes to the contract (e.g. sending money to it), will now go to a multisig-wallet created by another user.  \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363416801/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363446404",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-363446404",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 363446404,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MzQ0NjQwNA==",
    "user": {
      "login": "zmanian",
      "id": 93434,
      "node_id": "MDQ6VXNlcjkzNDM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/93434?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zmanian",
      "html_url": "https://github.com/zmanian",
      "followers_url": "https://api.github.com/users/zmanian/followers",
      "following_url": "https://api.github.com/users/zmanian/following{/other_user}",
      "gists_url": "https://api.github.com/users/zmanian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zmanian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zmanian/subscriptions",
      "organizations_url": "https://api.github.com/users/zmanian/orgs",
      "repos_url": "https://api.github.com/users/zmanian/repos",
      "events_url": "https://api.github.com/users/zmanian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zmanian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-06T14:54:11Z",
    "updated_at": "2018-02-06T14:54:11Z",
    "author_association": "NONE",
    "body": "Does this design imply that ethereum implementation must store and check for uniqueness against all published nonces for each transaction in an account for the entire existence of an account. This sounds inefficient.  How about a counter instead of a nonce?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/363446404/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364622122",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-364622122",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 364622122,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDYyMjEyMg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-10T03:19:39Z",
    "updated_at": "2018-02-10T03:20:04Z",
    "author_association": "MEMBER",
    "body": "> Does this design imply that ethereum implementation must store and check for uniqueness against all published nonces for each transaction in an account for the entire existence of an account. \r\n\r\nNo. This design still requires transactions with the same target account to have sequentially incrementing nonces. It's the [sharding abstraction proposal](https://ethresear.ch/t/tradeoffs-in-account-abstraction-proposals/263) that doesn't have that feature, and which doesn't even care (at least at protocol level) if the same transaction gets included in the chain multiple times.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/364622122/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/368966288",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-368966288",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 368966288,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODk2NjI4OA==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-27T17:51:23Z",
    "updated_at": "2018-02-27T19:36:55Z",
    "author_association": "NONE",
    "body": "It may be too late, but listening to the last core dev call it sounded like this isn't going to make it into Constantinople. This makes me sad, so I wanted to make an attempt to get people to reconsider.\r\n\r\nAs a dapp dev, this is probably the EIP I've been most excitedly waiting for, since it was [EIP 101](https://github.com/ethereum/EIPs/issues/28) in 2015. (The main competitor was [EIP 211](https://github.com/ethereum/EIPs/pull/211), which happily was released with Homestead.)\r\n\r\nRequiring non-abstract accounts is an ugly hack that makes a lot of things I want to build hard or impossible. The most obvious is that projects I've worked on have often wanted to pay for their users' gas, so that users aren't required to purchase Ether on an exchange in order to use our application. Without account abstraction, you have to do a difficult and imperfect dance involving sending small amounts of gas to each user's account, reimbursing them over time, topping them up if transaction costs rise, etc.\r\n\r\nA related annoyance is that it is harder to experiment with alternative ownership models, like native multisig wallets, zero-knowledge-proof-based contracts, ring signatures, etc. You can mostly do it, but you have to keep an account with a small (but not too small) amount of ether around, to actually send the transactions.\r\n\r\nFinally, I've been planning a project that attempted to use account abstraction in conjunction with [on-chain decentralized exchanges](https://www.reddit.com/r/ethereum/comments/55m04x/lets_run_onchain_decentralized_exchanges_the_way/) to pay for gas using ERC-20 tokens (I'm pretty sure you can do it in under 200k gas if you're careful), which I won't get to do until account abstraction is released.\r\n\r\nI understand that development time is limited, but account abstraction has much more relevance to my job and my hobby projects than Casper does, so I thought I'd at least make the argument. :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/368966288/reactions",
      "total_count": 7,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 7,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369421459",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-369421459",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 369421459,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTQyMTQ1OQ==",
    "user": {
      "login": "lrettig",
      "id": 3316532,
      "node_id": "MDQ6VXNlcjMzMTY1MzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3316532?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lrettig",
      "html_url": "https://github.com/lrettig",
      "followers_url": "https://api.github.com/users/lrettig/followers",
      "following_url": "https://api.github.com/users/lrettig/following{/other_user}",
      "gists_url": "https://api.github.com/users/lrettig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lrettig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lrettig/subscriptions",
      "organizations_url": "https://api.github.com/users/lrettig/orgs",
      "repos_url": "https://api.github.com/users/lrettig/repos",
      "events_url": "https://api.github.com/users/lrettig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lrettig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-28T23:35:08Z",
    "updated_at": "2018-02-28T23:35:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "For the record, [here are the notes](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2034.md#eip859) from the discussion of this EIP in the [last all core devs call](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2034.md). The sentiment seemed to be that 1. this is complex, 2. we don't have time to do this properly before Constantinople, and 3. this will happen along with sharding anyway.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/369421459/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398078664",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-398078664",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 398078664,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODA3ODY2NA==",
    "user": {
      "login": "cdetrio",
      "id": 997681,
      "node_id": "MDQ6VXNlcjk5NzY4MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/997681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cdetrio",
      "html_url": "https://github.com/cdetrio",
      "followers_url": "https://api.github.com/users/cdetrio/followers",
      "following_url": "https://api.github.com/users/cdetrio/following{/other_user}",
      "gists_url": "https://api.github.com/users/cdetrio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cdetrio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cdetrio/subscriptions",
      "organizations_url": "https://api.github.com/users/cdetrio/orgs",
      "repos_url": "https://api.github.com/users/cdetrio/repos",
      "events_url": "https://api.github.com/users/cdetrio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cdetrio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-18T14:43:39Z",
    "updated_at": "2018-06-18T14:43:39Z",
    "author_association": "MEMBER",
    "body": "Discussion around account abstraction for Metropolis (i.e. Byzantium) took place in https://github.com/ethereum/EIPs/pull/208.\r\n\r\nAfter the Metropolis EIP was deferred, discussion continued in the [first ethresear.ch thread](https://ethresear.ch/t/tradeoffs-in-account-abstraction-proposals/263) on abstraction. More discussion followed in a [second thread](https://ethresear.ch/t/a-recap-of-where-we-are-at-on-account-abstraction/1721). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398078664/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997321849",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-997321849",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 997321849,
    "node_id": "IC_kwDOAq426M47cex5",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-19T03:12:02Z",
    "updated_at": "2021-12-19T03:12:02Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997321849/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003656698",
    "html_url": "https://github.com/ethereum/EIPs/issues/859#issuecomment-1003656698",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/859",
    "id": 1003656698,
    "node_id": "IC_kwDOAq426M470pX6",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-02T03:12:37Z",
    "updated_at": "2022-01-02T03:12:37Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003656698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
