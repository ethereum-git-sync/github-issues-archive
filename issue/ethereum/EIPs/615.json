{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/615/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/615/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/615/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/615",
  "id": 224850482,
  "node_id": "MDU6SXNzdWUyMjQ4NTA0ODI=",
  "number": 615,
  "title": "EIP-615: Subroutines and Static Jumps for the EVM",
  "user": {
    "login": "gcolvin",
    "id": 16827129,
    "node_id": "MDQ6VXNlcjE2ODI3MTI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gcolvin",
    "html_url": "https://github.com/gcolvin",
    "followers_url": "https://api.github.com/users/gcolvin/followers",
    "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
    "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
    "organizations_url": "https://api.github.com/users/gcolvin/orgs",
    "repos_url": "https://api.github.com/users/gcolvin/repos",
    "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gcolvin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 37,
  "created_at": "2017-04-27T17:01:54Z",
  "updated_at": "2021-08-19T09:53:17Z",
  "closed_at": "2019-07-16T02:51:09Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 615\r\ntitle: Subroutines and Static Jumps for the EVM\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: Core\r\nauthor: Greg Colvin <greg@colvin.org>, Brooklyn Zelenka (@expede), Paweł Bylica (@chfast), Christian Reitwiessner (@chriseth)\r\ndiscussions-to: https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472\r\ncreated: 2016-12-10\r\n---\r\n\r\n## Simple Summary\r\n\r\nIn the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.\r\n\r\n## Abstract\r\n\r\nEVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine—including the compilers—are sufficiently performant to reduce the need for precompiles and otherwise meet the network's long-term demands.  This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible.\r\n\r\nWe also propose to validate—in near-linear time—that EVM contracts correctly use subroutines, avoid misuse of the stack, and meet other safety conditions _before_ placing them on the blockchain.  Validated code precludes most runtime exceptions and the need to test for them.  And well-behaved control flow and use of the stack makes life easier for interpreters, compilers, formal analysis, and other tools.\r\n\r\n## Motivation\r\n\r\nCurrently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack.  Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs.  So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis.  This puts the quality and speed of optimized compilation fundamentally at odds.  Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis.  Many of these cases are undecidable at deployment time, further inhibiting static and formal analyses.\r\n\r\nHowever, given Ethereum's security requirements, **near-linear** **`n log n`** **time complexity** is essential.  Otherwise, Contracts can be crafted or discovered with quadratic complexity to use as denial of service attack vectors against validations and optimizations.\r\n\r\nBut absent dynamic jumps code can be statically analyzed in linear time.  That allows for _linear time validation_.  It also allows for code generation and such optimizations as can be done in `log n` time to comprise an _`n log n`_ _time compiler_.\r\n\r\nAnd absent dynamic jumps, and with proper subroutines the EVM is a better target for code generation from other languages, including\r\n* Solidity\r\n* Vyper\r\n* LLVM IR\r\n  * front ends include C, C++, Common Lisp, D, Fortran, Haskell, Java, Javascript, Kotlin, Lua, Objective-C, Pony, Pure, Python, Ruby, Rust, Scala, Scheme, and Swift\r\n\r\nThe result is that all of the following validations and optimizations can be done at deployment time with near-linear `(n log n)` time complexity.\r\n* The absence of most exceptional halting states can be validated.\r\n* The maximum use of resources can be sometimes be calculated.\r\n* Bytecode can be compiled to machine code in near-linear time.\r\n* Compilation can more effectively optimize use of smaller registers.\r\n* Compilation can more effectively optimize injection of gas metering.\r\n\r\n## Specification\r\n\r\n### Dependencies\r\n\r\n> **[EIP-1702](./eip-1702.md). Generalized Account Versioning Scheme.** This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain.\r\n\r\n### Proposal\r\n\r\nWe propose to deprecate two existing instructions—`JUMP` and `JUMPI`—and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.\r\n\r\nEspecially important is efficient translation to and from [eWasm](https://github.com/ewasm/design) and to machine code.  To that end we maintain a close correspondence between [Wasm](https://webassembly.github.io/spec/core/_download/WebAssembly.pdf), [x86](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf), [ARM](https://static.docs.arm.com/100076/0100/arm_instruction_set_reference_guide_100076_0100_00_en.pdf) and proposed EVM instructions.\r\n\r\n| EIP-615   | Wasm          | x86  | ARM\r\n| --------- | ------------- | ---- | ---- |\r\n| JUMPTO    | br            | JMP  | B    |\r\n| JUMPIF    | br_if         | JE   | BEQ  |\r\n| JUMPV     | br_table      | JMP  | TBH  |\r\n| JUMPSUB   | call          | CALL | BL   |\r\n| JUMPSUBV  | call_indirect | CALL | BL   |\r\n| RETURN    | return        | RET  | RET  |\r\n| GETLOCAL  | local.get     | POP  | POP  |\r\n| PUTLOCAL  | local.put     | PUSH | PUSH |\r\n| BEGINSUB  | func          |      |      |\r\n| BEGINDATA | tables        |      |      |\r\n\r\n#### Preliminaries\r\n\r\nThese forms\r\n> *`INSTRUCTION`*\r\n>\r\n> *`INSTRUCTION x`*\r\n>\r\n> *`INSTRUCTION x, y`*\r\n\r\nname an *`INSTRUCTION`* with no, one and two arguments, respectively. An instruction is represented in the bytecode as a single-byte opcode. Any arguments are laid out as immediate data bytes following the opcode inline, interpreted as fixed length, MSB-first, two's-complement, two-byte positive integers. (Negative values are reserved for extensions.)\r\n\r\n#### Branches and Subroutines\r\n\r\nThe two most important uses of `JUMP` and `JUMPI` are static jumps and return jumps. Conditional and unconditional static jumps are the mainstay of control flow.  Return jumps are implemented as a dynamic jump to a return address pushed on the stack.  With the combination of a static jump and a dynamic return jump you can—and Solidity does—implement subroutines.  The problem is that static analysis cannot tell the one place the return jump is going, so it must analyze every possibility (a heavy analysis).\r\n\r\nStatic jumps are provided by\r\n> `JUMPTO jump_target`\r\n>\r\n> `JUMPIF jump_target`\r\n>\r\n> which are the same as `JUMP` and `JUMPI` except that they jump to an immediate `jump_target` rather than an address on the stack.\r\n\r\nTo support subroutines, `BEGINSUB`, `JUMPSUB`, and `RETURNSUB` are provided.  Brief descriptions follow, and full semantics are given below.\r\n\r\n> `BEGINSUB n_args, n_results`\r\n>\r\n> marks the **single** entry to a subroutine.  `n_args` items are taken off of the stack at entry to, and `n_results` items are placed on the stack at return from the subroutine.   The subroutine ends at the next `BEGINSUB` instruction (or `BEGINDATA`, below) or at the end of the bytecode.\r\n\r\n> `JUMPSUB jump_target`\r\n>\r\n> jumps to an immediate subroutine address.\r\n\r\n> `RETURNSUB`\r\n>\r\n>returns from the current subroutine to the instruction following the JUMPSUB that entered it.\r\n\r\n#### Switches, Callbacks, and Virtual Functions\r\n\r\nDynamic jumps are also used for `O(1)` indirection: an address to jump to is selected to push on the stack and be jumped to.  So we also propose two more instructions to provide for constrained indirection.  We support these with vectors of `JUMPDEST` or `BEGINSUB` offsets stored inline, which can be selected with an index on the stack.  That constrains validation to a specified subset of all possible destinations.  The danger of quadratic blow up is avoided because it takes as much space to store the jump vectors as it does to code the worst case exploit.\r\n\r\nDynamic jumps to a `JUMPDEST` are used to implement `O(1)` jumptables, which are useful for dense switch statements.  Wasm and most CPUs provide similar instructions.\r\n\r\n> `JUMPV n, jump_targets`\r\n>\r\n> jumps to one of a vector of `n` `JUMPDEST` offsets via a zero-based index on the stack.  The vector is stored inline at the `jump_targets` offset after the BEGINDATA bytecode as MSB-first, two's-complement, two-byte positive integers.  If the index is greater than or equal to `n - 1` the last (default) offset is used.\r\n\r\nDynamic jumps to a `BEGINSUB` are used to implement `O(1)` virtual functions and callbacks, which take at most two pointer dereferences on most CPUs.   Wasm provides a similar instruction.\r\n\r\n> `JUMPSUBV n, jump_targets`\r\n>\r\n>jumps to one of a vector of `n` `BEGINSUB` offsets via a zero-based index on the stack.  The vector is stored inline at the `jump_targets` offset after the DATA bytecode, as MSB-first, two's-complement, two-byte positive integers.  If the index is greater than or equal to `n - 1` the last (default) offset is used.\r\n\r\n#### Variable Access\r\n\r\nThese operations provide convenient access to subroutine parameters and local variables at fixed stack offsets within a subroutine.  Otherwise only sixteen variables can be directly addressed.\r\n\r\n> `PUTLOCAL n`\r\n>\r\n> Pops the stack to the local variable `n`.\r\n\r\n> `GETLOCAL n`\r\n>\r\n> Pushes the local variable `n` onto the stack.\r\n\r\nLocal variable `n` is the nth stack item below the frame pointer, `FP[-n]`, as defined below.\r\n\r\n#### Data\r\n\r\nThere needs to be a way to place unreachable data into the bytecode that will be skipped over and not validated.  Indirect jump vectors will not be valid code.  Initialization code must create runtime code from data that might not be valid code.  And unreachable data might prove useful to programs for other purposes.\r\n\r\n> `BEGINDATA`\r\n>\r\n> specifies that all of the following bytes to the end of the bytecode are data, and not reachable code.\r\n\r\n#### Structure\r\n\r\nValid EIP-615 EVM bytecode begins with a valid header.  This is the magic number  ‘\\0evm’ followed by the semantic versioning number '\\1\\5\\0'.  (For Wasm the header is '\\0asm\\1').\r\n\r\nFollowing the header is the BEGINSUB opcode for the _main_ routine.  It takes no arguments and returns no values.  Other subroutines may follow the _main_ routine, and an optional BEGINDATA opcode may mark the start of a data section.\r\n\r\n### Semantics\r\n\r\nJumps to and returns from subroutines are described here in terms of\r\n* The EVM data stack, (as defined in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)) usually just called “the stack.”\r\n* A return stack of `JUMPSUB` and `JUMPSUBV` offsets.\r\n* A frame stack of frame pointers.\r\n\r\nWe will adopt the following conventions to describe the machine state:\r\n* The _program counter_ `PC` is (as usual) the byte offset of the currently executing instruction.\r\n* The _stack pointer_ `SP` corresponds to the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)'s substate `s` of the machine state.\r\n  * `SP[0]` is where a new item is can be pushed on the stack.\r\n  * `SP[1]` is the first item on the stack, which can be popped off the stack.\r\n  * The stack grows towards lower addresses.\r\n* The _frame pointer_ `FP` is set to `SP + n_args` at entry to the currently executing subroutine.\r\n  * The _stack items_ between the frame pointer and the current stack pointer are called the _frame_.\r\n  * The current number of items in the frame, `FP - SP`, is the _frame size_.\r\n\r\n> **Note**: Defining the frame pointer so as to include the arguments is unconventional, but better fits our stack semantics and simplifies the remainder of the proposal.\r\n\r\nThe frame pointer and return stacks are internal to the subroutine mechanism, and not directly accessible to the program.  This is necessary to prevent the program from modifying its own state in ways that could be invalid.\r\n\r\nExecution of EVM bytecode begins with the _main_ routine with no arguments, `SP` and `FP` set to 0, and with one value on the return stack—`code_size - 1`. (Executing the virtual byte of 0 after this offset causes an EVM to stop.  Thus executing a `RETURNSUB` with no prior `JUMPSUB` or `JUMBSUBV`—that is, in the _main_ routine—executes a `STOP`.)\r\n\r\nExecution of a subroutine begins with `JUMPSUB` or `JUMPSUBV`, which\r\n\r\n* pushes `PC` on the return stack,\r\n* pushes `FP` on the frame stack\r\n  * thus suspending execution of the current subroutine,\r\n* sets `FP` to `SP + n_args`, and\r\n* sets `PC` to the specified `BEGINSUB` address\r\n  * thus beginning execution of the new subroutine.\r\n\r\nExecution of a subroutine is suspended during and resumed after execution of nested subroutines, and ends upon encountering a `RETURNSUB`, which\r\n\r\n* sets `FP` to the top of the virtual frame stack and pops the stack,\r\n* sets `SP` to `FP + n_results`,\r\n* sets `PC` to top of the return stack and pops the stack, and\r\n* advances `PC` to the next instruction\r\n\r\nthus resuming execution of the enclosing subroutine or _main_ routine.  A `STOP` or `RETURN` also ends the execution of a subroutine.\r\n\r\nFor example, starting from this stack,\r\n```\r\n_________________\r\n      | locals      20 <- FP\r\nframe |             21\r\n______|___________  22\r\n                       <- SP\r\n```\r\nand after pushing two arguments and branching with `JUMPSUB` to a `BEGINSUB 2, 3`\r\n```\r\nPUSH 10\r\nPUSH 11\r\nJUMPSUB beginsub\r\n```\r\nand initializing three local variables\r\n```\r\nPUSH 99\r\nPUSH 98\r\nPUSH 97\r\n```\r\nthe stack looks like this\r\n```\r\n                    20\r\n                    21\r\n__________________  22\r\n      | arguments   10 <- FP\r\nframe |___________  11\r\n      | locals      99\r\n      |             98\r\n______|___________  97\r\n                       <- SP\r\n```\r\nAfter some amount of computation the stack could look like this\r\n```\r\n                    20\r\n                    21\r\n__________________  22\r\n      | returns     44 <- FP\r\n      |             43\r\nframe |___________  42\r\n      | locals      13\r\n______|___________  14\r\n                       <- SP\r\n```\r\nand after `RETURNSUB` would look like this\r\n```\r\n_________________\r\n      | locals      20 <- FP\r\n      |             21\r\nframe |___________  22\r\n      | returns     44\r\n      |             43\r\n______|___________  42\r\n                       <- SP\r\n```\r\n\r\n### Validity\r\n\r\nWe would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must validate code in linear time. So our validation does not consider the code’s data and computations, only its control flow and stack use.  This means we will reject programs with invalid code paths, even if those paths are not reachable.  Most conditions can be validated, and will not need to be checked at runtime; the exceptions are sufficient gas and sufficient stack.  As such, static analysis may yield false negatives belonging to well-understood classes of code requiring runtime checks.  Aside from those cases, we can validate large classes at validation time and with linear complexity.\r\n\r\n_Execution_ is as defined in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)—a sequence of changes in the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines five such states.\r\n>**1**  Insufficient gas\r\n\r\n>**2**  More than 1024 stack items\r\n\r\n>**3**  Insufficient stack items\r\n\r\n>**4**  Invalid jump destination\r\n\r\n>**5**  Invalid instruction\r\n\r\nWe propose to expand and extend the Yellow Paper conditions to handle the new instructions we propose.\r\n\r\nTo handle the return stack we expand the conditions on stack size:\r\n>**2a**  The size of the data stack does not exceed 1024.\r\n\r\n>**2b**  The size of the return stack does not exceed 1024.\r\n\r\nGiven our more detailed description of the data stack we restate condition 3—stack underflow—as\r\n>**3**  `SP` must be less than or equal to `FP`\r\n\r\nSince the various `DUP` and `SWAP` operations—as well as `PUTLOCAL` and `GETLOCAL`—are defined as taking items off the stack and putting them back on, this prevents them from accessing data below the frame pointer, since taking too many items off of the stack would mean that `SP` is less than `FP`.\r\n\r\nTo handle the new jump instructions and subroutine boundaries, we expand the conditions on jumps and jump destinations.\r\n>**4a**  `JUMPTO`, `JUMPIF`, and `JUMPV` address only `JUMPDEST` instructions.\r\n\r\n>**4b**  `JUMPSUB` and `JUMPSUBV` address only `BEGINSUB` instructions.\r\n\r\n>**4c**  `JUMP` instructions do not address instructions outside of the subroutine they occur in.\r\n\r\nWe have two new conditions on execution to ensure consistent use of the stack by subroutines:\r\n>**6**  For `JUMPSUB` and `JUMPSUBV` the frame size is at least the `n_args` of the `BEGINSUB`(s) to jump to.\r\n\r\n>**7**  For `RETURNSUB` the frame size is equal to the `n_results` of the enclosing `BEGINSUB`.\r\n\r\nFinally, we have one condition that prevents pathological uses of the stack:\r\n>**8**  For every instruction in the code the frame size is constant.\r\n\r\nIn practice, we must test at runtime for conditions 1 and 2—sufficient gas and sufficient stack.  We don’t know how much gas there will be, we don’t know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial.\r\n\r\nAll of the remaining conditions we validate statically.\r\n\r\n\r\n#### Costs & Codes\r\n\r\nAll of the instructions are `O(1)` with a small constant, requiring just a few machine operations each, whereas a `JUMP` or `JUMPI` typically does an `O(log n)` binary search of an array of `JUMPDEST` offsets before every jump. With the cost of `JUMPI` being _high_ and the cost of `JUMP` being _mid_, we suggest the cost of `JUMPV` and `JUMPSUBV` should be _mid_, `JUMPSUB` and `JUMPIF` should be _low_, and`JUMPTO` and the rest should be _verylow_.  Measurement will tell.\r\n\r\nWe suggest the following opcodes:\r\n```\r\n0xb0 JUMPTO\r\n0xb1 JUMPIF\r\n0xb2 JUMPV\r\n0xb3 JUMPSUB\r\n0xb4 JUMPSUBV\r\n0xb5 BEGINSUB\r\n0xb6 BEGINDATA\r\n0xb7 RETURNSUB\r\n0xb8 PUTLOCAL\r\n0xb9 GETLOCAL\r\n```\r\n\r\n## Backwards Compatibility\r\n\r\nThese changes would need to be implemented in phases at decent intervals:\r\n>**1.**  If this EIP is accepted, invalid code should be deprecated. Tools should stop generating invalid code, users should stop writing it, and clients should warn about loading it.\r\n\r\n>**2.**  A later hard fork would require clients to place only valid code on the block chain.  Note that despite the fork old EVM code will still need to be supported indefinitely; older contracts will continue to run, and to create new contracts.\r\n\r\nIf desired, the period of deprecation can be extended indefinitely by continuing to accept code not versioned as new—but without validation.  That is, by delaying or canceling phase 2.\r\n\r\nRegardless, we will need a versioning scheme like [EIP-1702](./eip-1702.md) to allow current code and EIP-615 code to coexist on the same blockchain.\r\n\r\n## Rationale\r\n\r\nThis design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment.  It was also informed by the lead author's previous work implementing Java and Scheme interpreters.  As such there was very little room for alternative designs.\r\n\r\nAs described above, the approach was simply to deprecate the problematic dynamic jumps, then ask what opcodes were necessary to provide for the features they supported.  These needed to include those provided by eWasm, which themselves were modeled after typical hardware.  The only real innovation was to move the frame pointer and the return pointer to their own stacks, so as to prevent any possibility of overwriting them. (Although Forth also uses a return stack.)  This allowed for treating subroutine arguments as local variables, and facilitated the return of multiple values.\r\n\r\n## Implementation\r\n\r\nImplementation of this proposal need not be difficult.  At the least, interpreters can simply be extended with the new opcodes and run unchanged otherwise.  The new opcodes require only stacks for the frame pointers and return offsets and the few pushes, pops, and assignments described above. The bulk of the effort is the validator, which in most languages can almost be transcribed from the pseudocode above.\r\n\r\nA lightly tested C++ reference implementation is available in [Greg Colvin's Aleth fork.](https://github.com/gcolvin/aleth/tree/master/libaleth-interpreter)  This version required circa 110 lines of new interpreter code and a well-commented, 178-line validator.\r\n\r\n## Appendix A\r\n### Validation\r\n\r\nValidation comprises two tasks:\r\n* Check that jump destinations are correct and instructions valid.\r\n* Check that subroutines satisfy the conditions on control flow and stack use.\r\n\r\nWe sketch out these two validation functions in pseudo-C below.  To simplify the presentation only the five primitives are handled (`JUMPV` and `JUMPSUBV` would just add more complexity to loop over their vectors), we assume helper functions for extracting instruction arguments from immediate data and managing the stack pointer and program counter, and some optimizations are forgone.\r\n\r\n#### Validating Jumps\r\n\r\nValidating that jumps are to valid addresses takes two sequential passes over the bytecode—one to build sets of jump destinations and subroutine entry points, another to check that addresses jumped to are in the appropriate sets.\r\n```\r\n    bytecode[code_size]   // contains EVM bytecode to validate\r\n    is_sub[code_size]     // is there a BEGINSUB at PC?\r\n    is_dest[code_size]    // is there a JUMPDEST at PC?\r\n    sub_for_pc[code_size] // which BEGINSUB is PC in?\r\n\r\n    bool validate_jumps(PC)\r\n    {\r\n        current_sub = PC\r\n\r\n        // build sets of BEGINSUBs and JUMPDESTs\r\n        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))\r\n        {\r\n            if instruction is invalid\r\n                return false\r\n            if instruction is BEGINDATA\r\n                break;\r\n            if instruction is BEGINSUB\r\n                is_sub[PC] = true\r\n                current_sub = PC\r\n                sub_for_pc[PC] = current_sub\r\n            if instruction is JUMPDEST\r\n                is_dest[PC] = true\r\n            sub_for_pc[PC] = current_sub\r\n        }\r\n\r\n        // check that targets are in subroutine\r\n        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))\r\n        {\r\n            if instruction is BEGINDATA\r\n                break;\r\n            if instruction is BEGINSUB\r\n                current_sub = PC\r\n            if instruction is JUMPSUB\r\n                if is_sub[jump_target(PC)] is false\r\n                    return false\r\n            if instruction is JUMPTO or JUMPIF\r\n                if is_dest[jump_target(PC)] is false\r\n                    return false\r\n            if sub_for_pc[PC] is not current_sub\r\n                return false\r\n       }\r\n       return true\r\n    }\r\n```\r\nNote that code like this is already run by EVMs to check dynamic jumps, including building the jump destination set every time a contract is run, and doing a lookup in the jump destination set before every jump.\r\n\r\n#### Subroutine Validation\r\n\r\nThis function can be seen as a symbolic execution of a subroutine in the EVM code, where only the effect of the instructions on the state being validated is computed.  Thus the structure of this function is very similar to an EVM interpreter.  This function can also be seen as an acyclic traversal of the directed graph formed by taking instructions as vertices and sequential and branching connections as edges, checking conditions along the way.  The traversal is accomplished via recursion, and cycles are broken by returning when a vertex which has already been visited is reached.  The time complexity of this traversal is `O(|E|+|V|)`: The sum of the number of edges and number of vertices in the graph.\r\n\r\nThe basic approach is to call `validate_subroutine(i, 0, 0)`, for `i` equal to the first instruction in the EVM code through each `BEGINDATA` offset.  `validate_subroutine()` traverses instructions sequentially, recursing when `JUMP` and `JUMPI` instructions are encountered.  When a destination is reached that has been visited before it returns, thus breaking cycles.  It returns true if the subroutine is valid, false otherwise.\r\n\r\n```\r\n    bytecode[code_size]     // contains EVM bytecode to validate\r\n    frame_size[code_size ]  // is filled with -1\r\n\r\n    // we validate each subroutine individually, as if at top level\r\n    // * PC is the offset in the code to start validating at\r\n    // * return_pc is the top PC on return stack that RETURNSUB returns to\r\n    // * at top level FP = SP = 0 is both the frame size and the stack size\r\n    // * as items are pushed SP get more negative, so the stack size is -SP\r\n    validate_subroutine(PC, return_pc, SP)\r\n    {\r\n        // traverse code sequentially, recurse for jumps\r\n        while true\r\n        {\r\n            instruction = bytecode[PC]\r\n\r\n            // if frame size set we have been here before\r\n            if frame_size[PC] >= 0\r\n            {\r\n                // check for constant frame size\r\n                if instruction is JUMPDEST\r\n                    if -SP != frame_size[PC]\r\n                        return false\r\n\r\n                // return to break cycle\r\n                return true\r\n            }\r\n            frame_size[PC] = -SP\r\n\r\n            // effect of instruction on stack\r\n            n_removed = removed_items(instructions)\r\n            n_added = added_items(instruction)\r\n\r\n            // check for stack underflow\r\n            if -SP < n_removed\r\n                return false\r\n\r\n            // net effect of removing and adding stack items\r\n            SP += n_removed\r\n            SP -= n_added\r\n\r\n            // check for stack overflow\r\n            if -SP > 1024\r\n                return false\r\n\r\n            if instruction is STOP, RETURN, or SUICIDE\r\n                return true\r\n\r\n            // violates single entry\r\n            if instruction is BEGINSUB\r\n                 return false\r\n\r\n            // return to top or from recursion to JUMPSUB\r\n            if instruction is RETURNSUB\r\n                return true;;\r\n\r\n            if instruction is JUMPSUB\r\n            {\r\n                // check for enough arguments\r\n                sub_pc = jump_target(PC)\r\n                if -SP < n_args(sub_pc)\r\n                    return false\r\n                return true\r\n            }\r\n\r\n            // reset PC to destination of jump\r\n            if instruction is JUMPTO\r\n            {\r\n                PC = jump_target(PC)\r\n                continue\r\n            }\r\n\r\n            // recurse to jump to code to validate\r\n            if instruction is JUMPIF\r\n            {\r\n                if not validate_subroutine(jump_target(PC), return_pc, SP)\r\n                    return false\r\n            }\r\n\r\n            // advance PC according to instruction\r\n            PC = advance_pc(PC)\r\n        }\r\n\r\n        // check for right number of results\r\n        if (-SP != n_results(return_pc)\r\n            return false\r\n        return true\r\n    }\r\n```\r\n## Appendix B\r\n### EVM Analysis\r\n\r\nThere is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools--providing software and services focused on the correctness and security of EVM code.  A small sample is given here.\r\n\r\n#### Some Tools\r\n\r\n* [Contract Library](https://contract-library.com/)\r\n* [EthereumJ](https://github.com/ethereum/ethereumj)\r\n* [Exthereum](https://github.com/exthereum/blockchain)\r\n* [Harmony](https://github.com/ether-camp/ethereum-harmony)\r\n* [JEB](https://www.pnfsoftware.com/blog/ethereum-smart-contract-decompiler/)\r\n* [Mythril](https://github.com/ConsenSys/mythril)\r\n* [Securify](https://github.com/eth-sri/securify)\r\n* [Skale](https://www.skalelabs.com/)\r\n* [Status](https://status.im/)\r\n\r\n#### Some Papers\r\n\r\n* [A Formal Verification Tool for Ethereum VM Bytecode](https://www.google.com/url?q=http://fsl.cs.illinois.edu/FSL/papers/2018/park-zhang-saxena-daian-rosu-2018-fse/park-zhang-saxena-daian-rosu-2018-fse-public.pdf)\r\n* [A Lem formalization of EVM and some Isabelle/HOL proofs](https://github.com/pirapira/eth-isabelle)\r\n* [A survey of attacks on Ethereum smart contracts](https://eprint.iacr.org/2016/1007.pdf)\r\n* [Defining the Ethereum Virtual Machine for Interactive Theorem Provers](https://www.google.com/url?q=http://fc17.ifca.ai/wtsc/Defining%2520the%2520Ethereum%2520Virtual%2520Machine%2520for%2520Interactive%2520Theorem%2520Provers.pdf)\r\n* [Ethereum 2.0 Specifications](https://github.com/ethereum/eth2.0-specs)\r\n* [Formal Verification of Smart Contracts](https://www.cs.umd.edu/~aseem/solidetherplas.pdf)\r\n* [JelloPaper: Human Readable Semantics of EVM in K](https://jellopaper.org/)\r\n* [KEVM: A Complete Semantics of the Ethereum Virtual Machine.](https://www.ideals.illinois.edu/bitstream/handle/2142/97207/hildenbrandt-saxena-zhu-rodrigues-guth-daian-rosu-2017-tr.pdf)\r\n* [Making Smart Contracts Smarter](https://eprint.iacr.org/2016/633.pdf)\r\n* [Securify: Practical Security Analysis of Smart Contracts](https://arxiv.org/pdf/1806.01143.pdf)\r\n* [The Thunder Protocol](https://docs.thundercore.com/thunder-whitepaper.pdf)\r\n* [Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL](https://ts.data61.csiro.au/publications/csiro_full_text//Amani_BBS_18.pdf)\r\n*[A Lem formalization of EVM 1.5](https://github.com/seed/eth-isabelle/tree/evm15)\r\n\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "gcolvin",
    "id": 16827129,
    "node_id": "MDQ6VXNlcjE2ODI3MTI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gcolvin",
    "html_url": "https://github.com/gcolvin",
    "followers_url": "https://api.github.com/users/gcolvin/followers",
    "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
    "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
    "organizations_url": "https://api.github.com/users/gcolvin/orgs",
    "repos_url": "https://api.github.com/users/gcolvin/repos",
    "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gcolvin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/615/reactions",
    "total_count": 10,
    "+1": 9,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/615/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343806899",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343806899",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343806899,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgwNjg5OQ==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T04:16:12Z",
    "updated_at": "2017-11-13T04:16:12Z",
    "author_association": "NONE",
    "body": "This is a very useful proposal, especially for anything that involves decompilation of bytecode.\r\nIt would be great to have support for this proposal in the Solidity compiler.\r\n\r\nI have a few questions regarding the variable access section.\r\nIs the purpose of GETLOCAL and PUTLOCAL to allow writing more efficient bytecode?\r\nIs the objective to reduce memory accesses by using the stack instead?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343806899/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343808998",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343808998",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343808998,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgwODk5OA==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T04:28:54Z",
    "updated_at": "2017-11-13T04:28:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yeah, it's to support local variables on the stack that are too far away to reach with DUP or SWAP.  So more efficient bytecode, and also a better target for transpiling from eWASM.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343808998/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343810653",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343810653",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343810653,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgxMDY1Mw==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T04:39:51Z",
    "updated_at": "2017-11-13T05:00:50Z",
    "author_association": "NONE",
    "body": "Thanks.\r\n\r\nWhat is the semantics of GETLOCAL n, when n is greater than the number of arguments specified in BEGINSUB? I'd suspect an exception is thrown in that case?\r\n\r\nIt seems that the number of return variables specified in BEGINSUB, isn't used anywhere.\r\nAccording to my understanding, whenever we execute a RETSUB, the following should be true: FP - narg + nret == SP. If so, should an EVM interpreter check this and throw an exception otherwise?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343810653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343814912",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343814912",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343814912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgxNDkxMg==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T05:08:37Z",
    "updated_at": "2017-11-13T05:08:37Z",
    "author_association": "NONE",
    "body": "Could you please clarify if GETLOCAL n, where n is positive, is accessing an argument or local variable? It seems that the former is true, but it would be good to be more explicit about this in the proposal.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343814912/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343819004",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343819004",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343819004,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgxOTAwNA==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T05:35:58Z",
    "updated_at": "2017-11-13T05:35:58Z",
    "author_association": "NONE",
    "body": "Actually, the following is really confusing to me:\r\n> Execution of a subroutine begins with JUMPSUB or JUMPSUBV, which\r\n> ...\r\n> set FP to SP + n_args, and\r\n\r\nShouldn't this be rather \"set FP to SP\" or \"set FP to SP - n_args\" because the arguments have already been placed on the stack at this point.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343819004/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343822500",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-343822500",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 343822500,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzgyMjUwMA==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-13T06:04:09Z",
    "updated_at": "2017-11-13T06:04:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "Perhaps, Seed.  It confuses me too.  It's been a long while since I wrote and implemented this, so it will take a little study.  Getting near bedtime here, and I've got 100 miles of driving to get home tomorrow, so please be patient.  It's on my stack to do a cleanup pass and new PR for this and 616, so I much appreciate your review.  (If you read C++ your questions might be answered in the code at https://github.com/ethereum/cpp-ethereum/tree/develop/libevm)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343822500/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345552819",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-345552819",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 345552819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTU1MjgxOQ==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-19T21:51:52Z",
    "updated_at": "2017-11-19T21:51:52Z",
    "author_association": "NONE",
    "body": "We started specifying the semantics of new instructions in Lem.\r\nSee https://github.com/seed/eth-isabelle/blob/evm15/lem/evm.lem\r\n\r\nOne of the things we noticed is that it makes more sense to setup the stack-frame with the BEGINSUB instruction because we have the number of function arguments at hand. It also makes sense when compared native assembly like x86, where the stack-frame is created in the body of the function, not by the CALL instruction.\r\n\r\nI'll be continuing the specification next week and will probably have more comments to make.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345552819/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345554732",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-345554732",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 345554732,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTU1NDczMg==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-19T22:18:42Z",
    "updated_at": "2017-11-19T22:48:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "You ask\r\n> What is the semantics of GETLOCAL n, when n is greater than the number of arguments specified in BEGINSUB?\"\r\n\r\nIt pushes FP[-n] on the stack.\r\nYou also ask\r\n\r\n> According to my understanding, whenever we execute a RETSUB, the following should be true: FP - narg + nret == SP.\r\n\r\nClose.\r\nI think both cases are handled by condition 3, that after the execution of an instruction SP <= FP.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345554732/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345556753",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-345556753",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 345556753,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTU1Njc1Mw==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-19T22:47:48Z",
    "updated_at": "2017-11-19T22:47:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "As for setting up the stack frame, the semantics is given as:\r\n\r\nExecution of a subroutine begins with `JUMPSUB` or `JUMPSUBV`, which\r\n* push `PC` on the return stack,\r\n* push `FP` on the frame stack,thus suspending execution of the current subroutine, and\r\n* set `FP` to `SP + n_args`, and\r\n* set `PC` to the specified `BEGINSUB` address,\r\nthus beginning execution of the new subroutine.\r\n\r\nI'm not sure it matters where or in what order anything in between encountering the JUMPSUB and executing the BEGINSUB is described as happening, so long as the program winds up executing the instruction after the BEGINSUB with the correct stack.  So get the semantics right and we can get the English right.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345556753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347033796",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-347033796",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 347033796,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NzAzMzc5Ng==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-26T19:56:30Z",
    "updated_at": "2017-11-26T19:56:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@seed  I've edited to make clear that SP is mu-sub-s in the yellow paper, and removed the reference in the text to SP being the stack size.  The rest of the pointer arithmetic in the text is (I think) now consistent with the stack growing towards lower addresses, so that positive offsets off the stack pointer and negative offsets off the frame pointer both reach into the stack frame.  The validation pseudocode I have not fixed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347033796/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348829300",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-348829300",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 348829300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODgyOTMwMA==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T23:29:34Z",
    "updated_at": "2017-12-04T00:18:57Z",
    "author_association": "NONE",
    "body": "Thanks for updating the proposal. It does make a lot more sense. \r\n\r\nNote that μs growing towards lower addresses doesn't make much sense to me in the context of the yellow paper because the EVM doesn't expose stack addresses in any way. \r\n\r\nLet me try to confirm my understanding of the proposal with an example:\r\n[other subroutines stack frames] [arg1] [arg2] < FP is here > [local1] [local2] <SP/top is here>. \r\n\r\nwhere μs[0] = local2, μs[1] = local1, μs[2] = arg2, ...\r\nand GETLOCAL 0 = arg2, GETLOCAL 1 = arg1\r\nand GETLOCAL -1 = local1, GETLOCAL -2 = local2\r\n\r\nFew questions:\r\nIs the above correct?\r\nIs the validation code expected to reject GETLOCAL 3 and GETLOCAL -3?\r\nAre EVM interpreters meant to throw an invalid stack access exception when they encounter these?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348829300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348869836",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-348869836",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 348869836,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODg2OTgzNg==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T06:16:46Z",
    "updated_at": "2017-12-04T18:17:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "@seed The EVM doesn't expose stack addresses, but in 9.5 the Yellow Paper says,  \"Stack items are added or removed from the left-most, lower-indexed portion of the series.\"  And throughout Appendix H we have notation like  `µ's[0] ≡ µs[0] + µs[1]`.  So in this proposal after, e.g.\r\n```\r\nPUSH 10\r\nPUSH 11\r\nJUMPSUB _x_\r\nPUSH 12\r\nPUSH 13\r\n```\r\nthe stack looks like\r\n```\r\n10 <- FP\r\n11\r\n12\r\n13\r\n   <- SP\r\n```\r\nand `GETLOCAL 0` is 10 and `GETLOCAL 3` is 13.  So `GETLOCAL` can address the subroutine arguments, and might better be named `GETVAR`.  Negative arguments are not possible (args are unsigned ints) and `GETLOCAL n` where `n > 3` would be rejected by the validator.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348869836/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349180379",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349180379",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349180379,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTE4MDM3OQ==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T03:02:57Z",
    "updated_at": "2017-12-05T03:02:57Z",
    "author_association": "NONE",
    "body": "@gcolvin for some reason I had assumed FP = SP at entry of subroutine. Never mind, with the example it  all makes sense now, thanks. I would actually suggest adding the example to the proposal.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349180379/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349183164",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349183164",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349183164,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTE4MzE2NA==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T03:21:55Z",
    "updated_at": "2017-12-05T05:09:47Z",
    "author_association": "NONE",
    "body": "The proposal uses the minus sign (-) instead of the em-dash (—) symbols in a few places which can lead to confusion.\r\nExamples:\r\n> Local variable n is the n'th stack item below the frame pointer - FP[-n] as defined below.\r\n\r\nI believe the first - should be a —. Also the syntax introduced, FP[-n], doesn't seem to be used elsewhere.\r\n\r\n>The first instruction of an array of EVM bytecode begins execution of a main routine with no arguments, SP and FP set to 0, and with one value on the return stack - code size - 1. (Executing the virtual byte of 0 after this offset causes an EVM to stop. Thus executing a RETURNSUB with no prior JUMPSUB or JUMBSUBV - that is, in the main routine - executes a STOP.)\r\n\r\nHere again em-dashes should be used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349183164/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349205900",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349205900",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349205900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTIwNTkwMA==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T06:09:24Z",
    "updated_at": "2017-12-05T06:09:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "You are right on the punctuation.  I was too lazy to crawl through layers of menus to find the em-dash.  I took the array syntax from the yellow paper (e.g. µs[0]).  It would be nice if markdown wasn't too primitive (that is, more primitive than what we used 40 years ago) to support subscripts, but might we still do better to switch from SP and FP to µs and µf?\r\n\r\nYou are also right about the example diagram.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349205900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349465223",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349465223",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349465223,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTQ2NTIyMw==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T22:38:13Z",
    "updated_at": "2017-12-05T22:38:13Z",
    "author_association": "NONE",
    "body": "We finished the Lem implementation of JUMPIF, JUMPTO, JUMPSUB, RETURNSUB, BEGINSUB, GETLOCAL, PUTLOCAL.\r\nSee https://github.com/seed/eth-isabelle/blob/evm15/lem/evm.lem\r\n\r\nFew questions/comments resulting from this:\r\n- Should the address popped from the return stack by RETURNSUB point to a JUMPDEST? Or is JUMPSUB implicitly implying that the next instruction is the target of a RETURNSUB.\r\n- It seems more natural for JUMPSUB to push the return address of the next instruction, instead of jumping back to the JUMPSUB and advancing the PC in RETURNSUB.\r\n- The size of a JUMPSUB instruction is 3 bytes, so initialising the return stack to \"code_size - 1\" is misleading, though harmless. To reach the the first virtual STOP after the bytecode when executing a RETURNSUB we need to initialise the return stack with \"code_size - 3\".\r\n\r\nTo properly test both the Lem code and the cpp-Ethereum client at this point we need the Solidity compiler to output subroutine instructions.\r\nDo you know the status of subroutine support in the Solidity compiler?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349465223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349467702",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349467702",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349467702,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTQ2NzcwMg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T22:48:58Z",
    "updated_at": "2017-12-05T22:53:29Z",
    "author_association": "MEMBER",
    "body": "It can compile \"Solidity inline assembly\" programs to EVM 1.5:\r\n\r\n```\r\n{\r\n  function f(a) -> b\r\n  {\r\n    b := add(a, 5)\r\n  }\r\n\r\n  let x := f(2)\r\n}\r\n```\r\n\r\nusing `solc --assemble --machine=evm15 test.asm`\r\n\r\nresults in the following bytecode:\r\n\r\n```\r\nb000000011b560006005820190509050b75b6002b30000000550\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349467702/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349478946",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349478946",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349478946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTQ3ODk0Ng==",
    "user": {
      "login": "seed",
      "id": 80487,
      "node_id": "MDQ6VXNlcjgwNDg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/80487?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/seed",
      "html_url": "https://github.com/seed",
      "followers_url": "https://api.github.com/users/seed/followers",
      "following_url": "https://api.github.com/users/seed/following{/other_user}",
      "gists_url": "https://api.github.com/users/seed/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/seed/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/seed/subscriptions",
      "organizations_url": "https://api.github.com/users/seed/orgs",
      "repos_url": "https://api.github.com/users/seed/repos",
      "events_url": "https://api.github.com/users/seed/events{/privacy}",
      "received_events_url": "https://api.github.com/users/seed/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T23:42:18Z",
    "updated_at": "2017-12-05T23:42:18Z",
    "author_association": "NONE",
    "body": "@axic thanks, I'll look into it.\r\nHas anyone written tests to stimulate that part of the compiler, which we could potentially use to compare the behaviour of new instructions?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349478946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349487763",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349487763",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349487763,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTQ4Nzc2Mw==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-06T00:25:56Z",
    "updated_at": "2017-12-06T00:25:56Z",
    "author_association": "MEMBER",
    "body": "@seed it is not tested since the testing client (cpp-ethereum) build we have didn't support it. It could be added if some submits a PR.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349487763/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349495625",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-349495625",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 349495625,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTQ5NTYyNQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-06T01:08:29Z",
    "updated_at": "2017-12-07T17:35:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "@seed  Are you talking about initializing the return stack in the cpp-ethereum code or in the validation pseudocode?\r\n\r\nNo JUMPDEST is involved.  Just a JUMPSUB to a BEGINSUB, and a RETURNSUB back to the JUMPSUB.  The x86 CALL instruction pushes the PC on the stack and RET pops it and jumps to it.  Then the PC gets incremented in the usual way.  That was the model I had in mind, it's how the C++ code is written for JUMP, and I think it comports with (136) in the Yellow Paper. (The C++ code is not written to match this model for RETURNSUB, although the behavior is the same.)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349495625/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/350306762",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-350306762",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 350306762,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDMwNjc2Mg==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-08T16:27:52Z",
    "updated_at": "2017-12-08T16:27:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "So far as a formal spec (or implementation) goes I think you can specify it however you like, so long as the PC winds up in the right place.  It could be changed here too if it helps, but I find it more clear the way it is.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/350306762/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360673554",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-360673554",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 360673554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY3MzU1NA==",
    "user": {
      "login": "nootropicat",
      "id": 34722633,
      "node_id": "MDQ6VXNlcjM0NzIyNjMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34722633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nootropicat",
      "html_url": "https://github.com/nootropicat",
      "followers_url": "https://api.github.com/users/nootropicat/followers",
      "following_url": "https://api.github.com/users/nootropicat/following{/other_user}",
      "gists_url": "https://api.github.com/users/nootropicat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nootropicat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nootropicat/subscriptions",
      "organizations_url": "https://api.github.com/users/nootropicat/orgs",
      "repos_url": "https://api.github.com/users/nootropicat/repos",
      "events_url": "https://api.github.com/users/nootropicat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nootropicat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T03:19:59Z",
    "updated_at": "2018-01-26T03:31:20Z",
    "author_association": "NONE",
    "body": "For formal analysis purposes, all of this is implementable right now as an intermediate language that's easily compilable to evm. PUTLOCAL and GETLOCAL are indeed very useful but there's no need for separate opcodes - stack could be mapped to negative memory and accessed with MLOAD/MSTORE (ie. the stack starts at (-32) and every push goes downwards). Space of one-byte opcodes is limited. \r\n\r\nWhy not add it as a precompiled contract? Ie. the very first instruction (in EVM) calls it with code as an argument. The gas cost of that particular call could be set to zero, in effect working only as a costless (except storage) marking for a different vm version. This would totally avoid problems due to deprecating opcodes and backwards compatibility, allowing for a much more fundamental changes.\r\n\r\nIn principle I very much dislike the idea of breaking backwards compatibility. What if someone has a compiled contract on some private blockchain? It would be impossible to deploy on the public one without recompilation. What if there's some private or just unknown language that compiles to evm? Its compiler would have to be rewritten. Even if one doesn't exist at the moment (most likely), potential ones that _may_ exist may not be written at all, because the risk of compatibility-breaking changes would be judged as too high. For all these reasons modern processors still support old 16 bit code - even including undocumented accidental instructions (ie. ffreep)! ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360673554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360675882",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-360675882",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 360675882,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY3NTg4Mg==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T03:38:42Z",
    "updated_at": "2018-01-26T03:38:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "The difference with PUTLOCAL and GETLOCAL is that they have to respect frame boundaries.  This proposal was meant to break compatibility less than eWasm, which breaks it completely.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360675882/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360676861",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-360676861",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 360676861,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY3Njg2MQ==",
    "user": {
      "login": "nootropicat",
      "id": 34722633,
      "node_id": "MDQ6VXNlcjM0NzIyNjMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34722633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nootropicat",
      "html_url": "https://github.com/nootropicat",
      "followers_url": "https://api.github.com/users/nootropicat/followers",
      "following_url": "https://api.github.com/users/nootropicat/following{/other_user}",
      "gists_url": "https://api.github.com/users/nootropicat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nootropicat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nootropicat/subscriptions",
      "organizations_url": "https://api.github.com/users/nootropicat/orgs",
      "repos_url": "https://api.github.com/users/nootropicat/repos",
      "events_url": "https://api.github.com/users/nootropicat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nootropicat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T03:47:13Z",
    "updated_at": "2018-01-26T03:47:26Z",
    "author_association": "NONE",
    "body": "Respect how? You replied previously that they don't throw \"It pushes FP[-n] on the stack.\". So they act as memory access just with fp as the offset. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360676861/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360680871",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-360680871",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 360680871,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY4MDg3MQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-26T04:23:09Z",
    "updated_at": "2018-01-26T04:23:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "Validity condition 3.  Programs that try to get or put a stack slot outside of the local frame are invalid.  Memory access isn't constrained that way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360680871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467230869",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-467230869",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 467230869,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzIzMDg2OQ==",
    "user": {
      "login": "fulldecent",
      "id": 382183,
      "node_id": "MDQ6VXNlcjM4MjE4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/382183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fulldecent",
      "html_url": "https://github.com/fulldecent",
      "followers_url": "https://api.github.com/users/fulldecent/followers",
      "following_url": "https://api.github.com/users/fulldecent/following{/other_user}",
      "gists_url": "https://api.github.com/users/fulldecent/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fulldecent/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fulldecent/subscriptions",
      "organizations_url": "https://api.github.com/users/fulldecent/orgs",
      "repos_url": "https://api.github.com/users/fulldecent/repos",
      "events_url": "https://api.github.com/users/fulldecent/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fulldecent/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-25T23:44:47Z",
    "updated_at": "2019-02-25T23:44:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "Here a very brief review.\r\n\r\n# Who said static analysis is valuable?\r\n\r\nThis proposal recommends a super-large change, deprecating op-codes and introducing an entire subroutine mechanism into the machine for the benefit \"tightening the security\".\r\n\r\nThe justification is static analysis of (prospective) contracts will be easier and that formal methods are \"essential [tools] against loss\".\r\n\r\nThe proposal will be much stronger if examples (a single example?) are included where static analysis has previously been successful in detecting any problem. I don't know of any. My understanding is just the opposite -- every bug with $1M+ loss on Ethereum has been due to ****-poor coding and failure to pay bug bounties higher than the cost of a nice dinner.\r\n\r\n# This is already possible WITHOUT implementing the EIP\r\n\r\nCertain statements are made such as:\r\n\r\n> Further, since every jump can potentially be to any jump destination in the code, the number of possible paths through the code goes up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis.\r\n\r\nHere is a 5-minute analysis of an actual contract.\r\n\r\n* Get deployed CryptoKitties byte code from https://www.etherchain.org/account/06012c8cf97BEaD5deAe237070F9587f8E7A266d#code\r\n* Disassemble https://etherscan.io/opcode-tool\r\n* Preprocess `s/\\[\\d+\\]//g`\r\n* Search `JUMPI?$`, 508 results\r\n* Search `^PUSH\\d+.*\\nJUMPI?$`, 428 results\r\n\r\nBAM! The practical cost of static analysis is already reduced by an order of magnitude from the theoretical statement above. (Because they are already using literal jumps.)\r\n\r\nStronger support and more analysis of existing contracts should be presented in this EIP before recommending such a large change.\r\n\r\n# PS\r\n\r\n* The edited-date above is invalid.\r\n* The specification \"These forms ... name instructions with one, two, and two or more arguments, respectively\" is not parseable English. The number of examples does not line up with the number of \"respectively\" definitions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467230869/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467261765",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-467261765",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 467261765,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzI2MTc2NQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T01:59:54Z",
    "updated_at": "2019-02-26T01:59:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't know if this is a _super_-large proposal or not.  A fair comparison might be to eWasm, which provides essentially the same functionality.\r\n\r\nThere is no current eWasm EIP and implementation for direct comparison, but the Wasm spec itself is 150 pages, and only floating point and a few other non-deterministic operations aren't relevant.  eWasm also requires an Environment Interface between the VM and the client, and a Transcompiler of EVM to eWasm bytecode for backwards compatibility.  The [ewasm/design repo](https://github.com/ewasm/design), which is currently mostly empty, gives a feel for the scope of the effort remaining.\r\n\r\nThis spec is about 15 pages, and it took about 300 lines of C++ to add it to the [aleth](https://github.com/gcolvin/aleth/tree/master/libaleth-interpreter) interpreter.  It is backwards-compatible by default.\r\n\r\n@bmann @expede Boris, Brooke and I have spoken with VM and program specification and proof experts, program auditors, providers of tools like disassemblers, decompilers, lints, and others.  They use static analysis, find dynamic jumps a serious obstacle, and support this proposal.  Perhaps an appendix of links to their companies and repos would help.\r\n\r\nThis spec also supports fast, near-linear-time compilation to machine code, LLVM IR, or Wasm, with no quadratic \"compiler bombs.\"  The current EVM makes that difficult-to-impossible.\r\n\r\nThanks for noticing typos.  I've removed the \"edited-date' field, as Github now maintains a history of edits.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467261765/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467262707",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-467262707",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 467262707,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzI2MjcwNw==",
    "user": {
      "login": "expede",
      "id": 1052016,
      "node_id": "MDQ6VXNlcjEwNTIwMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1052016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/expede",
      "html_url": "https://github.com/expede",
      "followers_url": "https://api.github.com/users/expede/followers",
      "following_url": "https://api.github.com/users/expede/following{/other_user}",
      "gists_url": "https://api.github.com/users/expede/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/expede/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/expede/subscriptions",
      "organizations_url": "https://api.github.com/users/expede/orgs",
      "repos_url": "https://api.github.com/users/expede/repos",
      "events_url": "https://api.github.com/users/expede/events{/privacy}",
      "received_events_url": "https://api.github.com/users/expede/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T02:04:10Z",
    "updated_at": "2019-02-26T02:22:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Who said static analysis is valuable?\r\n\r\nI mean... lots of people. Entire [companies](https://quantstamp.com/) [and](https://www.trailofbits.com/) [divisions](https://consensys.net/diligence/) have sprung up around smart contract analysis (generally assisted by a checker). For example, here's a bunch of automated smart contract [security](https://consensys.github.io/smart-contract-best-practices/security_tools/) and [analysis](https://github.com/leonardoalt/ethereum_formal_verification_overview). And you're right: it's hard to do right now, largely because of the difficult to trace control flow.\r\n\r\nThis proposal makes this much more tractable in a way that is in-line with modern VMs such as Wasm and the JVM. We've spoken with a _bunch_ of folks from [SecurETH](https://secureth.org/) who feel that adding structured control flow will substantially improve the depth and reliability of their analyses.\r\n\r\n> every bug with $1M+ loss on Ethereum has been due to ****-poor coding and failure to pay bug bounties higher than the cost of a nice dinner.\r\n\r\nYes, and you still need these bounties for previously undiscovered cases. However, humans are notoriously bad at doing thorough analyses, and automated tools to check that properties hold is faster, cheaper, and works every time. Why not eliminate entire classes of bug before deployment, regardless of coding skill or size of cheque book?\r\n\r\n> BAM! The practical cost of static analysis is already reduced by an order of magnitude from the theoretical statement above.\r\n\r\n** deep sigh ** Oh sweet summer child. Were it only that simple.\r\n\r\nEDIT expanded first section for clarity",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467262707/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467577339",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-467577339",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 467577339,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzU3NzMzOQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T19:26:07Z",
    "updated_at": "2019-02-26T19:26:07Z",
    "author_association": "NONE",
    "body": "I can get behind @expede 's comment and say that this EIP would be beneficial to researchers working on formal verification at ConsenSys and at Diligence, specifically.\r\nI have talked offline with many of the people involved in getting this work to fruition and, in the case it is helpful, I am now backing its usefulness publicly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467577339/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467588062",
    "html_url": "https://github.com/ethereum/EIPs/issues/615#issuecomment-467588062",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/615",
    "id": 467588062,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzU4ODA2Mg==",
    "user": {
      "login": "MrChico",
      "id": 8930559,
      "node_id": "MDQ6VXNlcjg5MzA1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8930559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MrChico",
      "html_url": "https://github.com/MrChico",
      "followers_url": "https://api.github.com/users/MrChico/followers",
      "following_url": "https://api.github.com/users/MrChico/following{/other_user}",
      "gists_url": "https://api.github.com/users/MrChico/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MrChico/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MrChico/subscriptions",
      "organizations_url": "https://api.github.com/users/MrChico/orgs",
      "repos_url": "https://api.github.com/users/MrChico/repos",
      "events_url": "https://api.github.com/users/MrChico/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MrChico/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T19:53:33Z",
    "updated_at": "2019-02-26T19:53:33Z",
    "author_association": "MEMBER",
    "body": "Happy to see this EIP getting traction again! I can assist in getting this formalized in KEVM a.k.a. the Jello paper. \r\nThere's a lot of talk about performance in the EIP, but no numbers. Are there any rough ideas on how much can be gained?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/467588062/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
