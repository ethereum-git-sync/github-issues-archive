{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/721/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/721/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/721/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/721",
  "id": 259900225,
  "node_id": "MDU6SXNzdWUyNTk5MDAyMjU=",
  "number": 721,
  "title": "ERC: Non-fungible Token Standard",
  "user": {
    "login": "dete",
    "id": 1195159,
    "node_id": "MDQ6VXNlcjExOTUxNTk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dete",
    "html_url": "https://github.com/dete",
    "followers_url": "https://api.github.com/users/dete/followers",
    "following_url": "https://api.github.com/users/dete/following{/other_user}",
    "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
    "organizations_url": "https://api.github.com/users/dete/orgs",
    "repos_url": "https://api.github.com/users/dete/repos",
    "events_url": "https://api.github.com/users/dete/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dete/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 398,
  "created_at": "2017-09-22T18:31:36Z",
  "updated_at": "2022-12-03T08:46:41Z",
  "closed_at": "2021-04-13T20:30:01Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "This proposal has been accepted and merged as a draft standard, please see the [officially tracked version](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) for the current draft.\r\n\r\nPlease see PR #841 for the discussions leading up to this draft, and use this thread (#721) for further discussion. (Or, if you have a concrete proposal, consider opening a new PR with your proposed changes.)\r\n\r\n<details><summary>Original Draft (Sep 20, 2017)</summary>\r\n\r\n## Preamble\r\n\r\n    EIP: <to be assigned>\r\n    Title: Non-fungible Token Standard\r\n    Author: Dieter Shirley <dete@axiomzen.co>\r\n    Type: Standard\r\n    Category: ERC\r\n    Status: Draft\r\n    Created: 2017-09-20\r\n\r\n\r\n\r\n## Simple Summary\r\nA standard interface for non-fungible tokens.\r\n\r\n## Abstract\r\nThe following standard allows for the implementation of a standard API for non-fungible tokens (henceforth referred to as \"NFTs\") within smart contracts. This standard provides basic functionality to track and transfer ownership of NFTs.\r\n\r\n## Motivation\r\nA standard interface allows any NFTs on Ethereum to be handled by general-purpose applications. In particular, it will allow for NFTs to be tracked in standardized wallets and traded on exchanges.\r\n\r\n## Specification\r\n_I wanted to get the community's \"first impression\" before spending a bunch of time detailing out these end-points; expect this section to be significantly expanded after the first round of feedback. I've left out \"obvious\" return values for skimmability, and included a few notes where the functionality warrants special interest._\r\n - ERC-20 compatibility:\r\n    - `name()` _optional_\r\n    - `symbol()` _optional_\r\n    - `totalSupply()` - Number of NFTs tracked by this contract\r\n    - `balanceOf(address _owner)` - Number of NFTs owned by a particular address\r\n - Basic ownership:\r\n    - `tokensOfOwnerByIndex(address _owner, uint _index) constant returns (uint tokenId)` - There's really no good way to return a list of NFTs by owner, but it's valuable functionality. You should strenuously avoid calling this method \"on-chain\" (i.e. from a non-`constant` contract function).\r\n    - `ownerOf(uint _tokenId) constant returns (address owner)`\r\n    - `transfer(address _to, uint _tokenId)`\r\n    - `approve(address _to, uint _tokenId)` – SHOULD be cleared by any `transfer()` operation\r\n    - `transferFrom(address _from, address _to, unit _tokenId)` - the sender must have been previously authorized by `approve()`. (Note: Technically, the `_from` address here can be inferred by calling `ownerOf(_tokenId)`. I've left it in for symmetry with the corresponding ERC-20 method, and to forestall the (somewhat subtle) bug that could result from not clearing the `approve` authorization inside a successful `transfer` call.)\r\n - NFT metadata (optional):\r\n    - `tokenMetadata(uint _tokenId) returns (string infoUrl)` - recommended format is IPFS or HTTP [multiaddress](https://github.com/multiformats/multiaddr) with `name`, `image`, and `description` sub-paths. IPFS is the preferred mechanism (immutable and more durable).  Example: If `tokenMetadata()` returns `/ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG`, the object description would be accessible via `ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/description`.\r\n\r\n## Rationale\r\nThere are many proposed uses of Ethereum smart contracts that depend on tracking individual, non-fungible tokens (NFTs). Examples of existing or planned NFTs are LAND in [Decentraland](https://decentraland.org/), the eponymous punks in [CryptoPunks](https://www.larvalabs.com/cryptopunks), and in-game items using systems like [Dmarket](https://www.dmarket.io) or [EnjinCoin](https://enjincoin.io/). Future uses include tracking real-world non-fungible assets, like real-estate (as envisioned by companies like [Ubitquity](https://www.ubitquity.io) or [Propy](https://tokensale.propy.com/)).  It is critical in each of these cases that these items are not \"lumped together\" as numbers in a ledger, but instead each token must have its ownership individually and atomically tracked. Regardless of the nature of these items, the ecosystem will be stronger if we create a standardized interface that allows for cross-functional non-fungible token management and sales platforms.\r\n\r\nThe basis of this standard is that every NFT is identified by a unique, 256-bit unsigned integer within its tracking contract. The pair `(contract address, asset ID)` will then be globally unique within the Ethereum ecosystem.\r\n\r\nThis standard has followed the model of ERC-20 as much as possible to minimize the effort required for wallets (in particular) to track non-fungible tokens, while echoing a well-understood standard.\r\n\r\n## Backwards Compatibility\r\nThis standard follows the semantics of ERC-20 as closely as possible, but can't be entirely compatible with it due to the fundamental differences between fungible and non-fungible tokens.\r\n\r\nExample non-fungible implementations as of September, 2017:\r\n - [CryptoPunks](https://www.larvalabs.com/cryptopunks) - Partially ERC-20 compatible, but not easily generalizable because it includes auction functionality directly in the contract and uses function names that explicitly refer to the NFTs as \"punks\".\r\n - [Auctionhouse Asset Interface](https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol) - @dob needed a generic interface for his Auctionhouse dapp (currently ice-boxed). His \"Asset\" contract is very simple, but is missing ERC-20 compatiblity, approve() functionality, and metadata. This effort is referenced in the discussion for [EIP-173](https://github.com/ethereum/EIPs/issues/173).\r\n\r\n(It should be noted that \"limited edition, collectable tokens\" like [Curio Cards](https://mycuriocards.com/) and [Rare Pepe](https://rarepepewallet.com/) are _not_ non-fungible tokens. They're actually a collection of individual fungible tokens, each of which is tracked by its own smart contract with its own total supply (which may be `1` in extreme cases).)\r\n\r\n## Implementation\r\n_Reference implementation forthcoming..._\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n</details>\r\n\r\n<details><summary>Second Draft (Nov 9, 2017)</summary>\r\n\r\n## Preamble\r\n\r\n    EIP: <to be assigned>\r\n    Title: Non-fungible Token Standard\r\n    Author: Dieter Shirley <dete@axiomzen.co>\r\n    Type: Standard\r\n    Category: ERC\r\n    Status: Draft\r\n    Created: 2017-09-20\r\n\r\n\r\n\r\n## Simple Summary\r\nA standard interface for non-fungible tokens.\r\n\r\n## Abstract\r\nThis standard allows for the implementation of a standard API for non-fungible tokens (henceforth referred to as \"NFTs\") within smart contracts. This standard provides basic functionality to track and transfer ownership of NFTs.\r\n\r\n## Motivation\r\nA standard interface allows any NFTs on Ethereum to be handled by general-purpose applications. In particular, it will allow for NFTs to be tracked in standardized wallets and traded on exchanges.\r\n\r\n## Specification\r\n\r\n### ERC-20 Compatibility\r\n\r\n#### name\r\n\r\n``` js\r\nfunction name() constant returns (string name)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns the name of the collection of NFTs managed by this contract. - e.g. `\"My Non-Fungibles\"`.\r\n\r\n#### symbol\r\n\r\n``` js\r\nfunction symbol() constant returns (string symbol)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns a short string symbol referencing the entire collection of NFTs managed in this contract. e.g. \"MNFT\". This symbol SHOULD be short (3-8 characters is recommended), with no whitespace characters or new-lines and SHOULD be limited to the uppercase latin alphabet (i.e. the 26 letters used in English).\r\n\r\n#### totalSupply\r\n\r\n``` js\r\nfunction totalSupply() constant returns (uint256 totalSupply)\r\n```\r\n\r\nReturns the total number of NFTs currently tracked by this contract.\r\n\r\n#### balanceOf\r\n\r\n``` js\r\nfunction balanceOf(address _owner) constant returns (uint256 balance)\r\n```\r\n\r\nReturns the number of NFTs assigned to address `_owner`.\r\n\r\n### Basic Ownership\r\n\r\n#### ownerOf\r\n\r\n``` js\r\nfunction ownerOf(uint256 _tokenId) constant returns (address owner)\r\n```\r\n\r\nReturns the address currently marked as the owner of `_tokenID`. This method MUST `throw` if `_tokenID` does not represent an NFT currently tracked by this contract. This method MUST NOT return 0 (NFTs assigned to the zero address are considered destroyed, and queries about them should `throw`). \r\n\r\n#### approve\r\n\r\n``` js\r\nfunction approve(address _to, uint256 _tokenId)\r\n```\r\n\r\nGrants approval for address `_to` to take possession of the NFT with ID `_tokenId`. This method MUST `throw` if `msg.sender != ownerOf(_tokenId)`, or if `_tokenID` does not represent an NFT currently tracked by this contract, or if `msg.sender == _to`.\r\n\r\nOnly one address can \"have approval\" at any given time; calling `approveTransfer` with a new address revokes approval for the previous address. Calling this method with 0 as the `_to` argument clears approval for any address.\r\n\r\nSuccessful completion of this method MUST emit an `Approval` event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the `_to` address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if `_to` is already the currently approved address and this call otherwise has no effect. (i.e. An `approve()` call that \"reaffirms\" an existing approval MUST fire an event.)\r\n\r\nAction | Prior State | _to address | New State | Event\r\n-- | -- | -- | -- | --\r\nClear unset approval | Clear | 0 | Clear | None\r\nSet new approval | Clear | X | Set to X | Approval(owner, X, tokenID)\r\nChange approval | Set to X | Y | Set to Y | Approval(owner, Y, tokenID)\r\nReaffirm approval | Set to X | X | Set to X | Approval(owner, X, tokenID)\r\nClear approval | Set to X | 0 | Clear | Approval(owner, 0, tokenID)\r\n\r\n\r\nNote: ANY change of ownership of an NFT – whether directly through the `transfer` and `transferFrom` methods defined in this interface, or through any other mechanism defined in the conforming contract – MUST clear any and all approvals for the transferred NFT. The implicit clearing of approval via ownership transfer MUST also fire the event `Approval(0, _tokenId)` if there was an outstanding approval. (i.e. All actions that transfer ownership must emit the same Approval event, if any, as would emitted by calling `approve(0, _tokenID)`.)\r\n\r\n#### takeOwnership\r\n\r\n``` js\r\nfunction takeOwnership(uint256 _tokenId)\r\n```\r\n\r\nAssigns the ownership of the NFT with ID `_tokenId` to `msg.sender` if and only if `msg.sender` currently has approval (via a previous call to `approveTransfer`). A successful transfer MUST fire the `Transfer` event (defined below).\r\n\r\nThis method MUST transfer ownership to `msg.sender` or `throw`, no other outcomes can be possible. Reasons for failure include (but are not limited to):\r\n - `msg.sender` does not have approval for `_tokenId`\r\n - `_tokenID` does not represent an NFT currently tracked by this contract\r\n - `msg.sender` already has ownership of `_tokenId`\r\n\r\nImportant: Please refer to the Note in the `approveTransfer` method description; a successful transfer MUST clear pending approval.\r\n\r\n#### transfer\r\n\r\n``` js\r\nfunction transfer(address _to, uint256 _tokenId)\r\n```\r\n\r\nAssigns the ownership of the NFT with ID `_tokenId` to `_to` if and only if `msg.sender == ownerOf(_tokenId)`. A successful transfer MUST fire the `Transfer` event (defined below).\r\n\r\nThis method MUST transfer ownership to `_to` or `throw`, no other outcomes can be possible. Reasons for failure include (but are not limited to):\r\n - `msg.sender` is not the owner of `_tokenId`\r\n - `_tokenID` does not represent an NFT currently tracked by this contract\r\n - `_to` is 0 (Conforming contracts MAY have other methods to destroy or burn NFTs, which are conceptually \"transfers to 0\" and will emit `Transfer` events reflecting this. However, `transfer(0, tokenID)` MUST be treated as an error.)\r\n\r\nA conforming contract MUST allow the current owner to \"transfer\" a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for `_to == ownerOf(_tokenID)`.) This \"no-op transfer\" MUST be considered a successful transfer, and therefore MUST fire a `Transfer` event (with the same address for `_from` and `_to`).\r\n\r\nImportant: Please refer to the Note in the `approveTransfer` method description; a successful transfer MUST clear pending approval. _This includes no-op transfers to the current owner!_\r\n\r\n#### tokenOfOwnerByIndex\r\n\r\n``` js\r\nfunction tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId)\r\n````\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns the _nth_ NFT assigned to the address `_owner`, with _n_ specified by the `_index` argument. This method MUST `throw` if `_index >= balanceOf(_owner)`.\r\n\r\nRecommended usage is as follows:\r\n\r\n``` js\r\nuint256 ownerBalance = nonFungibleContract.balanceOf(owner);\r\n\r\nuint256[] memory ownerTokens = new uint256[](ownerBalance);\r\n\r\nfor (uint256 i = 0; i < ownerBalance; i++) {\r\n    ownerTokens[i] = nonFungibleContract.tokenOfOwnerByIndex(owner, i);\r\n}\r\n```\r\n\r\nImplementations MUST NOT assume that NFTs are accessed in any particular order by their callers (In particular, don't assume this method is called in a monotonically ascending loop.), and MUST ensure that calls to `tokenOfOwnerByIndex` are fully [idempotent](https://en.wikipedia.org/wiki/Idempotence) unless and until some non-`constant` function is called on this contract.\r\n\r\nCallers of `tokenOfOwnerByIndex` MUST never assume that the order of NFTs is maintained outside of a single operation, or through the invocation (direct or indirect) of any non-`constant` contract method.\r\n\r\nNOTE: Current limitations in Solidity mean that there is no efficient way to return a complete list of an address's NFTs with a single function call. Callers should not assume this method is implemented efficiently (from a gas standpoint) and should _strenuously avoid_ calling this method \"on-chain\" (i.e. from any non-`constant` contract function, or from any `constant` contract function that is likely to be called on-chain).\r\n\r\n### NFT Metadata\r\n\r\n#### tokenMetadata\r\n\r\n``` js\r\nfunction tokenMetadata(uint256 _tokenId) constant returns (string infoUrl)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns a [multiaddress](https://github.com/multiformats/multiaddr) string referencing an external resource bundle that contains (optionally localized) metadata about the NFT associated with `_tokenId`. The string MUST be an IPFS or HTTP(S) base path (without a trailing slash) to which specific subpaths are obtained through concatenation. (IPFS is the preferred format due to better scalability, persistence, and immutability.)\r\n\r\nStandard sub-paths:\r\n - name (required) - The `name` sub-path MUST contain the UTF-8 encoded name of the specific NFT (i.e. distinct from the name of the collection, as returned by the contract's `name` method). A name SHOULD be 50 characters or less, and unique amongst all NFTs tracked by this contract. A name MAY contain white space characters, but MUST NOT include new-line or carriage-return characters. A name MAY include a numeric component to differentiate from similar NFTs in the same contract. For example: \"Happy Token #157\".\r\n - image (optional) - If the `image` sub-path exists, it MUST contain a PNG, JPEG, or SVG image with at least 300 pixels of detail in each dimension. The image aspect ratio SHOULD be between 16:9 (landscape mode) and 2:3 (portrait mode). The image SHOULD be structured with a \"safe zone\" such that cropping the image to a maximal, central square doesn't remove any critical information. (The easiest way to meet this requirement is simply to use a 1:1 image aspect ratio.)\r\n - description (optional) - If the `description` sub-path exists, it MUST contain a UTF-8 encoded textual description of the asset. This description MAY contain multiple lines and SHOULD use a single new-line character to delimit explicit line-breaks, and two new-line characters to delimit paragraphs. The description MAY include [CommonMark](http://commonmark.org)-compatible Markdown annotations for styling. The description SHOULD be 1500 characters or less.\r\n - other metadata (optional) - A contract MAY choose to include any number of additional subpaths, where they are deemed useful. There may be future formal and informal standards for additional metadata fields independent of this standard.\r\n \r\nEach metadata subpath (including subpaths not defined in this standard) MUST contain a sub-path `default` leading to a file containing the default (i.e. unlocalized) version of the data for that metadata element. For example, an NFT with the metadata path `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe` MUST contain the NFT's name as a UTF-8 encoded string available at the full path `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/default`. Additionally, each metadata subpath MAY have one or more localizations at a subpath of an [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code (the same language codes used for HTML). For example, `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/en` would have the name in English, and `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/fr` would have the name in French (note that even localized values need to have a `default` entry). Consumers of NFT metadata SHOULD look for a localized value before falling back to the `default` value. Consumers MUST NOT assume that all metadata subpaths for a particular NFT are localized similarly. For example, it will be common for the `name` and `image` objects to not be localized even when the `description` is.\r\n\r\nYou can explore the metadata package referenced in this example [here](https://ipfs.io/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe).\r\n\r\n### Events\r\n\r\n#### Transfer\r\n\r\nThis event MUST trigger when NFT ownership is transferred via any mechanism.\r\n\r\nAdditionally, the creation of new NFTs MUST trigger a Transfer event for each newly created NFTs, with a `_from` address of 0 and a `_to` address matching the owner of the new NFT (possibly the smart contract itself). The deletion (or burn) of any NFT MUST trigger a Transfer event with a `_to` address of 0 and a `_from` address of the owner of the NFT (now former owner!).\r\n\r\nNOTE: A Transfer event with `_from == _to` is valid. See the `transfer()` documentation for details.\r\n\r\n``` js\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _tokenId)\r\n```\r\n\r\n#### Approval\r\n\r\nThis event MUST trigger on any successful call to `approve(address _spender, uint256 _value)` (unless the caller is attempting to clear approval when there is no pending approval).\r\n\r\nSee the documentation for the `approve()` method above for further detail.\r\n\r\n\r\n``` js\r\nevent Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)\r\n```\r\n\r\n\r\n## Rationale\r\n\r\n### Utility\r\n\r\nThere are many proposed uses of Ethereum smart contracts that depend on tracking individual, non-fungible tokens (NFTs). Examples of existing or planned NFTs are LAND in [Decentraland](https://decentraland.org/), the eponymous punks in [CryptoPunks](https://www.larvalabs.com/cryptopunks), and in-game items using systems like [Dmarket](https://www.dmarket.io) or [EnjinCoin](https://enjincoin.io/). Future uses include tracking real-world non-fungible assets, like real-estate (as envisioned by companies like [Ubitquity](https://www.ubitquity.io) or [Propy](https://tokensale.propy.com/)).  It is critical in each of these cases that these items are not \"lumped together\" as numbers in a ledger, but instead, each token must have its ownership individually and atomically tracked. Regardless of the nature of these items, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional non-fungible token management and sales platforms.\r\n\r\n### NTF IDs\r\n\r\nThe basis of this standard is that every NFT is identified by a unique, 256-bit unsigned integer within its tracking contract. This ID number MUST NOT change for the life of the contract. The pair `(contract address, asset ID)` will then be a globally unique and fully-qualified identifier for a specific NFT within the Ethereum ecosystem. While some contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers MUST NOT assume that ID numbers have any specific pattern to them, and should treat the ID as a \"black box\".\r\n\r\n## Backwards Compatibility\r\nThis standard follows the semantics of ERC-20 as closely as possible, but can't be entirely compatible with it due to the fundamental differences between fungible and non-fungible tokens.\r\n\r\nExample non-fungible implementations as of September 2017:\r\n - [CryptoPunks](https://www.larvalabs.com/cryptopunks) - Partially ERC-20 compatible, but not easily generalizable because it includes auction functionality directly in the contract and uses function names that explicitly refer to the NFTs as \"punks\".\r\n - [Auctionhouse Asset Interface](https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol) - @dob needed a generic interface for his Auctionhouse dapp (currently ice-boxed). His \"Asset\" contract is very simple, but is missing ERC-20 compatibility, approve() functionality, and metadata. This effort is referenced in the discussion for [EIP-173](https://github.com/ethereum/EIPs/issues/173).\r\n\r\n(It should be noted that \"limited edition, collectable tokens\" like [Curio Cards](https://mycuriocards.com/) and [Rare Pepe](https://rarepepewallet.com/) are _not_ non-fungible tokens. They're actually a collection of individual fungible tokens, each of which is tracked by its own smart contract with its own total supply (which may be `1` in extreme cases).)\r\n\r\n## Implementation\r\n_Reference implementation forthcoming..._\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n\r\n</details>",
  "closed_by": {
    "login": "Arachnid",
    "id": 17865,
    "node_id": "MDQ6VXNlcjE3ODY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Arachnid",
    "html_url": "https://github.com/Arachnid",
    "followers_url": "https://api.github.com/users/Arachnid/followers",
    "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
    "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
    "organizations_url": "https://api.github.com/users/Arachnid/orgs",
    "repos_url": "https://api.github.com/users/Arachnid/repos",
    "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Arachnid/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/721/reactions",
    "total_count": 374,
    "+1": 239,
    "-1": 10,
    "laugh": 20,
    "hooray": 50,
    "confused": 2,
    "heart": 35,
    "rocket": 15,
    "eyes": 3
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/721/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331540562",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331540562",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331540562,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTU0MDU2Mg==",
    "user": {
      "login": "dob",
      "id": 10389,
      "node_id": "MDQ6VXNlcjEwMzg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10389?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dob",
      "html_url": "https://github.com/dob",
      "followers_url": "https://api.github.com/users/dob/followers",
      "following_url": "https://api.github.com/users/dob/following{/other_user}",
      "gists_url": "https://api.github.com/users/dob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dob/subscriptions",
      "organizations_url": "https://api.github.com/users/dob/orgs",
      "repos_url": "https://api.github.com/users/dob/repos",
      "events_url": "https://api.github.com/users/dob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dob/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T19:34:03Z",
    "updated_at": "2017-09-22T19:34:03Z",
    "author_association": "NONE",
    "body": "You could consider using an [ipfs multiaddr](https://github.com/multiformats/multiaddr) as the return value for the token metadata. This would allow for a self describing IPFS hash, http url, or swarm addr in the future. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331540562/reactions",
      "total_count": 41,
      "+1": 38,
      "-1": 1,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331545869",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331545869",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331545869,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTU0NTg2OQ==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T19:57:40Z",
    "updated_at": "2017-09-22T19:57:40Z",
    "author_association": "NONE",
    "body": "Great point, @dob. Thanks for the suggestion! I've updated the draft above.\r\n\r\n(For reference, my original posting had suggested using the format `ipfs:QmYwAP...` for IPFS links.)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331545869/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331612958",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331612958",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331612958,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTYxMjk1OA==",
    "user": {
      "login": "kylerchin",
      "id": 7539174,
      "node_id": "MDQ6VXNlcjc1MzkxNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7539174?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kylerchin",
      "html_url": "https://github.com/kylerchin",
      "followers_url": "https://api.github.com/users/kylerchin/followers",
      "following_url": "https://api.github.com/users/kylerchin/following{/other_user}",
      "gists_url": "https://api.github.com/users/kylerchin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kylerchin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kylerchin/subscriptions",
      "organizations_url": "https://api.github.com/users/kylerchin/orgs",
      "repos_url": "https://api.github.com/users/kylerchin/repos",
      "events_url": "https://api.github.com/users/kylerchin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kylerchin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T05:53:53Z",
    "updated_at": "2017-09-23T05:53:53Z",
    "author_association": "NONE",
    "body": "wow!  awesome integration! This is better than sending the raw data over the wire. :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331612958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331615727",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331615727",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331615727,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTYxNTcyNw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T06:58:38Z",
    "updated_at": "2017-09-23T06:58:38Z",
    "author_association": "MEMBER",
    "body": "Nice proposal! For the metadata to be useful, though, I think you need to mandate its format, rather than just recommend it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331615727/reactions",
      "total_count": 17,
      "+1": 17,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331664581",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331664581",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331664581,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTY2NDU4MQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T19:25:57Z",
    "updated_at": "2017-09-23T19:25:57Z",
    "author_association": "NONE",
    "body": "A much needed EIP! 👏 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331664581/reactions",
      "total_count": 8,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 8,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331670969",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331670969",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331670969,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTY3MDk2OQ==",
    "user": {
      "login": "ethernian",
      "id": 4574735,
      "node_id": "MDQ6VXNlcjQ1NzQ3MzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4574735?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ethernian",
      "html_url": "https://github.com/ethernian",
      "followers_url": "https://api.github.com/users/ethernian/followers",
      "following_url": "https://api.github.com/users/ethernian/following{/other_user}",
      "gists_url": "https://api.github.com/users/ethernian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ethernian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ethernian/subscriptions",
      "organizations_url": "https://api.github.com/users/ethernian/orgs",
      "repos_url": "https://api.github.com/users/ethernian/repos",
      "events_url": "https://api.github.com/users/ethernian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ethernian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T21:26:33Z",
    "updated_at": "2017-09-23T21:26:33Z",
    "author_association": "NONE",
    "body": "I would propose to use term \"asset\" instead of \"nun-fungible token\" to separate both terms. \r\nIt is an usual mistake to take some (fungible) token as representation of some (non-fungible) physical asset. So we can make it clear from very beginning.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331670969/reactions",
      "total_count": 16,
      "+1": 15,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331677297",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331677297",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331677297,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTY3NzI5Nw==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T23:59:41Z",
    "updated_at": "2017-09-23T23:59:41Z",
    "author_association": "NONE",
    "body": "@Arachnid: The whole metadata method is optional, but if someone is going to implement it, they should probably implement it in a way that everyone else is expecting. I anticipate using \"SHOULD\" language for the full specification.\r\n\r\n@dip239:  Ah naming things. Every programmer's favourite bikeshedding vortex. 😁  I bounced between three separate ideas for naming: \"token\" as seen above, \"asset\", following @dob's lead (and your suggestion!), and \"NFT\" which I used in the prose, but which is incredibly awkward in the API calls: `nftMetadata(uint _nftId)`.\r\n\r\n\"Asset\" does seem like a decent choice, and my first personal draft used it. I discarded it for a two key reasons:\r\n - The definition of \"asset\" in a financial context says nothing about fungibility. Cash is an asset (fungible), so are shares (fungible), so is real-estate (non-fungible). ¯\\\\\\_(ツ)_/¯ \r\n - On the other hand, the definition of \"asset\" in a financial context _directly implies_ financial value, something that must be declared on one's balance sheet. I believe one of the motivations between using the term \"token\" for ERC-20 instead of \"coin\" was specifically to avoid the implication of financial value at a time (which I would argue we are still in) when the crypto community wanted to avoid giving ammunition to traditional regulators—who don't really understand all the implications of what we're doing here.\r\n\r\nI did spend some time trying out other alternatives (\"item\", \"object\", \"thing\", etc.), but none seemed right. I am happy to hear other suggestions because I am not entirely content with \"token\". It just seems like the best of some bad options.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331677297/reactions",
      "total_count": 17,
      "+1": 17,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331708046",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331708046",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331708046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTcwODA0Ng==",
    "user": {
      "login": "silasdavis",
      "id": 99715,
      "node_id": "MDQ6VXNlcjk5NzE1",
      "avatar_url": "https://avatars.githubusercontent.com/u/99715?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/silasdavis",
      "html_url": "https://github.com/silasdavis",
      "followers_url": "https://api.github.com/users/silasdavis/followers",
      "following_url": "https://api.github.com/users/silasdavis/following{/other_user}",
      "gists_url": "https://api.github.com/users/silasdavis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/silasdavis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/silasdavis/subscriptions",
      "organizations_url": "https://api.github.com/users/silasdavis/orgs",
      "repos_url": "https://api.github.com/users/silasdavis/repos",
      "events_url": "https://api.github.com/users/silasdavis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/silasdavis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-24T12:50:11Z",
    "updated_at": "2017-09-24T12:50:11Z",
    "author_association": "NONE",
    "body": "@dete your justification for NFT sounds rational to me, but allowing myself to plunge into the vortex for a moment. Sometimes finding a word that is relatively unreserved in modern usage but means the same thing works. 'Tesserae' were ancient tokens or tiles used as theatre tickets, forms of religious authentication, etc (see: https://www2.warwick.ac.uk/fac/arts/classics/research/dept_projects/tcam/about/,  https://www2.warwick.ac.uk/fac/arts/classics/research/dept_projects/tcam/blog/, https://en.wikipedia.org/wiki/Tessera_(commerce)). Seems like they did function as a kind of non-fungible potentially value-holding token, but were quite varied in their specific application, which might suit the present case. Then again maybe it is just trying a bit too hard...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331708046/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331883976",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331883976",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331883976,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTg4Mzk3Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-25T13:39:30Z",
    "updated_at": "2017-09-25T13:39:30Z",
    "author_association": "MEMBER",
    "body": "@dete I think you SHOULD use MUST instead. Otherwise, callers have no way to know how to interpret the return value correctly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331883976/reactions",
      "total_count": 8,
      "+1": 4,
      "-1": 0,
      "laugh": 4,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331999575",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-331999575",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 331999575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTk5OTU3NQ==",
    "user": {
      "login": "tjayrush",
      "id": 5417918,
      "node_id": "MDQ6VXNlcjU0MTc5MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5417918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tjayrush",
      "html_url": "https://github.com/tjayrush",
      "followers_url": "https://api.github.com/users/tjayrush/followers",
      "following_url": "https://api.github.com/users/tjayrush/following{/other_user}",
      "gists_url": "https://api.github.com/users/tjayrush/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tjayrush/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tjayrush/subscriptions",
      "organizations_url": "https://api.github.com/users/tjayrush/orgs",
      "repos_url": "https://api.github.com/users/tjayrush/repos",
      "events_url": "https://api.github.com/users/tjayrush/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tjayrush/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-25T20:17:55Z",
    "updated_at": "2017-09-25T20:18:21Z",
    "author_association": "NONE",
    "body": "Possible (but unlikely) names: ticket, badge, wafer, tile, marker",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331999575/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/332960312",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-332960312",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 332960312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjk2MDMxMg==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T20:51:39Z",
    "updated_at": "2017-09-28T20:51:39Z",
    "author_association": "NONE",
    "body": "@silasdavis: If this were a whole project, and not a single interface that is part of something larger, I'd jump on Tessera in a heartbeat. In that situation, a bit of an unusual name – with some history and context behind it – is pretty compelling. For something like an interface, tho, it's probably much better to stick with a term that people are already familiar with; even if it's imperfect.\r\n\r\n@tjayrush: Thanks for the suggestions! I don't think most of them work well, but \"marker\" might. I'm definitely going to stew on that one a bit more. If it weren't overloaded in such common usage as a writing implement, it would probably be just about perfect.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/332960312/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/332960929",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-332960929",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 332960929,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjk2MDkyOQ==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T20:53:47Z",
    "updated_at": "2017-09-28T20:53:47Z",
    "author_association": "NONE",
    "body": "@Arachnid: Happy to follow the community lead here, but if you look at ERC-20, they use \"SHOULD\" language for something as foundational as emitting `Transfer` events. The metadata structure felt no more critical to me than `Transfer`...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/332960929/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333025719",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-333025719",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 333025719,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzAyNTcxOQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-29T04:03:07Z",
    "updated_at": "2017-09-29T04:03:07Z",
    "author_association": "MEMBER",
    "body": "Do _not_ use ERC20 as an example of a good standard.  A ton of people went and implemented the _draft_ and then we had to finalize a \"standard\" that basically just listed what other people were doing.  I don't believe anyone sees ERC20 as a _good_ standard and everyone I have spoken to would like to see new better standards (hence why ERC223 exists).\r\n\r\nSpecifically, ERC20 used SHOULD because the standard came after a bunch of implementations and not all implementations did the same thing, so the standard couldn't say MUST without causing a bunch of ERC20-like tokens to not be ERC20.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333025719/reactions",
      "total_count": 28,
      "+1": 21,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 3,
      "heart": 4,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333175524",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-333175524",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 333175524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzE3NTUyNA==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-29T16:35:39Z",
    "updated_at": "2017-09-29T16:35:39Z",
    "author_association": "NONE",
    "body": "Great context, @MicahZoltu. Thank you!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333175524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333472952",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-333472952",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 333472952,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzQ3Mjk1Mg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-02T08:36:21Z",
    "updated_at": "2017-10-02T08:36:21Z",
    "author_association": "MEMBER",
    "body": "@dete I'd also argue that the format of something is more foundational than whether you emit it or not. If you don't emit a transfer event, others can't track token transfers for your token - but if you don't require the format of a field, then they can't parse it _anywhere_.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/333472952/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334694927",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-334694927",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 334694927,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDY5NDkyNw==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-06T08:41:04Z",
    "updated_at": "2017-10-06T08:41:13Z",
    "author_association": "NONE",
    "body": "Hey @dete! I went ahead and coded a first draft of this. Names are slightly different.\r\nhttps://github.com/decentraland/land/blob/master/contracts/BasicNFT.sol",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334694927/reactions",
      "total_count": 11,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 3,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334900298",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-334900298",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 334900298,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDkwMDI5OA==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-07T01:05:13Z",
    "updated_at": "2017-10-07T01:05:13Z",
    "author_association": "NONE",
    "body": "So, I was talking to @flockonus (another Solidity engineer here) and I was worrying about the \"lost token\" problem that ERC-223 tries to solve. (Essentially, ERC-20 has no mechanism to keep users from sending their tokens to contracts that don't know how to handle them, resulting in entirely unrecoverable coins. @dexaran [did some analysis](https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/) estimating that something like $400k has been lost in this way!)\r\n\r\nThe solution proposed by ERC-223 is to only allow transfers to contract addresses that implement the `tokenFallback` method. This has the nice side effect that the receiving contract gets a chance to do some work when it receives the coins.\r\n\r\nI talked to @flockonus because I was hesitant to add more complexity to NFTs, and he kind of floored me with a suggestion that seemed crazy at first, but is _really_ growing on me: Just get rid of the `transfer` method.\r\n\r\nSo hear me out: What if the only way to transfer an NFT was for the owner to `approve` a recipient, and have the recipient (whether contract or non-contract) call `takeOwnership` (which works like `transferFrom`, but with `msg.sender` hard-coded as the `_to` parameter).\r\n\r\nThis solves three problems, two of which are shared with fungible tokens (and addressed by ERC-223), one that is specific to NFTs:\r\n 1. Sending assets to contracts that don't know how to handle them. That becomes impossible if there is no direct `transfer` call; the contract _can't_ be given a token, it has to call `takeOwnership`.\r\n 2. Contracts should know when they get new tokens. Well, since the contract has to explicitly `takeOwnership`, the flow for sending a token to a contract would be `approve(contract)` followed by `contract.someMethod()`. `someMethod` that would `takeOwnership`, plus the kind of things you'd put into `tokenFallback` (if appropriate).\r\n 3. Some low-value NFTs could end up being something akin to \"spam\". The easiest motivating example would be \"trash\" items in a video game; no game I know of allows griefers to shove items in your backpack without your consent. (This could be especially nasty in a smart-contract context where certain operations may be O(n) on the number of NFTs you hold.)\r\n\r\nIt introduces a new problem, of course: The simplest conceivable operation (transferring ownership from user to user) now requires two transactions instead of one. But how much of a problem is this, really? As time goes on, we'll see more and more transactions mediated by exchanges, smart contracts, UIs, and automated agents.\r\n\r\nOne possible option would be to include `transfer` but make it optional (meaning that contracts would know not to use it), and strongly recommend that it `throws` if targeting a contract address. (Although that wouldn't solve the spammy NFT problem.)\r\n\r\nI'd love to hear other folks thoughts!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334900298/reactions",
      "total_count": 14,
      "+1": 14,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334917283",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-334917283",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 334917283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDkxNzI4Mw==",
    "user": {
      "login": "Dexaran",
      "id": 26142412,
      "node_id": "MDQ6VXNlcjI2MTQyNDEy",
      "avatar_url": "https://avatars.githubusercontent.com/u/26142412?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Dexaran",
      "html_url": "https://github.com/Dexaran",
      "followers_url": "https://api.github.com/users/Dexaran/followers",
      "following_url": "https://api.github.com/users/Dexaran/following{/other_user}",
      "gists_url": "https://api.github.com/users/Dexaran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Dexaran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Dexaran/subscriptions",
      "organizations_url": "https://api.github.com/users/Dexaran/orgs",
      "repos_url": "https://api.github.com/users/Dexaran/repos",
      "events_url": "https://api.github.com/users/Dexaran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Dexaran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-07T07:45:41Z",
    "updated_at": "2017-10-07T07:45:41Z",
    "author_association": "NONE",
    "body": "@dete It's an interesting idea, but I think that the problems of this approach outweigh its advantages because:\r\n\r\n1. Ethereum suffers bandwidth issues. I think that requiring that each token move is performed with two transactions is an irrational use of the blockchain.\r\n\r\n2. A couple of transactions will require additional gas so it will be more expensive.\r\n\r\n3.  Approving then withdrawing is not a common pattern of sending funds in the cryptocurrency world. You can send ETH, ETC, Bitcoins, PIVX and even Doge without any confirmation from the side of the receiver. This will not be an intuitive-clear for users.\r\n\r\n4. The ideology of uniformity. ETH and tokens are currencies. I think that it is better to make them behave similar.\r\n\r\n5. The problems that you try to solve with this proposal are already solved with ERC223. I don't see any value in solving already-solved problems.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/334917283/reactions",
      "total_count": 5,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 3,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336517096",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-336517096",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 336517096,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjUxNzA5Ng==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T17:30:19Z",
    "updated_at": "2017-10-13T17:30:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Some low-value NFTs could end up being something akin to \"spam\". The easiest motivating example would be \"trash\" items in a video game; no game I know of allows griefers to shove items in your backpack without your consent. (This could be especially nasty in a smart-contract context where certain operations may be O(n) on the number of NFTs you hold.)\r\n\r\nI thought about this some, and is it really that big of an issue?  With the current ERC, each spam item would require its own transaction, so it would be a rather expensive attack, right?\r\n\r\nThat said, what if there were two new optional methods:\r\n\r\n`approveMultiple(address _to, uint[] _tokenIds)`\r\n`transferMultipleFrom(address _from, address _to, uint[] _tokenIds)` \r\n\r\nThese would allow \"high volume\" NFT contracts (like your MMO item example) to do \"approved\" bulk transfers, while the lower volume contracts would be naturally protected from spam via the requirement to send a single tokenId per transaction using the standard `transfer` call.\r\n\r\nThese methods would also allow one to merge/move wallets w/ 2 transactions instead of the `N` transactions currently required to move one item at a time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336517096/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337687501",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-337687501",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 337687501,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzY4NzUwMQ==",
    "user": {
      "login": "flockonus",
      "id": 165553,
      "node_id": "MDQ6VXNlcjE2NTU1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/165553?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/flockonus",
      "html_url": "https://github.com/flockonus",
      "followers_url": "https://api.github.com/users/flockonus/followers",
      "following_url": "https://api.github.com/users/flockonus/following{/other_user}",
      "gists_url": "https://api.github.com/users/flockonus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/flockonus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/flockonus/subscriptions",
      "organizations_url": "https://api.github.com/users/flockonus/orgs",
      "repos_url": "https://api.github.com/users/flockonus/repos",
      "events_url": "https://api.github.com/users/flockonus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/flockonus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-18T18:36:39Z",
    "updated_at": "2018-02-12T04:11:47Z",
    "author_association": "NONE",
    "body": "About the point of removing the `transfer` method, we've been thinking heavily about this for CryptoKitties (disclosure i'm in Dete's team), and altho we have unconditional transfer method implemented for the alpha, it's easy to see why unconditional transfer might not work in multiple cases.\r\n\r\nTo start off, we have to understand that while a similar API to ERC20 is desirable, the case it aims to solve is different. In ERC20 the abstraction is _the more you have the better_ because the tokens have positive monetary value, and go into an indistinguishable sum.\r\n\r\nThat's not the case with non-fungible, either with a smart contract that tracks property ownership such as the one [Dubai is implementing](https://coinjournal.net/dubais-land-department-adopts-blockchain-technology/), or a game with relatively lower value assets, they might not always carry positive value or be desirable.\r\n\r\nSo even with due consideration about it being an expensive attack, when designing a mechanism we should take into account that some users will have significant more purchase power than others, and still they shouldn't be able to harm others with less.\r\n\r\nMy point is, if `transfer` is implemented it should be expected to throw depending on the smart contract implementation of what user decides to accept what. The business rules of accepting a token would definitely vary for each S.C. implementation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337687501/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342943495",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-342943495",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 342943495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0Mjk0MzQ5NQ==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-08T20:08:18Z",
    "updated_at": "2017-11-08T20:08:18Z",
    "author_association": "NONE",
    "body": "Upon further reflection and discussion with @flockonus, we are proposing to keep a straightforward (and therefore \"unsafe\") `transfer()` method. (i.e. It would work like ERC-20, and not [EIP-223](https://github.com/ethereum/EIPs/issues/223).)\r\n\r\nOur reasoning is as follows:\r\n - Simpler is always better for standards. The fewer requirements, the harder it is to screw it up. (And NFTs are already complicated enough!)\r\n - It is not the job of a smart contract to protect against every possible user error (it must protect against _invalid_ actions, not _unintended_ actions). In particular, the case we are trying to avoid (sending NFTs to contracts that don't know how to handle them) is better served by checks and warnings _in the wallet software_. A wallet (or other smart contract interface) will always be able to have more robust and dynamic checks than a smart contract, and is also able to engage in some \"back-and-forth\" dialog with the user. Smart contracts don't have the equivalent of a \"This seems unsafe, are you sure?\" dialog box!\r\n\r\nSimilarly, as @flockonus mentioned about the potential \"spam\" problem: This is not a problem that the community standard needs to solve. If an implementor of an ERC-721 contract feels like spam is likely to be a problem with their NFT, they are welcome to include additional functionality to make it easy for users to mark their accounts as not accepting unsolicited transfers.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342943495/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342949091",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-342949091",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 342949091,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0Mjk0OTA5MQ==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-08T20:28:52Z",
    "updated_at": "2017-11-08T20:28:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "Is `transfer()` still accepting a single NFT tokenId?  Any thoughts on my suggestion of defining some *optional* methods to support bulk transfers?\r\n\r\nSay I decide to sell a large portion of my NFT collection to someone else, and it contains hundreds of NFTs (or more).  Shouldn't there be a standard way to transfer `N` items atomically?\r\n\r\nI can see the point of trying to keep the ERC simple, but am concerned that w/o a solution for bulk transfers the scope of what NFTs the ERC can be viable for is limited.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342949091/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343246872",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343246872",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343246872,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzI0Njg3Mg==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-09T18:28:25Z",
    "updated_at": "2017-11-09T18:28:25Z",
    "author_association": "NONE",
    "body": "Here is the new draft, which is basically the first \"complete\" draft. Any and all comments are welcome!\r\n\r\n---\r\n\r\n## Preamble\r\n\r\n    EIP: <to be assigned>\r\n    Title: Non-fungible Token Standard\r\n    Author: Dieter Shirley <dete@axiomzen.co>\r\n    Type: Standard\r\n    Category: ERC\r\n    Status: Draft\r\n    Created: 2017-09-20\r\n\r\n\r\n\r\n## Simple Summary\r\nA standard interface for non-fungible tokens.\r\n\r\n## Abstract\r\nThis standard allows for the implementation of a standard API for non-fungible tokens (henceforth referred to as \"NFTs\") within smart contracts. This standard provides basic functionality to track and transfer ownership of NFTs.\r\n\r\n## Motivation\r\nA standard interface allows any NFTs on Ethereum to be handled by general-purpose applications. In particular, it will allow for NFTs to be tracked in standardized wallets and traded on exchanges.\r\n\r\n## Specification\r\n\r\n### ERC-20 Compatibility\r\n\r\n#### name\r\n\r\n``` js\r\nfunction name() constant returns (string name)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns the name of the collection of NFTs managed by this contract. - e.g. `\"My Non-Fungibles\"`.\r\n\r\n#### symbol\r\n\r\n``` js\r\nfunction symbol() constant returns (string symbol)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns a short string symbol referencing the entire collection of NFTs managed in this contract. e.g. \"MNFT\". This symbol SHOULD be short (3-8 characters is recommended), with no whitespace characters or new-lines and SHOULD be limited to the uppercase latin alphabet (i.e. the 26 letters used in English).\r\n\r\n#### totalSupply\r\n\r\n``` js\r\nfunction totalSupply() constant returns (uint256 totalSupply)\r\n```\r\n\r\nReturns the total number of NFTs currently tracked by this contract.\r\n\r\n#### balanceOf\r\n\r\n``` js\r\nfunction balanceOf(address _owner) constant returns (uint256 balance)\r\n```\r\n\r\nReturns the number of NFTs assigned to address `_owner`.\r\n\r\n### Basic Ownership\r\n\r\n#### ownerOf\r\n\r\n``` js\r\nfunction ownerOf(uint256 _tokenId) constant returns (address owner)\r\n```\r\n\r\nReturns the address currently marked as the owner of `_tokenID`. This method MUST `throw` if `_tokenID` does not represent an NFT currently tracked by this contract. This method MUST NOT return 0 (NFTs assigned to the zero address are considered destroyed, and queries about them should `throw`). \r\n\r\n#### approve\r\n\r\n``` js\r\nfunction approve(address _to, uint256 _tokenId)\r\n```\r\n\r\nGrants approval for address `_to` to take possession of the NFT with ID `_tokenId`. This method MUST `throw` if `msg.sender != ownerOf(_tokenId)`, or if `_tokenID` does not represent an NFT currently tracked by this contract, or if `msg.sender == _to`.\r\n\r\nOnly one address can \"have approval\" at any given time; calling `approveTransfer` with a new address revokes approval for the previous address. Calling this method with 0 as the `_to` argument clears approval for any address.\r\n\r\nSuccessful completion of this method MUST emit an `Approval` event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the `_to` address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if `_to` is already the currently approved address and this call otherwise has no effect. (i.e. An `approve()` call that \"reaffirms\" an existing approval MUST fire an event.)\r\n\r\nAction | Prior State | _to address | New State | Event\r\n-- | -- | -- | -- | --\r\nClear unset approval | Clear | 0 | Clear | None\r\nSet new approval | Clear | X | Set to X | Approval(owner, X, tokenID)\r\nChange approval | Set to X | Y | Set to Y | Approval(owner, Y, tokenID)\r\nReaffirm approval | Set to X | X | Set to X | Approval(owner, X, tokenID)\r\nClear approval | Set to X | 0 | Clear | Approval(owner, 0, tokenID)\r\n\r\n\r\nNote: ANY change of ownership of an NFT – whether directly through the `transfer` and `transferFrom` methods defined in this interface, or through any other mechanism defined in the conforming contract – MUST clear any and all approvals for the transferred NFT. The implicit clearing of approval via ownership transfer MUST also fire the event `Approval(0, _tokenId)` if there was an outstanding approval. (i.e. All actions that transfer ownership must emit the same Approval event, if any, as would emitted by calling `approve(0, _tokenID)`.)\r\n\r\n#### takeOwnership\r\n\r\n``` js\r\nfunction takeOwnership(uint256 _tokenId)\r\n```\r\n\r\nAssigns the ownership of the NFT with ID `_tokenId` to `msg.sender` if and only if `msg.sender` currently has approval (via a previous call to `approveTransfer`). A successful transfer MUST fire the `Transfer` event (defined below).\r\n\r\nThis method MUST transfer ownership to `msg.sender` or `throw`, no other outcomes can be possible. Reasons for failure include (but are not limited to):\r\n - `msg.sender` does not have approval for `_tokenId`\r\n - `_tokenID` does not represent an NFT currently tracked by this contract\r\n - `msg.sender` already has ownership of `_tokenId`\r\n\r\nImportant: Please refer to the Note in the `approveTransfer` method description; a successful transfer MUST clear pending approval.\r\n\r\n#### transfer\r\n\r\n``` js\r\nfunction transfer(address _to, uint256 _tokenId)\r\n```\r\n\r\nAssigns the ownership of the NFT with ID `_tokenId` to `_to` if and only if `msg.sender == ownerOf(_tokenId)`. A successful transfer MUST fire the `Transfer` event (defined below).\r\n\r\nThis method MUST transfer ownership to `_to` or `throw`, no other outcomes can be possible. Reasons for failure include (but are not limited to):\r\n - `msg.sender` is not the owner of `_tokenId`\r\n - `_tokenID` does not represent an NFT currently tracked by this contract\r\n - `_to` is 0 (Conforming contracts MAY have other methods to destroy or burn NFTs, which are conceptually \"transfers to 0\" and will emit `Transfer` events reflecting this. However, `transfer(0, tokenID)` MUST be treated as an error.)\r\n\r\nA conforming contract MUST allow the current owner to \"transfer\" a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for `_to == ownerOf(_tokenID)`.) This \"no-op transfer\" MUST be considered a successful transfer, and therefore MUST fire a `Transfer` event (with the same address for `_from` and `_to`).\r\n\r\nImportant: Please refer to the Note in the `approveTransfer` method description; a successful transfer MUST clear pending approval. _This includes no-op transfers to the current owner!_\r\n\r\n#### tokenOfOwnerByIndex\r\n\r\n``` js\r\nfunction tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId)\r\n````\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns the _nth_ NFT assigned to the address `_owner`, with _n_ specified by the `_index` argument. This method MUST `throw` if `_index >= balanceOf(_owner)`.\r\n\r\nRecommended usage is as follows:\r\n\r\n``` js\r\nuint256 ownerBalance = nonFungibleContract.balanceOf(owner);\r\n\r\nuint256[] memory ownerTokens = new uint256[](ownerBalance);\r\n\r\nfor (uint256 i = 0; i < ownerBalance; i++) {\r\n    ownerTokens[i] = nonFungibleContract.tokenOfOwnerByIndex(owner, i);\r\n}\r\n```\r\n\r\nImplementations MUST NOT assume that NFTs are accessed in any particular order by their callers (In particular, don't assume this method is called in a monotonically ascending loop.), and MUST ensure that calls to `tokenOfOwnerByIndex` are fully [idempotent](https://en.wikipedia.org/wiki/Idempotence) unless and until some non-`constant` function is called on this contract.\r\n\r\nCallers of `tokenOfOwnerByIndex` MUST never assume that the order of NFTs is maintained outside of a single operation, or through the invocation (direct or indirect) of any non-`constant` contract method.\r\n\r\nNOTE: Current limitations in Solidity mean that there is no efficient way to return a complete list of an address's NFTs with a single function call. Callers should not assume this method is implemented efficiently (from a gas standpoint) and should _strenuously avoid_ calling this method \"on-chain\" (i.e. from any non-`constant` contract function, or from any `constant` contract function that is likely to be called on-chain).\r\n\r\n### NFT Metadata\r\n\r\n#### tokenMetadata\r\n\r\n``` js\r\nfunction tokenMetadata(uint256 _tokenId) constant returns (string infoUrl)\r\n```\r\n\r\n_OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method._\r\n\r\nReturns a [multiaddress](https://github.com/multiformats/multiaddr) string referencing an external resource bundle that contains (optionally localized) metadata about the NFT associated with `_tokenId`. The string MUST be an IPFS or HTTP(S) base path (without a trailing slash) to which specific subpaths are obtained through concatenation. (IPFS is the preferred format due to better scalability, persistence, and immutability.)\r\n\r\nStandard sub-paths:\r\n - name (required) - The `name` sub-path MUST contain the UTF-8 encoded name of the specific NFT (i.e. distinct from the name of the collection, as returned by the contract's `name` method). A name SHOULD be 50 characters or less, and unique amongst all NFTs tracked by this contract. A name MAY contain white space characters, but MUST NOT include new-line or carriage-return characters. A name MAY include a numeric component to differentiate from similar NFTs in the same contract. For example: \"Happy Token #157\".\r\n - image (optional) - If the `image` sub-path exists, it MUST contain a PNG, JPEG, or SVG image with at least 300 pixels of detail in each dimension. The image aspect ratio SHOULD be between 16:9 (landscape mode) and 2:3 (portrait mode). The image SHOULD be structured with a \"safe zone\" such that cropping the image to a maximal, central square doesn't remove any critical information. (The easiest way to meet this requirement is simply to use a 1:1 image aspect ratio.)\r\n - description (optional) - If the `description` sub-path exists, it MUST contain a UTF-8 encoded textual description of the asset. This description MAY contain multiple lines and SHOULD use a single new-line character to delimit explicit line-breaks, and two new-line characters to delimit paragraphs. The description MAY include [CommonMark](http://commonmark.org)-compatible Markdown annotations for styling. The description SHOULD be 1500 characters or less.\r\n - other metadata (optional) - A contract MAY choose to include any number of additional subpaths, where they are deemed useful. There may be future formal and informal standards for additional metadata fields independent of this standard.\r\n \r\nEach metadata subpath (including subpaths not defined in this standard) MUST contain a sub-path `default` leading to a file containing the default (i.e. unlocalized) version of the data for that metadata element. For example, an NFT with the metadata path `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe` MUST contain the NFT's name as a UTF-8 encoded string available at the full path `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/default`. Additionally, each metadata subpath MAY have one or more localizations at a subpath of an [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code (the same language codes used for HTML). For example, `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/en` would have the name in English, and `/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe/name/fr` would have the name in French (note that even localized values need to have a `default` entry). Consumers of NFT metadata SHOULD look for a localized value before falling back to the `default` value. Consumers MUST NOT assume that all metadata subpaths for a particular NFT are localized similarly. For example, it will be common for the `name` and `image` objects to not be localized even when the `description` is.\r\n\r\nYou can explore the metadata package referenced in this example [here](https://ipfs.io/ipfs/QmZU8bKEG8fhcQwKoLHfjtJoKBzvUT5LFR3f8dEz86WdVe).\r\n\r\n### Events\r\n\r\n#### Transfer\r\n\r\nThis event MUST trigger when NFT ownership is transferred via any mechanism.\r\n\r\nAdditionally, the creation of new NFTs MUST trigger a Transfer event for each newly created NFTs, with a `_from` address of 0 and a `_to` address matching the owner of the new NFT (possibly the smart contract itself). The deletion (or burn) of any NFT MUST trigger a Transfer event with a `_to` address of 0 and a `_from` address of the owner of the NFT (now former owner!).\r\n\r\nNOTE: A Transfer event with `_from == _to` is valid. See the `transfer()` documentation for details.\r\n\r\n``` js\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _tokenId)\r\n```\r\n\r\n#### Approval\r\n\r\nThis event MUST trigger on any successful call to `approve(address _spender, uint256 _value)` (unless the caller is attempting to clear approval when there is no pending approval).\r\n\r\nSee the documentation for the `approve()` method above for further detail.\r\n\r\n\r\n``` js\r\nevent Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)\r\n```\r\n\r\n\r\n## Rationale\r\n\r\n### Utility\r\n\r\nThere are many proposed uses of Ethereum smart contracts that depend on tracking individual, non-fungible tokens (NFTs). Examples of existing or planned NFTs are LAND in [Decentraland](https://decentraland.org/), the eponymous punks in [CryptoPunks](https://www.larvalabs.com/cryptopunks), and in-game items using systems like [Dmarket](https://www.dmarket.io) or [EnjinCoin](https://enjincoin.io/). Future uses include tracking real-world non-fungible assets, like real-estate (as envisioned by companies like [Ubitquity](https://www.ubitquity.io) or [Propy](https://tokensale.propy.com/)).  It is critical in each of these cases that these items are not \"lumped together\" as numbers in a ledger, but instead, each token must have its ownership individually and atomically tracked. Regardless of the nature of these items, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional non-fungible token management and sales platforms.\r\n\r\n### NTF IDs\r\n\r\nThe basis of this standard is that every NFT is identified by a unique, 256-bit unsigned integer within its tracking contract. This ID number MUST NOT change for the life of the contract. The pair `(contract address, asset ID)` will then be a globally unique and fully-qualified identifier for a specific NFT within the Ethereum ecosystem. While some contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers MUST NOT assume that ID numbers have any specific pattern to them, and should treat the ID as a \"black box\".\r\n\r\n## Backwards Compatibility\r\nThis standard follows the semantics of ERC-20 as closely as possible, but can't be entirely compatible with it due to the fundamental differences between fungible and non-fungible tokens.\r\n\r\nExample non-fungible implementations as of September 2017:\r\n - [CryptoPunks](https://www.larvalabs.com/cryptopunks) - Partially ERC-20 compatible, but not easily generalizable because it includes auction functionality directly in the contract and uses function names that explicitly refer to the NFTs as \"punks\".\r\n - [Auctionhouse Asset Interface](https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol) - @dob needed a generic interface for his Auctionhouse dapp (currently ice-boxed). His \"Asset\" contract is very simple, but is missing ERC-20 compatibility, approve() functionality, and metadata. This effort is referenced in the discussion for [EIP-173](https://github.com/ethereum/EIPs/issues/173).\r\n\r\n(It should be noted that \"limited edition, collectable tokens\" like [Curio Cards](https://mycuriocards.com/) and [Rare Pepe](https://rarepepewallet.com/) are _not_ non-fungible tokens. They're actually a collection of individual fungible tokens, each of which is tracked by its own smart contract with its own total supply (which may be `1` in extreme cases).)\r\n\r\n## Implementation\r\n_Reference implementation forthcoming..._\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343246872/reactions",
      "total_count": 36,
      "+1": 35,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343287463",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343287463",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343287463,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzI4NzQ2Mw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-09T20:51:48Z",
    "updated_at": "2017-11-09T20:51:48Z",
    "author_association": "MEMBER",
    "body": "@dete You should update the initial issue with this draft, so people coming new to it don't need to scroll through all the comments.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343287463/reactions",
      "total_count": 13,
      "+1": 13,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343376748",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343376748",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343376748,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzM3Njc0OA==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T05:12:32Z",
    "updated_at": "2017-11-10T05:12:32Z",
    "author_association": "NONE",
    "body": "Thanks @Arachnid: I put a link in the first comment for now, I don't want to lose the older version for anyone who wants to follow the conversation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343376748/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343377015",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343377015",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343377015,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzM3NzAxNQ==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T05:15:10Z",
    "updated_at": "2017-11-10T05:15:10Z",
    "author_association": "NONE",
    "body": "Does anyone have any thoughts on whether the `_tokenID` in the events should be indexed? I would think yes (it's easy to imagine that people or processes would want to watch for events relating to specific NFTs), but this comment in the [Solidity docs on Events](https://solidity.readthedocs.io/en/develop/contracts.html#events) gave me pause:\r\n\r\n> NOTE: Indexed arguments will not be stored themselves. You can only search for the values, but it is impossible to retrieve the values themselves.\r\n\r\nThat seems... problematic...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343377015/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343452243",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343452243",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343452243,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzQ1MjI0Mw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T11:42:23Z",
    "updated_at": "2017-11-10T11:42:23Z",
    "author_association": "MEMBER",
    "body": "I don't believe that's quite accurate; you should be able to retrieve the contents of an indexed event (for a fixed length type) or its hash (for string/bytes/arrays).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343452243/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343488837",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343488837",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343488837,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzQ4ODgzNw==",
    "user": {
      "login": "NoahMarconi",
      "id": 627649,
      "node_id": "MDQ6VXNlcjYyNzY0OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/627649?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NoahMarconi",
      "html_url": "https://github.com/NoahMarconi",
      "followers_url": "https://api.github.com/users/NoahMarconi/followers",
      "following_url": "https://api.github.com/users/NoahMarconi/following{/other_user}",
      "gists_url": "https://api.github.com/users/NoahMarconi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NoahMarconi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NoahMarconi/subscriptions",
      "organizations_url": "https://api.github.com/users/NoahMarconi/orgs",
      "repos_url": "https://api.github.com/users/NoahMarconi/repos",
      "events_url": "https://api.github.com/users/NoahMarconi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NoahMarconi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T14:34:35Z",
    "updated_at": "2017-11-10T14:34:35Z",
    "author_association": "NONE",
    "body": "Any thoughts on transferring multiple tokens in a single transfer? \r\n\r\nWe ran into this needs recently and the gas costs are making many options unfeasible. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343488837/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343528075",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343528075",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343528075,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzUyODA3NQ==",
    "user": {
      "login": "jpitts",
      "id": 509756,
      "node_id": "MDQ6VXNlcjUwOTc1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/509756?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jpitts",
      "html_url": "https://github.com/jpitts",
      "followers_url": "https://api.github.com/users/jpitts/followers",
      "following_url": "https://api.github.com/users/jpitts/following{/other_user}",
      "gists_url": "https://api.github.com/users/jpitts/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jpitts/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jpitts/subscriptions",
      "organizations_url": "https://api.github.com/users/jpitts/orgs",
      "repos_url": "https://api.github.com/users/jpitts/repos",
      "events_url": "https://api.github.com/users/jpitts/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jpitts/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T16:58:07Z",
    "updated_at": "2017-11-10T16:58:07Z",
    "author_association": "MEMBER",
    "body": "For metadata, I would strongly recommend requiring a standard URI. \r\n\r\nPerhaps consider a way to allow for linkage to the same metadata hosted on different storage networks (i.e. additional parameter specifying 'ipfs\", 'swarm', or 'https'). This way the metadata has a better chance of persisting.\r\n\r\nAdditionally, instead of an external resource bundle, I would recommend using JSON-LD. This format allows for more complex data, has wide use and tooling (being JSON), and provides context to that data\r\n\r\nhttps://json-ld.org/.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343528075/reactions",
      "total_count": 8,
      "+1": 6,
      "-1": 2,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343617457",
    "html_url": "https://github.com/ethereum/EIPs/issues/721#issuecomment-343617457",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/721",
    "id": 343617457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzYxNzQ1Nw==",
    "user": {
      "login": "nadavhollander",
      "id": 3241822,
      "node_id": "MDQ6VXNlcjMyNDE4MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3241822?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nadavhollander",
      "html_url": "https://github.com/nadavhollander",
      "followers_url": "https://api.github.com/users/nadavhollander/followers",
      "following_url": "https://api.github.com/users/nadavhollander/following{/other_user}",
      "gists_url": "https://api.github.com/users/nadavhollander/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nadavhollander/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nadavhollander/subscriptions",
      "organizations_url": "https://api.github.com/users/nadavhollander/orgs",
      "repos_url": "https://api.github.com/users/nadavhollander/repos",
      "events_url": "https://api.github.com/users/nadavhollander/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nadavhollander/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T23:53:48Z",
    "updated_at": "2017-11-10T23:58:13Z",
    "author_association": "NONE",
    "body": "First -- greed with @jpitts on creating redundant storage of metadata on different storage networks and, more importantly IMO, being more unopinionated with respect to the data storage network.  I imagine a URI format along the lines of \"swarm://XYZ\" / \"ipfs://XYZ\" with the URI prefix specifying the specific storage network queried.\r\n\r\nSecondly, I'm working on tokenized debt issuance protocol ([Dharma](https://dharma.io)) and a big feature that would be extremely helpful to us is having built-in optional fungibility _within_ each non-fungible asset.  This may sound at odds with the purpose of NFTs, but I'll use Dharma as a tangible example:\r\n\r\nAlice wants to issue a bond token using Dharma, and she wants to be able to sell individual shares in that bond to different creditors.  She _could_ ostensibly have an NFT representing the debt asset as a whole, wrap that NFT into another fungible ERC20 token contract, and sell tokens from that contract  to creditors, but that would require her to incur the gas associated with deploying an entirely new token contract for a set of very generic token transfer functionality.  It would be much simpler and cheaper to be able to ask the contract to mint an NFT with its own fractional supply of X tokens.  In a sense, this would mean that individual debts would be non-fungible with one another, but _within_ each debt there would be a fractional supply of tokens that _are_ fungible with one another.\r\n\r\nAs an example, the function interface for `transfer` would look like this:\r\n```\r\nfunction transfer(address _to, uint256 _tokenId, uint246 _amount)\r\n```\r\n\r\nThe standard could easily be made compatible with NFTs that have no fractional supply -- their issuance would simply have a fractional supply of 1.  This is an advantageous arrangement for classes of digital assets that have (1) highly generic functionality and (2) require some sort of fractional fungibility and (2) don't merit the deployment of a smart contract for each issuance event.\r\n\r\nWith all the above being said, I would definitely not say this is a **must have** -- this arguably extends beyond the definition of non-fungibility to a certain degree.  **If, however, this is a very common need among projects that have similar dynamics to the tokens they're issuing, I think this would be the appropriate standard in which to include this functionality.**\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343617457/reactions",
      "total_count": 14,
      "+1": 5,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 8,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
