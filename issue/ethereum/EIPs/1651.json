{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1651",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1651",
  "id": 389623582,
  "node_id": "MDU6SXNzdWUzODk2MjM1ODI=",
  "number": 1651,
  "title": "A document management proposal for legally binding token",
  "user": {
    "login": "xguan5",
    "id": 37852062,
    "node_id": "MDQ6VXNlcjM3ODUyMDYy",
    "avatar_url": "https://avatars.githubusercontent.com/u/37852062?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/xguan5",
    "html_url": "https://github.com/xguan5",
    "followers_url": "https://api.github.com/users/xguan5/followers",
    "following_url": "https://api.github.com/users/xguan5/following{/other_user}",
    "gists_url": "https://api.github.com/users/xguan5/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/xguan5/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/xguan5/subscriptions",
    "organizations_url": "https://api.github.com/users/xguan5/orgs",
    "repos_url": "https://api.github.com/users/xguan5/repos",
    "events_url": "https://api.github.com/users/xguan5/events{/privacy}",
    "received_events_url": "https://api.github.com/users/xguan5/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2018-12-11T07:06:57Z",
  "updated_at": "2021-12-05T05:10:33Z",
  "closed_at": "2021-12-05T05:10:33Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "---\r\neip: <to be assigned>\r\ntitle: A document management proposal for legally binding token\r\nauthor: Tony Guan <tony.kuan@hotmail.com>\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2018-12-05\r\nrequires (*optional): <EIP number(s)>\r\nreplaces (*optional): <EIP number(s)>\r\n---\r\n\r\n# Standard for adding legal contract into token smart contract \r\n\r\n## Simple Summary\r\nProposing a model for including verified legal contracts into token. The purpose is to ensure that token is legally binding and relevant parties’ rights and obligations are enforceable by law. \r\n\r\n## Abstract\r\nIn order to make token legally binding, legal documents must be attached to token smart contract and serve as the foundation for judicial purpose. More importantly, documents must be carefully validated before it goes on chain. This proposal adopts multi-signature validation mechanism to ensure a legal contract is agreed by all relevant parties (granter, beneficiary, code auditor, lawyer) before it can be added to token smart contract. The use cases include day-to-day business activies where paper contracts come into play. In addition, the proposal provides role management functionality to authorize addresses that can sign as a specific role. \r\n\r\n\r\n## Motivation\r\nThis is the first step of a bigger goal: to establish a legal-oriented token system which ensures rights of token holders are protected by law. \r\n\r\nThe essence of blockchain is forging consensus and trust. Token, in its current form, ensures trust with solidity code. However, a smart contract is not a legally binding contract. Imagine if two parties enter into agreement and put it into smart contract code. Say if there are some loopholes in the code that allow one party to default, how do the other party protect his/her rights? By showing the smart contract code to the court? \r\n\r\nThe eventual ideal state would be “Code is Law”, meaning whatever written in code would be recognized and protected by law. However, in the foreseeable future, law enforcement has to rely on documents rather than code. It is unreasonable to expect the court judges to make a ruling based on some programs written in solidity. Therefore, it’s crucial to embed in the token the legal contracts that specifies the rights and obligations of relevant parties. Once the contract is validated and added to the smart contract, relevant token holders would be able to access and use it as evidence to claim legal protection in case anything goes wrong with the smart contract. Such \"legally binding token\" would have both computer programs and traditional judicial contracts as the foundation of trust. \r\n\r\nNonetheless, we are missing a standard for managing legal documents. Some token standards (such as ERC 721) allows to add file links (http or ipfs) stored as metadata. However, existing solutions do not verify the validity of the document links added to the blockchain. Legal documents are an essential piece of security token. Its validity needs to be carefully examined before it goes on chain. That’s why this proposal introduces multi-signature validation mechanism to ensure a legal contract is agreed by all relevant parties before it is added to security token smart contract as metadata.\r\n\r\nIn common business situations, signing a contract involves three different parties: granter, beneficiary and lawyer. For example, in the case of a company that wants to issue incentive stock options to an employee, the company would be the granter and the employee would be the beneficiary. In addition, contracts should have been drafted by the lawyer who needs to ensure the legality of the process.\r\n\r\nHowever, translating documents into smart contract code is a crucial gap between the blockchain world and the real world. We need someone to testify what’s written in code is consistent with what’s written in the contract document. That’s why we introduce the code auditor role. Code auditors’ responsibilities include guaranteeing the fairness and consistency of the smart contract with their specialty and reputation.\r\n\r\n\r\nBelow is an overview of the process.\r\n\r\n![alt text][flowchart]\r\n\r\n[flowchart]: https://github.com/xguan5/Legally-Binding-Token/blob/master/FlowChart.png \"Logo Title Text 2\"\r\n\r\n\r\nWith a document management standard in place, token rights will be enforceable both by legal enforcement of rights and obligations as well as via tamper-proof execution of computer code. The use cases of asset tokenization can potentially be extended to a much broader setting - whereever paper contracts are involved. \r\n\r\n\r\n## Specification\r\n\r\n### Role Management\r\nThere are four different roles involved in legal contracts: granter, beneficiary, lawyer and code auditor. Their respective descriptions were provided in the previous motivation section. \r\n\r\nAmong the four roles, granter has some special rights over the others. A granter can control if an address can be authorized or renounced as a specific role. Users should carefully validate the addresses for each role. The identity verification is beyond the scope of this project.\r\n\r\nEach role has its own contract for adding/deleting actions etc. Role contract import openzeppelin's Roles.sol. Below is an exmaple of granter interface. The other three roles have more or less same functions.\r\n\r\n```\r\ncontract GranterRole {\r\n  using Roles for Roles.Role; // use openzeppline's Roles.sol\r\n\r\n  event GranterAdded(address indexed account);\r\n  event GranterRemoved(address indexed account);\r\n\r\n  Roles.Role private granters;\r\n\r\n  constructor() public;\r\n\r\n  modifier onlyGranter();\r\n\r\n  //check if an address is authorized as granter\r\n  function isGranter(address account) public view returns (bool);\r\n\r\n  //authorize an address as granter\r\n  function addGranter(address account) public onlyGranter;\r\n\r\n  function renounceGranter(address account) public onlyGranter ;\r\n\r\n  function _addGranter(address account) internal;\r\n\r\n  function _removeGranter(address account) internal;\r\n}\r\n\r\n```\r\n\r\n### Document Management\r\n \r\nDocument contract extends from the role contracts. It manage a list of documents including each document' signer addresses and signing status for each role.\r\n\r\n#### AddDocument\r\n\r\n````\r\nfunction addDocument(bytes32 docHash, address _granter, address _lawyer, address _codeAudit, address _beneficiary) public preAuthorized(_granter,_lawyer,_codeAudit,_beneficiary) onlyGranter returns (bool success);\r\n````\r\n\r\nGranter add a document to sign by providing a IPFS hash (in bytes32 document) pointing to the document and also the four addresses as four roles that need to confirm this document. The four addresses provided must be pre-authorized as each respective role in their role contract. \r\n\r\nOnly granter has the authority to perform this action. When this function is called, granter confirmation is assumed.\r\n\r\nMust emit a DocumentAdd event and GranterConfirmation event.\r\n\r\nDocuments' IPFS hash is stored as bytes32 for efficiency purpose. Currently IPFS hash is 34 bytes long with first two segments represented as a single byte (uint8). We could use Multihash structure to convert the 34 bytes IPFS hash to 32 bytes. More details can be found at [https://github.com/saurfang/ipfs-multihash-on-solidity].\r\n\r\n\r\n#### ConfirmDocument\r\n\r\n````\r\n\r\nfunction confirmDocument(bytes32 docHash) public returns (bool success);\r\n````\r\n\r\nAfter granter add a document to sign, the specified signers each reviews the document and calls confirmDocument function to provide their respective confirmations.\r\nMust emit respective role's confirmation event.\r\n\r\n#### SubmitDocument\r\n\r\n````\r\n\r\nfunction submitDocument(bytes32 docHash) allSigned(docHash) public returns (bool success);\r\n````\r\n\r\nOnce all confirmations are obtained, this document status can be labeled as submitted and pushed into a list of submitted documents.\r\nOnly granter can perform this action. Must emit DocumentSubmit event.\r\n\r\n#### RevokeConfirmation\r\n\r\n````\r\n\r\nfunction revokeConfirmation(bytes32 docHash) public returns (bool success);\r\n````\r\nEach signer can revoke their confirmation before document is submitted. After document is submitted, confirmation cannot be revoked. Must emit respective role's Revocation event.\r\n\r\n#### isDoc\r\n````\r\n\r\nfunction isDoc(bytes32 docHash) public constant returns (bool isIndeed);\r\n````\r\nCheck if the provided document hash exists in the submitted document array.\r\n\r\n#### getAllDocument\r\n````\r\n\r\nfunction getAllDocument() public view returns (bytes32[] docHashes);\r\n````\r\nReturns an array of all submitted document hashes.\r\n\r\n#### getDocStatus\r\n````\r\n\r\nfunction getDocStatus(bytes32 docHash) public constant returns(address granter, address lawyer, address codeAudit, address beneficiary, bool granterSigned, bool lawyerSigned, bool codeAuditSigned, bool beneficiarySigned);\r\n````\r\nCheck the status of the provided document hash. Returns its signer addresses and each signer's status.\r\n\r\n#### Interface\r\n\r\n````\r\n\r\ncontract Document is GranterRole, LawyerRole, CodeAuditorRole, BeneficiaryRole {\r\n\r\n\r\n\tstruct DocStruct {\r\n\t\taddress granter;\r\n\t\taddress lawyer;\r\n\t\taddress codeAudit;\r\n\t\taddress beneficiary;\r\n\t\tbool granterSigned;\r\n\t\tbool lawyerSigned;\r\n\t\tbool codeAuditSigned;\r\n\t\tbool beneficiarySigned;\r\n\t\tbool submitted;\r\n\t\tuint index;\r\n\t}\r\n\r\n\tbytes32[] docIndex; //list of doc keys (docHash)\r\n\r\n\r\n\t//use docHash as key to map to DocStruct\r\n\tmapping (bytes32 => DocStruct) public DocStructs;\r\n\r\n\tevent DocumentAdd(bytes32 indexed docHash);\r\n\tevent DocumentSubmit(bytes32 indexed docHash);\r\n\tevent LawyerRevocation(address indexed sender, bytes32 indexed docHash);\r\n\tevent BeneficiaryRevocation(address indexed sender, bytes32 indexed docHash);\r\n\tevent GranterRevocation(address indexed sender, bytes32 indexed docHash);\r\n\tevent CodeAuditRevocation(address indexed sender, bytes32 indexed docHash);\r\n\tevent LawyerConfirmation(address indexed sender, bytes32 indexed docHash);\r\n\tevent BeneficiaryConfirmation(address indexed sender, bytes32 indexed docHash);\r\n\tevent GranterConfirmation(address indexed sender, bytes32 indexed docHash);\r\n\tevent CodeAuditConfirmation(address indexed sender, bytes32 indexed docHash);\r\n\r\n\tmodifier allSigned(bytes32 docHash);\r\n\r\n\tmodifier preAuthorized(address granter, address lawyer, address codeAudit, address beneficiary);\r\n\r\n\tfunction addDocument(bytes32 docHash, address _granter, address _lawyer, address _codeAudit, address _beneficiary) public preAuthorized(_granter,_lawyer,_codeAudit,_beneficiary) onlyGranter returns (bool success);\r\n\r\n\t//owner(Granter) add a new document hash, needs confirmation from all requiredparties\r\n\tfunction submitDocument(bytes32 docHash) allSigned(docHash) public returns (bool success);\r\n\r\n\t//relevant party review and confirm\r\n\tfunction confirmDocument(bytes32 docHash) public returns (bool success);\r\n\r\n\tfunction revokeConfirmation(bytes32 docHash) public returns (bool success);\r\n\r\n\tfunction isDoc(bytes32 docHash) public constant returns (bool isIndeed);\r\n\r\n\tfunction getAllDocument() public view returns (bytes32[] docHashes);\r\n\r\n\tfunction countAllDocument() public view returns (uint count);\r\n\r\n\tfunction getDocAtIndex(uint index) public constant returns(bytes32 docHash);\r\n\r\n\tfunction getDocStatus(bytes32 docHash) public constant returns(address granter, address lawyer, address codeAudit, address beneficiary, bool granterSigned, bool lawyerSigned, bool codeAuditSigned, bool beneficiarySigned);\r\n\r\n\t//make sure none of the 4 address are the same\r\n\tfunction compAddress(address _a, address _b, address _c, address _d) internal pure returns (bool success);\r\n\r\n}\r\n````\r\n\r\n\r\n## Rationale\r\n\r\n### Current Limitation\r\nThe design of this project was motivated by the frustration of bringing more \"private\" asset on chain. Existing solutions do not satisfy situations where paper contracts are needed as the foundation of trust. Simply attaching a file url as metadata does not suffice as its validity cannot be guaranteed. Careful validation is needed before document can be added to token. That is the purpose of this project. \r\n\r\n## Backward Compatibility\r\nThis proposal is compatible with popular token standards. Token issuers can include the document management functionalities by inheriting from this proposal.\r\n\r\n## Test Cases\r\nSample test cases can be found [here](https://github.com/xguan5/Legally-Binding-Token/tree/master/test)\r\n\r\n## Implementation\r\nA sample implementation can be found [here](https://github.com/xguan5/Legally-Binding-Token/tree/master/contracts)\r\n\r\n\r\n\r\n\r\n\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1651/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/451646873",
    "html_url": "https://github.com/ethereum/EIPs/issues/1651#issuecomment-451646873",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651",
    "id": 451646873,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1MTY0Njg3Mw==",
    "user": {
      "login": "EthWarrior",
      "id": 30319378,
      "node_id": "MDQ6VXNlcjMwMzE5Mzc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/30319378?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthWarrior",
      "html_url": "https://github.com/EthWarrior",
      "followers_url": "https://api.github.com/users/EthWarrior/followers",
      "following_url": "https://api.github.com/users/EthWarrior/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthWarrior/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthWarrior/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthWarrior/subscriptions",
      "organizations_url": "https://api.github.com/users/EthWarrior/orgs",
      "repos_url": "https://api.github.com/users/EthWarrior/repos",
      "events_url": "https://api.github.com/users/EthWarrior/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthWarrior/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-05T11:16:27Z",
    "updated_at": "2019-01-05T11:16:27Z",
    "author_association": "NONE",
    "body": "\"However, a smart contract is not a legally binding contract\" I would see that whether agreement is binding or not depends on the agreement between the parties. Parties can choose to use smart contracts to full-fill obligations of their agreements, just like they can choose to use an online platform to invest in crowdfunding or any other functions they want to achieve by agreeing into such. Most of contracts in services are drafted by terms and conditions. Since you can include the fact that you are using smart contracts to execute certain functions between the parties, such agreement and the functions of a smart contract (or a token) would have legal effects based on the agreement between the parties.\r\n\r\nI do however understand the need to link legal documents or any documents with smart contracts. However, who would it be sufficient that when there is terms and conditions or an agreement between parties, the smart contract address that is applicable is added to the terms and conditions of the service or to the agreement (This is something that we have considered in ETHLend actually). I see that one benefit is that the legal document \"link address\" would be immutably stored. However that the roles in various agreements vary a lot. For example, not every contract require a lawyer or the parties want to engage a lawyer for simple agreements. Also from legal perspective a contract usually have the parties but in some cases even more diverse set of participant depending on the agreement (guarantor etc.).\r\n\r\nI am not saying that there should not be document management for tokens, I am just saying that, whether a contract is binding or not depends on the principles of obligations on whether a contract has been concluded or not. Secondly, I think when we are planning for these kind of standards, we should carefully review and map the use-case and knowledge the diversity of the world of contracts since the worst that can happen is that we all are exercising a standard, which is out of sync with the jurisprudence.\r\n\r\nInteresting topic, would like to see how it will evolve.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/451646873/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974757117",
    "html_url": "https://github.com/ethereum/EIPs/issues/1651#issuecomment-974757117",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651",
    "id": 974757117,
    "node_id": "IC_kwDOAq426M46GZz9",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-21T05:09:49Z",
    "updated_at": "2021-11-21T05:09:49Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974757117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986168188",
    "html_url": "https://github.com/ethereum/EIPs/issues/1651#issuecomment-986168188",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1651",
    "id": 986168188,
    "node_id": "IC_kwDOAq426M46x7t8",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-05T05:10:32Z",
    "updated_at": "2021-12-05T05:10:32Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986168188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
