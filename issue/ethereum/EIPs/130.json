{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/130/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/130/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/130/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/130",
  "id": 164467530,
  "node_id": "MDU6SXNzdWUxNjQ0Njc1MzA=",
  "number": 130,
  "title": "Add web3.eth.encrypt method for RPC & web3",
  "user": {
    "login": "danfinlay",
    "id": 542863,
    "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/danfinlay",
    "html_url": "https://github.com/danfinlay",
    "followers_url": "https://api.github.com/users/danfinlay/followers",
    "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
    "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
    "organizations_url": "https://api.github.com/users/danfinlay/orgs",
    "repos_url": "https://api.github.com/users/danfinlay/repos",
    "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
    "received_events_url": "https://api.github.com/users/danfinlay/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 25,
  "created_at": "2016-07-08T06:30:30Z",
  "updated_at": "2022-01-30T02:24:01Z",
  "closed_at": "2022-01-30T02:24:01Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "# Update: Parity Implemented\r\n\r\nThis EIP now recommends that the Parity methods `encryptMessage` and `decryptMessage` be added to the `personal` namespace.\r\n\r\nhttps://github.com/paritytech/parity/wiki/JSONRPC-parity-module#parity_encryptmessage\r\n\r\nBelow is the original post, which is less refined.  Below that is the full discussion.\r\n\r\n\r\n## Specification\r\n\r\nOption 1: Add a new method, `encrypt(account, data, [cb])`, and `decrypt(account, data, [cb])` or something else, that allows a user to encrypt & decrypt arbitrary lengths of data with an account's private key, as well as clarify the documentation of `eth.sign`.\r\n\r\nOption 2: Clarify to current implementations that `eth.sign` should work for arbitrary lengths of data, not only with sha3 hashes, as well as add an `encrypt` method.\r\n## Rationale\r\n\r\nCurrently there is a `web3.eth.sign` method [that is described as a general signature method in the wiki](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign), but in practice, [implementations have made it a de-facto signHash method](https://github.com/ethereum/go-ethereum/issues/2397).\r\n\r\nThere is still a valuable place for a method to sign and encrypt arbitrary data with an account's private key (or an arbitrary public key). For example, using an account's private key can be used to encrypt private data that is stored in public, like personal data. A recent casual example would be saving wallet nicknames in a secure way, but obviously more serious examples abound, including potentially medical data.\r\n\r\nTo reconcile the current lack of a general purpose data signing method, I recommend we either endorse a new method or change the old.  Since applications exist and already rely on the current `eth.sign`, that's probably an inconsiderate option, so I personally think a new method is in order.\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/130/reactions",
    "total_count": 30,
    "+1": 30,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/130/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/231500943",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-231500943",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 231500943,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMTUwMDk0Mw==",
    "user": {
      "login": "aakilfernandes",
      "id": 1577353,
      "node_id": "MDQ6VXNlcjE1NzczNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aakilfernandes",
      "html_url": "https://github.com/aakilfernandes",
      "followers_url": "https://api.github.com/users/aakilfernandes/followers",
      "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
      "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
      "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
      "repos_url": "https://api.github.com/users/aakilfernandes/repos",
      "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-09T00:11:47Z",
    "updated_at": "2016-07-09T00:11:47Z",
    "author_association": "NONE",
    "body": "@flyswatter actually just deleted the comment bc i realized you need a json rpc method, and that is eip fitting\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/231500943/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234444209",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-234444209",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 234444209,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDQ0NDIwOQ==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-22T03:10:40Z",
    "updated_at": "2016-07-22T03:10:40Z",
    "author_association": "NONE",
    "body": "It's not really clear to me how `encrypt(account, data, [cb])` should be defined. From the input it looks like we should be treating the private key corresponding to `account` as a symmetric encryption key and doing symmetric encryption with that key (i.e. no recipient public keys in the input parameters etc). If this is the case then we need to specify the encryption algorithm (AES? Which mode? XSalsa20? something else?) and it seems that we would be moving away quite a bit from what we would expect the RPC spec to support.\n\nIf we are doing asymmetric (public key) encryption/decryption (through something like ECIES), then the inputs to the `encrypt` function should be a public key or a list of public keys that we want to have as targets of the encryption, and we need to define a spec for the structure of the encrypted blob including nonces or IVs etc. Again it seems to be a lot of work that fall outside the realm of expected supported functionality of the RPC spec.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234444209/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234584986",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-234584986",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 234584986,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDU4NDk4Ng==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-22T16:04:36Z",
    "updated_at": "2016-07-22T16:04:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think the method I’m really looking for is better defined as `decrypt(account_number, data, algorithm, [cb])`.\n\nThat’s because I think there’s a valuable place in letting a user decrypt data of an arbitrary size using their private key, unlike the current `eth.sign` method which only supports signing hashes.\n\nThe reason I think this is suitable for the RPC spec is because web3 currently provides a variety of methods which assume the user has a private key. Since web3 is already responsible for exposing an interface to a key pair, and we’re already doing the work of getting users to manage a key pair, it seems very strange that we limit that key to a single function.\n\nTo demonstrate the usefulness of this feature, try to answer this question: If a Ðapp wanted to use ether accounts to allow encrypted communication, what would the flow be?\n\nEncrypting to a public key can actually be done fine outside the scope of web3, so this proposal probably needs some revision, but once a message is received, the user needs a method to decrypt an arbitrary blob with an arbitrary algorithm.\n\nCurrently, there’s no method to formally request this via the web3 interface, so the Ðapp would have to provide some copy-paste text, and trust the user to extract their private key manually, and feed it into an encryption algorithm themselves.\n\nThat’s a lot of work to utilize an encryption key that is held in every wallet. Since web3 has already assumed the job of integrating user-controlled encryption into the browser, I can’t see a better place to finish the feature.\n\nI do understand that these operations aren’t explicitly required for the bare Ethereum protocol itself, but I don’t think web3’s job is to merely support Ethereum, it should aspire to support the next wave of distributed applications, and that includes public key cryptography.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234584986/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/235148822",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-235148822",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 235148822,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNTE0ODgyMg==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-26T02:55:06Z",
    "updated_at": "2016-07-26T02:55:06Z",
    "author_association": "NONE",
    "body": "Yes, a `decrypt` function would be doable I think. But you would still need to define a corresponding `encrypt` function outside of web3, and make sure you can extract the public key in order for people to encrypt to you.\n\nIt's a tricky problem design wise for sure. Currently I'm leaning towards letting various dapps and/or whisper-like protocols handle the key management themselves and using your main Ethereum keys to \"provision\" these encryption keys (by signing the public encryption keys) and associate them to your identity through a registry or similar. But I do agree that there is value in using your keystore for encryption keys as well.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/235148822/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309389060",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309389060",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309389060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTM4OTA2MA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T09:36:03Z",
    "updated_at": "2017-06-19T09:36:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "Any update on this ?\r\n\r\nthe ability to encrypt and decrypt data for the user is a must.\r\n\r\nThe ability to sign arbitrary data with personal_sign has already be proven useful but whenever we want to share private data across device we would require encryption/decryption.\r\n\r\nNote that parity is already implementing something along these line : https://github.com/paritytech/parity/wiki/JSONRPC-parity-module#parity_encryptmessage\r\n\r\nit require the ability to get a public key out of an address though: \r\nhttps://github.com/paritytech/parity/issues/5869\r\n\r\nIt would be great to have it standardised\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309389060/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309536374",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309536374",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309536374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTUzNjM3NA==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T19:05:43Z",
    "updated_at": "2017-06-19T19:11:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd be happy to implement the feature as specified by Parity, but as `eth_encryptMessage` and `eth_decryptMessage` instead of using the parity prefix. I don't understand why Parity made this method platform-specific. Maybe @gavofyork would like to comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309536374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309537063",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309537063",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309537063,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTUzNzA2Mw==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T19:08:19Z",
    "updated_at": "2017-06-19T19:08:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "One reason might be that the `decrypt` method requires using accounts, so this means it requires a signer, which may not be the appropriate responsibility of the `eth_` prefix. Maybe then this belongs on the `personal_` API?\r\n\r\nAlso, since you don't need access to private keys to `encrypt`, it might make just as much sense to keep it on a separate utility.\r\n\r\nReally what you need is a `personal_decrypt` function, and maybe nothing else, so you could rely on utility libraries like [eth-sig-util](https://github.com/MetaMask/eth-sig-util) for encrypting to public keys.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309537063/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309559968",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309559968",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309559968,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU1OTk2OA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T20:11:54Z",
    "updated_at": "2017-06-19T20:11:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "encrypting would still require to get the public key out of the ethereum address \r\n\r\nmaybe a ```personal_getPublicKey``` ?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309559968/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309573485",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309573485",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309573485,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU3MzQ4NQ==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T21:05:38Z",
    "updated_at": "2017-06-19T21:05:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "That's not a bad idea. like, `personal_getPublicKey(address)`.\r\n\r\nRight now you can also get the public key from any signature, so like `personal_sign`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309573485/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309582985",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309582985",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309582985,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU4Mjk4NQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T21:46:23Z",
    "updated_at": "2017-06-19T21:46:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "except ```personal_sign``` require confirmation while ```personal_getPublicKey``` should not require any",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309582985/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309583265",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309583265",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309583265,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU4MzI2NQ==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T21:47:47Z",
    "updated_at": "2017-06-19T21:47:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "Maybe. My understanding is that the whole \"Ethereum address as hash of public key\" thing is a security measure to protect the public key. If that's the case, automatically returning the public key would be a security issue. I'm not clear what that concern was, though. Would appreciate if someone could clarify it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309583265/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309584241",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309584241",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309584241,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU4NDI0MQ==",
    "user": {
      "login": "aakilfernandes",
      "id": 1577353,
      "node_id": "MDQ6VXNlcjE1NzczNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1577353?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aakilfernandes",
      "html_url": "https://github.com/aakilfernandes",
      "followers_url": "https://api.github.com/users/aakilfernandes/followers",
      "following_url": "https://api.github.com/users/aakilfernandes/following{/other_user}",
      "gists_url": "https://api.github.com/users/aakilfernandes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aakilfernandes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aakilfernandes/subscriptions",
      "organizations_url": "https://api.github.com/users/aakilfernandes/orgs",
      "repos_url": "https://api.github.com/users/aakilfernandes/repos",
      "events_url": "https://api.github.com/users/aakilfernandes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aakilfernandes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T21:52:18Z",
    "updated_at": "2017-06-19T21:52:18Z",
    "author_association": "NONE",
    "body": "@flyswatter i believe the main issue is that quantum computers can more easily (not sure how practically feasible it is) turn public keys into private keys. However, the public key is (I believe) made public with each transaction. In theory a node could track all the public keys of all known transactions and add them to a database.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309584241/reactions",
      "total_count": 4,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309585414",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309585414",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309585414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTU4NTQxNA==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-19T21:57:40Z",
    "updated_at": "2017-06-19T21:57:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, the public key is made public with each transaction, so maybe we can accept that web3-browsers are \"hot\" enough that their public keys are assumed public, and the address-protection is more a resilience for cold wallets that have never been used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309585414/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309657746",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-309657746",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 309657746,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTY1Nzc0Ng==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T06:31:09Z",
    "updated_at": "2017-06-20T06:31:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "I agree, especially since once it is out it is out. It would be hard to explain to the user without scaring him that once it accept to release its public key it would be given forever",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/309657746/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329770999",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-329770999",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 329770999,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyOTc3MDk5OQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-15T12:38:31Z",
    "updated_at": "2017-09-15T12:38:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd like to propose a different signature to make encrypt non vulnerable to a certain type of malicious dapp\r\n\r\nInstead of \r\n```\r\ndecrypt(account_number, data, algorithm, [cb])\r\n```\r\n\r\nit would be\r\n\r\n\r\n```\r\ndecrypt(account_number, origin, data, algorithm, [cb])\r\n```\r\n\r\nThe extra parameter ```origin``` purpose is to ensure a malicious dapp cannot request to decrypt data encrypted by another.\r\n\r\n# Let me explain by giving an example:\r\n\r\nLet say a user is navigating to \"onedapp.eth\", The user trust that url and the javascript served from it. This dapp is not a malicious one and it deal with confidential data.\r\n\r\nThe javascript call encrypt and store that data in a deterministic location for later retriveal. Let say that such location can be known by anone having the user's address.\r\n\r\nThe user is then navigating to a new url \"anotherdapp.eth\".\r\nThe user is trusting its signer to protect them from malicious dapps. \r\nThe javascript file from \"anotherdapp.eth\" download the data from the deterministic location and request the signer to decrypt the confidential data encrypted by the trusted dapp above. \r\n\r\nIf the version of encrypt without origin was used, the signer could not know whether that javascript is allowed to request decryption or not.\r\n\r\nAnd from the user point of view, it is impossible to know if \"anotherdapp.eth\" javascript is requesting to decrypt data that it has encrypted in an earlier visit to \"anotherdapp.eth\" and might accept it because it trusts its signer.\r\n\r\nOn the other hand, if origin was provided and stored along with the encrypted data, the signer can simply refuse the \"anotherdapp.eth\" javascript to request decryption from the user by checking the origin stored and the domain from which that javascript comes from.\r\n\r\n# It can work this way:\r\n\r\nthe dapp who want to encrypt data set ```origin``` to be the domain, swarm hash ... (or a multitude of them) allowed to decrypt it later\r\n\r\nThe origin is prefixed to the data, the data is then encrypted with the user public key. The dapp then store it somewhere\r\n\r\nWhen a dapp request decryption, the signer decrypt it but check the prefix before sending the decrypted data to the dapp and interpret it as the allowed domains. \r\n\r\nIf they match the domain,swarm hash... where the javascript come from ***the signer could even skip asking the user***, allowing dapp to provide a seamless experience to sync data across devices.\r\n\r\nIf they do not match, the signer refuse directly by giving an \"not authorized\" error\r\n\r\nIf no ```origin``` are specified, we could fallback to the behavior without ```origin``` but signer should present a warning message both for encryption and decryption.\r\n\r\nI suspect the use of empty origin would only make sense when the caller is a human. When a javascript file is involved the trust involved means decryption should be prefixed at least with the origin from which the javascript file originate.\r\n\r\nThis brings another possibility for when ```origin``` is empty : the signer set automatically it to be the domain from where the javascript file requesting encryption come from\r\n\r\nNote that, if it is manually provided (non empty), all domain provided should be considered. Alowing dapps to provide multiple domain or a combination of swarm hash, domain...\r\n\r\n\r\n# Note \r\nWhile we could use a convention so the data to be encrypted require to have a prefix interepreted as origin, I think the ```origin``` parameter is more explicit and force dapps to provide it explicitely.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329770999/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347611874",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-347611874",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 347611874,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NzYxMTg3NA==",
    "user": {
      "login": "catageek",
      "id": 1443839,
      "node_id": "MDQ6VXNlcjE0NDM4Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1443839?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catageek",
      "html_url": "https://github.com/catageek",
      "followers_url": "https://api.github.com/users/catageek/followers",
      "following_url": "https://api.github.com/users/catageek/following{/other_user}",
      "gists_url": "https://api.github.com/users/catageek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catageek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catageek/subscriptions",
      "organizations_url": "https://api.github.com/users/catageek/orgs",
      "repos_url": "https://api.github.com/users/catageek/repos",
      "events_url": "https://api.github.com/users/catageek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catageek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-28T18:07:28Z",
    "updated_at": "2017-11-28T18:07:28Z",
    "author_association": "NONE",
    "body": "@wighawag Instead of twisting an encrypt/decrypt scheme with the 'origin' data, I would incline to the usage of an authenticated signature stored with the encrypted data, from the eth.sign() function for example, or a HMAC. I prefer a bare encrypt/decrypt with more security around.\r\n\r\nI wonder if it is possible to have access to more operations on the key. for example, to build a linkable ring signature, we must perform modular operation with the private key. Today there is no way to do this operation, or entirely out-of-band. This need is in line with #208 where users will be able to adopt other schemes than ECDSA.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347611874/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347669126",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-347669126",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 347669126,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NzY2OTEyNg==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-28T21:27:18Z",
    "updated_at": "2017-11-28T21:27:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "What do you mean by twisting? it is basically just an extra field that can be used for dapp to indicate they were the one requesting encryption (or more accurately, who is allowed to decrypt ). \r\n\r\nThe signer is responsible to ensure that other dapps which do not match the \"origin\" field are not allowed to decrypt the encrypted data.\r\n\r\nNote that the use of origin on encryption does not require confirmation from the dapp's user since it only requires its public key (assuming the signer give access to such public key from the address). So the api flow stay the same.\r\n\r\nOn the other hand the use of eth.sign would require confirmation of the user but I am not sure to follow where eth.sign compete with \"origin\".\r\n\r\nThe idea behind the \"origin\" field is to allow dapp to encrypt data without the risk of another dapp decrypting it ( and thus exposing potential confidential data). \r\n\r\nBy providing \"origin\" it would also allow the dapp that fit the \"origin\" field to request decryption **without confirmation** (as \"origin\" indicates that it was that same dapp who requested encryption in the first place ( = it had access to the decrypted data and thus there would be no point to ask confirmation for decryption,  providing a nice user experience for dapp that require saving encrypted data regularly on behalf of the user) ). \r\n\r\neth.sign would add a confirmation flow in encryption  and would not protect another dapp for requesting decryption unless there is a field (like origin) indicating who/which dapp requested encryption in the first place and signer take this field in consideration before giving out the decrypted data.\r\n\r\nBut maybe I missed something?\r\n\r\nI am not sure how linkable ring signature relates to the \"origin\" field and its added safety. Could you explain a bit more?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347669126/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347951954",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-347951954",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 347951954,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0Nzk1MTk1NA==",
    "user": {
      "login": "catageek",
      "id": 1443839,
      "node_id": "MDQ6VXNlcjE0NDM4Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1443839?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catageek",
      "html_url": "https://github.com/catageek",
      "followers_url": "https://api.github.com/users/catageek/followers",
      "following_url": "https://api.github.com/users/catageek/following{/other_user}",
      "gists_url": "https://api.github.com/users/catageek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catageek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catageek/subscriptions",
      "organizations_url": "https://api.github.com/users/catageek/orgs",
      "repos_url": "https://api.github.com/users/catageek/repos",
      "events_url": "https://api.github.com/users/catageek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catageek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-29T18:28:35Z",
    "updated_at": "2017-11-29T18:28:35Z",
    "author_association": "NONE",
    "body": "Hi @wighawag \r\n\r\nForget the point about linkable ring signature, it has nothing to do with encrypt/decrypt. It is just a thought I had when writing.\r\n\r\nIt is a good idea to have an 'origin' or something like that to define who has the right to get the plain data. There are one major issue that I see with the implementation of origin that you detail: the decryption comes before the verification of the access right. This is not a good practice and there is no way to prevent any web site to request an access to the data, with the user having to enter his password to validate the (possibly fake) request. It will be very intrusive.\r\n\r\nSo, instead of storing:\r\n`ECIES(origin||data)`\r\n\r\nwe need to store origin in plain text to validate the request:\r\n`ECIES(data), origin`\r\n\r\nBut now, origin is not protected against unwanted modification.\r\n\r\nSo I thought a lot about a better solution. Here it is:\r\n\r\nWhen a dapp wants to encrypt some data:\r\n\r\n1. A pair of key (Pk,pk) of secp256k is generated or provided by the dapp\r\n2. We compute E = ECIES(data) using Pk\r\n3. We compute S = ECDSA(E||origin) using pk\r\n4. We compute Ek = ECIES(pk) using the public key of the user\r\n5. We store (E, S, origin, Ek) in the user storage\r\n\r\nWhen a dapp wants to decrypt the data:\r\n\r\n1. We check the signature S using E||origin\r\n2. We check origin against the dapp request\r\n3. If origin is accepted, we decrypt Ek to get pk (needs user password)\r\n4. We check that pk is the private key that signed S\r\n5. We decrypt E with pk to get data\r\n\r\nSo, to encrypt we do not need the user's password, and to decrypt we ask the password after the origin check. It is up to the dapp to decide if it keeps Pk and pk.\r\n\r\nWe can define (Pk,pk) as an **external account** protected by the user's password: It would be wise that clients manage these kind of accounts that would be potentially shared by the dapps.\r\n\r\nWe could also rename origin to acl, for access list because it is what it defines, and because we have ECDSA(E||acl) we can manage the access control in chain with a transaction tx = E||acl signed by Pk and received by a smart contract that will manage the access, like parity did with [secret store](https://github.com/paritytech/parity/wiki/Secret-Store). When the called contract will be able to pay for the transaction, it will possible without the intervention of the user.\r\n\r\nSo:\r\n\r\n- We need to define the **semantics of origin aka acl**\r\n- We need to define and implement **external accounts**, ie account for which the private key is shared with the dapp\r\n- We need to have more controls on secp256k curve to get some keys and sign messages without the need of a personal account involved in the process, but external accounts will be able to use it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/347951954/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348030045",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-348030045",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 348030045,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODAzMDA0NQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-29T23:20:31Z",
    "updated_at": "2017-11-29T23:20:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "@catageek Thanks for a more details answer but I am not sure I get your proposal. \r\n\r\nThe key purpose of the ```origin``` field (which I agree to rename to ```access_list``` or something similar) is that it is checked by the signers, not the dapps. In your proposal the signer seems absent and as such I do not see how it will prevent other dapp from requesting the data from the user. I am not sure what is \"We\" in your proposal? \r\n\r\n> There are one major issue that I see with the implementation of origin that you detail: the decryption comes before the verification of the access right. This is not a good practice and there is no way to prevent any web site to request an access to the data, with the user having to enter his password to validate the (possibly fake) request. It will be very intrusive.\r\n\r\nYou did not seem to understand here the involvement of the signer. The signer's role is to prevent unauthorized access to the data. The signer would decrypt first but check the ```access_list``` field **before** sending out the decrypted data to the dapp. In other words,  while decryption happen before, it is not given to the dapp until the ```access_list``` field is checked. By decrypting first there is no need for a signature when encrypting, allowing dapps to encrypt without user intervention. Furthermore there would be no need for user intervention in decrypting too since ```access_list``` would have been decided by the dapp that encrypted the data in the first place, which is pretty nice.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348030045/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348080608",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-348080608",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 348080608,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODA4MDYwOA==",
    "user": {
      "login": "catageek",
      "id": 1443839,
      "node_id": "MDQ6VXNlcjE0NDM4Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1443839?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catageek",
      "html_url": "https://github.com/catageek",
      "followers_url": "https://api.github.com/users/catageek/followers",
      "following_url": "https://api.github.com/users/catageek/following{/other_user}",
      "gists_url": "https://api.github.com/users/catageek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catageek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catageek/subscriptions",
      "organizations_url": "https://api.github.com/users/catageek/orgs",
      "repos_url": "https://api.github.com/users/catageek/repos",
      "events_url": "https://api.github.com/users/catageek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catageek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T04:38:39Z",
    "updated_at": "2017-11-30T04:38:39Z",
    "author_association": "NONE",
    "body": "@wighawag \r\n\r\n> The key purpose of the origin field (which I agree to rename to access_list or something similar) is that it is checked by the signers, not the dapps. In your proposal the signer seems absent and as such I do not see how it will prevent other dapp from requesting the data from the user. I am not sure what is \"We\" in your proposal?\r\n\r\nI deliberately used 'We' because, in my opinion, the operations are to be distributed to different actors: the dapp, the client( Geth, Parity, etc.) and the user. it is not defined who is 'We' in each operation.\r\n\r\nIf another dapp wants the data, it will have to match the access list policy (defined by the original dapp), and this first check is made before the user intervention, and only after the user has to decrypt the external account key. The user can check the acl at this step, like:\r\n\r\n> dapp at othedapp.eth wants to open external acount originaldapp.eth. This operation is authorized by the (local|contract) access list [other details here]. Do you want to proceed ?''\r\n\r\nSuch a message will not pop up if the access list did not match early in the process, protecting the user from annoying pop ups.\r\n\r\n> Furthermore there would be no need for user intervention in decrypting too since access_list would have been decided by the dapp that encrypted the data in the first place, which is pretty nice.\r\n\r\nIf I try to rephrase, you want the dapp to provide a secret at encryption and decryption, and you want the user to check this secret before giving the data. This implies that the dapp stores this secret on her side, in a (centralized) database. This implies also that the user will check if she trusts otherdapp.eth if it provides the good secret, without knowing if the access is legitimate or fraudulent (it may be wanted by original dapp, but original dapp could have been hacked, or leaked the secret).\r\n\r\nWhat I propose is that the original dapp provides an access list policy, that can be local or on chain. The dapp does not keep anything on her side, and this simplifies a lot the system and is in line with its essence of 'decentralized application'. The access list may contain any address that the original dapp provides, and it is upgradeable. It allows a dapp to share some data with another dapp, or to share some data with its upgraded version. The user has only to check that the access list is legitimate, and does not have to decide if otherdapp is legitimate or not: if original dapp has recorded otherdapp in the access list, then it is legitimate.\r\n\r\nBasically, the dapps says implicitly 'here is some data and the access list policy associated with it, please protect the data and respect the access policy when giving access to the data'.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348080608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348147053",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-348147053",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 348147053,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODE0NzA1Mw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T10:27:30Z",
    "updated_at": "2017-11-30T10:28:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Such a message will not pop up if the access list did not match early in the process, protecting the user from annoying pop ups.\r\n\r\nThis is also achieved using the simple ```access_list``` field since the signer will only show a \"non authorized\" popup when a malicious dapp will request to decrypt the data. There would be no popup otherwise\r\n\r\n> If I try to rephrase, you want the dapp to provide a secret at encryption and decryption, and you want the user to check this secret before giving the data. This implies that the dapp stores this secret on her side, in a (centralized) database. This implies also that the user will check if she trusts otherdapp.eth if it provides the good secret, without knowing if the access is legitimate or fraudulent (it may be wanted by original dapp, but original dapp could have been hacked, or leaked the secret).\r\n\r\nNo that is not how it works, there is no extra \"secret\" involved and dapps do not require to store any extra info :\r\n\r\nI ll just describe the flow :\r\n\r\nimagine a Dapp :\r\n1) its javascript file from swarm hash \"0xeeeee\" generate confidential data\r\n2) this same javascript request the signer to encrypt data (with access_list set to be \"0xeeeee\")\r\n3) signer simply encrypt using the user public key (or alternatively the javascript have access to that public key and encrypt the data itself)\r\n4) the dapp save that encrypted data somewhere\r\n\r\nthe user leave the page\r\nand come back to it later\r\n\r\n5) the javascript  file from swarm hash \"0xeeeee\" get the encrypted data back\r\n6) it then call decrypt \r\n7) the signer decrypt the data (keeping it to himself at this stage)\r\n8) the signer check if the ```access_list``` field exists and match the origin of the javascript file requesting decryption (in that case this is  \"0xeeeee\")\r\n9) since it matches, the signer give the decrypted data back without requesting permission from the user\r\n  In case the request was coming from a different swarm hash, the signer would reject and not give back the decrypted data (could show a \"non authorized popup\" alerting the user of what that dapp tried to do)\r\n \r\nHope it makes sense. The important bit is that the signer is capable of checking from where the javascript file come from, similar to web browsers. \r\n\r\n> Basically, the dapps says implicitly 'here is some data and the access list policy associated with it, please protect the data and respect the access policy when giving access to the data'.\r\n\r\nThis is what my proposal aims to do too by sending that message (```'here is some data and the access list policy associated with it, please protect the data and respect the access policy when giving access to the data'```) to the signer. I did not get yet how yours do it though.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348147053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348278864",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-348278864",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 348278864,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODI3ODg2NA==",
    "user": {
      "login": "catageek",
      "id": 1443839,
      "node_id": "MDQ6VXNlcjE0NDM4Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1443839?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catageek",
      "html_url": "https://github.com/catageek",
      "followers_url": "https://api.github.com/users/catageek/followers",
      "following_url": "https://api.github.com/users/catageek/following{/other_user}",
      "gists_url": "https://api.github.com/users/catageek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catageek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catageek/subscriptions",
      "organizations_url": "https://api.github.com/users/catageek/orgs",
      "repos_url": "https://api.github.com/users/catageek/repos",
      "events_url": "https://api.github.com/users/catageek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catageek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T18:32:29Z",
    "updated_at": "2017-11-30T18:32:29Z",
    "author_association": "NONE",
    "body": "Ok I get your point: you wish [same origin policy](https://en.wikipedia.org/wiki/Same-origin_policy) for the encrypted data, and my proposal looks more like [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) because I think that there will be some needs to have cross-dapp data.\r\n\r\nMaybe the CORS/SOP topic should be separated from the encrypt/decrypt topic.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348278864/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348322784",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-348322784",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 348322784,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODMyMjc4NA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T21:14:25Z",
    "updated_at": "2017-11-30T21:14:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "> you wish same origin policy for the encrypted data\r\n\r\nThat's correct, that's where I picked the word \"origin\" but the main difference here is that the location of data is not relevant, hence it is not protecting \"access\" as such, but \"decryption\". Hence this scheme allows data to be stored anywhere. \r\n\r\n> Maybe the CORS/SOP topic should be separated from the encrypt/decrypt topic.\r\n\r\nI won't comment about your proposal but for ```access_list``` proposal I strongly disagree: It is important for that field to be part of the encryption api since it protects from malicious dapp to request decryption of data encrypted by third party dapps. It is also adding potential user experience benefit that should not be taken lightly. \r\n\r\nI thus strongly recommend adding that field to the encryption api and make it a mandatory standard for signers to consider it when dealing with encrypted data. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348322784/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013794823",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-1013794823",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 1013794823,
    "node_id": "IC_kwDOAq426M48bUgH",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-16T02:06:32Z",
    "updated_at": "2022-01-16T02:06:32Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013794823/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025053071",
    "html_url": "https://github.com/ethereum/EIPs/issues/130#issuecomment-1025053071",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/130",
    "id": 1025053071,
    "node_id": "IC_kwDOAq426M49GRGP",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-30T02:24:00Z",
    "updated_at": "2022-01-30T02:24:00Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025053071/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
