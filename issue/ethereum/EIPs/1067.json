{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1067",
  "id": 321081202,
  "node_id": "MDU6SXNzdWUzMjEwODEyMDI=",
  "number": 1067,
  "title": "ERC-1067 (ERC extension)",
  "user": {
    "login": "techracers-blockchain",
    "id": 39080477,
    "node_id": "MDQ6VXNlcjM5MDgwNDc3",
    "avatar_url": "https://avatars.githubusercontent.com/u/39080477?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/techracers-blockchain",
    "html_url": "https://github.com/techracers-blockchain",
    "followers_url": "https://api.github.com/users/techracers-blockchain/followers",
    "following_url": "https://api.github.com/users/techracers-blockchain/following{/other_user}",
    "gists_url": "https://api.github.com/users/techracers-blockchain/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/techracers-blockchain/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/techracers-blockchain/subscriptions",
    "organizations_url": "https://api.github.com/users/techracers-blockchain/orgs",
    "repos_url": "https://api.github.com/users/techracers-blockchain/repos",
    "events_url": "https://api.github.com/users/techracers-blockchain/events{/privacy}",
    "received_events_url": "https://api.github.com/users/techracers-blockchain/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2018-05-08T07:57:54Z",
  "updated_at": "2021-12-20T04:15:11Z",
  "closed_at": "2021-12-20T04:15:11Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "> ERC: 1067\r\n> Title: Token standard\r\n> Author: Techracers\r\n> Status: Draft\r\n> Type: ERC\r\n> Created: 5-08.2018\r\n> Recommended implementation: https://github.com/techracers-blockchain/ERC-1067\r\n\r\n## Abstract\r\nToken contract usually have a monolithic design that is not friendly to upgrades. The following proposal describes a more distributed token contract architecture that has a simple upgrade-ability protocol and allows to bring in new functions after being deployed.\r\n\r\n## Motivation\r\nThere have been countless number of tokens where due to the inability to upgrade and fix bugs, contract holders have lost millions of dollars. A simple bug that might take days, months, or years to solve, can be solved simply and quickly using the ERC-1067 standard.\r\n\r\nThere exist approaches that includes an upgrade agent, which has its own limitations and restrictions and sometimes might not lead to a successful upgrade implementation. It has to include all token holders, and might cost a lot.\r\n\r\nIf there is a simple bug that was left out during the deployment of a token contract, it might result in the loss of millions of dollars. There have been a number of token contracts owners, who have come to us after the token sale with bugs that have no workaround but to cost a lot of time and money. If instead, we had an upgrade-ability protocol that allows rapid fast upgrades at low cost, such accidents can be rectified.\r\n\r\nThis will allow contracts to pause and handle bugs and allow them to fix bugs or upgrade the ERC standard to a newer one.\r\nThis standard has the ability to be cross compatible with any other monolithic ERC interface like the ERC20, ERC223, ERC721, ERC827 etc.\r\n\r\n## Specification\r\nThe following Upgradeable Token approach requires\r\n\t\r\n\r\n- a DataCentre contract that has a few sets of getter setter methods that allows us to keep the data at a separate location\t\r\n- that the token contract interacts with, reads and writes all the data into the DataCentre.\r\n\r\n## Methods\r\nAll of the ERC20 functions remain the same in essence. We interact with the DataCentre and write all the data into our DataCentre.\r\n\r\nAll the calls fetch data from the DataCentre, the supporting DataCentre function is written below each call-\r\n\r\n**totalSupply**\r\n_Token-_\r\n```\r\nfunction totalSupply() public constant returns (uint256) {\r\n\treturn DataCentre(dataCentreAddr).getValue(\"STK\", \"totalSupply\");\r\n}\r\n```\r\n\r\n_DataCentre-_\r\n```\r\nfunction getValue(bytes32 _container, bytes32 _key) public {\r\n\tcontainers[_container].values[_key] = _value;\r\n}\r\n```\r\n\r\n**balanceOf(address)**\r\n\r\nGet the account balance of another account with address _owner\r\n\r\n_Token-_\r\n\r\n```\r\nfunction balanceOf(address _owner) public constant returns (uint256) {\r\n\treturn DataCentre(dataCentreAddr).getBalanace(\"STK\", _owner);\r\n}\r\n```\r\n\r\n_DataCentre-_\r\n\r\n```\r\nfunction getBalance(bytes32 _container, address _key) public constant returns(uint256) {\r\n\treturn containers[_container].balances[_key];\r\n}\r\n```\r\n\r\n**transfer(address, uint)**\r\n_Token-_\r\n\r\n```\r\nfunction transfer(address to, uint value) public returns (bool) {\r\n\trequire(_to != address(this));\r\n\trequire(_to != address(0));\r\n\trequire(_amount > 0);\r\n\t_setBalanceOf(_from, balanceOf(_from).sub(_amount));\r\n\t_setBalanceOf(_to, balanceOf(_to).add(_amount));\r\n\tTransfer(_from, _to, _amount);\r\n\treturn true;\r\n}\r\n```\r\n_Internal Function-_ \r\n\r\n```\r\nfunction _setBalanceOf(address _owner, uint256 _newValue) internal {\r\n        DataCentre(dataCentreAddr).setBalanace(\"STK\", _owner, _newValue);\r\n}\r\n```\r\n   \r\n\r\n_DataCentre-_\r\n\r\n```\r\nfunction setBalance(bytes32 _container, address _key, uint256 _value) public onlyOwner {\r\n\tcontainers[_container].balances[_key] = _value;\r\n}\r\n\r\n```\r\nThe owner of the DataCentre contract is always the Token contract.\r\n\r\n## Upgradeability Protocol\r\n\r\nThe token contract has some simple measures through which an upgrade can be made in just 2 transactions-\r\n\r\n1. Deploy new token contract\r\n2. Kill the old token contract.\r\n\r\nThe kill function looks like below-\r\n```\r\n\r\nfunction kill(address _newTokenContract) public onlyOwner {\r\n\tif (dataCentreAddr != address(0)) {\r\n\t\tOwnable(dataCentreAddr).transferOwnership(_newTokenContract);\r\n\t}\r\n\tselfdestruct(_newTokenContract);\r\n}\r\n```\r\n\r\n## Recommended implementation\r\nThis is highly recommended implementation of ERC-1067 token:\r\n[https://github.com/techracers-blockchain/ERC-1067](https://github.com/techracers-blockchain/ERC-1067)\r\n\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1067/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/388064689",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-388064689",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 388064689,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4ODA2NDY4OQ==",
    "user": {
      "login": "LucasAschenbach",
      "id": 37406743,
      "node_id": "MDQ6VXNlcjM3NDA2NzQz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37406743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LucasAschenbach",
      "html_url": "https://github.com/LucasAschenbach",
      "followers_url": "https://api.github.com/users/LucasAschenbach/followers",
      "following_url": "https://api.github.com/users/LucasAschenbach/following{/other_user}",
      "gists_url": "https://api.github.com/users/LucasAschenbach/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LucasAschenbach/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LucasAschenbach/subscriptions",
      "organizations_url": "https://api.github.com/users/LucasAschenbach/orgs",
      "repos_url": "https://api.github.com/users/LucasAschenbach/repos",
      "events_url": "https://api.github.com/users/LucasAschenbach/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LucasAschenbach/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-10T14:09:37Z",
    "updated_at": "2018-05-10T14:15:21Z",
    "author_association": "NONE",
    "body": "I just developed a token with this particular structure and it works seamlessly for updates - totally recommend it!\r\n\r\nHowever, we would have to add, aside from the getters and setters inside the DataCentre (I called it Storage) a Communicator contract, storing all contract addresses which may access the setters, provided by the Storage contract, to make sure that the variables cannot be manipulated by unknown sources.\r\n\r\n```\r\npragma solidity ^0.4.21;\r\n\r\nimport \"./Owned.sol\";\r\n\r\n\r\ncontract Communicator is Owned {\r\n\r\n    mapping(bytes32 => address) public communicatorContract;\r\n\r\n    event CommunicatorContractAdded(address indexed addedCommunicatorContract);\r\n    event CommunicatorContractRemoved(address indexed oldCommunicatorContract);\r\n\r\n\r\n\r\n    modifier communicatorContractOnly {\r\n        require(communicatorContract[keccak256(msg.sender)] != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier communicatorOrOwner {\r\n        require(communicatorContract[keccak256(msg.sender)] != 0x0 || msg.sender == contractOwner);\r\n        _;\r\n    }\r\n\r\n    function addCommunicatorContract(address _newCommunicatorContract) external communicatorOrOwner {\r\n        communicatorContract[keccak256(_newCommunicatorContract)] = _newCommunicatorContract;\r\n        emit CommunicatorContractAdded(_newCommunicatorContract);\r\n    }\r\n\r\n    function removeCommunicatorContract(address _oldCommunicatorContract) external communicatorOrOwner {\r\n        communicatorContract[keccak256(_oldCommunicatorContract)] = 0x0;\r\n        emit CommunicatorContractRemoved(_oldCommunicatorContract);\r\n    }\r\n}\r\n```\r\n\r\nFurthermore, every contract, listed as a communicatorContract would need to inherit a Linked contract, providing the underlying contract with the address of the Storage contract and implementing the functionality of the owner contract, inherited by Storage.\r\n\r\n```\r\npragma solidity ^0.4.21;\r\n\r\nimport \"./Storage.sol\";\r\n\r\n\r\ncontract Linked {\r\n\r\n    Storage public core;\r\n\r\n    constructor(address _storageContract) public {\r\n        core = Storage(_storageContract);\r\n    }\r\n\r\n    modifier contractOwnerOnly {\r\n        address contractOwner = core.contractOwner();\r\n        require(contractOwner == msg.sender);\r\n        _;\r\n    }\r\n}\r\n```\r\n\r\n\r\nYet, this would really put the trust of the token users to test as the contract owner could now arbitrarily change the entire smart contract structure and potentially render the token overnight worthless.\r\nTo prevent this from happening, this structure requires another contract to which, immediately after deployment, the ownership of the Storage contract is transferred to. This contract would feature a shareholder structure so that the number of shares, one address owns, is directly proportional to the number of votes it gets to vote for update/withdraw/... proposals.\r\nThe map, storing the number of shares would then also be stored inside the storage contract and if the shareholders would want to alter the contract, they could vote to transfer the ownership to a different contract and, subsequently, terminate this one.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/388064689/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389121166",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-389121166",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 389121166,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTEyMTE2Ng==",
    "user": {
      "login": "techracers-blockchain",
      "id": 39080477,
      "node_id": "MDQ6VXNlcjM5MDgwNDc3",
      "avatar_url": "https://avatars.githubusercontent.com/u/39080477?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/techracers-blockchain",
      "html_url": "https://github.com/techracers-blockchain",
      "followers_url": "https://api.github.com/users/techracers-blockchain/followers",
      "following_url": "https://api.github.com/users/techracers-blockchain/following{/other_user}",
      "gists_url": "https://api.github.com/users/techracers-blockchain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/techracers-blockchain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/techracers-blockchain/subscriptions",
      "organizations_url": "https://api.github.com/users/techracers-blockchain/orgs",
      "repos_url": "https://api.github.com/users/techracers-blockchain/repos",
      "events_url": "https://api.github.com/users/techracers-blockchain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/techracers-blockchain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-15T10:33:37Z",
    "updated_at": "2018-05-15T10:33:37Z",
    "author_association": "NONE",
    "body": "Thanks a lot for sharing your views on this token architecture, Lucas!\r\nComing back to your suggestions, all of which are really good ones, we believe that those can be add-ones rather than build them right into the interface. \r\n\r\n- The Communicator contract would be a requirement if we want **multiple** contracts to interact with our DataCentre. For a simple ERC20 like token architecture, I think just 1 **owner** should more than suffice the requirements. I would definitely use that in case we have multiple token contracts using the same Data Centre.\r\n\r\n- Similarly, the Linked contract spawns out of our Communicator contract addition and would be something that we would like to omit.\r\n\r\n- The 3rd suggestion is something we have already thought about because a voting mechanism would more than help token stakeholders to reach a consensus on the upgrade process. But it has its own loopholes and that is why we didn't want to build it right into the interface. The major problems are- \r\n\r\n  1. Majority of tokens with founders. \r\n  2. Token holders might keep transferring tokens to different addresses and continue voting, which is unidentifiable with non-fungible tokens.\r\n  3. In order to circumvent 2, we might have to build in a transfer lock mechanism so that multiple votes cannot come through using the same tokens, but it will simply make the interface heavier and people might not like locking down their tokens.\r\n\r\nI think the proposal more than provides a very standard interface and protocols on which other methods and add-ones can be implemented. \r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389121166/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389966009",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-389966009",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 389966009,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTk2NjAwOQ==",
    "user": {
      "login": "LucasAschenbach",
      "id": 37406743,
      "node_id": "MDQ6VXNlcjM3NDA2NzQz",
      "avatar_url": "https://avatars.githubusercontent.com/u/37406743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LucasAschenbach",
      "html_url": "https://github.com/LucasAschenbach",
      "followers_url": "https://api.github.com/users/LucasAschenbach/followers",
      "following_url": "https://api.github.com/users/LucasAschenbach/following{/other_user}",
      "gists_url": "https://api.github.com/users/LucasAschenbach/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LucasAschenbach/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LucasAschenbach/subscriptions",
      "organizations_url": "https://api.github.com/users/LucasAschenbach/orgs",
      "repos_url": "https://api.github.com/users/LucasAschenbach/repos",
      "events_url": "https://api.github.com/users/LucasAschenbach/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LucasAschenbach/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-17T18:35:03Z",
    "updated_at": "2018-05-17T18:35:03Z",
    "author_association": "NONE",
    "body": "Thank you for the feedback on my suggestions and especially for the issues you raised about the shareholder contract!\r\n\r\nI just have one more remark I would like to share, regarding my first and second suggestion. Seeing as the sole purpose of this contract structure lies in providing updatability, it can safely be implied that its adapters will want to actually update their contract from time to time. However, in this case, every update would require the contract owner to delete the entire 'functions contract', add changes as desired, and then deploy the contract again on the blockchain. In most cases, though, the contract owner will probably merely add new functions to the contract and, still, will not just have to pay for deploying the added functions but also all the other functions which have been previously contained by the contract. When talking about a very basic token, these additional costs may be noticeable but not earth-shattering. However, with more complex tokens, this will create substantial additional costs for updates.\r\n\r\nIf new functions, on the other hand, would be added in a new contract, the update costs would be reduced significantly. Therefore, I think, the Communicator contract would in fact provide a true upside for this structure, regardless of whether there are multiple tokens stored in the DataCentre or just one.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389966009/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/494138089",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-494138089",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 494138089,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NDEzODA4OQ==",
    "user": {
      "login": "guylando",
      "id": 14879163,
      "node_id": "MDQ6VXNlcjE0ODc5MTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/14879163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guylando",
      "html_url": "https://github.com/guylando",
      "followers_url": "https://api.github.com/users/guylando/followers",
      "following_url": "https://api.github.com/users/guylando/following{/other_user}",
      "gists_url": "https://api.github.com/users/guylando/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guylando/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guylando/subscriptions",
      "organizations_url": "https://api.github.com/users/guylando/orgs",
      "repos_url": "https://api.github.com/users/guylando/repos",
      "events_url": "https://api.github.com/users/guylando/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guylando/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-20T20:26:48Z",
    "updated_at": "2019-05-20T20:26:48Z",
    "author_association": "NONE",
    "body": "1. Seems there is no reason for investors to trust a token implementing this concept since the token code can change at any moment (I believe a pause+migrate method has more trust and security https://github.com/ethereum/EIPs/issues/644#issuecomment-494106553).\r\n2. Also seems as a duplicate of https://github.com/ethereum/EIPs/issues/644 (more specifically: https://github.com/ethereum/EIPs/issues/644#issuecomment-315328961) in the sense that eip 644 is a draft so maybe instead of two drafts with the same goal they could be merged into one which could be moved to final.\r\n3. It is a best practice security wise usually to not interact with economically sensitive contract which contains selfdestruct.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/494138089/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986422636",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-986422636",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 986422636,
    "node_id": "IC_kwDOAq426M46y51s",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-06T04:14:57Z",
    "updated_at": "2021-12-06T04:14:57Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986422636/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997580061",
    "html_url": "https://github.com/ethereum/EIPs/issues/1067#issuecomment-997580061",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1067",
    "id": 997580061,
    "node_id": "IC_kwDOAq426M47dd0d",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-20T04:15:11Z",
    "updated_at": "2021-12-20T04:15:11Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997580061/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
