{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/2535",
  "id": 570829851,
  "node_id": "MDU6SXNzdWU1NzA4Mjk4NTE=",
  "number": 2535,
  "title": "EIP-2535: Diamonds",
  "user": {
    "login": "mudgen",
    "id": 49092,
    "node_id": "MDQ6VXNlcjQ5MDky",
    "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mudgen",
    "html_url": "https://github.com/mudgen",
    "followers_url": "https://api.github.com/users/mudgen/followers",
    "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
    "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
    "organizations_url": "https://api.github.com/users/mudgen/orgs",
    "repos_url": "https://api.github.com/users/mudgen/repos",
    "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mudgen/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3539577331,
      "node_id": "LA_kwDOAq426M7S-anz",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/discussions-to",
      "name": "discussions-to",
      "color": "20DFB1",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 179,
  "created_at": "2020-02-25T21:01:08Z",
  "updated_at": "2022-10-02T15:33:00Z",
  "closed_at": "2022-08-28T02:53:26Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "EIP-2535 Diamonds exists here: https://eips.ethereum.org/EIPS/eip-2535\r\n\r\nBelow is a feedback and discussion of the standard.\r\n\r\n",
  "closed_by": {
    "login": "Pandapip1",
    "id": 45835846,
    "node_id": "MDQ6VXNlcjQ1ODM1ODQ2",
    "avatar_url": "https://avatars.githubusercontent.com/u/45835846?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Pandapip1",
    "html_url": "https://github.com/Pandapip1",
    "followers_url": "https://api.github.com/users/Pandapip1/followers",
    "following_url": "https://api.github.com/users/Pandapip1/following{/other_user}",
    "gists_url": "https://api.github.com/users/Pandapip1/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Pandapip1/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Pandapip1/subscriptions",
    "organizations_url": "https://api.github.com/users/Pandapip1/orgs",
    "repos_url": "https://api.github.com/users/Pandapip1/repos",
    "events_url": "https://api.github.com/users/Pandapip1/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Pandapip1/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/2535/reactions",
    "total_count": 120,
    "+1": 62,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 19,
    "rocket": 27,
    "eyes": 12
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591213205",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591213205",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591213205,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTIxMzIwNQ==",
    "user": {
      "login": "androolloyd",
      "id": 1237259,
      "node_id": "MDQ6VXNlcjEyMzcyNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1237259?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/androolloyd",
      "html_url": "https://github.com/androolloyd",
      "followers_url": "https://api.github.com/users/androolloyd/followers",
      "following_url": "https://api.github.com/users/androolloyd/following{/other_user}",
      "gists_url": "https://api.github.com/users/androolloyd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/androolloyd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/androolloyd/subscriptions",
      "organizations_url": "https://api.github.com/users/androolloyd/orgs",
      "repos_url": "https://api.github.com/users/androolloyd/repos",
      "events_url": "https://api.github.com/users/androolloyd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/androolloyd/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T03:00:42Z",
    "updated_at": "2020-02-26T03:00:42Z",
    "author_association": "NONE",
    "body": "This is great. \r\n\r\nWould be curious to see a uniswap build using the Diamond pattern. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591213205/reactions",
      "total_count": 14,
      "+1": 12,
      "-1": 2,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591220401",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591220401",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591220401,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTIyMDQwMQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T03:29:30Z",
    "updated_at": "2020-02-26T03:29:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@androolloyd yes, me too!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591220401/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591234923",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591234923",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591234923,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTIzNDkyMw==",
    "user": {
      "login": "pi0neerpat",
      "id": 35622595,
      "node_id": "MDQ6VXNlcjM1NjIyNTk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/35622595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pi0neerpat",
      "html_url": "https://github.com/pi0neerpat",
      "followers_url": "https://api.github.com/users/pi0neerpat/followers",
      "following_url": "https://api.github.com/users/pi0neerpat/following{/other_user}",
      "gists_url": "https://api.github.com/users/pi0neerpat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pi0neerpat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pi0neerpat/subscriptions",
      "organizations_url": "https://api.github.com/users/pi0neerpat/orgs",
      "repos_url": "https://api.github.com/users/pi0neerpat/repos",
      "events_url": "https://api.github.com/users/pi0neerpat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pi0neerpat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T04:39:37Z",
    "updated_at": "2020-02-26T04:48:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think you need to add the proper table to the top of this file. Wait, this is an issue not a PR. I'm confused are you trying to make a new EIP? \r\n\r\n(Putting discussion here since I don't see an external link)\r\n\r\nThis looks interesting, albeit very ahead of it's time. You've clearly put a lot of thought into it, and it is very well written. I'm curious to see how this intersects with governance. My jerk reaction is that this is only useful in a specific application that includes permission-based \"cut\" control. But even that would introduce lots of systemic risk. For now I think we are all stuck with upgrades being controlled by a single source of control, like Maker and rDAI, which publish documentation to record the history of changes. I look forward to the day where this fine-grained control is reality, and small changes can be made on-the-fly without introducing additional risk!\r\n\r\nAm I missing another use-case for this?\r\n\r\nEdit: (follow-up) how can we isolate storage on the same permissioned system that we use to allow cuts?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591234923/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591251000",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591251000",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591251000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTI1MTAwMA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T05:43:50Z",
    "updated_at": "2020-02-26T06:48:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "@pi0neerpat thanks for your kind comments!  The discussion is here.  An official EIP for this standard is coming soon. It will be EIP 2535.  \r\n\r\nCompanies are already using this kind of architecture (ERC1538) for their contracts, such as [Caesar's Triumph](https://www.caesarstriumph.com/), [Enjin](https://github.com/enjin/erc-1155/blob/master/contracts/ProxyReceiver/IERC1538.sol) and others. It is real and in use today.\r\n\r\nEnjin's NFT standard EIP 1155 [recommends](https://eips.ethereum.org/EIPS/eip-1155#upgrades) using an architecture like ERC1538 for upgrades.\r\n\r\nI don't know why you think a diamond can't be controlled by a single source.  The reference implementation of the standard is implemented that way -- only the single owner of the diamond can make changes. Maybe I am understanding you wrong? Authentication is not part of the standard, it can be fine grained or not. \r\n\r\nA big use case is contracts with designs that exceed the max size of contracts, since diamonds don't have a max size. It is also very nice that while diamonds can be large their functionality can still be compartmented by facets.  Particularly NFT contracts tend to exceed the max size limit, such as implementations of ERC721 and ERC998 and others that implement an NFT but also need to implement custom functionality for the application. \r\n\r\nPermissions and authentication for cuts and access to storage variables can be handled in the same way as any other contract.  Yes, if you wanted to, you could add various different permissions/authentications for different changes and handling different storage variables.  Or you could keep it simple and not do that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591251000/reactions",
      "total_count": 9,
      "+1": 9,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591413729",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591413729",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591413729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQxMzcyOQ==",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T13:00:13Z",
    "updated_at": "2020-02-26T13:00:13Z",
    "author_association": "MEMBER",
    "body": "> The owners(s) of an upgradeable contract have the ability to alter, add or remove data from the contract's data storage. Owner(s) of a contract can also execute any arbitrary code in the contract on behalf of any address. Owners(s) can do these things by adding a function to the contract that they call to execute arbitrary code. This is an issue for upgradeable contracts in general and is not specific to diamonds.\r\n\r\nWell, exactly. How is this standard any different from the centralized owned upgradeable smart contracts out there? Why not a standard that abstracts upgrades being opt-in only by default?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591413729/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591414366",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591414366",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591414366,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQxNDM2Ng==",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T13:01:46Z",
    "updated_at": "2020-02-26T13:01:46Z",
    "author_association": "MEMBER",
    "body": "> This is great.\r\n> \r\n> Would be curious to see a uniswap build using the Diamond pattern.\r\n\r\nTo me Uniswap is great exactly because it's not upgradeable/centralized.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591414366/reactions",
      "total_count": 17,
      "+1": 15,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 2
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591440612",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591440612",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591440612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQ0MDYxMg==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T14:01:31Z",
    "updated_at": "2021-11-23T15:39:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@leonardoalt It is different in a lot of ways, but it is not different in regards to ownership/authentication. Ownership/authentication is not part of this standard.  The ownership/authentication can be implemented in a diamond any way anybody wants.\r\n\r\nI realize now that the way EIP-2535 Diamonds is currently written it misleads people into thinking that EIP-2535 Diamonds specifies how authentication/ownership is implemented or should work. It doesn't.  So I think I will change the text you quoted because it is misleading.  It certainly does not have to be that way, it just could be that way, depending on how ownership/authentication is implemented.\r\n\r\nBut note that the standard does suggest a different way to do ownership or authentication. See the \"Decentralized Authority\" section.\r\n\r\nAlso, the upgrade functionality can be removed in a diamond making a diamond immutable.  This could be done by removing the `cut` function.  And it possibly could be added back depending on certain cases dictated by the implementation of the diamond -- there are so many possibilities to what could be implemented and EIP-2535 Diamonds does not limit what can be done.\r\n\r\n> Why not a standard that abstracts upgrades being opt-in only by default?\r\n\r\nStandards or tutorials or implementations that build on top of EIP-2535 Diamonds to provide different ownership/authentication/upgrade schemes are very much wanted!\r\n\r\nEIP-2535 Diamonds provides basic architecture and structure and points of interoperability with user interfaces and software, and it leaves up to the implementer what the diamond does and how it works. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591440612/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591447046",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591447046",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591447046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQ0NzA0Ng==",
    "user": {
      "login": "pi0neerpat",
      "id": 35622595,
      "node_id": "MDQ6VXNlcjM1NjIyNTk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/35622595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pi0neerpat",
      "html_url": "https://github.com/pi0neerpat",
      "followers_url": "https://api.github.com/users/pi0neerpat/followers",
      "following_url": "https://api.github.com/users/pi0neerpat/following{/other_user}",
      "gists_url": "https://api.github.com/users/pi0neerpat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pi0neerpat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pi0neerpat/subscriptions",
      "organizations_url": "https://api.github.com/users/pi0neerpat/orgs",
      "repos_url": "https://api.github.com/users/pi0neerpat/repos",
      "events_url": "https://api.github.com/users/pi0neerpat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pi0neerpat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T14:14:58Z",
    "updated_at": "2020-02-26T14:17:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mudgen \r\n\r\n> I don't know why you think a diamond can't be controlled by a single source. \r\n\r\nThe only reason I say this is because the single source would just publish documentation whenever they made a change. There's no real reason to emitt changes as events or capture this on-chain. Maker and other protocols already have governance processes to document this already. \r\n\r\n> A big use case is contracts with designs that exceed the max size of contracts, since diamonds don't have a max size.\r\n\r\nThat's a very good feature!\r\n\r\n> Companies are already using this kind of architecture (ERC1538) for their contracts, such as Caesar's Triumph, Enjin and others. It is real and in use today\r\n\r\nI'll have to look more closely at these. This could be really useful for @austintgriffith [DAOG game](https://youtu.be/dcNBiopvhJE) where the rules of the game are updated on-the-fly. Right now the rules are limited in scope, but this could allow more open-ended rules to be added or removed. \r\n\r\n> Permissions and authentication for cuts and access to storage variables can be handled in the same way as any other contract.\r\n\r\nI'm glad you think this is possible because I really think this is the best potential use-case for this system. For instance, in the DAOG game, you could allow players to add/remove rules, without letting them interfere with the core game logic (i.e. the logic and storage deciding who wins and can withdraw the prize pot). Or with a Moloch, you could set certain thresholds for high/low impact changes to the dao contract itself. Dao members could pass smaller rules more easily, to run segregated  and quick experiments, without risking the dao's funds. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591447046/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591449472",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591449472",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591449472,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQ0OTQ3Mg==",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T14:20:07Z",
    "updated_at": "2020-02-26T14:20:07Z",
    "author_association": "MEMBER",
    "body": "> the upgrade functionality can be removed in a diamond making a diamond immutable.\r\n\r\nThe upgrade functionality can also be removed by the contract not being upgradeable in the first place.\r\n\r\n> there are so many possibilities to what could be implemented and the diamond standard does not limit what can be done\r\n\r\nExactly my point. It is basically a really complicated way to make contracts as mutable as simply delegating everything to a dynamic address, which is actually a lot more transparent and simpler to read and check what it's doing. Complicated upgrade standards enable backdoors by obfuscation, especially when you can literally change everything.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591449472/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591454670",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591454670",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591454670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQ1NDY3MA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T14:30:26Z",
    "updated_at": "2021-11-23T15:39:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "@leonardoalt Its is really not very complicated. It is new and the standard does provide a lot of information to help use and implement the standard.\r\n\r\nEIP-2535 Diamonds is this\r\n\r\n1. One function for adding/replacing/removing functions.\r\n2. One event for logging changes.\r\n3. Some functions for showing what functions the contract has.\r\n\r\nA big part of the standard is transparency (logging changes), which removes obfuscation. I plan to make a user interface that shows and visualizes all changes to a diamond.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591454670/reactions",
      "total_count": 15,
      "+1": 14,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591467231",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-591467231",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 591467231,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTQ2NzIzMQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T14:55:12Z",
    "updated_at": "2021-11-23T15:39:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "Some good discussion of EIP-2535 Diamonds here: https://ethereum-magicians.org/t/diamond-contract-standard/4038",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/591467231/reactions",
      "total_count": 8,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592080129",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592080129",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592080129,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjA4MDEyOQ==",
    "user": {
      "login": "spalladino",
      "id": 429604,
      "node_id": "MDQ6VXNlcjQyOTYwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/429604?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/spalladino",
      "html_url": "https://github.com/spalladino",
      "followers_url": "https://api.github.com/users/spalladino/followers",
      "following_url": "https://api.github.com/users/spalladino/following{/other_user}",
      "gists_url": "https://api.github.com/users/spalladino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/spalladino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/spalladino/subscriptions",
      "organizations_url": "https://api.github.com/users/spalladino/orgs",
      "repos_url": "https://api.github.com/users/spalladino/repos",
      "events_url": "https://api.github.com/users/spalladino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/spalladino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T17:27:35Z",
    "updated_at": "2020-02-27T17:27:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "Awesome work @mudgen!! I like this new version of the EIP, and have a few comments:\r\n\r\n- I really like the fact that `cut` can modify several functions atomically, and you don't need multiple calls, potentially leaving your contract in an inconsistent state. That said, I'd look into simplifying it a bit: instead of having the concept of add/remove/replace action, why not just have `cut` accept an array of pairs `selector,implementation`, directly setting the implementation for each selector? Add and replace would be similar, and removal can be done by setting implementation to zero. Function clashes can be managed via appropriate tooling here.\r\n\r\n- In line with the previous one, I'd also simplify the event. Having a big event with a bunch of actions is harder to consume. I'd just set up events with the `selector` and `implementation` arguments, and fire as many as needed. You could even make selector indexed, so clients can monitor for changes to a specific function (I'd look into gas tradeoffs here though).\r\n\r\n- There is another potential clash that is _event_ clashing. The `DiamondCut` event could have the same selector as an event from a facet, potentially fooling a client who is listening to these events. That said, a client could just query the contract to verify the facet address if needed.\r\n\r\n- I'd also simplify the loupe interface. I'd remove any enumerable features, and just keep a `getFacet(bytes4 selector)` method. I'm not sure in which situations another contract would need to iterate over the facets of a diamond, and an offchain client could look into past events. I think this should also simplify the storage structures needed to support a diamond, making it overall more gas efficient.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592080129/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592139604",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592139604",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592139604,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjEzOTYwNA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T19:36:23Z",
    "updated_at": "2020-02-27T19:38:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "@spalladino Thank you very much. This is great feedback!  I appreciate that you take the time to look at this and write this feedback.\r\n\r\n> Awesome work @mudgen!! I like this new version of the EIP, and have a few comments:\r\n> \r\n> * I really like the fact that `cut` can modify several functions atomically, and you don't need multiple calls, potentially leaving your contract in an inconsistent state. That said, I'd look into simplifying it a bit: instead of having the concept of add/remove/replace action, why not just have `cut` accept an array of pairs `selector,implementation`, directly setting the implementation for each selector? Add and replace would be similar, and removal can be done by setting implementation to zero. Function clashes can be managed via appropriate tooling here.\r\n\r\nI like the idea of simplifying the argument to `cut`.  Your suggestion omits the `string message` part of the argument that describes a set of changes. It is a commit message. Removing it would simplify the argument to `cut` and reduce some gas. Do you think its disadvantages outweigh its benefits? The argument is as complicated as it currently is because it gives the ability to have different change messages for different sets of changes in one transaction. This helps document the changes, but maybe it isn't worth the added complexity of the data structure.\r\n\r\n> * In line with the previous one, I'd also simplify the event. Having a big event with a bunch of actions is harder to consume. I'd just set up events with the `selector` and `implementation` arguments, and fire as many as needed. You could even make selector indexed, so clients can monitor for changes to a specific function (I'd look into gas tradeoffs here though).\r\n\r\nThe argument to the `cut` function and the argument to the `DiamondCuts` event is exactly the same. The `cut` function literally passes its argument directly to the `DiamondCuts` event without any manipulation. This is a nice simplicity.  You are right, it would be nicer if it was a simpler data structure.  It associates the change messages with their changes.  Again, if we remove the `string message` then this data structure could be simplified.  So I guess the important question is how important is it to have descriptive text describing changes to a diamond emitted in events?  I suppose the datastructure could also be simplified some by only allowing one change message for all changes in one transaction.  With the way it is now you can have multiple change messages for different sets of changes in one transaction. That is why the data structure is as complicated as it is.\r\n\r\n> * There is another potential clash that is _event_ clashing. The `DiamondCut` event could have the same selector as an event from a facet, potentially fooling a client who is listening to these events. That said, a client could just query the contract to verify the facet address if needed.\r\n\r\nCan you explain this more?  I don't understand the scenario you are describing here.\r\n\r\n> * I'd also simplify the loupe interface. I'd remove any enumerable features, and just keep a `getFacet(bytes4 selector)` method. I'm not sure in which situations another contract would need to iterate over the facets of a diamond, and an offchain client could look into past events. I think this should also simplify the storage structures needed to support a diamond, making it overall more gas efficient.\r\n\r\nWow, that is an interesting idea.  I see what you are saying, the loupe isn't needed if software can simply look at the events to determine which functions exist. I'm not sure why `getFacet(bytes4 selector)` would be needed by the standard.  The main purpose of the loupe is to provide interoperability with user interface software and tooling, but if events already give that then they could be used. People can always add in their own functions like `getFacet(bytes4 selector)` for their own purposes. I am considering removing the loupe completely from the standard.\r\n\r\n@spalladino What do you think now?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592139604/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592144157",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592144157",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592144157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjE0NDE1Nw==",
    "user": {
      "login": "spalladino",
      "id": 429604,
      "node_id": "MDQ6VXNlcjQyOTYwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/429604?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/spalladino",
      "html_url": "https://github.com/spalladino",
      "followers_url": "https://api.github.com/users/spalladino/followers",
      "following_url": "https://api.github.com/users/spalladino/following{/other_user}",
      "gists_url": "https://api.github.com/users/spalladino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/spalladino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/spalladino/subscriptions",
      "organizations_url": "https://api.github.com/users/spalladino/orgs",
      "repos_url": "https://api.github.com/users/spalladino/repos",
      "events_url": "https://api.github.com/users/spalladino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/spalladino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T19:46:20Z",
    "updated_at": "2020-02-27T19:46:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "The commit message is definitely interesting, but shouldn't it be handled off chain? Perhaps the contract should just have a small identifier that points to an actual commit or release off-chain, for traceability from the source to the deployment?\r\n\r\nStill, one option (following the `address,selector` pairs approach) would be for the cut event to publish the _array_ of `address,selector` pairs, and the commit message, similar to what you originally proposed - though easier to parse for the client. You lose indexability of selectors, but it may not be too critical.\r\n\r\n> Can you explain this more? I don't understand the scenario you are describing here.\r\n\r\nSorry, forget about this one. I mixed up event topics and function selectors. The first topic for an event, which is derived from a hash of its name and args and identifies the type of event, is 32 bytes long -not 4 bytes like a function selector. So clashes between event names are not possible.\r\n\r\n> People can always add in their own functions like getFacet(bytes4 selector) for their own purposes. I am considering removing the loupe completely from the standard.\r\n\r\nMaybe there is an opportunity to have this standard be automatically ERC165 compliant...? Haven't looked at it in-depth.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592144157/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592174517",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592174517",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592174517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjE3NDUxNw==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T21:01:03Z",
    "updated_at": "2020-02-27T21:35:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "> The commit message is definitely interesting, but shouldn't it be handled off chain? Perhaps the contract should just have a small identifier that points to an actual commit or release off-chain, for traceability from the source to the deployment?\r\n\r\nHave the identifier where?  The commit messages are not stored in the contracts, they are just emitted with the event that shows the changes.  I'd rather just emit the commit message in the event than emit a hash of a commit stored  somewhere because I don't think this would be useful for user interfaces that show people all the changes to a diamond, but the commit messages describing the changes could be useful. The idea of the user interface is that it would pull all the verified source code from somewhere like etherscan so people could easily see all the source code of all the facets used by a diamond,  and in addition people could see the verified source code of how a diamond was in the past if it was cut.  And people would see the commit messages describing the upgrades, why they were done etc.\r\n\r\n> Maybe there is an opportunity to have this standard be automatically ERC165 compliant...? Haven't looked at it in-depth.\r\n\r\nI don't see how it could be automatically compliant. I do like ERC165 and I think it is good for people to use it.\r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592174517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592209506",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592209506",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592209506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjIwOTUwNg==",
    "user": {
      "login": "fulldecent",
      "id": 382183,
      "node_id": "MDQ6VXNlcjM4MjE4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/382183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fulldecent",
      "html_url": "https://github.com/fulldecent",
      "followers_url": "https://api.github.com/users/fulldecent/followers",
      "following_url": "https://api.github.com/users/fulldecent/following{/other_user}",
      "gists_url": "https://api.github.com/users/fulldecent/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fulldecent/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fulldecent/subscriptions",
      "organizations_url": "https://api.github.com/users/fulldecent/orgs",
      "repos_url": "https://api.github.com/users/fulldecent/repos",
      "events_url": "https://api.github.com/users/fulldecent/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fulldecent/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T22:26:03Z",
    "updated_at": "2020-02-27T22:26:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "I recommend that this standard use ERC-165, just for the `cut` function. This will help tools, such as Etherscan, recognize compliant contracts.\r\n\r\n---\r\n\r\nBecause this contract is VERY general in purpose, the `cut` function should be renamed to a more qualified name such as `diamondCut`. Also I would like to see a discussion of the proposed name and any potential function selector conflicts in the rational section.\r\n\r\n---\r\n\r\nThe event has arrays in it, so this limits the ability to search logs.\r\n\r\n---\r\n\r\nThe API is overly complex:\r\n\r\n```\r\nenum CutAction {Add, Replace, Remove}\r\nstruct FacetCut {\r\n  address facet;\r\n  CutAction action;\r\n  bytes4[] functionSelectors;\r\n}\r\nstruct DiamondCut {\r\n  FacetCut[] facetCuts;\r\n  string message;\r\n}\r\ninterface Diamond {\r\n  function cut(DiamondCut[] calldata _diamondCuts) external;\r\n  event DiamondCuts(DiamondCut[] _diamondCuts);    \r\n}\r\n```\r\n\r\nIt can be:\r\n\r\n```solidity\r\nstruct DiamondBatchCuts {\r\n  bytes4[] functionSelectors;\r\n  address[] implementations;\r\n}\r\ninterface Diamond {\r\n  function diamondCut(DiamondBatchCuts calldata diamondCuts) external;\r\n  event DiamondCut(bytes4 functionSelector, address oldImplementation, address newImplementation);\r\n}\r\n```\r\n\r\nIt is unnecessary to categorize adding, changing and removing. Simply, a zero address corresponds to no implementation and a non-zero address is an implementation.\r\n\r\n---\r\n\r\nUse extra bytes.\r\n\r\nNobody asked for this feature but I'll suggest it any way.\r\n\r\nI assume the standard contract is implemented like:\r\n\r\n```solidity\r\ncontract DiamondImplementation {\r\n  mapping (bytes4 => address) implementations;\r\n  function diamondCut(DiamondBatchCuts calldata diamondCuts) external {\r\n    for (uint i = 1; i < diamondCuts.functionSelectors.length, I++) {\r\n      address old = diamondCuts.functionSelectors[I];\r\n      implementations[diamondCuts.functionSelectors[i]] = diamondCuts.implementations[i];\r\n      emit DiamondCut(diamondCuts.functionSelectors[I], old, diamondCuts.implementations[I]);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nSo this means the storage is `mapping (bytes4 => address) implementations;`. That is wasteful because you are only putting 160 bits in a 256 bit register.\r\n\r\nYou can store more... but what? The selector in the target contract!\r\n\r\nSo you can have a function selector `a` on your Diamond contract be implemented by function `b` on the implementation contract. Why would you want to do that? Because of code reuse.\r\n\r\nOR you can ignore this suggestion entirely if all the implementation contracts are implemented using the fallback function, which is better.\r\n\r\nE.g. specify that all implementations are:\r\n\r\n```solidity\r\ninterface DiamondFunctionImplementation {\r\n    fallback () external {\r\n      // code goes here\r\n    }\r\n}\r\n```\r\n\r\n^^ this will be more efficient.\r\n\r\nI didn't actually read the EIP some maybe you already specified this.\r\n\r\n---\r\n\r\nDocumentation on storage mutability is insufficient. This is a major design consideration. And as somebody that audits contracts I'll hate auditing this kind of contract :-~~~\r\n\r\n---\r\n\r\nMutability is bad. As stated before in my prior related review. I'm still not a fan of using this EIP or Zeppelin OS for upgradeable contracts. If you want to upgrade your contract then best practice is to deploy a new contract and spend your marketing budget to inform everybody of the new version.\r\n\r\nThis is what I did, multiple times, when working on ERC-721. Since I published the first \"ERC-721 compliant contract\" (it's Su Squares, check it out) that means I needed to redeploy it every time there was a new ERC-721 draft. That's okay, and all of the wallet providers know me because I kept having to bother them to update the contract address in MetaMask, MyEtherWallet, etc. And that's a good thing.\r\n\r\nAn exception is zero-knowledge proof contracts. These require an enormous amount of code. And these require a limited caveat to my note above. It might be reasonable for a ZKP contract to be deployed in multiple stages. But the contract should not be open to the public until deployment is completed (dependent contracts are loaded) and no further changes should be possible after deployment. Even still, the functionality of Diamond contracts should not be necessary for this deployment strategy.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592209506/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592234296",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592234296",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592234296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjIzNDI5Ng==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T23:43:49Z",
    "updated_at": "2021-11-23T15:40:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "@fulldecent I appreciate your feedback on this.\r\n\r\n> I recommend that this standard use ERC-165, just for the cut function. This will help tools, such as Etherscan, recognize compliant contracts.\r\n\r\nYes, I'll add this to EIP-2535 Diamonds.\r\n\r\n> Because this contract is VERY general in purpose, the cut function should be renamed to a more qualified name such as diamondCut. \r\n\r\nI agree that `cut` should be renamed to a more qualified name.  I'll rename it to `diamondCut`.\r\n\r\n> Also I would like to see a discussion of the proposed name and any potential function selector conflicts in the rational section.\r\n\r\nThere is a section about function selector conflicts in the security section.\r\n\r\n> The API is overly complex:\r\n\r\nThe argument to `cut` is complex because it supports descriptive messages describing changes, like commit messages. And different messages can be associated with different sets of changes. The argument can be simplified if we throw out the descriptive messages of the changes, but I think it is worth it to keep them. I understand that documentation messages are not sufficient for a security audit but I think they can help people understand diamonds and why/what changes are made.\r\n\r\nAn important part of EIP-2535 Diamonds is creating user interfaces that pull all the verified source code that is used and displaying it in such a way that a person can see and understand all the code that is currently used by a diamond and also look at past code that was used before it was cut.\r\n\r\n> It is unnecessary to categorize adding, changing and removing. Simply, a zero address corresponds to no implementation and a non-zero address is an implementation.\r\n\r\nIt is necessary to prevent function selector conflicts.  That's why it is there. The alternative is to let the user or off-chain software first verify that they aren't making any function selector clashes before calling `cut` but a diamond can't enforce they do this and it may be easier for them to specify add,replace,remove and the diamond can enforce they do this.\r\n\r\n> contract DiamondImplementation {\r\n\r\nI understand your DiamondImplementation and I understand that an address is 160 bits and that additional data can be stored in the 256 slot. But after that I am lost. But I am interested. Can you explain more?\r\n\r\n> As stated before in my prior related review.\r\n\r\nI think I kinda remember your prior review but for some reason I can't find it. Do you happen to know where it is? Because I'd like to review it if we can find it. **Nevermind I found it!** It was an email to me and I found it.\r\n\r\nI remember you working and handling Su Squares and I thought you did a good job with it and the way you did things with it was good.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592234296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592251595",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592251595",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592251595,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjI1MTU5NQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T00:41:28Z",
    "updated_at": "2020-02-28T00:41:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "This change is complete: I renamed the `cut` function to `diamondCut` in the standard. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592251595/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592253726",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592253726",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592253726,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjI1MzcyNg==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T00:49:47Z",
    "updated_at": "2020-02-28T00:59:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Wow, that is an interesting idea. I see what you are saying, the loupe isn't needed if software can simply look at the events to determine which functions exist. I'm not sure why getFacet(bytes4 selector) would be needed by the standard. The main purpose of the loupe is to provide interoperability with user interface software and tooling, but if events already give that then they could be used. People can always add in their own functions like getFacet(bytes4 selector) for their own purposes. I am considering removing the loupe completely from the standard.\r\n\r\nOkay, here's the truth, I just don't totally trust 100 percent that events will be available all the time, forever, and with good performance all the time, forever. Maybe that is dead wrong and hope it is wrong and I'd love someone to prove it to me that it is wrong so I am totally convinced.  I want to be overly safe until then -- after all we are dealing with diamonds!.  Having the loupe functions implemented is a very good guarantee that you will be able to inspect your diamonds for facets and functions. If it is implemented right and it doesn't work then that means ethereum contracts don't work anymore and we have bigger problems.\r\n\r\nSo I'm keeping the loupe functions in the standard.  Actually I removed two of them:  `functionSelectorByIndex` and `totalFunctions`,  because I don't see the need for them with the other ones. Also, by having events and loupe functions it provides two different ways to get the functions and facets of a diamond. If one way breaks for some impossible reason, the other way is available.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592253726/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592533989",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592533989",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592533989,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjUzMzk4OQ==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T14:21:31Z",
    "updated_at": "2020-02-28T14:21:31Z",
    "author_association": "NONE",
    "body": "I am going to support @leonardoalt fully here. Rare are the occasions where upgradeability on-chain cannot be replaced with off-chain mechanisms to achieve the same end result.\r\n\r\nAs an added problem, the more you complicate on-chain upgradeability mechanisms, the more obfuscated and less auditable these become. This means that clients' trust on the system is greatly reduced.\r\n\r\nIf everything is mutable why not just delegate execution?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592533989/reactions",
      "total_count": 6,
      "+1": 5,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592559124",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592559124",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592559124,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjU1OTEyNA==",
    "user": {
      "login": "androolloyd",
      "id": 1237259,
      "node_id": "MDQ6VXNlcjEyMzcyNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1237259?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/androolloyd",
      "html_url": "https://github.com/androolloyd",
      "followers_url": "https://api.github.com/users/androolloyd/followers",
      "following_url": "https://api.github.com/users/androolloyd/following{/other_user}",
      "gists_url": "https://api.github.com/users/androolloyd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/androolloyd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/androolloyd/subscriptions",
      "organizations_url": "https://api.github.com/users/androolloyd/orgs",
      "repos_url": "https://api.github.com/users/androolloyd/repos",
      "events_url": "https://api.github.com/users/androolloyd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/androolloyd/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T15:19:06Z",
    "updated_at": "2020-02-28T15:19:06Z",
    "author_association": "NONE",
    "body": "> I am going to support @leonardoalt fully here. Rare are the occasions where upgradeability on-chain cannot be replaced with off-chain mechanisms to achieve the same end result.\r\n> \r\n> As an added problem, the more you complicate on-chain upgradeability mechanisms, the more obfuscated and less auditable these become. This means that clients' trust on the system is greatly reduced.\r\n> \r\n> If everything is mutable why not just delegate execution?\r\n\r\nI feel like this approach takes the stance that we're never going to improve the way we do things today.\r\n\r\nThe audit log itself ensures that no central party has to prove what the state is, as it's self managed.\r\n\r\nAs a user if you want any real trust with proxies, you want to have your own, anytime an app needs a proxy they deploy one for you, as a user, you could have A proxy that you trust, that you cut with any features that you need, without having to extend that trust to anyone else to verify what the state of your proxy is.\r\n\r\nGovernance maintained Diamonds with the ability to cut in new features seems like a huge boon in terms of how we manage and maintain upgradeability.\r\n\r\nNo question there are new security challenges to deal with, but these types of patterns work well in other application development to date.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592559124/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592581620",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592581620",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592581620,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjU4MTYyMA==",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T16:09:21Z",
    "updated_at": "2020-02-28T16:09:21Z",
    "author_association": "MEMBER",
    "body": "As a user you should be asked to opt-in an upgrade, not be forced to trust obfuscated code.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592581620/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592582605",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592582605",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592582605,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjU4MjYwNQ==",
    "user": {
      "login": "androolloyd",
      "id": 1237259,
      "node_id": "MDQ6VXNlcjEyMzcyNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1237259?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/androolloyd",
      "html_url": "https://github.com/androolloyd",
      "followers_url": "https://api.github.com/users/androolloyd/followers",
      "following_url": "https://api.github.com/users/androolloyd/following{/other_user}",
      "gists_url": "https://api.github.com/users/androolloyd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/androolloyd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/androolloyd/subscriptions",
      "organizations_url": "https://api.github.com/users/androolloyd/orgs",
      "repos_url": "https://api.github.com/users/androolloyd/repos",
      "events_url": "https://api.github.com/users/androolloyd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/androolloyd/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T16:11:37Z",
    "updated_at": "2020-02-28T16:11:37Z",
    "author_association": "NONE",
    "body": "> As a user you should be asked to opt-in an upgrade, not be forced to trust obfuscated code.\r\n\r\nNo disagreements there, which is why its great for user owned contracts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592582605/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592692014",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592692014",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592692014,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjY5MjAxNA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T19:37:06Z",
    "updated_at": "2020-02-28T20:20:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@leonardoalt @androolloyd  @GNSPS One thing to keep in mind, which @fulldecent pointed out, is that this standard is **very** general, which also means that it is extremely flexible. It is easy to make the error of pegging this standard to a particular use case or to make assumptions about it.\r\n\r\n>As a user you should be asked to opt-in an upgrade, not be forced to trust obfuscated code.\r\n\r\n@leonardoalt This standard is probably flexible enough to accommodate that. I'm interested in more details about how that could work.\r\n\r\nI myself am very guilty of pegging this standard to a particular use case: \"upgradeable contracts\". This standard is useful for creating very useful immutable contracts that can't be upgraded. How so? Well there might be many ways (being so general and all) but I think of two really good use cases. But before I tell you the use cases let me tell you how to make useful immutable contracts with this standard.\r\n\r\nThe standard has been carefully edited to say that a diamond \"uses\" the `diamondCut` function.  It does not say that the `diamondCut` function has to be added to the diamond as one of its functions. So this means that you can delegatecall to the `diamondCut` function in the constructor of the diamond to add all the functions needed by the diamond. The example in the standard shows how to call `diamondCut` in the constructor of a diamond.  Since the `diamondCut` function is never actually added to the diamond the diamond is immutable with the same immutability and trust guarantees as a vanilla contract.  My two use cases illustrate why this is useful:\r\n\r\n1. If you have a contract that hits the max contract size limit and there is too much code or dependency upon storage variables to separate it out into regular contracts, then you can make it an immutable diamond (which has no max size).  Cool thing about making it a diamond is that you still break your big contract into smaller contracts, modularizing your code to a degree. A good description of a diamond is this:  A group of contracts that share the same storage variables and address.\r\n\r\n2. You can start with an upgradeable diamond in your development and testing and upgrade it to your heart's delight. Reap the advantages of easy upgrading and a stable address as you work out new features, bugs and kinks.  Release the upgradeable contract on a test network with your application for beta testing and upgrade it when needed. This is iterative development. When it is all solid then make it an immutable diamond and launch it on the main network. \r\n\r\nObfuscation exists when there are no tools to make something transparent and clear. This standard standardizes diamonds so that tools can be written for them so they are transparent and clear.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592692014/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592694059",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-592694059",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 592694059,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjY5NDA1OQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T19:42:29Z",
    "updated_at": "2020-02-28T19:42:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "@androolloyd  I love this use case:\r\n>As a user if you want any real trust with proxies, you want to have your own, anytime an app needs a proxy they deploy one for you, as a user, you could have A proxy that you trust, that you cut with any features that you need, without having to extend that trust to anyone else to verify what the state of your proxy is.\r\n\r\nI want everyone to have their own diamond.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592694059/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593046095",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-593046095",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 593046095,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MzA0NjA5NQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-01T02:55:21Z",
    "updated_at": "2020-03-01T03:39:14Z",
    "author_association": "CONTRIBUTOR",
    "body": ">The only reason I say this is because the single source would just publish documentation whenever they made a change. There's no real reason to emitt changes as events or capture this on-chain. Maker and other protocols already have governance processes to document this already.\r\n\r\n@pi0neerpat I realized that you are right. It is better to let people document their contracts and their upgrades off chain the way they want to.  Thank you for this useful feedback. I updated the standard to reflect this. Specifically I removed the documentation `message` part of the input and event. \r\n\r\n---\r\n\r\n>The commit message is definitely interesting, but shouldn't it be handled off chain? Perhaps the contract should just have a small identifier that points to an actual commit or release off-chain, for traceability from the source to the deployment?\r\n\r\n@spalladino I realized that you are right.  I removed the commit message functionality. I think that the facet addresses can be used as pointers to facet and upgrade documentation, in the same way they are used as pointers to verified source code on etherscan. Thank you for this very useful feedback.\r\n\r\n> I really like the fact that cut can modify several functions atomically, and you don't need multiple calls, potentially leaving your contract in an inconsistent state. That said, I'd look into simplifying it a bit: instead of having the concept of add/remove/replace action, why not just have cut accept an array of pairs selector,implementation, directly setting the implementation for each selector? Add and replace would be similar, and removal can be done by setting implementation to zero. Function clashes can be managed via appropriate tooling here.\r\n\r\n@spalladino You are right about simplifying the argument to the `diamondCut` function.  After removing the `message` part I was able to simplify it and I updated the standard.  \r\n\r\nThe add/remove/place action is used to prevent function selector clashes. I don't feel comfortable with delegating that responsibility to tools because some tools might not do it.  Also, having the action makes explicit what is happening which is good. I know it is redundant with events but someone can look at past transactions and know whether functions were added or replaced.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593046095/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593052117",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-593052117",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 593052117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MzA1MjExNw==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-01T04:25:02Z",
    "updated_at": "2020-03-01T04:25:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "> The event has arrays in it, so this limits the ability to search logs.\r\n\r\n@fulldecent You are right about the events. I changed the events in the standard to something very similar to what you suggested.\r\n\r\n---\r\n\r\n> In line with the previous one, I'd also simplify the event. Having a big event with a bunch of actions is harder to consume. I'd just set up events with the selector and implementation arguments, and fire as many as needed. You could even make selector indexed, so clients can monitor for changes to a specific function (I'd look into gas tradeoffs here though).\r\n\r\n@spalladino You are right about events.  I updated the standard with events like you suggested. I am leery about making the function selector indexed because of the extra gas cost and how useful it might be.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593052117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593088662",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-593088662",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 593088662,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MzA4ODY2Mg==",
    "user": {
      "login": "pi0neerpat",
      "id": 35622595,
      "node_id": "MDQ6VXNlcjM1NjIyNTk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/35622595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pi0neerpat",
      "html_url": "https://github.com/pi0neerpat",
      "followers_url": "https://api.github.com/users/pi0neerpat/followers",
      "following_url": "https://api.github.com/users/pi0neerpat/following{/other_user}",
      "gists_url": "https://api.github.com/users/pi0neerpat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pi0neerpat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pi0neerpat/subscriptions",
      "organizations_url": "https://api.github.com/users/pi0neerpat/orgs",
      "repos_url": "https://api.github.com/users/pi0neerpat/repos",
      "events_url": "https://api.github.com/users/pi0neerpat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pi0neerpat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-01T11:56:40Z",
    "updated_at": "2020-03-01T12:00:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "> The add/remove/place action is used to prevent function selector clashes. I don't feel comfortable with delegating that responsibility to tools because some tools might not do it. Also, having the action makes explicit what is happening which is good. I know it is redundant with events but someone can look at past transactions and know whether functions were added or replaced.\r\n\r\nNot sure if this will help, but I made a tool to assist in stripping out variables for both turning a regular contract into a proxy, and to help when performing an upgrade.  It gathers all variables from all contracts (so dev can write new code as normal, without thinking of proxy) and throws them into Storage.sol.  The dev can then just git diff to make sure variables are appendend and not reorderes. In this case, it's the EIP1822 Universal Upgradeable Proxy Standard.\r\n\r\nhttps://www.npmjs.com/package/sol-proxy",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593088662/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593149217",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-593149217",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 593149217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MzE0OTIxNw==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-01T21:40:23Z",
    "updated_at": "2020-03-01T21:40:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "@pi0neerpat sol-proxy is interesting, thank you.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593149217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593161096",
    "html_url": "https://github.com/ethereum/EIPs/issues/2535#issuecomment-593161096",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2535",
    "id": 593161096,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MzE2MTA5Ng==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-01T23:08:37Z",
    "updated_at": "2020-03-01T23:08:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "> How can we isolate storage on the same permissioned system that we use to allow cuts?\r\n\r\n@pi0neerpat I am glad you ask this because it is a very good question. I've thought about it a lot. The answer is *we can't*.  If a person can add/replace functions then he/she can alter storage willy nilly. But the story does not end there. There are things that can be done to eliminate, reduce or limit the danger to storage.  I just added a new subsection to the standard called, \"Security of Diamond Storage\" to address this.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/593161096/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
