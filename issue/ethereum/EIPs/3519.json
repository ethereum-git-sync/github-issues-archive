{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/3519",
  "id": 862431426,
  "node_id": "MDU6SXNzdWU4NjI0MzE0MjY=",
  "number": 3519,
  "title": "Discussion for EIP-3440",
  "user": {
    "login": "nginnever",
    "id": 7103153,
    "node_id": "MDQ6VXNlcjcxMDMxNTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7103153?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nginnever",
    "html_url": "https://github.com/nginnever",
    "followers_url": "https://api.github.com/users/nginnever/followers",
    "following_url": "https://api.github.com/users/nginnever/following{/other_user}",
    "gists_url": "https://api.github.com/users/nginnever/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nginnever/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nginnever/subscriptions",
    "organizations_url": "https://api.github.com/users/nginnever/orgs",
    "repos_url": "https://api.github.com/users/nginnever/repos",
    "events_url": "https://api.github.com/users/nginnever/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nginnever/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2021-04-20T05:33:46Z",
  "updated_at": "2022-01-04T18:19:32Z",
  "closed_at": "2021-11-07T02:28:46Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 3440\r\ntitle: ERC-721 Editions Standard\r\nauthor: Nathan Ginnever (@nginnever)\r\ndiscussions-to: https://ethereum-magicians.org/t/eip-3340-nft-editions-standard-extension/6044\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2021-04-20\r\nrequires: 721, 712\r\n---\r\n\r\n## Simple Summary\r\n\r\nThis standard addresses an extension to the [ERC-721 specification](./eip-721.md) by allowing signatures on NFTs representing works of art. This provides improved provenance by creating functionality for an artist to designate an original and signed limited-edition prints of their work. \r\n\r\n## Abstract\r\n\r\nERC-3440 is an ERC-721 extension specifically designed to make NFTs more robust for works of art. This extends the original ERC-721 spec by providing the ability to designate the original and limited-edition prints with a specialized enumeration extension similar to the [original 721 extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol) built-in. The key improvement of this extension is allowing artists to designate the limited nature of their prints and provide a signed piece of data that represents their unique signature to a given token Id, much like an artist would sign a print of their work.\r\n\r\n## Motivation\r\nCurrently the link between a NFT and the digital work of art is only enforced in the token metadata stored in the shared `tokenURI` state of a NFT. While the blockchain provides an immutable record of history back to the origin of an NFT, often the origin is not a key that an artist maintains as closely as they would a hand written signature.\r\n\r\nAn edition is a printed replica of an original piece of art. ERC-721 is not specifically designed to be used for works of art, such as digital art and music. ERC-721 (NFT) was originally created to handle deeds and other contracts. Eventually 721 evolved into gaming tokens, where metadata hosted by servers may be sufficient. This proposal takes the position that we can create a more tangible link between the NFT, digital art, owner, and artist. By making a concise standard for art, it will be easier for an artist to maintain a connection with the Ethereum blockchain as well as their fans that purchase their tokens.\r\n\r\nThe use cases for NFTs have evolved into works of digital art, and there is a need to designate an original NFT and printed editions with signatures in a trustless manner. ERC-721 contracts may or may not be deployed by artists, and currently, the only way to understand that something is uniquely touched by an artist is to display it on 3rd party applications that assume a connection via metadata that exists on servers, external to the blockchain. This proposal helps remove that distance with readily available functionality for artists to sign their work and provides a standard for 3rd party applications to display the uniqueness of a NFT for those that purchase them. The designation of limited-editions combined with immutable signatures, creates a trustlessly enforced link. This signature is accompanied by view functions that allow applications to easily display these signatures and limited-edition prints as evidence of uniqueness by showing that artists specifically used their key to designate the total supply and sign each NFT.\r\n\r\n## Specification\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\r\n\r\nERC-721 compliant contracts MAY implement this ERC for editions to provide a standard method for designating the original and limited-edition prints with signatures from the artist.\r\n\r\nImplementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.\r\n\r\nArtists MAY use the signing feature to sign the original or limited edition prints but this is OPTIONAL. A standard message to sign is RECOMMENDED to be simply a hash of the integer of the token Id. \r\n\r\nSignature messages MUST use the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) standard.\r\n\r\nA contract that is compliant with ERC-3440 shall implement the following abstract contract (referred to as ERC3440.sol):\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\n\r\n/**\r\n * @dev ERC721 token with editions extension.\r\n */\r\nabstract contract ERC3440 is ERC721URIStorage {\r\n\r\n    // eip-712\r\n    struct EIP712Domain {\r\n        string  name;\r\n        string  version;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n    \r\n    // Contents of message to be signed\r\n    struct Signature {\r\n        address verificationAddress; // ensure the artists signs only address(this) for each piece\r\n        string artist;\r\n        address wallet;\r\n        string contents;\r\n    }\r\n\r\n    // type hashes\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 constant SIGNATURE_TYPEHASH = keccak256(\r\n        \"Signature(address verifyAddress,string artist,address wallet, string contents)\"\r\n    );\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    \r\n    // Optional mapping for signatures\r\n    mapping (uint256 => bytes) private _signatures;\r\n    \r\n    // A view to display the artist's address\r\n    address public artist;\r\n\r\n    // A view to display the total number of prints created\r\n    uint public editionSupply = 0;\r\n    \r\n    // A view to display which ID is the original copy\r\n    uint public originalId = 0;\r\n    \r\n    // A signed token event\r\n    event Signed(address indexed from, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Sets `artist` as the original artist.\r\n     * @param _artist the wallet of the signing artist (TODO consider multiple\r\n     * signers and contract signers (non-EOA)\r\n     */\r\n    function _designateArtist(address _artist) internal virtual {\r\n        require(artist == address(0), \"ERC721Extensions: the artist has already been set\");\r\n\r\n        // If there is no special designation for the artist, set it.\r\n        artist = _artist;\r\n    }\r\n    \r\n    /**\r\n     * @dev Sets `tokenId as the original print` as the tokenURI of `tokenId`.\r\n     * @param _tokenId the nft id of the original print\r\n     */\r\n    function _designateOriginal(uint256 _tokenId) internal virtual {\r\n        require(msg.sender == artist, \"ERC721Extensions: only the artist may designate originals\");\r\n        require(_exists(_tokenId), \"ERC721Extensions: Original query for nonexistent token\");\r\n        require(originalId == 0, \"ERC721Extensions: Original print has already been designated as a different Id\");\r\n\r\n        // If there is no special designation for the original, set it.\r\n        originalId = _tokenId;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Sets total number printed editions of the original as the tokenURI of `tokenId`.\r\n     * @param _maxEditionSupply max supply\r\n     */\r\n    function _setLimitedEditions(uint256 _maxEditionSupply) internal virtual {\r\n        require(msg.sender == artist, \"ERC721Extensions: only the artist may designate max supply\");\r\n        require(editionSupply == 0, \"ERC721Extensions: Max number of prints has already been created\");\r\n\r\n        // If there is no max supply of prints, set it. Leaving supply at 0 indicates there are no prints of the original\r\n        editionSupply = _maxEditionSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `tokenIds` representing the printed editions.\r\n     * @param _tokenURI the metadata attached to each nft\r\n     */\r\n    function _createEditions(string memory _tokenURI) internal virtual {\r\n        require(msg.sender == artist, \"ERC721Extensions: only the artist may create prints\");\r\n        require(editionSupply > 0, \"ERC721Extensions: the edition supply is not set to more than 0\");\r\n        for(uint i=0; i < editionSupply; i++) {\r\n            _mint(msg.sender, i);\r\n            _setTokenURI(i, _tokenURI);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev internal hashing utility \r\n     * @param _message the signature message struct to be signed\r\n     * the address of this contract is enforced in the hashing\r\n     */\r\n    function _hash(Signature memory _message) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(abi.encode(\r\n                SIGNATURE_TYPEHASH,\r\n                address(this),\r\n                _message.artist,\r\n                _message.wallet,\r\n                _message.contents\r\n            ))\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Signs a `tokenId` representing a print.\r\n     * @param _tokenId id of the NFT being signed\r\n     * @param _message the signed message\r\n     * @param _signature signature bytes created off-chain\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Signed} event.\r\n     */\r\n    function _signEdition(uint256 _tokenId, Signature memory _message, bytes memory _signature) internal virtual {\r\n        require(msg.sender == artist, \"ERC721Extensions: only the artist may sign their work\");\r\n        require(_signatures[_tokenId].length == 0, \"ERC721Extensions: this token is already signed\");\r\n        bytes32 digest = _hash(_message);\r\n        address recovered = ECDSA.recover(digest, _signature);\r\n        require(recovered == artist, \"ERC721Extensions: artist signature mismatch\");\r\n        _signatures[_tokenId] = _signature;\r\n        emit Signed(artist, _tokenId);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev displays a signature from the artist.\r\n     * @param _tokenId NFT id to verify isSigned\r\n     * @return bytes gets the signature stored on the token\r\n     */\r\n    function getSignature(uint256 _tokenId) external view virtual returns (bytes memory) {\r\n        require(_signatures[_tokenId].length != 0, \"ERC721Extensions: no signature exists for this Id\");\r\n        return _signatures[_tokenId];\r\n    }\r\n    \r\n    /**\r\n     * @dev returns `true` if the message is signed by the artist.\r\n     * @param _message the message signed by an artist and published elsewhere\r\n     * @param _signature the signature on the message\r\n     * @param _tokenId id of the token to be verified as being signed\r\n     * @return bool true if signed by artist\r\n     * The artist may broadcast signature out of band that will verify on the nft\r\n     */\r\n    function isSigned(Signature memory _message, bytes memory _signature, uint _tokenId) external view virtual returns (bool) {\r\n        bytes32 messageHash = _hash(_message);\r\n        address _artist = ECDSA.recover(messageHash, _signature);\r\n        return (_artist == artist && _equals(_signatures[_tokenId], _signature));\r\n    }\r\n\r\n    /**\r\n    * @dev Utility function that checks if two `bytes memory` variables are equal. This is done using hashing,\r\n    * which is much more gas efficient then comparing each byte individually.\r\n    * Equality means that:\r\n    *  - 'self.length == other.length'\r\n    *  - For 'n' in '[0, self.length)', 'self[n] == other[n]'\r\n    */\r\n    function _equals(bytes memory _self, bytes memory _other) internal pure returns (bool equal) {\r\n        if (_self.length != _other.length) {\r\n            return false;\r\n        }\r\n        uint addr;\r\n        uint addr2;\r\n        uint len = _self.length;\r\n        assembly {\r\n            addr := add(_self, /*BYTES_HEADER_SIZE*/32)\r\n            addr2 := add(_other, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        assembly {\r\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Rationale\r\n\r\nA major role of NFTs is to display uniqueness in digital art. Provenance is a desired feature of works of art, and this standard will help improve a NFT by providing a better way to verify uniqueness. Taking this extra step by an artist to explicitly sign tokens provides a better connection between the artists and their work on the blockchain. Artists can now retain their private key and sign messages in the future showing that the same signature is present on a unique NFT.\r\n\r\n## Backwards Compatibility\r\n\r\nThis proposal combines already available 721 extensions and is backwards compatible with the ERC-721 standard.\r\n\r\n## Test Cases\r\nAn example implementation including tests can be found [here](https://github.com/nginnever/NFT-editions).\r\n\r\n## Reference Implementation\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ERC3440.sol\";\r\n\r\n/**\r\n * @dev ERC721 token with editions extension.\r\n */\r\ncontract ArtToken is ERC3440 {\r\n\r\n    /**\r\n     * @dev Sets `address artist` as the original artist to the account deploying the NFT.\r\n     */\r\n     constructor (\r\n        string memory _name, \r\n        string memory _symbol,\r\n        uint _numberOfEditions,\r\n        string memory tokenURI,\r\n        uint _originalId\r\n    ) ERC721(_name, _symbol) {\r\n        _designateArtist(msg.sender);\r\n        _setLimitedEditions(_numberOfEditions);\r\n        _createEditions(tokenURI);\r\n        _designateOriginal(_originalId);\r\n\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(\"Artist's Editions\")),\r\n            keccak256(bytes(\"1\")),\r\n            1,\r\n            address(this)\r\n        ));\r\n    }\r\n    \r\n    /**\r\n     * @dev Signs a `tokenId` representing a print.\r\n     */\r\n    function sign(uint256 _tokenId, Signature memory _message, bytes memory _signature) public {\r\n        _signEdition(_tokenId, _message, _signature);\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Security Considerations\r\nThis extension gives an artist the ability to designate an original edition, set the maximum supply of editions as well as print the editions and uses the `tokenURI` extension to supply a link to the art work. To minimize the risk of an artist changing this value after selling an original piece this function can only happen once. Ensuring that these functions can only happen once provides consistency with uniqueness and verifiability. Due to this, the reference implementation handles these features in the constructor function. An edition may only be signed once, and care should be taken that the edition is signed correctly before release of the token/s.\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/3519/reactions",
    "total_count": 4,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/822986327",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-822986327",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 822986327,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgyMjk4NjMyNw==",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-04-20T05:34:27Z",
    "updated_at": "2021-04-20T05:34:27Z",
    "author_association": "NONE",
    "body": "Since this is your first issue, we kindly remind you to check out [EIP-1](https://eips.ethereum.org/EIPS/eip-1) for guidance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/822986327/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/840799218",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-840799218",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 840799218,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0MDc5OTIxOA==",
    "user": {
      "login": "nginnever",
      "id": 7103153,
      "node_id": "MDQ6VXNlcjcxMDMxNTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7103153?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nginnever",
      "html_url": "https://github.com/nginnever",
      "followers_url": "https://api.github.com/users/nginnever/followers",
      "following_url": "https://api.github.com/users/nginnever/following{/other_user}",
      "gists_url": "https://api.github.com/users/nginnever/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nginnever/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nginnever/subscriptions",
      "organizations_url": "https://api.github.com/users/nginnever/orgs",
      "repos_url": "https://api.github.com/users/nginnever/repos",
      "events_url": "https://api.github.com/users/nginnever/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nginnever/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-13T20:01:02Z",
    "updated_at": "2021-05-13T20:01:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm currently extending this extension to support multitoken and replace ERC1155, as 1155 is a bit more biased to ERC20. This will include sectioning off the ID space of the mapping for editions and allowing multiple `originalIDs` to be placed in a correct position. I may open a different request for comments for this. I am not sure if extensions are the best place for EIP however and may just continue these extensions on the forums. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/840799218/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248899",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-950248899",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 950248899,
    "node_id": "IC_kwDOAq426M44o6XD",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-10-24T02:26:46Z",
    "updated_at": "2021-10-24T02:26:46Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950248899/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541379",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-962541379",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 962541379,
    "node_id": "IC_kwDOAq426M45XzdD",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-07T02:28:46Z",
    "updated_at": "2021-11-07T02:28:46Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962541379/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/966262157",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-966262157",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 966262157,
    "node_id": "IC_kwDOAq426M45l_2N",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-11T12:26:53Z",
    "updated_at": "2021-11-11T12:26:53Z",
    "author_association": "MEMBER",
    "body": "The actual EIP has the following discussion URL: https://ethereum-magicians.org/t/eip-3340-nft-editions-standard-extension/6044",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/966262157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1005060183",
    "html_url": "https://github.com/ethereum/EIPs/issues/3519#issuecomment-1005060183",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/3519",
    "id": 1005060183,
    "node_id": "IC_kwDOAq426M476ABX",
    "user": {
      "login": "MaxflowO2",
      "id": 82993680,
      "node_id": "MDQ6VXNlcjgyOTkzNjgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/82993680?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MaxflowO2",
      "html_url": "https://github.com/MaxflowO2",
      "followers_url": "https://api.github.com/users/MaxflowO2/followers",
      "following_url": "https://api.github.com/users/MaxflowO2/following{/other_user}",
      "gists_url": "https://api.github.com/users/MaxflowO2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MaxflowO2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MaxflowO2/subscriptions",
      "organizations_url": "https://api.github.com/users/MaxflowO2/orgs",
      "repos_url": "https://api.github.com/users/MaxflowO2/repos",
      "events_url": "https://api.github.com/users/MaxflowO2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MaxflowO2/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-04T18:19:31Z",
    "updated_at": "2022-01-04T18:19:31Z",
    "author_association": "NONE",
    "body": "Yeah sign me up, want to actually make this happen",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1005060183/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
