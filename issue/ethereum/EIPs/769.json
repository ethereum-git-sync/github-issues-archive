{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/769/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/769/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/769/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/769",
  "id": 274666267,
  "node_id": "MDU6SXNzdWUyNzQ2NjYyNjc=",
  "number": 769,
  "title": "ERC - Multi-signature standard API for Second Layer Applications",
  "user": {
    "login": "alex-miller-0",
    "id": 7378490,
    "node_id": "MDQ6VXNlcjczNzg0OTA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alex-miller-0",
    "html_url": "https://github.com/alex-miller-0",
    "followers_url": "https://api.github.com/users/alex-miller-0/followers",
    "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
    "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
    "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
    "repos_url": "https://api.github.com/users/alex-miller-0/repos",
    "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 28,
  "created_at": "2017-11-16T21:15:26Z",
  "updated_at": "2022-01-03T06:14:17Z",
  "closed_at": "2022-01-03T06:14:17Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "# ERC - Multisignature Standard API for Second Layer Applications\r\n\r\nThis ERC defines a standardized API for interacting with a multi-signature account contract. This aims to be the smallest amount of functionality required to operate a multisig contract on Ethereum and is meant to be applied to second layer applications (e.g. wallets).\r\n\r\n## API\r\n\r\nA standard multisig contract is deployed based on Christian Lundkvist's [design](https://github.com/christianlundkvist/simple-multisig/blob/master/contracts/SimpleMultiSig.sol), which I have slightly modified [here](https://github.com/alex-miller-0/simple-multisig/blob/master/contracts/SimpleMultisig.sol).\r\n\r\nThere are two parts to the API:\r\n  1. Public variables\r\n  2. An execution function\r\n\r\n***Note:** this is meant to a very generic API containing only the necessary metadata and an execution interface. It was written with the contract linked above in mind, but it should be extendable to cover other use cases.*\r\n\r\n### Public Variables\r\n\r\n```\r\nmapping (address => bool) public isOwner;\r\n```\r\n\r\nThe above mapping is needed to evaluate if a signer of a message is indeed an authorized\r\nsigner of the contract.\r\n\r\n```\r\nuint public nOwners;\r\naddress[] public ownersArr;\r\n```\r\n\r\nTogether, these two variables allow the application to query the owners of the contract (for display purposes).\r\n\r\n```\r\nuint public nonce;\r\n```\r\n\r\nA nonce is required to prevent replay attacks. It is incremented after each successful transaction\r\nexecution. It must be used when forming transactions (see #197).\r\n\r\n```\r\nuint public threshold;\r\n```\r\n\r\nThis is the number of signatures required to execute a given message. Note that some contracts\r\nmay reject transactions containing more than `threshold` signatures, so it is best to treat\r\nthis as the exact number needed.\r\n\r\n### Execution\r\n\r\nGiven a set of signatures, a transaction may be executed using the following function:\r\n\r\n```\r\nfunction execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data)\r\n```\r\n\r\nWhere `destination`, `value`, and `data` are hashed with additional data following #197. This hash is used in an ECDSA signature to produce `v`, `r`, and `s` parameters for each co-signer.\r\n\r\n## Rationale\r\n\r\nRecent events have cast Ethereum multisig patterns into the spotlight. Since 2012 Bitcoin has used a standardized pay to script hash (P2SH) multisig pattern which still has no documented exploitations. The relative safety of Bitcon's pattern is likely a result of its extremely small attack surface.\r\n\r\nMultisig contracts are critical pieces of infrastructure in the crypto world because they remove single points of failure. There are many potential Ethereum users who would feel much safer with a multisig setup, but are unable to utilize one because many common tools and wallets don't offer multisig support. Although many multisig implementations exist on Ethereum today, they do not share a common API and require more functionality and complexity than many users would want.\r\n\r\nThe purpose of this standard is to define a common, simple interface that facilitates multisig support in second layer applications like wallets. Setting up a basic multisig wallet with friends or family members should be as easy as pasting a few addresses and clicking a button.\r\n\r\nNote: This scheme is agnostic to how signatures are stored. They could either be aggregated by one of the co-signers (i.e. stored on a sever or passed around via a messaging protocol) or they could be temporarily stored in the contract.\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/769/reactions",
    "total_count": 6,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/769/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345187499",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345187499",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345187499,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTE4NzQ5OQ==",
    "user": {
      "login": "stskeeps",
      "id": 1255200,
      "node_id": "MDQ6VXNlcjEyNTUyMDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1255200?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stskeeps",
      "html_url": "https://github.com/stskeeps",
      "followers_url": "https://api.github.com/users/stskeeps/followers",
      "following_url": "https://api.github.com/users/stskeeps/following{/other_user}",
      "gists_url": "https://api.github.com/users/stskeeps/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stskeeps/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stskeeps/subscriptions",
      "organizations_url": "https://api.github.com/users/stskeeps/orgs",
      "repos_url": "https://api.github.com/users/stskeeps/repos",
      "events_url": "https://api.github.com/users/stskeeps/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stskeeps/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-17T09:14:18Z",
    "updated_at": "2017-11-17T09:14:18Z",
    "author_association": "NONE",
    "body": "It'd be good to have smart contracts as one of the owners of a multisig standardized as well, or at least queryable if it's supported. Think a multisig being a part owner of another multisig, for instance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345187499/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345333619",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345333619",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345333619,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTMzMzYxOQ==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-17T18:58:49Z",
    "updated_at": "2017-11-17T18:58:49Z",
    "author_association": "MEMBER",
    "body": "You know what. I finally figured out what's missing from this. This needs a modifier statement complete with the forwarding of the data from the transaction. This way type safety is also achieved within the solidity process and enables this to be extended to include swapping rules, confirmation rules, etc. There *might* also be a use for somehow storing all the signatures in memory but that's probably a bit out of scope. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345333619/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345371149",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345371149",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345371149,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTM3MTE0OQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-17T21:33:00Z",
    "updated_at": "2017-11-17T21:38:03Z",
    "author_association": "NONE",
    "body": "@stskeeps I can definitely see benefits to mutisigs being owners of other multisigs, but I worry about the complexity that requires. Contracts can't (and to my knowledge won't ever) be able to sign transactions directly. This seems dangerous for a standard, simple multisig approach.\r\n\r\n@VoR0220 I don't follow. Perhaps it's because I'm unfamiliar with a lot of the new Solidity features. Can you provide an example? As for storing signatures, I agree it could be useful. This scheme does not preclude someone from implementing a contract that does that.\r\n\r\nEdit: I see I pushed storage of signatures off-chain in the original draft. Technically that is not required so I updated the ERC.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345371149/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345419277",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345419277",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345419277,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQxOTI3Nw==",
    "user": {
      "login": "3sGgpQ8H",
      "id": 3917202,
      "node_id": "MDQ6VXNlcjM5MTcyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3917202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3sGgpQ8H",
      "html_url": "https://github.com/3sGgpQ8H",
      "followers_url": "https://api.github.com/users/3sGgpQ8H/followers",
      "following_url": "https://api.github.com/users/3sGgpQ8H/following{/other_user}",
      "gists_url": "https://api.github.com/users/3sGgpQ8H/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3sGgpQ8H/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3sGgpQ8H/subscriptions",
      "organizations_url": "https://api.github.com/users/3sGgpQ8H/orgs",
      "repos_url": "https://api.github.com/users/3sGgpQ8H/repos",
      "events_url": "https://api.github.com/users/3sGgpQ8H/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3sGgpQ8H/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T05:14:15Z",
    "updated_at": "2017-11-18T05:14:15Z",
    "author_association": "NONE",
    "body": "@alex-miller-0 \r\n> Contracts can't (and to my knowledge won't ever) be able to sign transactions directly\r\n\r\nThough contract may answer whether it has “signed” particular transaction or not.  Once contract implements method like `hasSigned (bytes32 _hash) returns (bool)`, such contract could be used as one of the owners of multisig wallet.  The wallet just need to support two kinds of signatures: “EC-signatures” verified via `ecrecover`, and “contract” signatures verified by calling `hasSigned` method on corresponding contract address.  “Contract” signature is actually just an address of smart contract to call “hasSigned” on.  Of cause wallet should first check that all contracts provided as “contract” signatures for transactions are actually the owners of the wallet.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345419277/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345449725",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345449725",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345449725,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ0OTcyNQ==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T15:32:43Z",
    "updated_at": "2017-11-18T15:33:32Z",
    "author_association": "MEMBER",
    "body": "@alex-miller-0 It's a rather old solidity feature actually and fairly simple. The modifier would look something like the following:\r\n\r\n```\r\nmodifier canProceed(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address to) {\r\n       execute(sigV, sigR, sigS, address(this), to, msg.value, msg.data);\r\n       _;\r\n}\r\n```\r\n\r\nGranted the call part at the end would *probably* need to be modified, but I think this makes it a tad cleaner and more extensible...also preserves type safety in the original function call. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345449725/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460038",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345460038",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345460038,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MDAzOA==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:11:11Z",
    "updated_at": "2017-11-18T18:21:11Z",
    "author_association": "NONE",
    "body": "@alex-miller-0 one thing I’ve been considering is to make the core logic of verifying the signatures  into a stateless library. This would further mimic the stateless nature of bitcoin P2SH. This library would take as inputs the array of owners, the threshold number, as well as the list of signatures. It would return true if the list of signatures is valid and false otherwise.\r\n\r\nYou would still need to create the actual multisig contracts in much the same way except the core would be a call to this library.\r\n\r\nSuch a library, being stateless, could also be a good target for formal verification.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460038/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460413",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345460413",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345460413,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MDQxMw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:17:15Z",
    "updated_at": "2017-11-18T18:17:15Z",
    "author_association": "MEMBER",
    "body": "I would love to see an optional section, or extension EIP that implements variable membership for this system, too. In my mind that's the one thing preventing this from being generally useful for a lot of persistent multisig use-cases.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460413/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460831",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345460831",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345460831,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MDgzMQ==",
    "user": {
      "login": "3sGgpQ8H",
      "id": 3917202,
      "node_id": "MDQ6VXNlcjM5MTcyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3917202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3sGgpQ8H",
      "html_url": "https://github.com/3sGgpQ8H",
      "followers_url": "https://api.github.com/users/3sGgpQ8H/followers",
      "following_url": "https://api.github.com/users/3sGgpQ8H/following{/other_user}",
      "gists_url": "https://api.github.com/users/3sGgpQ8H/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3sGgpQ8H/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3sGgpQ8H/subscriptions",
      "organizations_url": "https://api.github.com/users/3sGgpQ8H/orgs",
      "repos_url": "https://api.github.com/users/3sGgpQ8H/repos",
      "events_url": "https://api.github.com/users/3sGgpQ8H/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3sGgpQ8H/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:22:37Z",
    "updated_at": "2017-11-18T18:22:37Z",
    "author_association": "NONE",
    "body": "@VoR0220 \r\nI would say:\r\n\r\n    modifier multisig (uint8[] sigV, bytes32[] sigR, bytes32[] sigS) {\r\n      require (checkSignatures (sigV, sigR, sigS, address(this), msg.value, msg.data);\r\n      _;\r\n    }\r\n\r\nHere `checkSignatures` performs the same signatures check as `execute` but then just returns check result (true means signatures are OK) instead of executing the transaction.\r\n\r\nIn this case `execute` method could be implemented as:\r\n\r\n    function execute (\r\n      uint8[] sigV, bytes32[] sigR, bytes32[] sigS,\r\n      address destination, uint value, bytes data) {\r\n      require (checkSignatures (sigV, sigR, sigS, destination, value, data));\r\n      require (destination.call.value (value)(data));\r\n    }",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345460831/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345461704",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345461704",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345461704,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MTcwNA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:35:49Z",
    "updated_at": "2017-11-18T18:35:49Z",
    "author_association": "MEMBER",
    "body": "@mikhail-vladimirov This is off-topic for the spec, which only defines interface, not implementation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345461704/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345461848",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345461848",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345461848,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MTg0OA==",
    "user": {
      "login": "3sGgpQ8H",
      "id": 3917202,
      "node_id": "MDQ6VXNlcjM5MTcyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3917202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3sGgpQ8H",
      "html_url": "https://github.com/3sGgpQ8H",
      "followers_url": "https://api.github.com/users/3sGgpQ8H/followers",
      "following_url": "https://api.github.com/users/3sGgpQ8H/following{/other_user}",
      "gists_url": "https://api.github.com/users/3sGgpQ8H/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3sGgpQ8H/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3sGgpQ8H/subscriptions",
      "organizations_url": "https://api.github.com/users/3sGgpQ8H/orgs",
      "repos_url": "https://api.github.com/users/3sGgpQ8H/repos",
      "events_url": "https://api.github.com/users/3sGgpQ8H/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3sGgpQ8H/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:38:16Z",
    "updated_at": "2017-11-18T18:41:05Z",
    "author_association": "NONE",
    "body": "@christianlundkvist \r\n> array of owners, the threshold number\r\n\r\nThis will immediately limit usages of such library to the narrow class of simple n-of-m wallets.  I mean there will be impossible to use it in\r\n1. Multisig wallets whose owners have different signing powers, e.g. signature of senior owner counts as two signatures of junior owners\r\n2. Multisig wallets whose full list of owners is not known to the contract, but contract may easily check whether particular address is an owner or not, e.g. wallets whose ownership rights are represented by tradable ERC-20 tokens\r\n3. Multisig wallets whose set of owners is not flat-structured, e.g. whose set of owners is split into several groups and in order to be executed transaction has to have at least one signature from each group\r\n\r\netc.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345461848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345462195",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345462195",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345462195,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MjE5NQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:43:50Z",
    "updated_at": "2017-11-18T18:43:50Z",
    "author_association": "NONE",
    "body": "@christianlundkvist Yes I think a static library is a good idea.\r\n\r\n@Arachnid I see how that might be useful, but I personally would be wary of using a contract where the owners could change and/or I could be booted from ownership. Is a second layer application's ability to facilitate draining and creation of a new multisig insufficient?\r\n\r\n@VoR0220 Are you just suggesting a modifier instead of the `if` statement written into the implementation I linked? If so I agree your version is cleaner.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345462195/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345462498",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345462498",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345462498,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MjQ5OA==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:48:46Z",
    "updated_at": "2017-11-18T18:48:46Z",
    "author_association": "NONE",
    "body": "@mikhail-vladimirov \r\n\r\n> This will immediately limit usages of such library to the narrow class of simple n-of-m wallets.\r\n\r\nYep, that was my goal with creating `simple-multisig` to begin with. I only wanted the minimum possible functionality in order to make the contract simple enough to easily audit and formally verify.\r\n\r\n@Arachnid The main usecase I had in mind was holding ETH and tokens, in which case switching owners can be achieved by sending the ETH and tokens to a new contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345462498/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345463093",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345463093",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345463093,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2MzA5Mw==",
    "user": {
      "login": "3sGgpQ8H",
      "id": 3917202,
      "node_id": "MDQ6VXNlcjM5MTcyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3917202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3sGgpQ8H",
      "html_url": "https://github.com/3sGgpQ8H",
      "followers_url": "https://api.github.com/users/3sGgpQ8H/followers",
      "following_url": "https://api.github.com/users/3sGgpQ8H/following{/other_user}",
      "gists_url": "https://api.github.com/users/3sGgpQ8H/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3sGgpQ8H/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3sGgpQ8H/subscriptions",
      "organizations_url": "https://api.github.com/users/3sGgpQ8H/orgs",
      "repos_url": "https://api.github.com/users/3sGgpQ8H/repos",
      "events_url": "https://api.github.com/users/3sGgpQ8H/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3sGgpQ8H/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T18:57:47Z",
    "updated_at": "2017-11-18T18:58:08Z",
    "author_association": "NONE",
    "body": "@christianlundkvist \r\n> Yep, that was my goal with creating simple-multisig to begin with\r\n\r\nThis is really good for those who are satisfied with functionality.  The simpler contract is the better contract.  The question is whether such limited functionality should become EIP standard or not.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345463093/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345464608",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345464608",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345464608,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2NDYwOA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T19:20:39Z",
    "updated_at": "2017-11-18T19:20:39Z",
    "author_association": "MEMBER",
    "body": "@alex-miller-0 @christianlundkvist An example would be the multisig that holds the ENS root. Multisigs that correspond to large team wallets also probably don't want to have to change address and migrate all their tokens every time team membership changes.\r\n\r\nGiven that a quorum of participants can move all the funds to a new account, it doesn't seem like a larger risk to allow that same quorum to change the list of participants.\r\n\r\nI can see an argument for leaving membership changes out of the basic protocol, but some form of functionality would be useful as at least an optional feature - even if the only thing you can do is swap out one member for another without changing the total number or the threshold.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345464608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345465268",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345465268",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345465268,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2NTI2OA==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T19:29:45Z",
    "updated_at": "2017-11-18T19:29:45Z",
    "author_association": "MEMBER",
    "body": "I like the idea of making that an extension of this and this small portion being the base standard. Modifier being about implementation is kind of like..hrm..I guess what you'd really be arguing for is a standard library implementation? Which I think might be a better way of viewing this than a standard interface (what good does the interface do us if what's in the interface is genuinely broken?) Although...there is a good point made here by @mikhail-vladimirov (also, yes, that's exactly what I was going for re: the modifier), that weights might need to be taken into account and hence there is a good need for this to be abstracted into the interface category. However...perhaps there's a means of doing that via the described extension EIP? Not sure if it is. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345465268/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345465335",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345465335",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345465335,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2NTMzNQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T19:30:39Z",
    "updated_at": "2017-11-18T19:30:39Z",
    "author_association": "NONE",
    "body": "@mikhail-vladimirov Agree. I created this proposal because I think the basic interface should be extremely simple and common across all UIs even if some have additional features. This would make multisig integration easy, which would likely drive use.\r\n\r\n@Arachnid That is a compelling use case. I don't see any reason it couldn't be extended from the basic protocol but my imagined use case (opening a multisig with friends+family to keep your funds safer) would be much less safe with that functionality.\r\n\r\nThat said, I will remove the portion of the ERC where I say these are read-only variables, since it seems this standard should be more flexible and should just be confined to an execution interface and some metadata.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345465335/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345467450",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345467450",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345467450,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2NzQ1MA==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T20:03:29Z",
    "updated_at": "2017-11-18T20:03:29Z",
    "author_association": "MEMBER",
    "body": "I'm beginning to think that we should view this from the point of contract inheritance layers. The point should be to practice inheritance with this being the base layer (should only focus on verifying transactions and the threshold...though that threshold bit might need to be considered further if we have to think for weighting), and then the second layer is where we standardize an interface for the swapping, weighting, adding, removing, etc. The third layer, is the application main logic to be executed under which inherits the above 1-2 layers. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345467450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345468828",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345468828",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345468828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2ODgyOA==",
    "user": {
      "login": "3sGgpQ8H",
      "id": 3917202,
      "node_id": "MDQ6VXNlcjM5MTcyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3917202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3sGgpQ8H",
      "html_url": "https://github.com/3sGgpQ8H",
      "followers_url": "https://api.github.com/users/3sGgpQ8H/followers",
      "following_url": "https://api.github.com/users/3sGgpQ8H/following{/other_user}",
      "gists_url": "https://api.github.com/users/3sGgpQ8H/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3sGgpQ8H/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3sGgpQ8H/subscriptions",
      "organizations_url": "https://api.github.com/users/3sGgpQ8H/orgs",
      "repos_url": "https://api.github.com/users/3sGgpQ8H/repos",
      "events_url": "https://api.github.com/users/3sGgpQ8H/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3sGgpQ8H/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T20:24:57Z",
    "updated_at": "2017-11-19T03:28:42Z",
    "author_association": "NONE",
    "body": "@alex-miller-0 \r\n> I think the basic interface should be extremely simple and common\r\n\r\nWhen talking about sophisticated wallets, I didn't mean that standard should require such complicated scenarios to be supported by all compliant wallets nor that standard should describe such scenarios.  I just believe that standard should not make such scenarios impossible.\r\n\r\nFor example your proposal says:\r\n> Where destination, value, and data are hashed with additional data following #197. This hash is used in an ECDSA signature to produce v, r, and s parameters for each co-signer.\r\n\r\nActual standard has to define exactly how the hash is calculated, because hash calculation has to be implemented in client code and, if we want to have single client that is able to work with all standard-compliant wallets, then all the wallets should calculate hash in the same way.  Here we will need to define how nonce is assigned to a transaction and how it is hashed in.  Or, we will need to define some other mechanism to prevent signed transaction from being executed multiple times.\r\n\r\nAs for me, mechanism implemented in simple wallet you referred is fine for simple basic wallet, but is too limited to become a standard, because nonce is assigned to a transaction at the moment the transaction is being executed, but owners need to know nonce when they are signing the transaction, i.e. prior to execution.  This makes it really hard to collect signatures for several transactions in parallel assuming some of the transactions may not be able to collect enough signatures and will never be executed.\r\n\r\nSo I think that while general idea is really good, standard should define more flexible mechanism for preventing transaction re-execution and unfortunately it seems that such better mechanism will require signature of `execute` method to be changed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345468828/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345469528",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345469528",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345469528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2OTUyOA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T20:37:02Z",
    "updated_at": "2017-11-18T20:37:02Z",
    "author_association": "MEMBER",
    "body": "> Modifier being about implementation is kind of like..hrm..I guess what you'd really be arguing for is a standard library implementation? \r\n\r\nNo, I'm just pointing out that modifiers aren't part of the ABI.\r\n\r\n> @alex-miller-0 That is a compelling use case. I don't see any reason it couldn't be extended from the basic protocol but my imagined use case (opening a multisig with friends+family to keep your funds safer) would be much less safe with that functionality.\r\n\r\nI don't follow - why would your example be less safe with that functionality?\r\n\r\n> I'm beginning to think that we should view this from the point of contract inheritance layers. The point should be to practice inheritance with this being the base layer (should only focus on verifying transactions and the threshold...though that threshold bit might need to be considered further if we have to think for weighting), and then the second layer is where we standardize an interface for the swapping, weighting, adding, removing, etc. The third layer, is the application main logic to be executed under which inherits the above 1-2 layers.\r\n\r\nThat's also out of scope for an interface specification. Bear in mind implementations may not even be implemented in Solidity.\r\n\r\n> As for me, mechanism implemented in simple wallet you referred is fine for simple basic wallet, but is too limited to become a standard, because nonce is assigned to a transaction at the moment the transaction is being executed, but owners need to know nonce when they are signing the transaction, i.e. prior to execution. This makes it really hard to collect signatures for several transactions in parallel assuming some of the transactions may not be able to collect enough signatures and will never be executed.\r\n\r\nPersonally, I don't think this is a barrier to common multisig wallet use-cases.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345469528/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345469941",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345469941",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345469941,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ2OTk0MQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T20:44:43Z",
    "updated_at": "2017-11-18T20:44:43Z",
    "author_association": "NONE",
    "body": "> why would your example be less safe with that functionality?\r\n\r\nI just meant it adds complexity and requires additional state/changes, which I view as generally less safe. My language was a little stronger than it should have been; I think it's fine as an option just not as a requirement.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345469941/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345470330",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345470330",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345470330,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ3MDMzMA==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-18T20:51:24Z",
    "updated_at": "2017-11-18T20:52:56Z",
    "author_association": "MEMBER",
    "body": "@Arachnid I'm not sure if it is out of scope. Unless my usage of inheritance being specified was too strong, then I can see that as being out of scope. However, I guess my main point is that I'm agreeing with the sentiment that the interfaces ought to be separate, one for basic usage, and another meant to be coupled with the basic usage that carries the standard swap, remove, add functions. \r\n\r\nAlso re: modifiers...got it. 👍 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345470330/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345520917",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-345520917",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 345520917,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTUyMDkxNw==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-19T14:30:11Z",
    "updated_at": "2017-11-19T14:30:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "Related #745 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345520917/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351070002",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-351070002",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 351070002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTA3MDAwMg==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-12T14:39:00Z",
    "updated_at": "2017-12-12T14:40:17Z",
    "author_association": "MEMBER",
    "body": "@naumenkogs because a multisig is useful for more than just handling transactions. It's in the name. It's made to do something when multiple signatures create a quorum. \r\n\r\nFurthermore...this is very easy to extend. It can literally handle anything that you throw at it. Any kind of call, any kind of data, any value...anything. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351070002/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351147537",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-351147537",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 351147537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTE0NzUzNw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-12T18:41:07Z",
    "updated_at": "2017-12-12T18:41:07Z",
    "author_association": "MEMBER",
    "body": "> @naumenkogs well, it's still not clear why actions should be stored off-chain. Even though it's not just handling transactions, we can always store message/payload/... in the contract memory. (unless it's private before getting executed — one more thing to discuss)\r\n\r\nI would argue the reverse: Unless you have a good reason that actions (or anything else) have to be stored onchain, don't.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351147537/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351486067",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-351486067",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 351486067,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTQ4NjA2Nw==",
    "user": {
      "login": "VoR0220",
      "id": 7756785,
      "node_id": "MDQ6VXNlcjc3NTY3ODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7756785?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VoR0220",
      "html_url": "https://github.com/VoR0220",
      "followers_url": "https://api.github.com/users/VoR0220/followers",
      "following_url": "https://api.github.com/users/VoR0220/following{/other_user}",
      "gists_url": "https://api.github.com/users/VoR0220/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VoR0220/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VoR0220/subscriptions",
      "organizations_url": "https://api.github.com/users/VoR0220/orgs",
      "repos_url": "https://api.github.com/users/VoR0220/repos",
      "events_url": "https://api.github.com/users/VoR0220/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VoR0220/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-13T18:51:13Z",
    "updated_at": "2017-12-13T18:51:13Z",
    "author_association": "MEMBER",
    "body": "@naumenkogs I would say that you *could* practice inheritance here and execute from there. Wrt to the payload issue, if you're going to be performing an external message call, why wouldn't you prepare the payload based off the function you intend to call from the multisig ala the example above using the `data` parameter at the end? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/351486067/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/616949456",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-616949456",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 616949456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNjk0OTQ1Ng==",
    "user": {
      "login": "jtolio",
      "id": 109603,
      "node_id": "MDQ6VXNlcjEwOTYwMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/109603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtolio",
      "html_url": "https://github.com/jtolio",
      "followers_url": "https://api.github.com/users/jtolio/followers",
      "following_url": "https://api.github.com/users/jtolio/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtolio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtolio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtolio/subscriptions",
      "organizations_url": "https://api.github.com/users/jtolio/orgs",
      "repos_url": "https://api.github.com/users/jtolio/repos",
      "events_url": "https://api.github.com/users/jtolio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtolio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T04:46:55Z",
    "updated_at": "2020-04-21T04:46:55Z",
    "author_association": "NONE",
    "body": "hello people of 2017! i come from the far future. it's 2020. we're all in quarantine from a global pandemic. the british are going through something called \"megxit.\" https://blog.gridplus.io/building-a-usable-multisig-wallet-59039b60cbf6 is still not a thing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/616949456/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997602608",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-997602608",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 997602608,
    "node_id": "IC_kwDOAq426M47djUw",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-20T05:12:43Z",
    "updated_at": "2021-12-20T05:12:43Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997602608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003889858",
    "html_url": "https://github.com/ethereum/EIPs/issues/769#issuecomment-1003889858",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/769",
    "id": 1003889858,
    "node_id": "IC_kwDOAq426M471iTC",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-03T06:14:16Z",
    "updated_at": "2022-01-03T06:14:16Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1003889858/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
