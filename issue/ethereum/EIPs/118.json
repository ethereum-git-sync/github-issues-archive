{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/118/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/118/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/118/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/118",
  "id": 161079240,
  "node_id": "MDU6SXNzdWUxNjEwNzkyNDA=",
  "number": 118,
  "title": "New  Opcode ASYNC_CALL",
  "user": {
    "login": "wanderer",
    "id": 158211,
    "node_id": "MDQ6VXNlcjE1ODIxMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wanderer",
    "html_url": "https://github.com/wanderer",
    "followers_url": "https://api.github.com/users/wanderer/followers",
    "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
    "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
    "organizations_url": "https://api.github.com/users/wanderer/orgs",
    "repos_url": "https://api.github.com/users/wanderer/repos",
    "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wanderer/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 18,
  "created_at": "2016-06-19T15:58:31Z",
  "updated_at": "2022-01-30T02:24:15Z",
  "closed_at": "2022-01-30T02:24:15Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## DESCRIPTION\n\nIf block.number >= METROPOLIS_FORK_BLKNUM, then opcode 0xfa functions equivalently to a CALL, except it takes 6 arguments not including value, and makes an ASYNC calls the child. No Items are PUSHED on to the stack. Normal Calls made after an Async call work as normal. \n\nIn the current execution model, async calls are executed after the parent execution is finished.  If more than one Async calls (ac₀, ac₁ .... acₙ) happened during a given execution then after the parent execution has stopped then the async calls are ran in the order that they were generated (ac₀, ac₁ .... acₙ).  \n\nHere is a Sequence Diagram of the current model\n![current](https://docs.google.com/drawings/d/1GJV7coOiVV14ksFmRXw9rcojKC66MrEBrTZL2O-nkRA/pub?w=300&amp;h=500)\n\nThe first instance of A (A₀) Make a call to contract B which then make a call back to A which creates a new instance of A (A₁)\n\nHere is how Async calls would look\n![async](https://docs.google.com/drawings/d/1bvBVicUu6TH2b9b7_uJbBDSrviyBY0NjWomWbxMQa80/pub?w=278&amp;h=365)\n\nOnly one instance of A is every created. All calls are run sequential. \n\nIn the future we maybe able to loosen the restriction on running calls sequentially. In a Concurrent Model Async calls could run in parallel.  It is assumed that contracts running concurrently would be running at the same \"speed\" (gas Per clock cycles).\n\n![concurrent](https://docs.google.com/drawings/d/1HNnFhFia_bIyrUZgtCluzXKcFnDBEgWRMYDfJwl8Sqs/pub?w=278&h=365)\n## REVERTS\n\nReverting also work that same way as the current model. If the parent execution run out of gas the child async calls will not be executed. (although a future improvement could this restriction optional)\n## GAS PRICE\n\nThe gas price should be half that of CALL (20 gas) since you could view an async call as one half of a sync call. \n## RATIONALE\n\nBy using async calls a contract programmer can guarantees about the state of storage and contract re-entry.  \n\nThe async call can also be used in the future for cross shard communications. In this scenario async call would have to be modified to accept a port (which parent shard to call). It would work similar to `ETHLOG` except there would be no need for a get log.  \n\nLast async calls can be used to recall a contract if recursive calling is disable (in an actor model where contracts are actors or It can also be thought of as contracts being singleton instances). [See here ](https://docs.google.com/document/d/1A_f4NOZelNq1R3LAnZLNCcITWkcp3BYXD8zohGRg9cA/edit?usp=sharing)\n## REFERENCES\n- [mauve paper](vitalik.ca/files/mauve_paper.html)\n- [An Alternative Hardfork Strategy](https://docs.google.com/document/d/1A_f4NOZelNq1R3LAnZLNCcITWkcp3BYXD8zohGRg9cA/edit?usp=sharing)\n## ALTERNATIVES\n- static calls #116 \n- sandboxed calls #117 \n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/118/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/118/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227005668",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227005668",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227005668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzAwNTY2OA==",
    "user": {
      "login": "Souptacular",
      "id": 3460120,
      "node_id": "MDQ6VXNlcjM0NjAxMjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3460120?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Souptacular",
      "html_url": "https://github.com/Souptacular",
      "followers_url": "https://api.github.com/users/Souptacular/followers",
      "following_url": "https://api.github.com/users/Souptacular/following{/other_user}",
      "gists_url": "https://api.github.com/users/Souptacular/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Souptacular/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Souptacular/subscriptions",
      "organizations_url": "https://api.github.com/users/Souptacular/orgs",
      "repos_url": "https://api.github.com/users/Souptacular/repos",
      "events_url": "https://api.github.com/users/Souptacular/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Souptacular/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-19T16:14:25Z",
    "updated_at": "2016-06-19T16:14:25Z",
    "author_association": "MEMBER",
    "body": "+1 Nice approach.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227005668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227009859",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227009859",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227009859,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzAwOTg1OQ==",
    "user": {
      "login": "kumavis",
      "id": 1474978,
      "node_id": "MDQ6VXNlcjE0NzQ5Nzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1474978?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kumavis",
      "html_url": "https://github.com/kumavis",
      "followers_url": "https://api.github.com/users/kumavis/followers",
      "following_url": "https://api.github.com/users/kumavis/following{/other_user}",
      "gists_url": "https://api.github.com/users/kumavis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kumavis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kumavis/subscriptions",
      "organizations_url": "https://api.github.com/users/kumavis/orgs",
      "repos_url": "https://api.github.com/users/kumavis/repos",
      "events_url": "https://api.github.com/users/kumavis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kumavis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-19T17:36:04Z",
    "updated_at": "2016-06-19T17:36:26Z",
    "author_association": "MEMBER",
    "body": "I think this is a fairly clean change. I was just imagining doing this at the solidity level, but more cleanly makes for a nice opcode.\n\nWorth note that this does not handle the case of re-entrancy **when you need a return value** from the call\n\nA couple things that should be explicitly stated in the async case:\n- value of msg.sender? (i imagine its same as normal)\n- value of tx.sender? (i imagine its same as normal)\n\n> The gas price should be half that of CALL (20 gas) since you could view an async call as one half of a sync call.\n\nseems like the change in computational cost is minimal. you get to free up some memory bc the call stack is empty but we dont set the gasfee of CALL's by stack depth anyways. gas price should be approximately the same as a standard CALL\n\n> The async call can also be used in the future for cross shard communications. \n\nsince the params are different I think it will be easiest to just define a new opcode when we're ready for cross-shard comms\n\ncurious if theres a way to modify this without muddying it up such that you can get return values as well\n\n``` js\nasync.series([\n doX,\n doY,\n], getResults)\n```\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227009859/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227015984",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227015984",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227015984,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzAxNTk4NA==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-19T19:36:22Z",
    "updated_at": "2016-06-19T19:36:22Z",
    "author_association": "MEMBER",
    "body": "> curious if theres a way to modify this without muddying it up such that you can get return values as well\n\n```\nasync.series([\n doX,\n doY,\n], getResults)\n```\n\nYeah I really want to build up to being able to do something like this.  I image async call going into a queue (FIFO). So if contract A was running and contract B & C both made async calls to it there would be 2 message in contract A's message queue. In this proposal once A is done running the next message in the queue is ran. \n\nNow to facilitate callbacks we could give the contract access to the queue. So instead of the kernel shifting the queue the contract it self could do it.  I image something like `SHIFT_QUEUE` which when called could load the next message into memory at a given index. You then could build event loop style programming which would allow for pattern you gave an example of\n\n> since the params are different I think it will be easiest to just define a new opcode when we're ready for cross-shard comms\n\nIt would need one extra parameter but it would essentially work the same. Ideally there won't be explicit shards. Just ports that contract sends message throught that allow it to communicate to sub-contracts or parent contracts.  \n\n> seems like the change in computational cost is minimal. you get to free up some memory bc the call stack is empty but we dont set the gasfee of CALL's by stack depth anyways. gas price should be approximately the same as a standard CALL\n\nI think you right but If we introduce a concurrency model (add that has to happen with sharding at some level) the difference will grow\n\n> A couple things that should be explicitly stated in the async case:\n> value of msg.sender? (i imagine its same as normal)\n> value of tx.sender? (i imagine its same as normal)\n\nyep they will remain the same.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227015984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227023693",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227023693",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227023693,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzAyMzY5Mw==",
    "user": {
      "login": "kumavis",
      "id": 1474978,
      "node_id": "MDQ6VXNlcjE0NzQ5Nzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1474978?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kumavis",
      "html_url": "https://github.com/kumavis",
      "followers_url": "https://api.github.com/users/kumavis/followers",
      "following_url": "https://api.github.com/users/kumavis/following{/other_user}",
      "gists_url": "https://api.github.com/users/kumavis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kumavis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kumavis/subscriptions",
      "organizations_url": "https://api.github.com/users/kumavis/orgs",
      "repos_url": "https://api.github.com/users/kumavis/repos",
      "events_url": "https://api.github.com/users/kumavis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kumavis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-19T22:15:02Z",
    "updated_at": "2016-06-19T22:15:02Z",
    "author_association": "MEMBER",
    "body": "> I think you right but If we introduce a concurrency model (add that has to happen with sharding at some level) the difference will grow\n\nall the more reason to let the cross-shard async call just be a different opcode and not worry about defining that now\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227023693/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227024577",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227024577",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227024577,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzAyNDU3Nw==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-19T22:34:51Z",
    "updated_at": "2016-06-19T22:34:51Z",
    "author_association": "MEMBER",
    "body": "> all the more reason to let the cross-shard async call just be a different opcode and not worry about defining that now\n\nyep, lets cross that bridge when we get there. But where I'm coming from, all shards are invisible to the contract.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227024577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227658150",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227658150",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227658150,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzY1ODE1MA==",
    "user": {
      "login": "taoeffect",
      "id": 138706,
      "node_id": "MDQ6VXNlcjEzODcwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/138706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/taoeffect",
      "html_url": "https://github.com/taoeffect",
      "followers_url": "https://api.github.com/users/taoeffect/followers",
      "following_url": "https://api.github.com/users/taoeffect/following{/other_user}",
      "gists_url": "https://api.github.com/users/taoeffect/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/taoeffect/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/taoeffect/subscriptions",
      "organizations_url": "https://api.github.com/users/taoeffect/orgs",
      "repos_url": "https://api.github.com/users/taoeffect/repos",
      "events_url": "https://api.github.com/users/taoeffect/events{/privacy}",
      "received_events_url": "https://api.github.com/users/taoeffect/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-22T06:49:18Z",
    "updated_at": "2016-06-22T06:50:19Z",
    "author_association": "NONE",
    "body": "Sorry, I am rather ignorant about the low-level details of the EVM's opcodes and execution model, but over in the solidity github I [was wondering](https://github.com/ethereum/solidity/issues/662#issuecomment-227640929) whether the message-passing Actor model from Erlang (and/or the improved [Agent](https://clojure.org/reference/agents) model from Clojure), could solve all of the reentrancy issues.\n\nAfter chatting in the solidity gitter I got the impression that it can. So my question is whether this info is at all relevant or useful or related to (in any way) to the creation of such an `ASYNC_CALL` opcode?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227658150/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227937036",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227937036",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227937036,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzkzNzAzNg==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-23T02:58:02Z",
    "updated_at": "2016-06-23T02:58:02Z",
    "author_association": "NONE",
    "body": "> I think this is a fairly clean change. I was just imagining doing this at the solidity level, but more cleanly makes for a nice opcode.\n\nI'm not inherently opposed to this, if it's useful, but I don't think it's hard to get the requested functionality with the existing opcodes. There is nothing saying that you must make an EVM call at the moment your high-level language has the word `call`. Keep a queue in memory, and when you reach the end of your execution, send the messages in the queue.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227937036/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227947956",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227947956",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227947956,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzk0Nzk1Ng==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-23T04:38:11Z",
    "updated_at": "2016-06-23T04:38:53Z",
    "author_association": "MEMBER",
    "body": "@PeterBorah you can almost get the same functionality as current. But if you build the queue inside the contract the gas costs will be off since the first call to the contract will have to pay for the anyother calls that may be in the queue. Likewise if we had strictly actor model approach you could accomplish the multiple instance writing to the same storage by breaking storage off into a contract it self.\n\nSo its more about \"what is the sanest default\" I would like to try to argue here that a singleton/actor model for contracts make more sense.  Using only async calls contracts would act like a singleton instances. \n\n@taoeffect yes exactly this is the first step needed to move fully to a actor model/ singleton instance for contracts \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227947956/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227949457",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-227949457",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 227949457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzk0OTQ1Nw==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-23T04:52:40Z",
    "updated_at": "2016-06-23T04:52:40Z",
    "author_association": "NONE",
    "body": "> But if you build the queue inside the contract the gas costs will be off since the first call to the contract will have to pay for the anyother calls that may be in the queue. \n\nI don't think I understand the distinction you're trying to draw. In the current model, each call pays for itself and any subcalls it creates. I believe that the same will be true in an async model, except that in the async model all the calls are bunched at the end rather being interspersed throughout the code. Can you give me an example where the gas would be different?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/227949457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/228037839",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-228037839",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 228037839,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyODAzNzgzOQ==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-23T12:42:22Z",
    "updated_at": "2016-06-23T12:42:22Z",
    "author_association": "MEMBER",
    "body": "@PeterBorah lets walk through an example and see if we can figure out there is a misunderstand in either of our knowledge.\n\n0) a tx is sent to contract A \n\n1) contract A async calls contract B with 100 gas (call 0)\n2) contract A async calls contract B with 200 gas (call 1)\n3) contract A async calls contract B with 300 gas (call 2)\n4) contract A finishes running. \n\n5) Now contract B will run call 0 and it call contract A (call 3) and finishes\n6) Now contract B will run call 1 and it call contract A (call 4) and finishes\n7) Now contract B will run call 2 and it call contract A (call 5) and finishes\n\n8)   Now contract B will run call 3 and finishes\n9)   Now contract B will run call 4 and and finishes\n10) Now contract B will run call 5 and finishes\n\n11) the Tx finishes execution\n\nNow how would you duplicate that functionality currently? I have several answers in mind but I'm curious what you will come up with.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/228037839/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/228164370",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-228164370",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 228164370,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyODE2NDM3MA==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-23T19:53:27Z",
    "updated_at": "2016-06-23T19:53:42Z",
    "author_association": "NONE",
    "body": "That's not how I understood the original suggestion. Given this line:\n\n> async calls are executed after the parent execution is finished\n\nI would expect it to go like this:\n\n0) a tx is sent to contract A\n\n1) contract A async calls contract B with 100 gas (call 0)\n2) contract A async calls contract B with 200 gas (call 1)\n3) contract A async calls contract B with 300 gas (call 2)\n4) contract A finishes running.\n\n5) Now contract B will run call 0 and it call contract A (call 3) and finishes\n6) Now contract A will run call 3 and finishes\n\n6) Now contract B will run call 1 and it call contract A (call 4) and finishes\n\n(etc.)\n\nThat's how it will work if we're just moving execution of calls to the end of the parent execution. And if you model that in the normal EVM, the gas semantics will be the same, since you're still making the calls from the right context, just at a different time.\n\nIf instead all calls are going into a global FIFO queue, then you need all contracts to be aware of that queue. Modeled on the current EVM, that would look like:\n\n0) A tx is sent to the queue contract, with a message for contract A (call 0a)\n1) The queue contract runs call 0a which causes it to call contract A (call 0b)\n2) Contract A runs call 0b and calls the queue contract with a message for contract B (call 1a)\n3) The queue contract receives the message, stores it, and immediately finishes.\n4) Contract A continues call 0b and calls the queue contract with another message for contract B (call 2a)\n5) The queue contract receives the message, stores it, and immediately finishes.\n6) Contract A finishes call 0b.\n7) The queue contract gets back execution (because it's still in call 0a) and picks up the next message, which was sent in 1a. It calls contract B (call 1b.)\n(etc.)\n\nThis does indeed have different gas semantics, since calls don't need to pay for their subcalls. You could model the old semantics by having the queue contract keep track of the tree of calls, and refuse to pass more gas than its parent had available.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/228164370/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234637219",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-234637219",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 234637219,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDYzNzIxOQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-22T19:41:06Z",
    "updated_at": "2016-07-22T19:42:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "In the pure actor model each actor has a FIFO queue which allows multiple writers and one reader.  So contract A sends a message to contract B and it goes on contract B's queue and A keeps running.  Eventually A's message gets to B and B runs.  B can asynchronously send messages to A and keep on running itself.  I haven't thought about a global queue, though it seems it would be a bottleneck.  I haven't thought about gas.  I have wondered about synchronous calls, which I think require a second, higher priority queue to (mostly) maintain present semantics for present calls.  @wanderer @PeterBorah\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234637219/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234688835",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-234688835",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 234688835,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDY4ODgzNQ==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-23T00:50:00Z",
    "updated_at": "2016-07-23T00:50:00Z",
    "author_association": "MEMBER",
    "body": "@PeterBorah  \n\n> That's how it will work if we're just moving execution of calls to the end of the parent execution. And if you model that in the normal EVM, the gas semantics will be the same, since you're still making the calls from the right context, just at a different time.\n\nYep that is almost correct... There are a few edges cases when putting all the calls at the end.\n\n1) a - async ->b then b-call->a. b would have a reentry here if async was just a `call` at the end of the execution\n\n2) more memory would be required. Esp if you conditional used `async`, where the conditions changed on reentry. Also more complex memory management in the contract would be required to account for additional reentries. \n\nOne of the additional goals here is to eventually move to a concurrent model, then `async`s could run in parallel. The other goal would be to eventually move to a pure actor model. \n\n@gcolvin \n\n> In the pure actor model each actor has a FIFO queue which allows multiple writers and one reader. So contract A sends a message to contract B and it goes on contract B's queue and A keeps running\n> \n>  I have wondered about synchronous calls, which I think require a second, higher priority queue to (mostly) maintain present semantics for present calls\n\nFor now `call`s would have to act exactly the same I think. But it would be really nice to able to move to a pure actor model. Unfortunately some contracts actually rely on reentry. I think there is a way around this. But we need to get this eip in first.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234688835/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234806011",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-234806011",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 234806011,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDgwNjAxMQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-24T22:13:50Z",
    "updated_at": "2016-07-24T22:41:39Z",
    "author_association": "CONTRIBUTOR",
    "body": " So here is a possible Actor model for ASYNC_CALL as I see it right now.\n- For a contract (actor) to receive a message from within Ethereum or from without is the same - it starts a transaction.\n- A transaction is the atomic execution of contract code.\n- Within a transaction contract code can CALL other contracts - these calls are not explicitly part of the actor model, but are part of the contract code execution.\n- Within a transaction contract code can create other contracts (other actors) - creating actors is part of the actor model.\n- Within a transaction contract code can ASYNC_CALL (send messages to) other contracts - this is of course the heart of the actor model.\n- Within a transaction a contract cannot receive messages, they get queued - this is part of the actor model as well.\n\nThis model ensures that contract calls within transactions remain distinct from messages in the Actor model, and since calls already occur only within transactions the other restrictions on Actors come for free.  No call for receiving messages is needed - this is simply the entry point of the contract.\n\nNote that the current CALL opcodes allow for recursion.  The https://github.com/ethereum/EIPs/issues/116, https://github.com/ethereum/EIPs/issues/117, and https://github.com/ethereum/EIPs/issues/119 proposals aim to prevent some of the dangers this implies. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234806011/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234808052",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-234808052",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 234808052,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDgwODA1Mg==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-24T22:52:58Z",
    "updated_at": "2016-07-27T16:57:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "Some background I dug up on the Actor Model.  A few references:\n- Hewitt's early papers kicked it off:\n  http://worrydream.com/refs/Hewitt-ActorModel.pdf\n- Agha's 1985 thesis is a classic formal presentation of the Actor model:\n  https://www.cypherpunks.to/erights/history/actors/AITR-844.pdf\n- This more recent Agha paper briefly lays out the Actor model, then formalizes it as a typed variant of the pi calculus:\n  http://formal.cs.uiuc.edu/papers/ATactors_festschrift.pdf\n\nAs the third paper puts it: (broken into bullet points by me)\n- A computational system in the Actor Model, called a configuration, consists of a collection of concurrently executing actors and a collection of messages in transit.\n- Each actor has a unique name (the uniqueness property) and a behavior, and communicates with other actors via asynchronous messages.\n- Actors are reactive in nature, i.e. they execute only in response to messages received. An actor’s behavior is deterministic in that its response to a message is uniquely determined by the message contents.\n- Message delivery in the Actor Model is fair. The delivery of a message can only be delayed for a finite but unbounded amount of time.\n- An actor can perform three basic actions on receiving a message...\n1. create a finite number of actors with universally fresh names,\n2. send a finite number of messages, and\n3. assume a new behavior.\n\nAssuming a new behavior can be as simple as storing a value that affects a branch in the next execution of the contract, or as fancy as creating a new contract with generated code and storing its address as the new behavior.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234808052/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234809945",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-234809945",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 234809945,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNDgwOTk0NQ==",
    "user": {
      "login": "gcolvin",
      "id": 16827129,
      "node_id": "MDQ6VXNlcjE2ODI3MTI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16827129?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gcolvin",
      "html_url": "https://github.com/gcolvin",
      "followers_url": "https://api.github.com/users/gcolvin/followers",
      "following_url": "https://api.github.com/users/gcolvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/gcolvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gcolvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gcolvin/subscriptions",
      "organizations_url": "https://api.github.com/users/gcolvin/orgs",
      "repos_url": "https://api.github.com/users/gcolvin/repos",
      "events_url": "https://api.github.com/users/gcolvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gcolvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-07-24T23:27:10Z",
    "updated_at": "2016-07-25T03:18:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd especially appreciate one of our mathematicians explaining Agha's typed pi calculus for dummies like me.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/234809945/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013794851",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-1013794851",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 1013794851,
    "node_id": "IC_kwDOAq426M48bUgj",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-16T02:06:42Z",
    "updated_at": "2022-01-16T02:06:42Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013794851/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025053103",
    "html_url": "https://github.com/ethereum/EIPs/issues/118#issuecomment-1025053103",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/118",
    "id": 1025053103,
    "node_id": "IC_kwDOAq426M49GRGv",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-30T02:24:14Z",
    "updated_at": "2022-01-30T02:24:14Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025053103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
