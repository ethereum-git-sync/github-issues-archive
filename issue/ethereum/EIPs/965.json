{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/965/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/965/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/965/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/965",
  "id": 310541664,
  "node_id": "MDU6SXNzdWUzMTA1NDE2NjQ=",
  "number": 965,
  "title": "Send by Signature (ERC777 extension) - transfer without paying for gas",
  "user": {
    "login": "chompomonim",
    "id": 153896,
    "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
    "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/chompomonim",
    "html_url": "https://github.com/chompomonim",
    "followers_url": "https://api.github.com/users/chompomonim/followers",
    "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
    "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
    "organizations_url": "https://api.github.com/users/chompomonim/orgs",
    "repos_url": "https://api.github.com/users/chompomonim/repos",
    "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
    "received_events_url": "https://api.github.com/users/chompomonim/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 35,
  "created_at": "2018-04-02T17:05:04Z",
  "updated_at": "2024-01-01T20:44:18Z",
  "closed_at": "2022-01-01T23:11:34Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Preamble\r\n```\r\nEIP: 965\r\nTitle: Authorize Operator by Cheque (ERC777 extension) - possibility to transfer without paying for gas\r\nAuthor: Jaro Šatkevič @chompomonim, Anatoly Ressin @artazor\r\nType: Standard Track\r\nCategory: ERC\r\nStatus: Draft\r\nCreated: 2018-06-05\r\nRequires: 777\r\n```\r\n\r\n## Problem\r\nThe problem of tokens spending is that token owner have to have ETH in his account to pay for gas. So it's impossible to have pure token account. Even in ERC777 (#777) where you can have operator which can manage your tokens (and paying for gas), there still is same problem of lack of gas to initiate `authorizeOperator` call.\r\n\r\n## Solution\r\n\r\nAdd default operator smart contract which would accept tx with signed permission to send tokens. This tx can be made by anyone who has tokens owner signature and is willing to pay for gas.\r\n\r\n\r\nPossible implementation:\r\n```solidity\r\ncontract ChequeOperator {\r\n    using SafeMath for uint256;\r\n    using ECRecovery for bytes32;\r\n\r\n    struct Agreement {\r\n        uint256 totalPaid;\r\n        address token;\r\n        address payer;\r\n        address beneficiary;\r\n        bytes data;\r\n    }\r\n    mapping(bytes => Agreement) internal agreements;\r\n    mapping(address => mapping(uint256 => bool)) public usedNonces; // For simple sendByCheque\r\n    \r\n    \r\n    /* Simple send by Checque */\r\n    \r\n    function signerOfSimpleCheque(address _token, address _to, uint256 _amount, bytes _data, uint256 _nonce, bytes _sig) private pure returns (address) {\r\n        return keccak256(abi.encodePacked(_token, _to, _amount, _data, _nonce)).toEthSignedMessageHash().recover(_sig);\r\n    }\r\n    \r\n    function sendByCheque(address _token, address _to, uint256 _amount, bytes _data, uint256 _nonce, bytes _sig) public {\r\n        require(_to != address(this));\r\n\r\n        // Check if signature is valid and get signer's address\r\n        address signer = signerOfSimpleCheque(_token, _to, _amount, _data, _nonce, _sig);\r\n        require(signer != address(0));\r\n\r\n        // Mark this cheque as used\r\n        require (!usedNonces[signer][_nonce]);\r\n        usedNonces[signer][_nonce] = true;\r\n\r\n        // Send tokens\r\n        ERC777Token token = ERC777Token(_token);\r\n        token.operatorSend(signer, _to, _amount, _data, \"\");\r\n    }\r\n\r\n\r\n    /* Send by Aggreement */\r\n\r\n    function signerOfAgreementCheque(bytes _agreementId, uint256 _amount, uint256 _fee, bytes _sig) private pure returns (address) {\r\n        return keccak256(abi.encodePacked(_agreementId, _amount, _fee)).toEthSignedMessageHash().recover(_sig);\r\n    }\r\n\r\n    function createAgreement(bytes _id, address _token, address _payer, address _beneficiary, bytes _data) public {\r\n        require(_beneficiary != address(0));\r\n        require(_payer != address(0));\r\n        //require(ERC777Token(_token));\r\n        require(agreements[_id].beneficiary == address(0));\r\n        agreements[_id] = Agreement({\r\n            totalPaid: 0,\r\n            token: _token,\r\n            payer: _payer,\r\n            beneficiary: _beneficiary,\r\n            data: _data\r\n        });\r\n    } \r\n\r\n    function sendByAgreement(bytes _agreementId, uint256 _amount, uint256 _fee, bytes _sig) public returns (bool) {\r\n        // Check if agreement exists\r\n        Agreement storage agreement = agreements[_agreementId];\r\n        require(agreement.beneficiary != address(0));\r\n\r\n        // Check if signature is valid, remember last running sum\r\n        address signer = signerOfAgreementCheque(_agreementId, _amount, _fee, _sig);\r\n        require(signer == agreement.payer);\r\n\r\n        // Calculate amount of tokens to be send\r\n        uint256 amount = _amount.sub(agreement.totalPaid).sub(_fee);\r\n        require(amount > 0);\r\n\r\n        // If signer has less tokens that asked to transfer, we can transfer as much as he has already\r\n        // and rest tokens can be transferred via same cheque but in another tx \r\n        // when signer will top up his balance.\r\n        ERC777Token token = ERC777Token(agreement.token);\r\n        if (amount > token.balanceOf(signer)) {\r\n            amount = token.balanceOf(signer).sub(_fee);\r\n        }\r\n\r\n        // Increase already paid amount\r\n        agreement.totalPaid = agreement.totalPaid.add(amount);\r\n\r\n        // Send tokens\r\n        token.operatorSend(signer, agreement.beneficiary, amount, agreement.data, \"\");\r\n       \r\n        if (_fee > 0) {\r\n            token.operatorSend(signer, msg.sender, _fee, \"\", \"\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MyToken is ERC777Token {\r\n    using ECRecovery for bytes32;\r\n    mapping (address => mapping (uint256 => bool)) private usedNonces;\r\n\r\n    constructor(address _checqueOperator) public {\r\n        // Setting checquieOperator as default operator\r\n        //require(ChequeOperator(_checqueOperator));\r\n        mDefaultOperators.push(_checqueOperator);\r\n        mIsDefaultOperator[_checqueOperator] = true;\r\n    }\r\n}\r\n\r\n```\r\n\r\nAdditioanlly \r\n\r\nOn user's (wallet) side cheque creation could look like:\r\n```js\r\nconst leftPad = require('left-pad')\r\n\r\nconst hexData = [\r\n    _agreementId,\r\n     leftPad((_amount).toString(16), 64, 0),\r\n     leftPad((_fee).toString(16), 64, 0)\r\n].join('')\r\n\r\nconst msg = web3.sha3(hexData, { encoding: 'hex' }).slice(2)\r\n\r\nconst signature = web3.eth.sign(accounts[0], msg).slice(2)\r\n```\r\n\r\nLater transaction could look like:\r\n```js\r\nawait checqueOperator.sendByAgreement(_agreementId, _amount, _fee, signature)\r\n```\r\n\r\n## Use case \r\nThis kind of cheques could potentially be widely used. Example use-case:\r\n\r\n**Frequent payments use case** situation where shop gives discount points for client in a form of tokens. Also client downloads special app which is not only loyalty app but also is some kind of wallet and stores private key.\r\n\r\nLater, when client will want to use such points (e.g. could be many times per day), without depositing some amount of gwei into his 'token wallet', he will not be able to transfer tokens. Meanwhile this token wallet could sign cheque and transfer it to shop back. Then shop (or some another entity) using this cheque could transfer tokens while paying for gas by himself.\r\n\r\n**Merchant use case** the merchant generates a one-time address (OTA) and associates it with an invoice/order. The buyer transfers tokens to OTA as a means of paying the invoice.\r\n\r\nNow the merchant wants to sweep the tokens out of OTA, but OTA cannot pay for the gas since it has no ether. So the merchant needs to send yet another transaction to fund OTA with just enough gas so it can sweep the tokens out.\r\n\r\nThe cheque model solves this problem by allowing the merchant to call sendByCheque and get the tokens out of OTA while paying for the gas from his own (master) account. This is possible because the merchant already controls OTA's keys and can produce the signature for the check.",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/965/reactions",
    "total_count": 6,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 6,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/965/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/387014385",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-387014385",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 387014385,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NzAxNDM4NQ==",
    "user": {
      "login": "hellwolf",
      "id": 186660,
      "node_id": "MDQ6VXNlcjE4NjY2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/186660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hellwolf",
      "html_url": "https://github.com/hellwolf",
      "followers_url": "https://api.github.com/users/hellwolf/followers",
      "following_url": "https://api.github.com/users/hellwolf/following{/other_user}",
      "gists_url": "https://api.github.com/users/hellwolf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hellwolf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hellwolf/subscriptions",
      "organizations_url": "https://api.github.com/users/hellwolf/orgs",
      "repos_url": "https://api.github.com/users/hellwolf/repos",
      "events_url": "https://api.github.com/users/hellwolf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hellwolf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-07T09:43:26Z",
    "updated_at": "2018-05-07T09:43:26Z",
    "author_association": "NONE",
    "body": "I find this pattern in general a very good one for inviting people to use certain blockchain application where its users don't necessarily process the ether funds hence raising the bar of adaptation.\r\n\r\nMy few comments:\r\n\r\n- Would you consider to use struct and internal calls to simplify the look of the function?\r\n- Naming consideration: cheque seems implying this pattern be used for token/coin transactions only. But to generalize it, it is for any kind of power-of-attorney scenario.\r\n\r\nMaybe the contract could be generalize into a PowerOfAttorny contract?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/387014385/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/388075425",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-388075425",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 388075425,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4ODA3NTQyNQ==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-10T14:45:17Z",
    "updated_at": "2018-05-10T14:56:49Z",
    "author_association": "NONE",
    "body": "I'm a strong advocate for this pattern as well. I find it useful for another payment-related core use case: the merchant generates a **one-time address** (OTA) and associates it with an invoice/order. The buyer transfers tokens to OTA as a means of paying the invoice.\r\n\r\nNow the merchant wants to sweep the tokens out of OTA, but OTA cannot pay for the gas since it has no ether. So the merchant needs to send yet another transaction to fund OTA with just enough gas so it can sweep the tokens out.\r\n\r\nThe cheque model solves this problem by allowing the merchant to call `sendByCheque` and get the tokens out of OTA while paying for the gas from his own (master) account. This is possible because the merchant already controls OTA's keys and can produce the signature for the check.\r\n\r\nI believe this use case will prove to be important for any token that is geared towards payments/means-of-exchange. It makes life easier for the services that need to accept payments denominated in that token, as they won't need to go through the extra-steps of sending additional transactions only for funding the one-time accounts with the gas that is later required to sweep the tokens out of those accounts.\r\n\r\n@chompomonim how should we move forward for bringing this proposal on the table for the #777 standard?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/388075425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389423432",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-389423432",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 389423432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTQyMzQzMg==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T07:32:26Z",
    "updated_at": "2018-05-16T07:32:36Z",
    "author_association": "NONE",
    "body": "@meronym this is very interesting and valid use case! I like it very much.\r\n\r\nI'm now thinking to start some kind of repo for motivations use-cases, example code and so on around `sendByCheque` pattern. I'm not sure however if it should be part of #777 or just extension for it for people who would like to get all the added benefits.\r\n\r\nDo you think we should start promoting this pattern to become part of ERC777?\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389423432/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389629614",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-389629614",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 389629614,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTYyOTYxNA==",
    "user": {
      "login": "syakunin",
      "id": 1478007,
      "node_id": "MDQ6VXNlcjE0NzgwMDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1478007?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/syakunin",
      "html_url": "https://github.com/syakunin",
      "followers_url": "https://api.github.com/users/syakunin/followers",
      "following_url": "https://api.github.com/users/syakunin/following{/other_user}",
      "gists_url": "https://api.github.com/users/syakunin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/syakunin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/syakunin/subscriptions",
      "organizations_url": "https://api.github.com/users/syakunin/orgs",
      "repos_url": "https://api.github.com/users/syakunin/repos",
      "events_url": "https://api.github.com/users/syakunin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/syakunin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T19:00:31Z",
    "updated_at": "2018-05-16T19:01:04Z",
    "author_association": "NONE",
    "body": "Two issues with the code\r\n1. There is no `callRecipient` function call according to ERC777 when tokens are transferred between accounts. Argument  `_to` can be a contract address. Consider using `doSend` private function instead of manually updating balances.\r\n2. In Solidity the hash for signature is calculated in the following way\r\n`bytes32 hash = keccak256(prefix, keccak256(_to, _value, _data, _nonce));`\r\nhowever in JavaScript message is signed like this\r\n```javascript\r\nconst hexData = [\r\n     _to.slice(2),\r\n     _data,\r\n     leftPad((_value).toString(16), 64, 0),\r\n     leftPad((_nonce).toString(16), 64, 0)\r\n].join('')\r\n```\r\norder of parameters is wrong.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389629614/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389764086",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-389764086",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 389764086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTc2NDA4Ng==",
    "user": {
      "login": "syakunin",
      "id": 1478007,
      "node_id": "MDQ6VXNlcjE0NzgwMDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1478007?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/syakunin",
      "html_url": "https://github.com/syakunin",
      "followers_url": "https://api.github.com/users/syakunin/followers",
      "following_url": "https://api.github.com/users/syakunin/following{/other_user}",
      "gists_url": "https://api.github.com/users/syakunin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/syakunin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/syakunin/subscriptions",
      "organizations_url": "https://api.github.com/users/syakunin/orgs",
      "repos_url": "https://api.github.com/users/syakunin/repos",
      "events_url": "https://api.github.com/users/syakunin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/syakunin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-17T06:54:36Z",
    "updated_at": "2018-05-17T06:54:36Z",
    "author_association": "NONE",
    "body": "Let's imagine a situation where an issuer signs a series of cheques for one person (for example 100 cheques). When a person wants to withdraw all his collected cheques, he will have to send each cheque to the blockchain and pay for each transaction. This consumes a lot of gas. What if he could withdraw all his collected cheques with one tx? A little change in the code can do that.\r\n```solidity\r\nmapping(address => mapping(address => uint256)) public paidChequeSum;\r\nfunction sendByCheque(address _to, uint256 _value, bytes _data, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\r\n     require(_to != address(this));\r\n\r\n     // Check if signature is valid, remember last running sum\r\n     bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n     bytes32 hash = keccak256(prefix, keccak256(_to, _value, _data));\r\n\r\n     address signer = ecrecover(hash, v, r, s);\r\n     require(signer != address(0));\r\n\r\n     uint256 amount = _value.sub(paidChequeSum[signer][_to]);\r\n     require(amount > 0);\r\n\r\n     if (amount > balances[signer]) {\r\n         amount = balances[signer];\r\n     }\r\n\r\n    // Increase already paid amount\r\n    paidChequeSum[signer][_to] = paidChequeSum[signer][_to].add(amount);\r\n\r\n    doSend(signer, _to, amount, _data, msg.sender, \"\", false);\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n- First thing to notice is the `_value` parameter. It is a running sum of sent tokens to a certain address. For example issuer issues a series of cheques with 2 tokens in each cheque. The first cheque will have `_value=2`, the second - `_value=4`, third - `_value=6`, etc.\r\n- Second, `_nonce` argument disappears, since `_value` is always increasing it plays the `_nonce` role.\r\n- Third, in current implementation, if the cheque issuer does not have enough funds on his balance the tx is rolled back. In proposed implementation a user will receive all remaining tokens on issuer balance and later a user can retry to withdraw left tokens using the same cheque.\r\n- User is not forced to store all cheques to withdraw them, he can store only the latest one and withdraw all tokens with the latest cheque in one tx (if issuer have enough balance).\r\n\r\nOf course there are some drawbacks:\r\n- Issuer needs to track running sum for each user offchain, because issuer cannot get the latest issued cheque sum onchain (the cheque may not be withdrawn at the moment)\r\n- If the cheque series for a certain address is too large it can hit `uint256` overflow\r\n\r\nFor both drawbacks the solution may be \"Use the other `_to` address!\". When issuer is in doubt of a running sum, he may ask a user for a clean address. For second drawback the same rule applies. When a cheque series is close to `uint256` overflow, issuer may ask user for a clean address.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389764086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389775017",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-389775017",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 389775017,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTc3NTAxNw==",
    "user": {
      "login": "syakunin",
      "id": 1478007,
      "node_id": "MDQ6VXNlcjE0NzgwMDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1478007?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/syakunin",
      "html_url": "https://github.com/syakunin",
      "followers_url": "https://api.github.com/users/syakunin/followers",
      "following_url": "https://api.github.com/users/syakunin/following{/other_user}",
      "gists_url": "https://api.github.com/users/syakunin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/syakunin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/syakunin/subscriptions",
      "organizations_url": "https://api.github.com/users/syakunin/orgs",
      "repos_url": "https://api.github.com/users/syakunin/repos",
      "events_url": "https://api.github.com/users/syakunin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/syakunin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-17T07:42:17Z",
    "updated_at": "2018-05-17T07:42:17Z",
    "author_association": "NONE",
    "body": "One more issue with the code is that we need to pass the signer address too.\r\n`function sendByCheque(address _from, address _to, uint256 _value, bytes _data, uint8 v, bytes32 r, bytes32 s) public returns (bool);`\r\nand then, after `ecrecover` compare it with recovered address\r\n`require(signer == _from);`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389775017/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389778515",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-389778515",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 389778515,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTc3ODUxNQ==",
    "user": {
      "login": "ptrwtts",
      "id": 497330,
      "node_id": "MDQ6VXNlcjQ5NzMzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/497330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ptrwtts",
      "html_url": "https://github.com/ptrwtts",
      "followers_url": "https://api.github.com/users/ptrwtts/followers",
      "following_url": "https://api.github.com/users/ptrwtts/following{/other_user}",
      "gists_url": "https://api.github.com/users/ptrwtts/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ptrwtts/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ptrwtts/subscriptions",
      "organizations_url": "https://api.github.com/users/ptrwtts/orgs",
      "repos_url": "https://api.github.com/users/ptrwtts/repos",
      "events_url": "https://api.github.com/users/ptrwtts/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ptrwtts/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-17T07:55:34Z",
    "updated_at": "2018-05-17T07:55:34Z",
    "author_association": "NONE",
    "body": "This seems similar to #865, except it extends ERC777 rather than ERC20. An important feature in #865 is the ability to offer a fee (in tokens), to compensate the operator who submits the transaction. This fee could also be 0, but having the capability increases the applicable use-cases (e.g. an application wants to help it's users make token transfers, but not perpetually pay the cost of transactions).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/389778515/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394496187",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394496187",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394496187,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDQ5NjE4Nw==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-04T20:55:06Z",
    "updated_at": "2018-06-04T21:20:06Z",
    "author_association": "NONE",
    "body": "@syakunin thanks for your comments. Trying to address all of them.\r\n\r\n> There is no callRecipient function call according to ERC777 when tokens are transferred between accounts. Argument _to can be a contract address. Consider using doSend private function instead of manually updating balances.\r\n\r\nGood point. Fixed.\r\n\r\n> ... order of parameters is wrong.\r\nFixed, thanks.\r\n\r\n> Let's imagine a situation where an issuer signs a series of cheques for one person (for example 100 cheques). When a person wants to withdraw all his collected cheques, he will have to send each cheque to the blockchain and pay for each transaction. This consumes a lot of gas. What if he could withdraw all his collected cheques with one tx? A little change in the code can do that.\r\n\r\nGood point. Having possibility to skip some cheques in terms of saving gas (while taking some risks as well) is quite good idea. I was almost ready to accept your suggestion but I came up with even better, more in spirit of ERC777, idea --- `authorizeOperatorByCheque`. Will describe it in next comment.\r\n\r\n> One more issue with the code is that we need to pass the signer address too. function sendByCheque(address _from, address _to, uint256 _value,  bytes _data, uint8 v, bytes32 r, bytes32 s) public returns (bool); and then, after ecrecover compare it with recovered address require(signer == _from);\r\n\r\nInteresting... You wanna say, that ecrecover can recover into not proper `signer` and that could be used as an attack? \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394496187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394497603",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394497603",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394497603,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDQ5NzYwMw==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-04T20:59:59Z",
    "updated_at": "2018-06-04T20:59:59Z",
    "author_association": "NONE",
    "body": "> This seems similar to #865, except it extends ERC777 rather than ERC20. An important feature in #865 is the ability to offer a fee (in tokens), to compensate the operator who submits the transaction. This fee could also be 0, but having the capability increases the applicable use-cases (e.g. an application wants to help it's users make token transfers, but not perpetually pay the cost of transactions).\r\n\r\n@ptrwtts thanks for pointing into #865. Idea of offering a fee (to motivate oracles) sounds very interesting. I also wanted to accept this proposal, but it pushed me to rethink of how it should work to be in spirit of ERC777 and not ERC20. In next comment I'm going to add update of this proposal.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394497603/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394502814",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394502814",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394502814,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDUwMjgxNA==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-04T21:18:15Z",
    "updated_at": "2018-06-06T14:46:19Z",
    "author_association": "NONE",
    "body": "This is update for original proposal and if nobody will find any critical issues with it, I'm going switch original #965 description into this one.\r\n\r\n-------------------------------\r\n## Preamble\r\n```\r\nEIP: 965\r\nTitle: Authorize Operator by Cheque (ERC777 extension) - possibility to transfer without paying for gas\r\nAuthor: Jaro Šatkevič @chompomonim, Anatoly Ressin @artazor\r\nType: Standard Track\r\nCategory: ERC\r\nStatus: \r\nCreated: 2018-06-05\r\nRequires: 777\r\n```\r\n\r\n## Problem\r\n\r\nThe problem of tokens spending is that token owner have to have ETH in his account to pay for gas. So it's impossible to have pure token account. Even in ERC777 (#777) where you can have operator which can manage your tokens (and paying for gas), there still is same problem of lack of gas to initiate `authorizeOperator` call.\r\n\r\n## Solution\r\n\r\nAdd possibility to authorize operator by cheque. User could sign permission and send to operator via any wanted channels. Operator would send tx with signed permission into blockchain by himself so user would not need to pay for gas.\r\n\r\nPossible function's implementation:\r\n```solidity\r\ncontract MyToken is ERC777 {\r\n    using ECRecovery for bytes32;\r\n    mapping (address => mapping (uint256 => bool)) private usedNonces;\r\n\r\n    function authorizeOperatorByCheque(address _operator, uint256 _nonce, bytes _sig) public returns (bool) {\r\n        require(_operator != address(this));\r\n\r\n        // Getting signer address\r\n        address signer = keccak256(_operator, _nonce).toEthSignedMessageHash().recover(_sig);\r\n        require (signer != address(0));\r\n\r\n        // Setting nonce to protect against repeating authorization in future\r\n        require (!usedNonces[signer][_nonce]);\r\n        usedNonces[signer][_nonce] = true;\r\n\r\n        // Authorizing operator\r\n        require(_operator != signer);\r\n        isOperatorFor[_operator][signer] = true;\r\n        emit AuthorizedOperator(_operator, signer);\r\n\r\n        return true;\r\n    }\r\n```\r\n\r\nOn user's (wallet) side cheque creation could look like:\r\n```js\r\nconst leftPad = require('left-pad')\r\n\r\nconst hexData = [\r\n     _operator.slice(2),\r\n     leftPad((_nonce).toString(16), 64, 0)\r\n].join('')\r\n\r\nconst msg = web3.sha3(hexData, { encoding: 'hex' }).slice(2)\r\n\r\nconst signature = web3.eth.sign(accounts[0], msg).slice(2)\r\n\r\nconst r = '0x' + signature.slice(0,64);\r\nconst s = '0x' + signature.slice(64, 128);\r\nconst v = Number.parseInt(signature.slice(128, 130), 16) + 27;\r\n```\r\n\r\nLater transaction could look like:\r\n```js\r\nawait token.sendByCheque(_operator, _nonce, v, r, s)\r\n```\r\n\r\n### Operator as smart contract which is accepting cheques\r\nIf user needs more control and don't want allow operator dispose of all his balance, there could be smart contract which do send tokens as users operator but only by accepting cheques.\r\n\r\nSuch smart contract could look like this:\r\n```solidity\r\ncontract ChequeBouncer {\r\n      using ECRecovery for bytes32;\r\n\r\n      function signerOfCheque(address _to, uint256 _amount, uint256 _fee, bytes _data) private returns (address) {\r\n          return keccak256(_to, _amount, _fee, _data).toEthSignedMessageHash().recover(_sig);\r\n      }\r\n}\r\n\r\ncontract ChequeOperator is ChequeBouncer {\r\n\r\n    ERC777Token public token; \r\n    mapping(address => mapping(address => uint256)) public paidChequeSum;\r\n\r\n    constructor(address _token) public {\r\n        token = ERC777Token(_token);\r\n    }\r\n\r\n    function sendByCheque(address _to, uint256 _amount, uint256 _fee, bytes _data, bytes _sig) public returns (bool) {\r\n         require(_to != address(this));\r\n\r\n         // Check if signature is valid, remember last running sum\r\n         address signer = signerOfCheque(_to, _amount, _fee, _data, _sig);\r\n         require(signer != address(0));\r\n\r\n         uint256 amount = _amount.sub(paidChequeSum[signer][_to]).sub(_fee);\r\n         require(amount > 0);\r\n\r\n         if (amount > token.balances[signer]) {\r\n             amount = token.balances[signer].sub(_fee);\r\n         }\r\n\r\n        // Increase already paid amount\r\n        paidChequeSum[signer][_to] = paidChequeSum[signer][_to].add(amount);\r\n\r\n        // Send tokens\r\n        token.operatorSend(signer, _to, amount, _data, \"\");\r\n        token.operatorSend(signer, msg.sender, _fee, \"\", \"\");\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n## Use case\r\nI think this kind of cheques could potentially be widely used. Example use-case:\r\n\r\nImagine situation where shop gives discount points for client in a form of tokens. Also client downloads special app which is not only loyalty app but also is some kind of wallet and stores private key.\r\n\r\nLater, when client will want to use such points, without depositing some amount of gwei into his 'token wallet', he will not be able to transfer tokens. Meanwhile this token wallet could sign cheque and transfer it to shop back. Then shop (or some another entity) using this cheque could transfer tokens while paying for gas by himself.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394502814/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394516414",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394516414",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394516414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDUxNjQxNA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-04T22:09:33Z",
    "updated_at": "2018-06-04T22:09:33Z",
    "author_association": "NONE",
    "body": "This functionality could/should be implemented as a `SignatureBouncer` (https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/access/SignatureBouncer.sol) which is designed to solve exactly these sort of \"gassless\" operations. \r\n\r\nThis sort of \"verify function call parameters\" feature is pending as part of https://github.com/OpenZeppelin/openzeppelin-solidity/pull/973",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394516414/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394638255",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394638255",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394638255,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDYzODI1NQ==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-05T09:09:30Z",
    "updated_at": "2018-06-05T09:09:30Z",
    "author_association": "NONE",
    "body": "@shrugs If I understand correctly, with the bouncer model everyone can send txs, but a selected few bouncers can sign the allowance. In the model proposed here, everyone can sign a cheque (to allow spending on their behalf), and anybody can redeem (in practice there are use cases when only a few addresses will redeem - see my example above with one-time addresses - but that's not explicitly constrained by the model).\r\n\r\nThe `onlyOwner` thus seems superfluous for the cheque model, as there's no need for a central authority to create a whitelist. Everyone can sign checks to allow anybody else to redeem them.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394638255/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394977543",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-394977543",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 394977543,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDk3NzU0Mw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-06T07:58:12Z",
    "updated_at": "2018-06-07T20:53:39Z",
    "author_association": "NONE",
    "body": "Sure! I should have elaborated more, sorry. The model would definitely be different than the \"off chain whitelist\" approach that Signature Bouncer takes, but the concept of \"sign a permission for taking a future action with certain arguments\" fits in well. Perhaps a `ChequeBouncer` that verifiers amounts and signers?\r\n\r\nIt would be something like\r\n\r\n```solidity\r\ncontract ChequeBouncer {\r\n  using ECRecovery for bytes32;\r\n\r\n  // only verify signer, this contract, and amount. this hash where you'd add a nonce\r\n  function signerOfCheque(uint256 _amount, bytes _sig)\r\n    private\r\n    returns (address)\r\n  {\r\n    return keccak256(\r\n        address(this),\r\n        _amount,\r\n      )\r\n      .toEthSignedMessageHash()\r\n      .recover(_sig);\r\n  }\r\n}\r\n\r\ncontract MyToken is ERC777, ChequeBouncer {\r\n  // allows anyone with signature to collect _amount tokens from signer and send them to _to\r\n  function sendByCheque(address _to, uint256 _amount, bytes _sig)\r\n    public\r\n  {\r\n    address signer = signerOfCheque(_amount, _sig);\r\n    require(signer != address(0));\r\n    doSend(signer, _to, _amount);\r\n  }\r\n}\r\n```\r\n\r\nThe \"gassless tx with Operator\" pattern is also a good use-case for Signature Bouncer. Imagine a Proxy contract that allows anyone to call it with a meta transaction, but only if that metatransaction is signed by the owner (bouncer) of that proxy.\r\n\r\n---\r\n\r\n(although if you'd like to guarantee the checks by making the committed funds unspendable until cashed, issuing that commitment to the cheque on-chain is necessary)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/394977543/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395055086",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-395055086",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 395055086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTA1NTA4Ng==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-06T12:44:08Z",
    "updated_at": "2018-06-06T12:44:08Z",
    "author_association": "NONE",
    "body": "I'd include the `_to` address in the hash as well, as I feel that a white cheque's requirements for secure channel transmission and storage (so it cannot be eavesdropped, hacked or spent in a different way than originally intended) outbalances the flexibility gains.\r\n\r\nI'm not sure I understand the meta-transaction example, can you get into a bit more details on how it'd work?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395055086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395075646",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-395075646",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 395075646,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTA3NTY0Ng==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-06T13:50:59Z",
    "updated_at": "2018-06-06T13:50:59Z",
    "author_association": "NONE",
    "body": "@shrugs thanks for mentioning `ChequeBouncer`. I'm totally ok to have implementation using this approach and already fixed my proposal (in comment) above.\r\n\r\nAnyway now it's important to set interface for `authorizeOperatorByCheque` or/and for `sendByCheque` and then play with implementations.\r\n\r\n@meronym, @syakunin, @ptrwtts have you looked on `authorizeOperatorByCheque` idea? Does it sounds better than pure `sendByCheque` proposed initially?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395075646/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395350787",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-395350787",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 395350787,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTM1MDc4Nw==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-07T09:12:55Z",
    "updated_at": "2018-06-07T09:13:31Z",
    "author_association": "NONE",
    "body": "@chompomonim In general I like the `authorizeOperatorByCheque` approach more because it allows for more flexibility.\r\n\r\nNow the question is whether we should include a `sendByCheque` method as well, to which I'd vote yes, justified by my example above re sweeping the tokens from one-time addresses. If the `authorizeOperatorByCheque` is the only method available, the workflow would still require two different transactions (one for authorization and one from the operator), which seems a bit overkill.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395350787/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395391497",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-395391497",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 395391497,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTM5MTQ5Nw==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-07T11:45:32Z",
    "updated_at": "2018-06-07T11:45:32Z",
    "author_association": "NONE",
    "body": "> Now the question is whether we should include a `sendByCheque` method as well, to which I'd vote yes, justified by my example above re sweeping the tokens from one-time addresses. If the authorizeOperatorByCheque is the only method available, the workflow would still require two different transactions (one for authorization and one from the operator), which seems a bit overkill.\r\n\r\nGood point. In your case it's better to have `sendByCheque` as part of token because it's one time operation for each address.\r\n\r\nFrom other side if it's ERC777 send and wallet which supports it, you could not generate a lot of addresses, but ask people to set some data while transferring tokens. Then you'll not need to generate a lot of separate addresses. Unfortunately we're not in that world yet...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395391497/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395441112",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-395441112",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 395441112,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTQ0MTExMg==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-07T14:28:17Z",
    "updated_at": "2018-06-07T14:29:51Z",
    "author_association": "NONE",
    "body": "> From other side if it's ERC777 send and wallet which supports it, you could not generate a lot of addresses, but ask people to set some data while transferring tokens. Then you'll not need to generate a lot of separate addresses. Unfortunately we're not in that world yet...\r\n\r\nAgreed. The point of one-time addresses is legacy support for clients (i.e. wallets or custodian exchange accounts) that don't allow for customization of the token transfer data. I expect that client/wallet support for ERC777 will take quite a bit to mature, and an intermediate solution (such as `sendByCheque` can fill in the adoption time gap and enable the merchants accept payments from legacy clients while providing a mechanism for associating the payments with an invoice.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/395441112/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399720237",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-399720237",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 399720237,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTcyMDIzNw==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-24T00:37:35Z",
    "updated_at": "2018-06-24T00:52:24Z",
    "author_association": "NONE",
    "body": "After some considerations I see that there is one more fix needed for `ChecqueOperator`.\r\n\r\nIf we're using `paidChequeSum` which accumulates sum we should not use data, because any of cheques could be skipped. So `data` can't be parameter of `sendByCheque` because some datas could be skipped.\r\n\r\nTo solve this problem we could add some kind of `agreements` functionality:\r\n```solidity\r\n\r\ncontract ChequeOperator is ChequeBouncer {\r\n\r\n    ERC777Token public token; \r\n    struct Agreement {\r\n        uint256 totalPaid;\r\n        address payer;\r\n        address beneficiary;\r\n        bytes data;\r\n    }\r\n    mapping(bytes32 => Agreement) public agreements;\r\n\r\n    constructor(address _token) public {\r\n        token = ERC777Token(_token);\r\n    }\r\n\r\n    function createAgreement(bytes32 _id, address _payer, address _beneficiary, bytes _data) {\r\n        require(_beneficiary != address(0));\r\n        require(_payer != address(0));\r\n        require(agreements[_id].beneficiary == address(0));\r\n        agreements[_id] = Agreement({\r\n            totalPaid: 0,\r\n            payer: _payer,\r\n            beneficiary: _beneficiary,\r\n            data: _data\r\n        });\r\n    } \r\n\r\n    function sendByCheque(bytes32 _agreementId, uint256 _amount, uint256 _fee, bytes _sig) public returns (bool) {\r\n         // Check if agreement exists\r\n         Agreement storage agreement = agreements[_agreementId];\r\n         require(agreement.beneficiary != address(0));\r\n\r\n         // Check if signature is valid, remember last running sum\r\n         address signer = signerOfCheque(_agreementId, _amount, _fee, _sig);\r\n         require(signer == agreement.payer);\r\n\r\n         // Calculate amount of tokens to be send\r\n         uint256 amount = _amount.sub(agreement.totalPaid).sub(_fee);\r\n         require(amount > 0);\r\n\r\n         // If signer has less tokens that asked to transfer, we can transfer as much as he has already\r\n         // and rest tokens can be transferred via same cheque but in another tx \r\n         // when signer will top up his balance.\r\n         if (amount > token.balances[signer]) {\r\n             amount = token.balances[signer].sub(_fee);\r\n         }\r\n\r\n        // Increase already paid amount\r\n        agreement.totalPaid = agreement.totalPaid.add(amount);\r\n\r\n        // Send tokens\r\n        token.operatorSend(signer, agreement.beneficiary, amount, agreement.data, \"\");\r\n       \r\n        if (_fee > 0) {\r\n            token.operatorSend(signer, msg.sender, _fee, \"\", \"\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nI like this idea but it's good only for frequent token sends among two sides for similar purpose (agreement). Also it could be implemented in many way. Token standard don't need to have any knowledge about that. It's just my suggestion.\r\n\r\nIt's not very good for @meronym usecase. So let's have in `ERC965` two functions: \r\n\r\n```solidity\r\n    function authorizeOperatorBySignature(address _operator, uint256 _nonce, bytes _sig) public;\r\n    function sendBySignature(address _to, uint256 _amount, bytes _data, uint256 _nonce, bytes _sig) public;\r\n```\r\n\r\nI also propose to change `cheque` into `signature`, because `cheque` is something associated with money and not with paper which setting permissions.\r\n\r\nThere are no fee in `sendBySignature` because it should be part of `ChequeOperator` smart contract and is not needed for one shot sends.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/399720237/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410510087",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-410510087",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 410510087,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDUxMDA4Nw==",
    "user": {
      "login": "mg6maciej",
      "id": 1316369,
      "node_id": "MDQ6VXNlcjEzMTYzNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1316369?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mg6maciej",
      "html_url": "https://github.com/mg6maciej",
      "followers_url": "https://api.github.com/users/mg6maciej/followers",
      "following_url": "https://api.github.com/users/mg6maciej/following{/other_user}",
      "gists_url": "https://api.github.com/users/mg6maciej/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mg6maciej/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mg6maciej/subscriptions",
      "organizations_url": "https://api.github.com/users/mg6maciej/orgs",
      "repos_url": "https://api.github.com/users/mg6maciej/repos",
      "events_url": "https://api.github.com/users/mg6maciej/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mg6maciej/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T10:20:53Z",
    "updated_at": "2018-08-05T13:29:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "Could you fix or delete code in https://github.com/ethereum/EIPs/issues/965#issue-310541664 and #964 to remove security issue? Someone might think it's a good code and use it.\r\nContract address (`this`) should be hashed with all the other data to avoid replay attacks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410510087/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410520705",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-410520705",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 410520705,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDUyMDcwNQ==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T13:36:37Z",
    "updated_at": "2018-08-05T13:36:37Z",
    "author_association": "NONE",
    "body": "@mg6maciej thanks for pinging me. After ERC777 got default operators I was willing to fix this proposal to use default operator for `sendByChecque`. Today I did it.\r\n\r\nI deleted description from outdated #964 and updated main description of this issue.\r\n\r\nDoes it solves your security concerns? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410520705/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/415044314",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-415044314",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 415044314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNTA0NDMxNA==",
    "user": {
      "login": "meronym",
      "id": 1806636,
      "node_id": "MDQ6VXNlcjE4MDY2MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1806636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meronym",
      "html_url": "https://github.com/meronym",
      "followers_url": "https://api.github.com/users/meronym/followers",
      "following_url": "https://api.github.com/users/meronym/following{/other_user}",
      "gists_url": "https://api.github.com/users/meronym/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meronym/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meronym/subscriptions",
      "organizations_url": "https://api.github.com/users/meronym/orgs",
      "repos_url": "https://api.github.com/users/meronym/repos",
      "events_url": "https://api.github.com/users/meronym/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meronym/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-22T14:07:21Z",
    "updated_at": "2018-08-22T14:07:35Z",
    "author_association": "NONE",
    "body": "Well done @chompomonim ! There are a few typos in the method definitions and subsequent calls: `signerOfAggrementCheque`, `sendByAgrrement`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/415044314/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/416351060",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-416351060",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 416351060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjM1MTA2MA==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-27T20:05:42Z",
    "updated_at": "2018-08-27T20:05:42Z",
    "author_association": "NONE",
    "body": "@meronym thanks for pointing typos. I just fixed them.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/416351060/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/419021639",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-419021639",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 419021639,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxOTAyMTYzOQ==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-06T09:07:36Z",
    "updated_at": "2018-09-06T09:07:36Z",
    "author_association": "NONE",
    "body": "After some thoughts and discussion around potential infrastructure build around this standard (some kind of nodes which would take cheques, get fee in tokens and persist them into blockchain), I see that more changes are needed for this proposal.\r\n\r\n1. Possibility to create `createAgreement` via checque by paying fee in tokens for agreement creation (agreements are needed for batched transactions).\r\n2. Possibility to create agreement where for persisting cheque would pay third party (subsidize using some dApp).\r\n3. Having possibility to put tokens into escrow (e.g. when creating agreement) so service provider could provide services without waiting for tx being persisted into blockchain (e.g. in case when provider will accept cheques by himself, batch them and later persist into blockchain). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/419021639/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/419022219",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-419022219",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 419022219,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxOTAyMjIxOQ==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-06T09:09:32Z",
    "updated_at": "2018-09-06T09:09:32Z",
    "author_association": "NONE",
    "body": "Another idea is that ERC965 could work well with ERC20 kind of tokens if they would have default operators there. Does anyone know if there is already any ERC for #777 type of operators but for ERC20?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/419022219/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/426246005",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-426246005",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 426246005,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjI0NjAwNQ==",
    "user": {
      "login": "MrChico",
      "id": 8930559,
      "node_id": "MDQ6VXNlcjg5MzA1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8930559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MrChico",
      "html_url": "https://github.com/MrChico",
      "followers_url": "https://api.github.com/users/MrChico/followers",
      "following_url": "https://api.github.com/users/MrChico/following{/other_user}",
      "gists_url": "https://api.github.com/users/MrChico/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MrChico/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MrChico/subscriptions",
      "organizations_url": "https://api.github.com/users/MrChico/orgs",
      "repos_url": "https://api.github.com/users/MrChico/repos",
      "events_url": "https://api.github.com/users/MrChico/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MrChico/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-02T11:56:04Z",
    "updated_at": "2018-10-02T11:56:04Z",
    "author_association": "MEMBER",
    "body": "I think this should be augmented to be compatible with https://eips.ethereum.org/EIPS/eip-712",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/426246005/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/482947991",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-482947991",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 482947991,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Mjk0Nzk5MQ==",
    "user": {
      "login": "oberstet",
      "id": 233340,
      "node_id": "MDQ6VXNlcjIzMzM0MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/233340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oberstet",
      "html_url": "https://github.com/oberstet",
      "followers_url": "https://api.github.com/users/oberstet/followers",
      "following_url": "https://api.github.com/users/oberstet/following{/other_user}",
      "gists_url": "https://api.github.com/users/oberstet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oberstet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oberstet/subscriptions",
      "organizations_url": "https://api.github.com/users/oberstet/orgs",
      "repos_url": "https://api.github.com/users/oberstet/repos",
      "events_url": "https://api.github.com/users/oberstet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oberstet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-14T10:59:22Z",
    "updated_at": "2019-04-14T10:59:34Z",
    "author_association": "CONTRIBUTOR",
    "body": "As far as I can see, there are currently 2 proposals for tokens that allow gasless token transfers:\r\n\r\n* EIP #865\r\n* EIP #965\r\n\r\nAre there more proposals?\r\nAny new directions or recommendations rgd this feature in general?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/482947991/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483124819",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-483124819",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 483124819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzEyNDgxOQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T06:33:12Z",
    "updated_at": "2019-04-15T06:33:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "There is also #1776 \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483124819/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483530012",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-483530012",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 483530012,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzUzMDAxMg==",
    "user": {
      "login": "lastmjs",
      "id": 7000719,
      "node_id": "MDQ6VXNlcjcwMDA3MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7000719?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lastmjs",
      "html_url": "https://github.com/lastmjs",
      "followers_url": "https://api.github.com/users/lastmjs/followers",
      "following_url": "https://api.github.com/users/lastmjs/following{/other_user}",
      "gists_url": "https://api.github.com/users/lastmjs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lastmjs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lastmjs/subscriptions",
      "organizations_url": "https://api.github.com/users/lastmjs/orgs",
      "repos_url": "https://api.github.com/users/lastmjs/repos",
      "events_url": "https://api.github.com/users/lastmjs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lastmjs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-16T06:34:55Z",
    "updated_at": "2019-04-16T06:34:55Z",
    "author_association": "NONE",
    "body": "Hey everyone, I'm new to this, but this feature is very important to a use case for my project. What is involved in getting this proposal or similar proposals for gas delegation moving and implemented, and how long should I expect this to take? I'm most likely willing to put significant effort into helping this along come summer, I just need some guidance.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483530012/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/484137376",
    "html_url": "https://github.com/ethereum/EIPs/issues/965#issuecomment-484137376",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/965",
    "id": 484137376,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NDEzNzM3Ng==",
    "user": {
      "login": "chompomonim",
      "id": 153896,
      "node_id": "MDQ6VXNlcjE1Mzg5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chompomonim",
      "html_url": "https://github.com/chompomonim",
      "followers_url": "https://api.github.com/users/chompomonim/followers",
      "following_url": "https://api.github.com/users/chompomonim/following{/other_user}",
      "gists_url": "https://api.github.com/users/chompomonim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chompomonim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chompomonim/subscriptions",
      "organizations_url": "https://api.github.com/users/chompomonim/orgs",
      "repos_url": "https://api.github.com/users/chompomonim/repos",
      "events_url": "https://api.github.com/users/chompomonim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chompomonim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-17T15:23:11Z",
    "updated_at": "2019-04-17T15:23:11Z",
    "author_association": "NONE",
    "body": "The main problem is that there is needed additional standard for wallets and services which would agree on accepting tokens as fee and send transaction into Ethereum networks with your signatures.\r\n\r\nIf you need that only for your own token, then you can use such techniques already today, you don't need to wait until any finalisations of one or another standard. But if you'd like to have such features in major wallets, then it's really not going to happen any time soon.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/484137376/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
