{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1500",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1500",
  "id": 370747211,
  "node_id": "MDU6SXNzdWUzNzA3NDcyMTE=",
  "number": 1500,
  "title": "ERC 1500: Non-transferrable, configurable vouchers for free usage of dApps ",
  "user": {
    "login": "jaytoday",
    "id": 17043,
    "node_id": "MDQ6VXNlcjE3MDQz",
    "avatar_url": "https://avatars.githubusercontent.com/u/17043?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jaytoday",
    "html_url": "https://github.com/jaytoday",
    "followers_url": "https://api.github.com/users/jaytoday/followers",
    "following_url": "https://api.github.com/users/jaytoday/following{/other_user}",
    "gists_url": "https://api.github.com/users/jaytoday/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jaytoday/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jaytoday/subscriptions",
    "organizations_url": "https://api.github.com/users/jaytoday/orgs",
    "repos_url": "https://api.github.com/users/jaytoday/repos",
    "events_url": "https://api.github.com/users/jaytoday/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jaytoday/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2018-10-16T18:43:29Z",
  "updated_at": "2021-12-18T21:11:21Z",
  "closed_at": "2021-12-18T21:11:21Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "---\r\neip: 1500\r\ntitle: Non-transferrable, configurable vouchers for free usage of dApps \r\nauthor: James Levy (@jamslevy), Chance Wees (@figs999)\r\ndiscussions-to:  [ethereum-magicians.org](https://ethereum-magicians.org/t/erc-1500-non-transferrable-configurable-vouchers-for-free-usage-of-dapps/1814)\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2018-11-05\r\n---\r\n\r\n## Simple Summary\r\n\r\nA system for facilitating sponsored, non-transferrable and configurable vouchers for dApps. This system is designed to not require any modifications from dApp contracts or front-end code.\r\n\r\n## Abstract\r\n\r\nAn on-chain system for facilitating sponsored vouchers that can be redeemed on a specified contract but cannot be transferred or sold, and can be configured to require identity verification to prevent abuse or other factors. \r\n\r\nWhen paired with a gas relayer `meta transaction` system such as the ones designed by the [meta cartel](https://twitter.com/meta_cartel), this system allows for new users without funds in their account to not only send transactions, but to purchase collectibles, make transactions on marketplaces, and other operations requiring both gas fees and additional funding. \r\n\r\nRedeemed voucher funds are sent as a normal transaction from the redeeming user, and support for this system does not require any front-end dApp code or the contract code used by dApps to be modified. \r\n\r\n## Motivation\r\n\r\nThe overall goal of providing a more simple and low-friction onboarding process for new users is one of the main challenges for Ethereum to substantially broaden its addressable audience. For those who do not already have cryptocurrency funds available to spend and would like to try one or more decentralized apps, the only option typically available to them is to go through a lengthy fiat onramp process where their bank details must be verified before a purchase of some initial funds can be completed. \r\n\r\nWhile the use of gas relayers and meta transactions helps to reduce this friction for new users, there are a limited number of decentralized apps that only require gas fees. Many of the applications and use-cases of interest require additional funds beyond gas to acquire tokens or NFTs. \r\n\r\nMeanwhile, dApp developers struggle to acquire new users amongst an increasingly large volume of apps to choose from. \r\n\r\nThis system helps both the new users and the app developers seeking additional ways of acquiring users, without requiring dApp developers to modify either their contract code or front-end code.\r\n\r\n\r\n## Specification\r\n\r\n### Terminology\r\n\r\n- `Vouchers Registry` is a registry contract that allows donors to provide funds used for vouchers and to configure any additional parameters to be used for their donated voucher funds. It also facilitates the redemption of voucher funds by users, and handles a recommended whitelisting process for users. \r\n\r\n- `Vouchers User` is a user contract containing functions defined by this EIP required for the redemption of voucher funds, that may also be interoperable with existing user contract standards such as [ERC 725](https://github.com/ethereum/EIPs/issues/725) and [ERC 1077](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1077.md). \r\n\r\n---\r\n\r\n### Vouchers Registry\r\n\r\nThe `Vouchers Registry` contract should contain several mappings that are used for maintaining information about donated and redeemed voucher funds, as well as a recommended `addressIdentityVerified` mapping for whitelisting users:\r\n\r\n```\r\ncontract VouchersRegistry is Ownable{\r\n    \r\n    mapping(bytes32 => uint) public contractVouchersDonorBalance;\r\n    mapping(bytes32 => uint) public contractVouchersAddressRedeemed;\r\n    mapping(bytes32 => uint) public contractVouchersRedeemablePerUser;\r\n    mapping(bytes32 => uint) public contractVouchersFunctionData;\r\n    mapping(address => uint) public addressIdentityVerified;\r\n\r\n}\r\n```\r\n\r\nThe `Vouchers Registry` contract should also contain several functions that are used for donating and redeeming voucher funds and whitelisting users:\r\n\r\n**addContractVouchers**\r\n\r\nThis payable function is used by voucher donors to provide funds to be used for vouchers. The function accepts a `contractAddress` parameter specifying for which contract the donated  funds should be used, as well as a `redeemablePerUser` parameter specifying how much funds (in wei) should be redeemable by each user for the specified set of voucher funds. It\r\n\r\n```\r\n function addContractVouchers(address contractAddress, uint redeemablePerUser, bytes32 voucherFunctionData) \r\n```\r\n\r\n**withdrawContractVouchers**\r\n\r\nThis function allows donors to withdraw any unspent funds they have previously donated that have not already been spent. It accepts a`contractAddress` parameter that should match the same parameter specified in `addContractVouchers` and a `withdrawAmount` parameter specifying how much of the previously donated funds to withdraw. \r\n\r\n```\r\nfunction withdrawContractVouchers(address contractAddress, uint withdrawAmount)\r\n```\r\n\r\n**redeemContractVouchers**\r\n\r\nThis function is called by the `Vouchers User` contract when voucher funds are being redeemed by a user. It checks that the requested funds are available, do not exceed the available allocated amount for the requesting user, and the balance of voucher funds redeemed by the requesting user is updated to the contract's storage, with a small additional gas fee included. \r\n\r\n\r\n```\r\nfunction redeemContractVouchers(address contractAddress, address donorAddress, uint redeemAmount, bytes32 voucherFunctionData)\r\n```\r\n\r\nThis function calls the `forwardRedeemedVouchers` function in the `Vouchers User` contract:\r\n\r\n```\r\nuserAddress.forwardRedeemedVouchers.value(redeemAmount)(contractAddress, voucherFunctionData);\r\n```\r\n\r\n\r\n**setAddressIdentityVerified**\r\n\r\nThis function contains functionality for having the administrator of the vouchers registry specify users that have gone through an identity verification process that is recommended to avoid abuse of the system via \"sybil attacks\". The details of this off-chain process are left up to the administrator of the vouchers registry. \r\n\r\n```\r\nfunction setAddressIdentityVerified(address userAddress, uint verificationToken)\r\n```\r\n\r\nAdditional functionality may be added by the Vouchers Registry administrator, such as requiring participating contracts to be whitelisted.\r\n\r\n---\r\n\r\n### Vouchers User\r\n\r\nThe `Vouchers User` contract contains two functions that are required for the redemption of voucher funds. In the most simple example, it uses an authentication model where authenticated actions are limited to the contract `owner`. However, the authentication model can be modified to allow for patterns such as `meta transactions` that may result in additional UX improvements. \r\n\r\n**requestContractVouchers**\r\n\r\nThis function accepts a `contractAddress` parameter and `donorAddress` parameter that are used to determine which voucher funds the user is redeeming. A future iteration of this system may potentially eliminate the need for the user to specify a `donorAddress` parameter.\r\n\r\n```\r\nfunction requestContractVouchers(address contractAddress, address donorAddress, uint redeemAmount, bytes32 voucherFunctionData)\r\n```\r\n\r\nThe function calls the `redeemContractVouchers` function of the `Voucher Registry` contract:\r\n\r\n```\r\n_registry.redeemContractVouchers(contractAddress, donorAddress, redeemAmount, voucherFunctionData);\r\n```\r\n\r\nThat function, in turn calls `forwardRedeemedVouchers` function of the `Voucher User` contract.\r\n\r\n**forwardRedeemedVouchers**\r\n\r\nThis function is called from the `redeemContractVouchers` function of the `Voucher Registry` contract. \r\n\r\n```\r\nfunction forwardRedeemedVouchers(address contractAddress, bytes32 voucherFunctionData) \r\n```\r\n\r\n\r\n\r\n## Implementation\r\n\r\n### Voucher Registry Contract\r\n\r\n```\r\npragma solidity ^0.4.24;\r\n\r\nimport './openzeppelin-solidity/contracts/ownership/Ownable.sol';\r\nimport './openzeppelin-solidity/contracts/math/SafeMath.sol';\r\nimport './VouchersUser.sol';\r\n\r\ncontract VouchersRegistry is Ownable{\r\n    \r\n    string constant SAFETY_CHECK_PASSED = \"safetyCheckPassed\";\r\n    string constant SAFETY_CHECK_FAILED = \"safetyCheckFailed\";\r\n    \r\n    mapping(address => uint) public safetyCheckPassedContracts;\r\n    mapping(address => uint) public safetyCheckFailedContracts;\r\n    \r\n    mapping(bytes32 => uint) public contractVouchersDonorBalance;\r\n    mapping(bytes32 => uint) public contractVouchersAddressRedeemed;\r\n    mapping(bytes32 => uint) public contractVouchersRedeemablePerUser;\r\n    mapping(bytes32 => bytes32) public contractVouchersFunctionData;\r\n    mapping(address => uint) public addressIdentityVerified;\r\n    \r\n    uint redemptionGasFee = 1000000;\r\n    \r\n    function setContractStatus(address contractAddress, string status, uint checkVersion) public onlyOwner {\r\n        require(checkVersion > 0);\r\n        \r\n        if(stringsEquivelant(status, SAFETY_CHECK_PASSED))\r\n            SetSafetyCheckPassed(contractAddress,checkVersion);\r\n        else if(stringsEquivelant(status, SAFETY_CHECK_FAILED))\r\n            SetSafetyCheckFailed(contractAddress,checkVersion);\r\n    }\r\n    \r\n    function SetSafetyCheckPassed(address contractAddress, uint checkVersion) internal{\r\n        safetyCheckPassedContracts[contractAddress] = checkVersion;\r\n        if(safetyCheckFailedContracts[contractAddress] != 0)\r\n            safetyCheckFailedContracts[contractAddress] = 0;\r\n    }\r\n    \r\n    function SetSafetyCheckFailed(address contractAddress, uint checkVersion) internal{\r\n        safetyCheckFailedContracts[contractAddress] = checkVersion;\r\n        if(safetyCheckPassedContracts[contractAddress] != 0)\r\n            safetyCheckPassedContracts[contractAddress] = 0;\r\n    }\r\n\t\r\n\tfunction setAddressIdentityVerified(address userAddress, uint verificationToken) public onlyOwner {\r\n\t\taddressIdentityVerified[userAddress] = verificationToken;\r\n\t}\r\n    \r\n    function stringsEquivelant (string a, string b) internal pure returns (bool){\r\n       return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n    \r\n    event AddressNotPassedSafetyCheckRefund(address refundee, uint refundAmount);\r\n    \r\n    function addContractVouchers(address contractAddress, uint redeemablePerUser, bytes32 voucherFunctionData) public payable {\r\n        require(safetyCheckPassedContracts[contractAddress] > 0);\r\n        \r\n        address donorAddress = msg.sender;\r\n        bytes32 voucherKey = getVoucherKey(donorAddress, contractAddress);\r\n        \r\n        uint currentBalance = contractVouchersDonorBalance[voucherKey];\r\n        contractVouchersDonorBalance[voucherKey] = SafeMath.add(currentBalance, msg.value);\r\n        \r\n        contractVouchersRedeemablePerUser[voucherKey] = redeemablePerUser;\r\n        if(voucherFunctionData != 0)\r\n            contractVouchersFunctionData[voucherKey] = voucherFunctionData;\r\n    }\r\n    \r\n    function withdrawContractVouchers(address contractAddress, uint withdrawAmount) public {\r\n        address donorAddress = msg.sender;\r\n        bytes32 voucherKey = getVoucherKey(donorAddress, contractAddress);\r\n        uint currentBalance = contractVouchersDonorBalance[voucherKey];\r\n        \r\n        require(currentBalance >= withdrawAmount && withdrawAmount > 0);\r\n        \r\n        contractVouchersDonorBalance[voucherKey] = SafeMath.sub(currentBalance, withdrawAmount);\r\n        msg.sender.transfer(withdrawAmount);\r\n    }\r\n\t\r\n\tfunction redeemContractVouchers(address contractAddress, address donorAddress, uint redeemAmount, bytes32 voucherFunctionData) public {\r\n\t\tVouchersUser userAddress = VouchersUser(msg.sender);\r\n\t\trequire(addressIdentityVerified[userAddress] > 0);\r\n\t\t\r\n\t\tuint gasCost = SafeMath.mul(redemptionGasFee, tx.gasprice);\r\n\t\tuint requiredAmount = SafeMath.add(redeemAmount, gasCost);\r\n\t\t\r\n\t\tbytes32 voucherKey = getVoucherKey(donorAddress, contractAddress);\r\n\t\tuint donorBalance = contractVouchersDonorBalance[voucherKey];\r\n\t\trequire(donorBalance >= requiredAmount);\r\n\t\t\r\n\t\tbytes32 userKey = getUserKey(donorAddress, contractAddress, userAddress); \r\n\t\tuint totalRedemption = SafeMath.add(redeemAmount, contractVouchersAddressRedeemed[userKey]);\r\n\t\t\r\n\t\trequire(totalRedemption <= contractVouchersRedeemablePerUser[voucherKey]);\r\n\t\tcontractVouchersAddressRedeemed[userKey] = totalRedemption;\r\n\t\tcontractVouchersDonorBalance[voucherKey] = SafeMath.sub(donorBalance,requiredAmount);\r\n\r\n\t\tif(contractVouchersFunctionData[voucherKey] > 0)\r\n\t\t\tvoucherFunctionData = contractVouchersFunctionData[voucherKey];\r\n        \t\t\r\n\t\tuserAddress.forwardRedeemedVouchers.value(redeemAmount)(contractAddress, voucherFunctionData);\r\n\t}\r\n\t\r\n\tfunction getVoucherKey(address donorAddress, address contractAddress) public pure returns(bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(donorAddress, contractAddress));\r\n\t}\r\n\r\n\tfunction getUserKey(address donorAddress, address contractAddress, address userAddress) public pure returns(bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(donorAddress, contractAddress, userAddress));\r\n\t}\t\t\r\n}\r\n```\r\n\r\n### Voucher User Contract\r\n\r\nIn this example, direct authentication is used where transactions requesting the redemption of voucher funds must be made by the `Voucher User` contract owner.\r\n\r\n```\r\npragma solidity ^0.4.24;\r\n\r\nimport './openzeppelin-solidity/contracts/ownership/Ownable.sol';\r\nimport './openzeppelin-solidity/contracts/math/SafeMath.sol';\r\nimport './relevant-community/contracts/BondingCurve.sol';\r\nimport './VouchersRegistry.sol';\r\n\r\ncontract VouchersUser is Ownable{\r\n\tVouchersRegistry _registry;\r\n\r\n\tconstructor(VouchersRegistry registry) public {\r\n\t\trequire(uint256(registry) != 0);\r\n\t\t_registry = registry;\r\n\t}\r\n\t\r\n\tfunction requestContractVouchers(address contractAddress, address donorAddress, uint redeemAmount, bytes32 voucherFunctionData) public onlyOwner \r\n\t{\r\n\t\t_registry.redeemContractVouchers(contractAddress, donorAddress, redeemAmount, voucherFunctionData);\r\n\t}\r\n\t\r\n\tfunction forwardRedeemedVouchers(address contractAddress, bytes32 voucherFunctionData) public payable {\r\n\t\trequire(contractAddress.call.value(msg.value)(voucherFunctionData));\r\n\t}\r\n}\r\n```\r\n\r\n## Roadmap\r\n\r\n* Variation using `meta transaction` authentication instead of direct authentication for the `Voucher User` contract.\r\n\r\n* Variation where the user does not need to specify the `donorAddress`, and are automatically matched with the best available voucher funds to use for a specified contract. \r\n\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1500/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435764712",
    "html_url": "https://github.com/ethereum/EIPs/issues/1500#issuecomment-435764712",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500",
    "id": 435764712,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTc2NDcxMg==",
    "user": {
      "login": "pb25193",
      "id": 42832605,
      "node_id": "MDQ6VXNlcjQyODMyNjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42832605?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pb25193",
      "html_url": "https://github.com/pb25193",
      "followers_url": "https://api.github.com/users/pb25193/followers",
      "following_url": "https://api.github.com/users/pb25193/following{/other_user}",
      "gists_url": "https://api.github.com/users/pb25193/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pb25193/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pb25193/subscriptions",
      "organizations_url": "https://api.github.com/users/pb25193/orgs",
      "repos_url": "https://api.github.com/users/pb25193/repos",
      "events_url": "https://api.github.com/users/pb25193/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pb25193/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T06:07:45Z",
    "updated_at": "2018-11-05T06:08:43Z",
    "author_association": "NONE",
    "body": "Hey, james. \r\nWe posted EIP 1261 some days ago. We are currently using EIP 1261 for doing what is described in this post. We are building infrastructure presently that gives you a GUI to manage the membership in the contracts that we deploy. EIP 1261 tokens are non transferable, revocable, and are used as permissioning tools. Originally designed for governance apps, it can be used for dapp usage permissioning as well. We will be releasing a dapp called Vault, a crowdfunding platform, which uses EIP 1261 to enable 'sign ups'\r\n\r\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-1261.md",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435764712/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986093247",
    "html_url": "https://github.com/ethereum/EIPs/issues/1500#issuecomment-986093247",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500",
    "id": 986093247,
    "node_id": "IC_kwDOAq426M46xpa_",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-04T21:10:16Z",
    "updated_at": "2021-12-04T21:10:16Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986093247/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997285253",
    "html_url": "https://github.com/ethereum/EIPs/issues/1500#issuecomment-997285253",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1500",
    "id": 997285253,
    "node_id": "IC_kwDOAq426M47cV2F",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-18T21:11:20Z",
    "updated_at": "2021-12-18T21:11:20Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/997285253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
