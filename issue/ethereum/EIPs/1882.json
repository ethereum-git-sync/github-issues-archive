{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1882",
  "id": 426538241,
  "node_id": "MDU6SXNzdWU0MjY1MzgyNDE=",
  "number": 1882,
  "title": "ERC-1900: Decentralized Type System for EVM",
  "user": {
    "login": "loredanacirstea",
    "id": 4785356,
    "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/loredanacirstea",
    "html_url": "https://github.com/loredanacirstea",
    "followers_url": "https://api.github.com/users/loredanacirstea/followers",
    "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
    "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
    "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
    "repos_url": "https://api.github.com/users/loredanacirstea/repos",
    "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
    "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 25,
  "created_at": "2019-03-28T14:53:36Z",
  "updated_at": "2021-12-04T20:12:51Z",
  "closed_at": "2021-12-04T20:12:51Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The current draft can be found at https://eips.ethereum.org/EIPS/eip-1900\r\n\r\nIn-work implementation: https://github.com/pipeos-one/dType, along with a list of all related EIPs, articles and demo videos.",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1882/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/477822544",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-477822544",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 477822544,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NzgyMjU0NA==",
    "user": {
      "login": "OFRBG",
      "id": 8671781,
      "node_id": "MDQ6VXNlcjg2NzE3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8671781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/OFRBG",
      "html_url": "https://github.com/OFRBG",
      "followers_url": "https://api.github.com/users/OFRBG/followers",
      "following_url": "https://api.github.com/users/OFRBG/following{/other_user}",
      "gists_url": "https://api.github.com/users/OFRBG/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/OFRBG/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/OFRBG/subscriptions",
      "organizations_url": "https://api.github.com/users/OFRBG/orgs",
      "repos_url": "https://api.github.com/users/OFRBG/repos",
      "events_url": "https://api.github.com/users/OFRBG/events{/privacy}",
      "received_events_url": "https://api.github.com/users/OFRBG/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-29T00:44:56Z",
    "updated_at": "2019-03-29T00:44:56Z",
    "author_association": "NONE",
    "body": "Kinda related: https://github.com/ewasm/design. I don't think it's desired to add overhead to L1 and L0. This would work better as a \"TypeScript\" for Solidity. Remix already includes some static analysis, which could be extended for an extended-type Solidity.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/477822544/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/477925958",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-477925958",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 477925958,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NzkyNTk1OA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-29T09:16:24Z",
    "updated_at": "2019-03-29T09:16:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I don't think it's desired to add overhead to L1 and L0. \r\n\r\nWhat is the overhead that you see? (so, I can properly answer)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/477925958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478050102",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-478050102",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 478050102,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODA1MDEwMg==",
    "user": {
      "login": "OFRBG",
      "id": 8671781,
      "node_id": "MDQ6VXNlcjg2NzE3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8671781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/OFRBG",
      "html_url": "https://github.com/OFRBG",
      "followers_url": "https://api.github.com/users/OFRBG/followers",
      "following_url": "https://api.github.com/users/OFRBG/following{/other_user}",
      "gists_url": "https://api.github.com/users/OFRBG/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/OFRBG/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/OFRBG/subscriptions",
      "organizations_url": "https://api.github.com/users/OFRBG/orgs",
      "repos_url": "https://api.github.com/users/OFRBG/repos",
      "events_url": "https://api.github.com/users/OFRBG/events{/privacy}",
      "received_events_url": "https://api.github.com/users/OFRBG/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-29T15:53:18Z",
    "updated_at": "2019-03-29T15:53:18Z",
    "author_association": "NONE",
    "body": "Adding extra lines of code of structs and memory allocation. IMHO Solidity code should be as short as possible, and higher level abstractions, such as types and pseudo-HOF should be used in a different dialect that finally compiles to native Solidity.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478050102/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478270597",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-478270597",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 478270597,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODI3MDU5Nw==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-30T17:48:32Z",
    "updated_at": "2019-03-30T17:48:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "@OFRBG , \r\nRegarding overhead: Solidity itself is an overhead over the bytecode. The question is not if an overhead exists, but whether it is justified or not. So, what did you understand as being the benefit of having a decentralized type system and why doesn't it justify this overhead? (I just published https://medium.com/@loredana.cirstea/a-vision-of-a-system-registry-for-the-world-computer-be1dc2da7cae if you want to read more about the vision).\r\n\r\nIn order to achieve functional programming, you need higher order functions (HOFs) in Solidity. You can have dType itself without the overhead of adding HOFs, but if multiple projects need the same libraries, it is an overhead to not standardize.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478270597/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478282984",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-478282984",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 478282984,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODI4Mjk4NA==",
    "user": {
      "login": "kjekac",
      "id": 2727556,
      "node_id": "MDQ6VXNlcjI3Mjc1NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2727556?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kjekac",
      "html_url": "https://github.com/kjekac",
      "followers_url": "https://api.github.com/users/kjekac/followers",
      "following_url": "https://api.github.com/users/kjekac/following{/other_user}",
      "gists_url": "https://api.github.com/users/kjekac/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kjekac/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kjekac/subscriptions",
      "organizations_url": "https://api.github.com/users/kjekac/orgs",
      "repos_url": "https://api.github.com/users/kjekac/repos",
      "events_url": "https://api.github.com/users/kjekac/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kjekac/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-30T19:43:34Z",
    "updated_at": "2019-03-30T20:40:27Z",
    "author_association": "NONE",
    "body": "I really really like the general idea of this. Having a type system decoupled from the contract language would make language interoperability (and hence language experimentation) much easier, and generally just make all the data stored on-chain much easier to compute with.\r\n\r\nHowever, I would personally want to detach this from anything C-like (`struct`, ...) and go straight to proper type theory, which would make things less language-bound, as well as giving us nice properties for free. For example it would be relatively straight forward to find a normal form of a particular type, and thus be able to automatically convert data of one type to another, even though they were defined differently syntactically. It would also generally be easier to prove things about contracts, given that you would have fewer cases and very clear semantics.\r\n\r\nI previously worked on a project called [Typedefs](https://typedefs.com/) and one of the long-term ideas there is to put it on e.g. IPFS as a kind of \"global type system\" that any data in any computing system can reference, to tell people/programs how it can be deconstructed and used. The whole project is built on an extremely simple core, it doesn't give you any primitive types except for `Unit` and `Void` (both in the functional programming sense, so not the C-like `void`), but using these together with combinators and recursion, you can build up types that are isomorphic to basically any type you could wish for. For example, in pseudocode:\r\n\r\n```\r\nBoolean := Unit + Unit\r\nChar8 := Boolean × Boolean × Boolean × Boolean × Boolean × Boolean × Boolean × Boolean\r\nString := (Char8 × String) + Unit\r\n```\r\n\r\nOf course, this is horribly inefficient in itself, but when writing a backend for a specific language/platform, you can define specializations to utilize the primitives and/or standard library types that you have available, as long as you can provide encode/decode functions between these and this minimal/universal representation. This makes the type system itself as language agnostic as possible, while still maintaining the full power of any modern type system. Building a backend for Solidity itself should be fairly trivial, the interesting thing would be how to make it \"blockchain-aware\", so to speak. I don't have time at the moment but will try to get back with a few thoughts on how to go about that in the coming week.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478282984/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478389163",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-478389163",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 478389163,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODM4OTE2Mw==",
    "user": {
      "login": "wires",
      "id": 315734,
      "node_id": "MDQ6VXNlcjMxNTczNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/315734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wires",
      "html_url": "https://github.com/wires",
      "followers_url": "https://api.github.com/users/wires/followers",
      "following_url": "https://api.github.com/users/wires/following{/other_user}",
      "gists_url": "https://api.github.com/users/wires/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wires/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wires/subscriptions",
      "organizations_url": "https://api.github.com/users/wires/orgs",
      "repos_url": "https://api.github.com/users/wires/repos",
      "events_url": "https://api.github.com/users/wires/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wires/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-31T21:57:16Z",
    "updated_at": "2019-03-31T21:57:16Z",
    "author_association": "NONE",
    "body": "Great comment by @kjekac, really well explained!\r\n\r\nI see the comments regarding overhead at the lower levels, but let me try to twist that kind of thinking a bit.\r\n\r\nSomething as fundamental as the types of the inputs and outputs to functions can have a huge impact on the complexity at the higher levels. We well chosen type theory can constrain behaviour and maintain hold on complexity. An unfortunate flaw in the design and you feel it all over the place (https://developers.slashdot.org/story/09/03/03/1459209/Null-References-the-Billion-Dollar-Mistake).\r\n\r\nLet me know if you have any questions, I second that it is a good idea and that typedefs can be applied to this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478389163/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478509180",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-478509180",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 478509180,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODUwOTE4MA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-01T09:39:20Z",
    "updated_at": "2019-04-01T09:39:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "@kjekac ,\r\n\r\nFor dType, our focus was:\r\n- full Ethereum compatibility\r\n- extensibility to other languages\r\n- concept-oriented rather than type-oriented\r\n- global consensus on types and data formats\r\n- easily determining the type of a transaction side effect or constant function value \r\n\r\nThere are some type theory features that dType does not have, due to Solidity's limitations:\r\n- converting a dtype into another dtype with different structure\r\n- choice operator\r\n- void and unit types\r\n- direct type inheritance (you have composability instead)\r\n- recursivity of type definition\r\n\r\n> However, I would personally want to detach this from anything C-like (struct, ...) and go straight to proper type theory, which would make things less language-bound, as well as giving us nice properties for free.\r\n\r\nI understand why this would be great.\r\nBut for dType, we actually wanted it to be fully Ethereum compatible, so you can do things programmatically on-chain (e.g. our functional programming video example: https://youtu.be/pcqi4yWBDuQ). dType stores the minimum usable ABI definition information.\r\n\r\nWe also wanted the type to be contained in the ABI description. Meaning, for example, that anyone should be able to determine the type (& metadata, implementation libraries etc.) of a return value given that value, ABI definition & Type Registry.\r\nThis can be achieved with `struct`s, but I am not sure how it could be achieved (and with what effort) with non-native types, that are transpiled to Solidity. Maybe you can help with an example.\r\n\r\n> For example it would be relatively straight forward to find a normal form of a particular type, and thus be able to automatically convert data of one type to another, even though they were defined differently syntactically.\r\n\r\nYes, with `dType` you cannot convert from one type to another (only dtype <-> `bytes`). However, our approach is more concept-oriented, even more that type-oriented. In a way, we want to incentivize consensus on concept definitions across projects and convertibility was not a focus.\r\n\r\n> I previously worked on a project called Typedefs and one of the long-term ideas there is to put it on e.g. IPFS as a kind of \"global type system\" that any data in any computing system can reference, to tell people/programs how it can be deconstructed and used.\r\n\r\nWe thought of the same thing - extending the system to any language - our current implementation has an additional `lang` descriptor for each type -https://github.com/ctzurcanu/dType/blob/5e71ee683a167bd1b796f6ea07c41407be54aa0f/contracts/contracts/dTypeLib.sol#L6-L9. The idea was to also provide type checking against the blockchain (e.g. `isType(type_name)` & `destructure(type_value)` are some initial tools that we have implemented). \r\n\r\nAnd we have `bytes32 source`, which is the Swarm hash for the type's source code - either Solidity libraries and contracts or source code in other languages.\r\n\r\n> Boolean := Unit + Unit\r\n> Char8 := Boolean × Boolean × Boolean × Boolean × Boolean × Boolean × Boolean × Boolean\r\n> String := (Char8 × String) + Unit\r\n\r\nWhile we have `x` (product/tuple) - `struct`s are essentially packed tuples, we don't support `+` (co-product/choice operator), so we do not have optional type components for example - and I do not see an easy/efficient way of supporting this. If you have a solution (for Solidity), we would like to discuss it.\r\n\r\n> the interesting thing would be how to make it \"blockchain-aware\", so to speak. I don't have time at the moment but will try to get back with a few thoughts on how to go about that in the coming week.\r\n\r\nI would be interested in this, thank you.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/478509180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/480512489",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-480512489",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 480512489,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDUxMjQ4OQ==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-06T15:21:29Z",
    "updated_at": "2019-04-06T15:21:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "A draft has been submitted as a PR: https://github.com/ethereum/EIPs/pull/1900\r\nAn extension to this proposal can be found at https://github.com/ethereum/EIPs/issues/1921\r\nI published a new blog post [dType — Decentralized Type System & Functional Programming on Ethereum](https://medium.com/@loredana.cirstea/dtype-decentralized-type-system-functional-programming-on-ethereum-4f7666377c9f), explaining some of the concepts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/480512489/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506029954",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-506029954",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 506029954,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNjAyOTk1NA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-26T20:21:12Z",
    "updated_at": "2019-06-26T20:21:12Z",
    "author_association": "MEMBER",
    "body": "A few thoughts:\r\n - The spec could use a clear definition of what a type is, and what it's composed of. As it's written we're left to infer that from the data structures.\r\n - It's not clear to me why you'd want a key/value datastore for each type you define (the 'Storage Contract'). What's the motivation here?\r\n - One interface can have many implementations, but there doesn't seem to be any distinction made between the two here.\r\n - Given that it seems likely that the database will mostly be read not by other contracts but by offchain tools, it would make sense to use a compact encoding scheme such as CBOR or Protocol Buffers to encode type information, for efficient storage.\r\n - You should define the purpose of the fields in the structs where they're first encountered, not down the bottom.\r\n - Making the type registry mutable introduces a large amount of additional complexity. Why not make it immutable, so that a type identifier can be guaranteed to be a stable reference to a type?\r\n - What is a type library for, and why does it have to serialize and deserialize types?\r\n - Requiring each type to be accompanied by a 'type root contract' seems like a lot of overhead, that will discourage defining new types.\r\n - The 'source' field needs more definition. What language is it? Where can it be found?\r\n - \"Initially single word names will be disallowed, to avoid name squatting\" - are human-readable names going to be primary identifiers here? Can you specify that explicitly somewhere? Why is it necessary that a human-readable type name be unique (or even part of the canonical definition of the type)?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506029954/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506471602",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-506471602",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 506471602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNjQ3MTYwMg==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-27T19:03:02Z",
    "updated_at": "2019-06-27T19:03:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid, thank you for the feedback!\r\n\r\nI updated the draft and restructured it, to solve the following points from https://github.com/ethereum/EIPs/issues/1882#issuecomment-506029954:\r\n- (1) clearer explanation of what a type is and what it's composed of\r\n- (2) I removed the TypeStorage contract description, postponing it for a future ERC (currently researching multiple storage patterns)\r\n- (5) defining the purpose of the struct fields when they are first encountered\r\n- (6) mentioning type immutability and the possibility of removing the dType `remove` function\r\n- (7) clearer explanation regarding the type library and `structureBytes`/`destructureBytes`\r\n- (8) `TypeRootContract` will be the type library address in the context of this ERC.\r\n- (9) adding more information about the `source` field\r\n- (10) mentioning human-readable names (+ version number) as a primary identifier for types\r\n\r\nReplying to your other points:\r\n\r\n> (2) It's not clear to me why you'd want a key/value datastore for each type you define (the 'Storage Contract'). What's the motivation here?\r\n\r\nWe would like to make Solidity more functional and that means that the data should be harmonized (well formatted) and kept in the same place.\r\nWe are thinking about other storage patterns as well - instead of one smart contract, distributed among many user contracts.\r\n\r\n> (3) One interface can have many implementations, but there doesn't seem to be any distinction made between the two here.\r\n\r\nAre you referring to the dType registry interface and implementation or to the type library?\r\n\r\n> (4) Given that it seems likely that the database will mostly be read not by other contracts but by offchain tools, it would make sense to use a compact encoding scheme such as CBOR or Protocol Buffers to encode type information, for efficient storage.\r\n\r\nWe expect most of the data to be used on-chain as well.\r\nThere will be exceptions where a type field will be `bytes`, using a compact encoding scheme: when we are defining a type for another language than Solidity. In this case, that type will be fully defined (in an un-encoded way, with all sub-fields) in the Swarm source file referenced in `source`.\r\n\r\n> (6) Making the type registry mutable introduces a large amount of additional complexity. Why not make it immutable, so that a type identifier can be guaranteed to be a stable reference to a type?\r\n\r\nThat is a good idea.\r\nImmutability will follow once it becomes precompiled. It may also save a significant amount of gas. But that is part of subsequent ERCs\r\n\r\n> (8) Requiring each type to be accompanied by a 'type root contract' seems like a lot of overhead, that will discourage defining new types.\r\n\r\nIt is a lot of overhead involved. But also makes things very well defined in case the community votes the inclusion of the new types into precompiles. Afterwards, the overhead shrinks considerably. Nevertheless, we are defaulting the `TypeRootContract` address to the type library address for this ERC and moving this discussion to a future ERC detailing storage patterns for type data.\r\n\r\n> (9) The 'source' field needs more definition. What language is it? Where can it be found?\r\n\r\n`language` and `source` fields were to be treated in detail in a future ERC. `language = 0`  for Solidity and it will be an `enum`. `source` is a pointer to the source code in the set language on Swarm or another distributed file system.\r\n\r\n> (10) \"Initially single word names will be disallowed, to avoid name squatting\" - are human-readable names going to be primary identifiers here? Can you specify that explicitly somewhere? Why is it necessary that a human-readable type name be unique (or even part of the canonical definition of the type)?\r\n\r\nFor naming, we should probably adopt capitalized camelback standard. The id is calculated as a `keccak(language, name)` so we prepare for future adoption of data bridges between types in different languages that have the same name. We would like to treat declarations in Solidity of the form:\r\n\r\n```js\r\nTypeName varOfType = <instance data>;\r\n```\r\n\r\nA search on the dType registry would be:\r\n```js\r\n // language 0 is Solidity\r\nfind({name= “TypeName”, language= 0})`\r\n```\r\nThis search will return the address of the library, the id of the type, set the correct data structure. Potentially a precompile could be run by a new opcode to do the same thing (not covered in this ERC).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506471602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506495949",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-506495949",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 506495949,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNjQ5NTk0OQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-27T20:21:00Z",
    "updated_at": "2019-06-27T20:21:00Z",
    "author_association": "MEMBER",
    "body": "> We would like to make Solidity more functional and that means that the data should be harmonized (well formatted) and kept in the same place.\r\n> We are thinking about other storage patterns as well - instead of one smart contract, distributed among many user contracts.\r\n\r\nWhat does this mean? Can you give an example use-case?\r\n\r\n> > (3) One interface can have many implementations, but there doesn't seem to be any distinction made between the two here.\r\n>\r\n> Are you referring to the dType registry interface and implementation or to the type library?\r\n\r\nNo, I'm talking about the distinction between a type definition and an implementation. For example, the ERC20 standard defines some types, which are implemented by a large number of different contracts. Capturing the ability for a type to have many implementations seems like a pretty basic feature to support.\r\n\r\n> We expect most of the data to be used on-chain as well.\r\n\r\nCan you give an example use-case for using type data onchain?\r\n\r\n> Immutability will follow once it becomes precompiled. It may also save a significant amount of gas. But that is part of subsequent ERCs\r\n\r\nBut why support mutable types at all? Once it changes, it stops being the same type; the type's fields etc are fundamental to what it is. Any change also likely breaks compatibility with anything using it.\r\n\r\n> language and source fields were to be treated in detail in a future ERC. language = 0 for Solidity and it will be an enum. source is a pointer to the source code in the set language on Swarm or another distributed file system.\r\n\r\nIf you don't define how these are used in the ERC where they're declared, it seems likely that you'll never be able to use them coherently, because there will be no universal expectation over the content stored in them.\r\n\r\n> For naming, we should probably adopt capitalized camelback standard. The id is calculated as a keccak(language, name) so we prepare for future adoption of data bridges between types in different languages that have the same name. We would like to treat declarations in Solidity of the form:\r\n\r\nIt's not clear to me why you need human names as primary identifiers at all. Why not use the typehash, just like Solidity does for function signatures? This addresses both mutability and name collisions. If you must have a human readable identifier, you could use ENS, for instance, to point a human readable name to a typehash.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506495949/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506940414",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-506940414",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 506940414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNjk0MDQxNA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-29T08:43:41Z",
    "updated_at": "2019-06-29T08:43:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid , \r\n\r\n> What does this mean? Can you give an example use-case?\r\n\r\nPublished an in-work draft https://github.com/ethereum/EIPs/pull/2158 for the storage extension, to clarify motivation. Discussions at https://github.com/ethereum/EIPs/issues/2157.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/506940414/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507243175",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-507243175",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 507243175,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNzI0MzE3NQ==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-01T12:26:12Z",
    "updated_at": "2019-07-01T12:26:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid ,\r\n\r\n> No, I'm talking about the distinction between a type definition and an implementation. For example, the ERC20 standard defines some types, which are implemented by a large number of different contracts. Capturing the ability for a type to have many implementations seems like a pretty basic feature to support.\r\n\r\nDevs have the freedom to implement type helper functions, as long as the required ones are implemented (to be discussed). As for the definition, I am open to other proposals that not necessarily based on `structs`. I am actually trying to have optional subtypes, that can be stored with `map`. dType registry will be extended with an additional `optionals` field in the `dType` struct & a standardized way to define optionals in the Type Library, but this is not ready yet. Other than this, what can I do more to give more freedom to the implementation?\r\n\r\n> Can you give an example use-case for using type data onchain?\r\n\r\n- the registry must check that a type's subtypes are already part of the registry, so it must contain references to them.\r\n- on-chain calculation of a type's signature, given the type identifier (especially for functions), is more secure and should be the go-to reference\r\n\r\nI have some in-work examples in the dType repo with on-chain permissions control based on the dType registry identifiers. E.g. fine-grained function permissions, that can also be used in the storage contracts. And in-work patterns for functional programming, which use function dType identifiers to mimic more complex HOFs.\r\n\r\n> But why support mutable types at all? Once it changes, it stops being the same type; the type's fields etc are fundamental to what it is. Any change also likely breaks compatibility with anything using it.\r\n\r\nI removed the `update` function because it was an artifact from a previous version. Indeed, types should not be modified. I left the `remove` function in place, for discussion. Is this ok from your side?\r\n\r\n> If you don't define how these are used in the ERC where they're declared, it seems likely that you'll never be able to use them coherently because there will be no universal expectation over the content stored in them.\r\n(language and source fields)\r\n\r\nI started a draft at https://github.com/loredanacirstea/EIPs/blob/d6fbbff5f1a1ecfa1eee6f8efa4ca3d896303e38/EIPS/eip-dtype_language.md with details. I will make a PR soon. We wanted to separate the ERCs because some devs may agree with dType core but not with the language extension. The `source` field has a purpose by itself in ERC-1900, as specified. Let us know what you think.\r\n\r\n> It's not clear to me why you need human names as primary identifiers at all. Why not use the typehash, just like Solidity does for function signatures? This addresses both mutability and name collisions. If you must have a human readable identifier, you could use ENS, for instance, to point a human readable name to a typehash.\r\n\r\nOur initial version was using `keccak256(language, name, types)` as an identifier. The drawbacks of this:\r\n- the same type might have some differences when used cross-language (see language extension draft, at \"Encoded Types for Language-specific Use\")\r\n- devs might want to get the type definition (& ABI) by name. I can see this used in editor plugins, that can have a small cache for type names without storing the entire data. Also, when searching for a type, duplicate names can be confusing - names should be properly defined after their purpose & content + a version number (specs TBD).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507243175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507465103",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-507465103",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 507465103,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNzQ2NTEwMw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-01T23:49:57Z",
    "updated_at": "2019-07-01T23:49:57Z",
    "author_association": "MEMBER",
    "body": "> Devs have the freedom to implement type helper functions, as long as the required ones are implemented (to be discussed). As for the definition, I am open to other proposals that not necessarily based on structs. I am actually trying to have optional subtypes, that can be stored with map. dType registry will be extended with an additional optionals field in the dType struct & a standardized way to define optionals in the Type Library, but this is not ready yet. Other than this, what can I do more to give more freedom to the implementation?\r\n\r\nI still think you're not understanding the difference between an interface and an implementation. An interface describes an API for other code to interact with, but not how it's implemented. What you're proposing here seems to be more along the lines of a directory of library code.\r\n\r\n> the registry must check that a type's subtypes are already part of the registry, so it must contain references to them.\r\n\r\nIf a type's ID is based on a serialization of its fields, then types are immutable and this doesn't matter; types can be inserted into the registry in any order.\r\n\r\n> on-chain calculation of a type's signature, given the type identifier (especially for functions), is more secure and should be the go-to reference\r\n\r\nCan you qualify 'more secure'? What's your threat model?\r\n\r\n> I removed the update function because it was an artifact from a previous version. Indeed, types should not be modified. I left the remove function in place, for discussion. Is this ok from your side?\r\n\r\nRemoving a type seems like it would cause chaos if it's in use somewhere, and still requires you to maintain a permission model.\r\n\r\n> The source field has a purpose by itself in ERC-1900, as specified. Let us know what you think.\r\n\r\nEIP 1900 currently says:\r\n\r\n> `source` - a `bytes32` Swarm hash where the source code of the type library and contracts can be found; in future EIPs, where dType will be extended to support other languages (e.g. JavaScript, Rust), the file identified by the Swarm hash will contain the type definitions in that language.\r\n\r\nI see several problems with this:\r\n - It ties the system indelibly to Swarm, and to Keccak256 hashing.\r\n - It doesn't indicate a content-type, or any other metadata.\r\n - There's no clear mechanism for someone to determine what language the code is in, or what format the file is.\r\n\r\nI'm also not sure what the motivation here is; why would anyone need to fetch the source in this context?\r\n\r\nIt seems to me that this spec is a long way away from being a simple distributed type registry. It has a lot of unnecessary complexity, and doesn't make a clear distinction between interfaces and implementations. I wish you luck, but I don't plan to offer further technical feedback.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507465103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507619192",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-507619192",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 507619192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNzYxOTE5Mg==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-02T10:34:02Z",
    "updated_at": "2019-07-02T10:36:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid ,\r\n\r\n> I still think you're not understanding the difference between an interface and an implementation. An interface describes an API for other code to interact with, but not how it's implemented. What you're proposing here seems to be more along the lines of a directory of library code.\r\n\r\nI asked you before: \"Are you referring to the dType registry interface and implementation or to the type library?\", to which you answered with \"No, I'm talking about the distinction between a type definition and an implementation\". I suggest you pay attention to how clearly you phrase your questions before being unsatisfied with the answer.\r\nI thought it was clear that this ERC aims to both:\r\n- standardize type libraries\r\n- propose a unique type registry to be implemented (anyone can make their own registry, and the interface is defined here: https://github.com/ethereum/EIPs/blob/8d46acbaaead36b2063dc31fbfbf4fca1e34e621/EIPS/eip-1900.md#dtype-registry-data-structures-and-interface, but it is beneficial to have a unique registry and I explained why already)\r\n\r\nSo aside from your destructive (as opposed to constructive) and your inexact criticism, what can I do? Is ERC not the correct category? EIP-1 definition is \"ERC - application-level standards and conventions\", so it seems right.\r\n\r\n> Can you qualify 'more secure'? What's your threat model?\r\n\r\nOn-chain calculation is the standard. Any off-chain calculation may have a faulty implementation. You need a standard to compare off-chain implementations - why is this unclear? The threat model is the same as for blockchain vs. off-chain data & behavior.\r\n\r\n> Removing a type seems like it would cause chaos if it's in use somewhere, and still requires you to maintain a permission model.\r\n\r\nCorrect. I am ok with removing the `remove` function, but I want more debate on it, from multiple parties.\r\n\r\n> It ties the system indelibly to Swarm, and to Keccak256 hashing.\r\n\r\nIt's a `bytes32` identifier. Any storage solution that is compatible with `bytes32` will do. If multiple storages are used, then we need (at least) another field to describe which one is used. I wanted to keep it simple for now and open to suggestions.\r\n\r\n> - It doesn't indicate a content-type, or any other metadata.\r\n> - There's no clear mechanism for someone to determine what language the code is in, or what format the file is.\r\n\r\nBut tell me a way for the EVM to check something that is off-chain. You know very well it cannot and this is not constructive criticism. We can, however, replace the `bytes32` source hash with an EthPM package identifier, that contains bytecode and source matadata hash (containing the file extension).\r\nFor a unique registry, like we are proposing, we still need governance on top to verify correctness and consensus.\r\n\r\n> I'm also not sure what the motivation here is; why would anyone need to fetch the source in this context?\r\n\r\nNon-centralized source code verification (see EthPM).\r\n\r\n> It seems to me that this spec is a long way away from being a simple distributed type registry. It has a lot of unnecessary complexity and doesn't make a clear distinction between interfaces and implementations.\r\n\r\nTo summarize, I understand the \"unnecessary complexity\" as making the type ABI computable on chain, as opposed to blackboxing it to a packed encoding that the EVM cannot decode. In this case, the complexity is beneficial and overhead-worth (if used by many, overhead decreases).\r\nOtherwise, please define \"unnecessary complexity\" in the context of the ERC.\r\n\r\n> I wish you luck, but I don't plan to offer further technical feedback.\r\n\r\nThis is fine, I thank you for the effort and time. However, you do not present a way forward.\r\nAs per EIP-1 (https://github.com/ethereum/EIPs/blob/27ea3a138b8d54b9657d518cc4fac7d8fe8b3dfc/EIPS/eip-1.md#eip-editors), you are an editor with the following responsibilities:\r\n- \"Read the EIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to get to final status.\"\r\n- \"The editors don't pass judgment on EIPs. We merely do the administrative & editorial part.\"\r\n\r\nYou did not say that this ERC does not make technical sense. Your opposition is currently \"unnecessary complexity\", which you did not define properly. I am (and have been) open to improving anything that is not technically sound.\r\n\r\nTherefore, I do not see a reason to deny merging of this ERC Draft to `master`. It is work in progress, as defined in EIP-1: \"Once the first draft has been merged, you may submit follow-up pull requests with further changes to your draft until such point as you believe the EIP to be mature and ready to proceed to the next status.\"\r\n\r\nIf you do not want to approve and merge due to technical reasons, please clearly list what they are and what editor to ping when I solve them.\r\nIf you do not want to approve and merge due to non-technical reasons, conflicts of interest etc., please ping/appoint another editor for this job.\r\n\r\nHowever, if you are not in your editorial capacity (and you need to specify that, as you are on the editor's list), we welcome debate and new ideas from a technical person, like yourself and others.\r\n\r\nThis ERC is important for Ethereum. Saying that you refuse to give further feedback without explaining why, goes against the ethos of the community: collaboration, effort decentralization and evolution of computing.\r\nI have no commercial interest in this. I am a volunteer working for these values.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/507619192/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510229750",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-510229750",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 510229750,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMDIyOTc1MA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-10T21:08:36Z",
    "updated_at": "2019-07-10T21:09:23Z",
    "author_association": "MEMBER",
    "body": "@loredanacirstea I was offering technical feedback as an individual contributor, not as an editor. As you've decided to ignore nearly all of my feedback, wasting time on giving more of it seems pointless.\r\n\r\nI never suggested I was acting as an editor, or gating merging the draft based on my technical critique.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510229750/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510243758",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-510243758",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 510243758,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMDI0Mzc1OA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-10T21:54:32Z",
    "updated_at": "2019-07-10T21:54:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid , you are on the EIP editor list, you are by default in an editor capacity, you should specify when you are not, when commenting.\r\n\r\nTo recap: \r\n- I did a substantial rewording in https://github.com/ethereum/EIPs/pull/1900/commits/1adf3deb105afc6db72ccd7b09ad2b7b6ec0f9d3, based on your suggestions.\r\n- I answered all your questions and provided explanations when our view was different\r\n- I published an additional ERC that I previously wanted to postpone, just because I wanted to answer your questions better: Storage Extension https://github.com/ethereum/EIPs/pull/2158). Even though I removed mentions of it from the current ERC.\r\n- I reworded ERC-1900 and started a draft on another ERC that I previously wanted to postpone (https://github.com/ethereum/EIPs/issues/1882#issuecomment-507243175) - [Language Extension](https://github.com/loredanacirstea/EIPs/blob/d6fbbff5f1a1ecfa1eee6f8efa4ca3d896303e38/EIPS/eip-dtype_language.md), just because you said _\"If you don't define how these are used in the ERC where they're declared, it seems likely that you'll never be able to use them coherently because there will be no universal expectation over the content stored in them.\"_\r\n\r\n**I think my effort was more than enough to demonstrate that I did not ignore your feedback, but appreciated it.**\r\n\r\nYou say that you wasted your time because I did not necessarily agree with all of your suggestions, while I did provide arguments.\r\nStill, you did not find the time to review this ERC as an editor. An ERC that you already read, never said that it was a bad idea, was abiding by EIP-1 rules and that could be improved and discussed after merging it as a Draft and getting an identifier.\r\n\r\nThese are facts.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510243758/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510321350",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-510321350",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 510321350,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMDMyMTM1MA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-11T04:08:53Z",
    "updated_at": "2019-07-11T04:08:53Z",
    "author_association": "MEMBER",
    "body": "> you are on the EIP editor list, you are by default in an editor capacity, you should specify when you are not, when commenting.\r\n\r\nAs I've said before in other PRs, editors are not primarily technical reviewers of EIPs, because that's not scalable. When I'm making requests for changes in a PR in order to merge it, I'm acting as an editor. When I'm discussing technical proposals in general, I'm clearly not - because that's not part of an editor's job.\r\n\r\n> Still, you did not find the time to review this ERC as an editor. An ERC that you already read, never said that it was a bad idea, was abiding by EIP-1 rules and that could be improved and discussed after merging it as a Draft and getting an identifier.\r\n\r\nI only saw this issue because you drew my attention to it via Twitter. I didn't notice the associated PR, or I would have merged it as draft as soon as it met the typographical requirements.\r\n\r\nI'll make one more attempt at clarifying a couple of misunderstandings:\r\n\r\n> I asked you before: \"Are you referring to the dType registry interface and implementation or to the type library?\", to which you answered with \"No, I'm talking about the distinction between a type definition and an implementation\". I suggest you pay attention to how clearly you phrase your questions before being unsatisfied with the answer.\r\n\r\nThis is a type:\r\n```\r\ninterface IFoo {\r\n  function doFoo(uint x) view returns(uint);\r\n}\r\n```\r\n\r\nThis is an implementation:\r\n```\r\ncontract Foo implements IFoo {\r\n  function doFoo(uint x) view returns(uint) {\r\n    return x * 2;\r\n  }\r\n}\r\n```\r\n\r\nIt's possible for one type to have many implementations - for example, ERC20.\r\n\r\nA type library would specify common interfaces that implementations can conform to, and allow consumers to know what implementations support those interfaces.\r\n\r\nThis EIP claims to be a 'decentralised type system', but it lacks any distinction between a type and implementations of that type. Based on our back-and-forward, it seems like what you're really trying to build is a repository of library code. Which is fine - but then you should rename the EIP and reword accordingly.\r\n\r\n> > Can you qualify 'more secure'? What's your threat model?\r\n> \r\n> On-chain calculation is the standard. Any off-chain calculation may have a faulty implementation. You need a standard to compare off-chain implementations - why is this unclear? The threat model is the same as for blockchain vs. off-chain data & behavior.\r\n\r\nI don't see how this is a security issue. If you write a standard for how to generate a hash from a type specification, you can provide standard test vectors, and anyone can implement that. Changing how you store data onchain so that you can do that inside Solidity buys you some convenience, but at the cost of a lot of additional storage overhead and gas costs.\r\n\r\n> It's a bytes32 identifier. Any storage solution that is compatible with bytes32 will do. If multiple storages are used, then we need (at least) another field to describe which one is used. I wanted to keep it simple for now and open to suggestions.\r\n\r\nAssuming the goal is for a consumer to be able to fetch the content associated with this field, the data you have here is insufficient for that, unless you specify that it must, for example, refer to a Swarm manifest content hash. If you leave this unspecified, people will use it inconsistently, and nobody will be able to write code to fetch it with confidence that it will actually work.\r\n\r\nIf you do not want to specify it here, you should leave it out - anything else will result in useless overhead, because it is underspecified.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/510321350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/527461310",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-527461310",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 527461310,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNzQ2MTMxMA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-03T13:35:57Z",
    "updated_at": "2019-09-03T13:35:57Z",
    "author_association": "MEMBER",
    "body": "I think Ethereum is in need of more coupling between the on-chain and the off-chain world, especially, but not limited to, the connection between the high- or source-level concepts of a smart contract and the on-chain bytecode part. Being able to directly refer to the type of a contract (or a struct being defined in that contract) residing at a certain address would be really nice. Due to the metadata hash, this should in principle be possible, but we still do not have an easy to use storage solution.\r\n\r\nI have the feeling that this proposal could be slimmed down a little, or at least could be specified in different \"feature stages\" and I'm not sure whether such data should be stored in storage, but it is certainly going in the right direction.\r\n\r\nAlso, I see the point that a decentralized type system is only half the fun without support from compilers. The problem is that we drew the boundary for the Solidity compiler at bytecode generation, i.e. excluding deployment and excluding any kind of networking access. The benefit here is that it makes the compiler more stable and the builds reproducible, but it makes features like on-chain type discovery or type-auto-registration impossible as a central language feature. Maybe we could discuss how type registries could be used in Solidity through \"compiler drivers\" by supplying the necessary data to the still offline and deterministic compiler.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/527461310/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/529840460",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-529840460",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 529840460,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTg0MDQ2MA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-10T08:54:26Z",
    "updated_at": "2019-09-10T08:57:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid, in response to [your comment](https://ethereum-magicians.org/t/case-discussion-on-the-eip-process-based-on-eip-1900-eip-1/3627/19):\r\n> All I am asking for is a practical end to end example of how someone would use DType - how you define a type, implement it, and consume it.\r\n\r\nNote: these proposals are not optimized in terms of storage or gas costs.\r\n\r\n## A) EIP-1900:\r\n\r\nDefine/implement the types in a library:\r\n\r\n```solidity\r\nlibrary GeopointLib {\r\n\r\n    struct Longitude {\r\n        int32 longitude;\r\n    }\r\n    \r\n    struct Latitude {\r\n        int32 latitude;\r\n    }\r\n\r\n    struct Geopoint {\r\n        Longitude longitude;\r\n        Latitude latitude;\r\n        bytes32 identifier;\r\n        // other fields\r\n    }\r\n    \r\n    // type rules for each type, if needed\r\n    // other helper functions e.g. insert(self, Geopoint memory geopoint) ...\r\n}\r\n```\r\n\r\nRegister the type with dType, by sending this info to the type registry:\r\n```json\r\n{\r\n      \"name\": \"Longitude\",\r\n      \"types\": [\r\n          {\"name\": \"int32\", \"label\": \"longitude\", \"relation\": 0, \"dimensions\":[]},\r\n      ],\r\n      \"lang\": 0,\r\n      \"typeChoice\": 0,\r\n      \"contractAddress\": \"0x0000000000000000000000000000000000000001\",\r\n      \"source\": \"0x0000000000000000000000000000000000000000000000000000000000000001\"\r\n}\r\n```\r\n```json\r\n{\r\n      \"name\": \"Latitude\",\r\n      \"types\": [\r\n          {\"name\": \"int32\", \"label\": \"latitude\", \"relation\": 0, \"dimensions\":[]},\r\n      ],\r\n      \"lang\": 0,\r\n      \"typeChoice\": 0,\r\n      \"contractAddress\": \"0x0000000000000000000000000000000000000001\",\r\n      \"source\": \"0x0000000000000000000000000000000000000000000000000000000000000001\"\r\n  }\r\n```\r\n```json\r\n{\r\n      \"name\": \"Geopoint\",\r\n      \"types\": [\r\n          {\"name\": \"Longitude\", \"label\": \"longitude\", \"relation\": 0, \"dimensions\":[]},\r\n          {\"name\": \"Latitude\", \"label\": \"latitude\", \"relation\": 0, \"dimensions\":[]},\r\n          {\"name\": \"bytes32\", \"label\": \"identifier\", \"relation\": 0, \"dimensions\":[]}\r\n      ],\r\n      \"lang\": 0,\r\n      \"typeChoice\": 0,\r\n      \"contractAddress\": \"0x0000000000000000000000000000000000000001\",\r\n      \"source\": \"0x0000000000000000000000000000000000000000000000000000000000000001\"\r\n}\r\n```\r\n\r\nAny dev can now use the type by importing the Geopoint type library:\r\n\r\n```\r\nimport 'GeopointLib.sol';\r\n\r\ncontract DevContract {\r\n    using GeopointLib for GeopointLib.Longitude;\r\n    using GeopointLib for GeopointLib.Latitude;\r\n    using GeopointLib for GeopointLib.Geopoint;\r\n}\r\n```\r\n\r\n## 2) [EIP-1921](https://github.com/ethereum/EIPs/pull/2267) - Functions Extension\r\n\r\nImplement functions that can handle the type, e.g.:\r\n\r\n```solidity\r\nlibrary GeopointUtils {\r\n    calculateDistance(\r\n        Geopoint memory geopoint1,\r\n        Geopoint memory geopoint2\r\n    )\r\n        pure\r\n        public\r\n        returns(Distance memory distance)\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n, where `Distance` is another type, e.g.:\r\n```\r\nlibrary GeoMathLib {\r\n    struct Distance {\r\n        uint256 meters;\r\n    }\r\n}\r\n```\r\n\r\nThe `calculateDistance` function is registered with dType\"\r\n```json\r\n{\r\n      \"name\": \"calculateDistance\",\r\n      \"types\": [\r\n          {\"name\": \"Geopoint\", \"label\": \"geopoint1\", \"relation\": 0, \"dimensions\":[]},\r\n          {\"name\": \"Geopoint\", \"label\": \"geopoint2\", \"relation\": 0, \"dimensions\":[]},\r\n      ],\r\n      \"outputs\": [\r\n          {\"name\": \"Distance\", \"label\": \"distance\", \"relation\": 0, \"dimensions\":[]},\r\n      ],\r\n      \"lang\": 0,\r\n      \"typeChoice\": 0,\r\n      \"contractAddress\": \"0x0000000000000000000000000000000000000002\",\r\n      \"source\": \"0x0000000000000000000000000000000000000000000000000000000000000002\"\r\n}\r\n```\r\n\r\nDevs can use it:\r\n\r\n```solidity\r\nimport 'GeopointUtils.sol';\r\n\r\ncontract DevContract {\r\n    using GeopointLib for GeopointLib.Geopoint;\r\n    using GeoMathLib for GeopointLib.Distance;\r\n    using GeopointUtils for GeopointUtils.Geopoint;\r\n    \r\n    \r\n    // in a function\r\n        geo1.calculateDistance(geo2)\r\n}\r\n```\r\n\r\n\r\n## 3) [EIP-2157](http://eips.ethereum.org/EIPS/eip-2157) - Storage Extension\r\n\r\nOptionally, devs can define a storage contract for `Geopoint`, referenced in the dType registry, in `contractAddress`. E.g.:\r\n\r\n```solidity\r\ncontract GeopointStorage is StorageBase {\r\n    using GeopointLib for GeopointLib.Geopoint;\r\n\r\n    mapping(bytes32 => Type) public typeStruct;\r\n\r\n    struct Type {\r\n        GeopointLib.Geopoint data;\r\n        uint256 index;\r\n    }\r\n    \r\n    function insert(GeopointLib.Geopoint memory data) public returns (bytes32 hash) {}\r\n    function update(bytes32 hashi, GeopointLib.Geopoint memory data) public returns(bytes32 hash) {}\r\n    function remove(bytes32 hash) public returns(uint256 index) {}\r\n    function isStored(bytes32 hash) public view returns(bool isIndeed) {}\r\n    function getByHash(bytes32 hash) public view returns(GeopointLib.Geopoint memory data) {}\r\n    \r\n}\r\n```\r\n\r\nThe ABI for this contract is deterministic - we know the `Geopoint` type's ABI from dType and the function names and arguments are standardized.\r\n\r\nAny dev can reuse this contract for storing data. \r\n\r\n\r\n## 4) [EIP-2193](http://eips.ethereum.org/EIPS/eip-2193) - Alias\r\n\r\nWith EIP-1900 & EIP-2157, you can have human readable identifiers for each data item. E.g. `Geopoint.Berlin`, `Bob@Geopoint`.\r\n\r\nRegarding the [comment](https://github.com/ethereum/EIPs/issues/1882#issuecomment-506495949):\r\n> It's not clear to me why you need human names as primary identifiers at all. Why not use the typehash, just like Solidity does for function signatures? This addresses both mutability and name collisions. If you must have a human readable identifier, you could use ENS, for instance, to point a human readable name to a typehash.\r\n\r\nWe need a way to retrieve and cache the types for use in Solidity editors. Using ENS for resolution & reverse resolution for each type adds complexity.\r\n\r\nThis makes ENS obsolete, at least for our purposes and for the purpose of having addressability on fine-grained data items.\r\n\r\n\r\n## Conclusion:\r\n\r\nA type library is produced by developers and consumed by developers.\r\n\r\nThe only thing that is consumed by a non-dev is storage data. Storage data can be consumed by other projects and even end-users (see https://youtu.be/zcq2di8QIUE?t=143).\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/529840460/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/529904380",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-529904380",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 529904380,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTkwNDM4MA==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-10T12:07:11Z",
    "updated_at": "2019-09-10T12:07:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "To expand what the dType registry could mean for a developer:\r\n\r\n1) Anyone can cache & index the content of the registry and provide it as an editor plugin for Solidity files, for autocompletion.\r\n2) A typed Solidity -> Solidity transpiler can be built (we are working on a PoC). This is how it could work: \r\n\r\n\r\nThe ABI of the type itself & the functions can be recomposed entirely from the chain, from the dType registry. The transpiler could compose the `struct`s needed for the typed code to work.\r\n\r\nFor `Geopoint`, it is even enough to have the `struct`s subtypes:\r\n```\r\nstruct Lng {int32 lng;}\r\nstruct Lat {int32 lat;}\r\nstruct Geo {\r\n    Lng lng;\r\n    Lat lat;\r\n    bytes32 identifier\r\n}\r\n```\r\nAnd this `Geo` type can be used with any libraries that know how to handle `Geopoint`, without importing the type definition's library.\r\n\r\nEven without importing other function libraries. E.g. `calculateDistance`, can be transformed into a `delegatecall` / `staticcall`, based on the ABI of `calculateDistance`, which is also on chain. Or an interface can be deterministically created in the background, to expose this function’s ABI: `interface GeopointUtils { function calculateDistance….}`.\r\n\r\nDevs would only see nice code & human-readable names.\r\n\r\n\r\nAs to why devs should walk the extra mile and use dType:\r\n- they make savings on deployment gas\r\n- can make more complex contracts within the bytecode size limit\r\n- they can quickly find & reuse libraries -> interoperability & battle-tested code\r\n- they can extend functionality for a type & contribute to the ecosystem\r\n- they can consume data produced by others, for that type\r\n- benefit from higher-order functions developed for that type\r\n- present their source code in a public, unified manner\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/529904380/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/530119266",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-530119266",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 530119266,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUzMDExOTI2Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-10T21:05:26Z",
    "updated_at": "2019-09-10T21:05:26Z",
    "author_association": "MEMBER",
    "body": "@loredanacirstea Your examples involve writing types and pushing them to the registry, but not actually querying the registry. What purpose does the registry actually serve here? Can you give an example of how a developer would consume data from the registry?\r\n\r\n```\r\n{\r\n      \"name\": \"Longitude\",\r\n      \"types\": [\r\n          {\"name\": \"int32\", \"label\": \"longitude\", \"relation\": 0, \"dimensions\":[]},\r\n      ],\r\n      \"lang\": 0,\r\n      \"typeChoice\": 0,\r\n      \"contractAddress\": \"0x0000000000000000000000000000000000000001\",\r\n      \"source\": \"0x0000000000000000000000000000000000000000000000000000000000000001\"\r\n}\r\n```\r\n\r\nWhat are the `lang`, `typeChoice`, `contractAddress` and `source` fields supposed to hold? There's no deployed contract for this type, so it's difficult to see how the `contractAddress` and `source` fields would be useful. The `types` information conveys the ABI, which contains all the necessary information about this type.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/530119266/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/530871511",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-530871511",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 530871511,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUzMDg3MTUxMQ==",
    "user": {
      "login": "loredanacirstea",
      "id": 4785356,
      "node_id": "MDQ6VXNlcjQ3ODUzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4785356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loredanacirstea",
      "html_url": "https://github.com/loredanacirstea",
      "followers_url": "https://api.github.com/users/loredanacirstea/followers",
      "following_url": "https://api.github.com/users/loredanacirstea/following{/other_user}",
      "gists_url": "https://api.github.com/users/loredanacirstea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loredanacirstea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loredanacirstea/subscriptions",
      "organizations_url": "https://api.github.com/users/loredanacirstea/orgs",
      "repos_url": "https://api.github.com/users/loredanacirstea/repos",
      "events_url": "https://api.github.com/users/loredanacirstea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loredanacirstea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-12T15:10:31Z",
    "updated_at": "2019-09-12T15:10:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Arachnid, these short videos show how smart contract developers could consume the dType registry data by write dTyped Solidity with the transpiler mentioned above: https://youtu.be/pBsual6FogE (type definitions), https://youtu.be/dpIVOYlAWrY (type definitions + function types).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/530871511/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705472",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-974705472",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 974705472,
    "node_id": "IC_kwDOAq426M46GNNA",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-20T20:12:23Z",
    "updated_at": "2021-11-20T20:12:23Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974705472/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086416",
    "html_url": "https://github.com/ethereum/EIPs/issues/1882#issuecomment-986086416",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1882",
    "id": 986086416,
    "node_id": "IC_kwDOAq426M46xnwQ",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-12-04T20:12:50Z",
    "updated_at": "2021-12-04T20:12:50Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/986086416/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
