{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/35/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/35/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/35/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/35",
  "id": 118813928,
  "node_id": "MDU6SXNzdWUxMTg4MTM5Mjg=",
  "number": 35,
  "title": "EIP 103 (Serenity): Blockchain rent",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 63,
  "created_at": "2015-11-25T11:11:21Z",
  "updated_at": "2022-02-05T00:34:11Z",
  "closed_at": "2022-02-05T00:34:11Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Motivation\n\nThe Ethereum platform gives users access to a number of computational resources: particularly computational steps, memory, logs / bloom filter usage and permanent storage in the Ethereum state. For most of these resources, the gas system is roughly incentive-compatible, although price-fixing the exchange rates between these resources is, in the current framework, unfortunately required. Storage, however, is unique in that it is not ephemeral; once storage is filled, it must be stored by all full nodes forever until/if it is deliberately cleared. The cost of storage is `bytes * time`, but users are only paying for `bytes`.\n\nA partial solution exists for Ethereum 1.0 in the form of the `SSTORE` clearing refund, where a user gets up to a net 10000 gas back for converting a filled storage slot into an empty slot. However, this approach is imperfect for two reasons:\n1. During a block where transaction inclusion demand does not reach the gas limit (or even where the opportunity-cost gasprice is cheaper than average), miners have the incentive to fill up storage slots so as to use them as a \"bank\" that expensive transactions can use to grant themselves additional gas at a time when gasprice is expensive; essentially, conducting inter-temporal gas arbitrage with the additional negative externality of requiring all full nodes to store extra data in the meantime.\n2. There is no incentive to use storage slots for a short period of time instead of a long period of time.\n### Proposal\n\nA proposal for solving this is to introduce \"blockchain rent\": rather than charging for bytes, actually charge for bytes \\* time. Here is a proposed protocol for doing so:\n- In the account RLP, keep track of the variables `last_accessed` and `total_storage_bytes`. `last_accessed` is meant to represent the block number at which storage was most recently changed, and `total_storage_bytes` is meant to represent the total number of bytes in account storage.\n- When you perform an `SSTORE(k, v)` operation on the account, let `fee = (TOTFEE[block.number] - TOTFEE[last_accessed]) * account.total_storage_bytes`, where `TOTFEE[n]` is the sum of the data storage fees from block 0 to block n (eg. `TOTFEE[n] = n * c` for some constant `c` would work as a basic policy but one can come up with more dynamic policies that change per block). Set `account.balance -= fee`, `account.last_accessed = block.number` and `account.total_storage_bytes += len(v) + (len(k) if v != '' else 0) - len(old value of account.storage[k]) - (len(k) if old value of account.storage[k] != '' else 0)`. If `account.balance < 0`, destroy the account.\n- Create a special type of `ping` transaction which performs a dummy `SSTORE(0, account.storage[0])` operation on any desired account. Miners can run this if they see an account that needs to be deleted in order to process fees and delete it if it is in fact bankrupt. If and only if a ping leads to an account bankruptcy, it requires no gas.\n\nFor example, suppose that `TOTFEE[n] = n * 10` (ie. 10 wei per block per second), a block was last accessed in block 321070, the current block is 312085, the account has a pre-existing balance of 1000, and it only has two keys in storage:  `{\"cow\": \"dog\", \"horse\": \"doge\"}`. We should have `account.last_accessed = 321070` and `account.total_storage_bytes = 3 + 3 + 5 + 4 = 15`. Now, suppose we have a transaction that sends 10000 wei and, in the process of executing code, sets `SSTORE(\"moose\", \"deer\")`. We compute:\n- Balance increased from `1000` to `11000`\n- `fee = (TOTFEE[312085] - TOTFEE[312070]) * 15 = (3120850 - 3120700) * 15 = 2250`\n- Balance decreased from `11000` to `8750` due to the fee\n- `account.total_storage_bytes += len(\"deer\") + len(\"moose\") - 0 - 0`, ie. increased by 9 for a new total of `15 + 9 = 24`. The values subtracted are both zero because there was nothing pre-existing in that key.\n- `account.last_accessed = 312085`\n### Setting `TOTFEE`\n\nThe hardest challenge in this scheme is setting the `TOTFEE` function. One could set this to a static value (ie. `TOTFEE[n] = c * n`), but this is essentially a form of price-fixing and so is arguably hard to set in a way that is economically efficient. A somewhat more effective strategy is to set a space limit (arguably, this is no less reasonable than setting a gas limit), and targeting `TOTFEE` based on that value. For example, consider a policy where we have some function for setting a space limit `L` (eg. a flat `L = 2**35` or a linearly growing `L = 2**10 * (block.timestamp - genesis.timestamp)`). Then, every block, we set `TOTFEE[n] = TOTFEE[n-1] + 2**(20 * L / (L - total_state_size))` (ie. the fee is 2**20 wei ~= 0.001 shannon initially, then when the total state size increases to 5% of the maximum it doubles, when it increases to 10% of the maximum it doubles again, and so forth, with the doubling intervals decreasing in size and ultimately converging to a singularity at L). In theory, the amount of storage usage should increase until it hits an equilibrium equal to the marginal demand for storage at a supply somewhere less than `L` (in the case of the above example, roughly `L / 2` is plausible); the main tradeoff to be made is in the steepness of the supply function. Steeper supply functions are more robust to mistakes made in the initial supply-function-setting process, but they also lead to more volatile rent charges.\n### Why should I _want_ to support a proposal that adds in a \"weird new tax\" when storage usage per second is free now?\n- The `SSTORE` gas costs may go down, _benefiting_ dapp developers that only use storage for short time durations\n- The disk space requirements for a full node will go down\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/35/reactions",
    "total_count": 10,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 4,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/35/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159588990",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159588990",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159588990,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTU4ODk5MA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T12:02:55Z",
    "updated_at": "2015-11-25T12:02:55Z",
    "author_association": "NONE",
    "body": "In that proposal, the only way someone else can pay a contract's fees is to send money to it, correct? Should there be a way in which someone could send money to a contract but that the contract itself could not spend to anything other than fees? The scenario I'm thinking is one where someone created a contract that always does something with any money it received and keeps a balance of zero because it was programmed at a time that that shouldn't matter.\n\nFor example: say I build a contract that whenever anyone sends money to it, it automatically sends it 50% to Bob and 50% to Alice. It's a very useful contract for both Bob and Alice and they would like to keep it alive, but they can't send money to it in order to pay its fees because it will always forward all the deposits back to them. Even if the contract was programmed with the rent scenario in mind, how can Bob and Alice even know how much is enough for the contract? If say, the contract is programmed to keep 0.1% of anything that it forwards, and if storage costs are low and the contract is used a lot, it might create a scenario where the contract has fees to pay it's rent for the next 30 years and Bob and Alice cannot retrieve any of these funds..\n\nAbout how to set the fee, can't that be left to the miners? Each contract might offer a price and miners choose to accept it or not and contracts can only be deleted if no miner in the last N blocks have accepted their rent? \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159588990/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159589934",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159589934",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159589934,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTU4OTkzNA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T12:09:00Z",
    "updated_at": "2015-11-25T12:09:00Z",
    "author_association": "MEMBER",
    "body": "> In that proposal, the only way someone else can pay a contract's fees is to send money to it, correct?\n\nCorrect.\n\nOne option to solve the problem is for the contract to keep an internal \"shadow balance\" in storage, and then have a function for getting the difference between balance and shadow balance; someone wanting to send to the contract to fill it up would just call this function beforehand in order to learn how much to send, and then send that amount on top of what they were going to send.\n\n> About how to set the fee, can't that be left to the miners? Each contract might offer a price and miners choose to accept it or not and contracts can only be deleted if no miner in the last N blocks have accepted their rent? \n\nThe economics of this seem iffy; particularly, in this exact scheme, note that each miner receives 100% of the gain from including a contract but only pays a small fraction of the cost, so you'll get a much-larger-than-optimal quantity of contract inclusion.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159589934/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159596379",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159596379",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159596379,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTU5NjM3OQ==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T12:42:00Z",
    "updated_at": "2015-11-25T12:42:00Z",
    "author_association": "MEMBER",
    "body": "Having to keep contracts funded with ether all the time seems a bit awkward, although I can certainly see the need for and benefits of that. Which alternatives are there? Is it possible to pay for storage using gas? Can a contract perhaps deduct a certain amount of gas during the SSTORE that is used to hold the value in storage?\nWould it be possible to set up a \"Storage fund contract\" that holds a certain amount of ether but is used by a group of contracts which can then retrieve just the required amount of ether to fund their existence?\n\nCorrectly balancing storage and computation fee is also a major concern, because we do not really know how costs for storage and computing will change in the future. Also with EIP-101 in mind - would it make sense to use a \"storage token\" that is different from ether and used to pay for storage? Perhaps some of the logic could be moved into the storage token contract.\n\nOh and perhaps a side note: Contract code can be used to emulate storage:\nThe only content of contract A's storage is a pointer to another contract P. It uses EXTCODECOPY to load data from P and whenever it wants to modify the data, it creates a new contract and updates the pointer. So I think we should also consider blockchain rent for code.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159596379/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159598065",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159598065",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159598065,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTU5ODA2NQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T12:46:51Z",
    "updated_at": "2015-11-25T12:48:33Z",
    "author_association": "MEMBER",
    "body": "I suppose you can set up a system where a contract accumulates a \"debt\" of gas fees and that debt has to be paid off before you can interact with the contract (ie. same as above, except you do `debt += fee`, and when you send a transaction to a contract you do `msg.gas -= min(debt, msg.gas); debt -= min(debt, msg.gas)` first), and if the debt goes higher than the block gas limit then the contract can get deleted. However, any mechanism by which gas can be \"stored\" potentially allows for inter-temporal arbitrage (ie. paying down debts only when gas is marginally free); not sure about this but it might be the inevitable tradeoff for currency neutrality.\n\nAnother approach here is a hybrid strategy: allow temporary storage using some kind of ether or gas fees, at low cost, and then have permanent storage at high cost.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159598065/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159608892",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159608892",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159608892,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYwODg5Mg==",
    "user": {
      "login": "simondlr",
      "id": 716965,
      "node_id": "MDQ6VXNlcjcxNjk2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/716965?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/simondlr",
      "html_url": "https://github.com/simondlr",
      "followers_url": "https://api.github.com/users/simondlr/followers",
      "following_url": "https://api.github.com/users/simondlr/following{/other_user}",
      "gists_url": "https://api.github.com/users/simondlr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/simondlr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/simondlr/subscriptions",
      "organizations_url": "https://api.github.com/users/simondlr/orgs",
      "repos_url": "https://api.github.com/users/simondlr/repos",
      "events_url": "https://api.github.com/users/simondlr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/simondlr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T13:33:21Z",
    "updated_at": "2015-11-25T13:33:21Z",
    "author_association": "NONE",
    "body": "> Another approach here is a hybrid strategy: allow temporary storage using some kind of ether or gas fees, at low cost, and then have permanent storage at high cost.\n\nI'm a fan of this. I feel there's something to be said for allowing _some_ permanent storage on a blockchain. The \"set & forget\" nature of the \"world computer\" supported by various participants across the world is a big benefit. It's potentially dangerous to have some parts of a burgeoning contract ecosystem disappear, because rent wasn't paid (by whomever). Could lead to some cascading dapp failures. Also, who is set up to continue paying rent? If a build a dapp and rely on a contract that's paying rent, I want to be pretty damn well sure it's not going to drop off, or worse that I & others have to pay rent for it to keep going. If a developer says they will pay rent and they leave or die, will a community step up to continue paying rent?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159608892/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159617227",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159617227",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159617227,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYxNzIyNw==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T14:08:48Z",
    "updated_at": "2015-11-25T14:08:48Z",
    "author_association": "NONE",
    "body": "I'm greatly in favor of some kind of blockchain rent. There's an odd morality in essentially forcing future users to pay for current use.\n\nI agree with chriseth about contract code being used as storage. If this is a possibility, it would be better to create a specific perma-store opcode. (Call it owning a part of the blockchain rather than renting it.) However, what does it mean if a contract has some owning-storage and some renting-storage and it can't pay the rent? Does the whole thing cease to exist? Or just the rented data? Either could be a landmine for a DApp developer.\n\nEvery currently existing DApp will have to have a new incentive structure to self-perpetuate. For example, demanding a small fee when you use it. In itself this isn't bad, but nearly all old contracts will disintegrate short generous donations. In a hybrid system, we could rule that all old DApps have retroactively used owning-storage, and that new DApps can use renting-storage as they please.\n\nIf EIP 101 happens, how will this interact with the new ETH-contract? There will be a contract at 0x00... whose data is altered by the protocol and not by itself. I suppose the ping transaction could actually be a normal transaction sent to 0x00... but I'm not sure how the contract would be able to delete other contracts in an elegant manner.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159617227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159618009",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159618009",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159618009,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYxODAwOQ==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T14:12:11Z",
    "updated_at": "2015-11-25T14:12:11Z",
    "author_association": "NONE",
    "body": "I'm pretty strongly opposed to this, unless there's absolutely no way around it. One of the unique properties of Ethereum is that contracts are trustworthy. I can build my contract on top of another one, and feel confident that that will continue to work.\n\nIn a blockchain rent world, that guarantee goes away. You now have to be paranoid that any contract you rely on might disappear at any time. Careful contracts will try to keep a fund around to rescue contracts they depend on, but that's never going to be a foolproof process. I have visions of a tiny utility contract used in a fundamental layer of contracts being forgotten about, and years later running out of funds, causing a quarter of active contracts to stop working. That's a failure you can't even recover from because of code immutability.\n\nIt also potentially opens up some attack vectors: I can call a contract a bunch of times, with the intention of filling up its storage and thereby making it too expensive to maintain. This costs me ether, of course, but it's only a one-time cost, while it might continue to cost the contract forever. And it might have disproportionate effects due to the cascading failure problem.\n\nFinally, though probably least importantly, it adds a pretty serious amount of complexity to the process of creating a contract. Right now, the illusion that you're writing a normal web script is pretty good. After this change, there will be a whole host of complex issues around analyzing your code to determine future storage usage, checking dependencies to determine their likely reliability, etc.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159618009/reactions",
      "total_count": 3,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159619211",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159619211",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159619211,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYxOTIxMQ==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T14:16:15Z",
    "updated_at": "2015-11-25T14:16:15Z",
    "author_association": "NONE",
    "body": "Instead, we should be aiming to keep contract storage below Moore's Law. If we need to increase storage costs to do so, so be it.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159619211/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159629785",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159629785",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159629785,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYyOTc4NQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T14:48:18Z",
    "updated_at": "2015-11-25T14:48:18Z",
    "author_association": "MEMBER",
    "body": "Ok, so it seems like parametrizing contract storage lifetime with 0 = current log, ∞ = current sstore and 0 < k < ∞ = new hybrid option might be a route worth exploring, perhaps where temp storage is encapsulated in a clear way so it isn't mistaken for permanent storage. For one trivial example of where storage with lifetime 1 might be useful, consider cheques.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159629785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159631718",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159631718",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159631718,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYzMTcxOA==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T14:55:30Z",
    "updated_at": "2015-11-25T14:55:57Z",
    "author_association": "NONE",
    "body": "I think I don't understand what you mean by \"lifetime 1\". A cheque might go a long time without being cashed, so it will need a lifetime of longer than 1 block.\n\nI'm definitely more open to a hybrid approach, though, if the unreliability of temporary storage is emphasized.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159631718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159637386",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159637386",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159637386,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYzNzM4Ng==",
    "user": {
      "login": "wanderer",
      "id": 158211,
      "node_id": "MDQ6VXNlcjE1ODIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/158211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wanderer",
      "html_url": "https://github.com/wanderer",
      "followers_url": "https://api.github.com/users/wanderer/followers",
      "following_url": "https://api.github.com/users/wanderer/following{/other_user}",
      "gists_url": "https://api.github.com/users/wanderer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wanderer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wanderer/subscriptions",
      "organizations_url": "https://api.github.com/users/wanderer/orgs",
      "repos_url": "https://api.github.com/users/wanderer/repos",
      "events_url": "https://api.github.com/users/wanderer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wanderer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:15:29Z",
    "updated_at": "2015-11-25T15:19:36Z",
    "author_association": "MEMBER",
    "body": "on `TOTFEE`  would it make sense to replace `c` as some function of the average gasPrice over x previous block? \n\nEDIT: I kinda don't like targeting a `total_state_size`  b/c we cannot predict hardware storage costs. But we can attempt infer the total system cost by the gasPrice.   \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159637386/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159637557",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159637557",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159637557,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYzNzU1Nw==",
    "user": {
      "login": "alanpog",
      "id": 265086,
      "node_id": "MDQ6VXNlcjI2NTA4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/265086?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alanpog",
      "html_url": "https://github.com/alanpog",
      "followers_url": "https://api.github.com/users/alanpog/followers",
      "following_url": "https://api.github.com/users/alanpog/following{/other_user}",
      "gists_url": "https://api.github.com/users/alanpog/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alanpog/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alanpog/subscriptions",
      "organizations_url": "https://api.github.com/users/alanpog/orgs",
      "repos_url": "https://api.github.com/users/alanpog/repos",
      "events_url": "https://api.github.com/users/alanpog/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alanpog/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:16:15Z",
    "updated_at": "2015-11-25T15:20:56Z",
    "author_association": "NONE",
    "body": "> One of the unique properties of Ethereum is that contracts are trustworthy\n\nI don't think trustworthiness in this context means necessarily _permanent_ contracts, but I'd characterize it as having certainty, at any time _Ta_ that the contract will still exist at time _Tb_, for the _Tb_ that matters to you.\n\nThere's huge value in being able to predict, at contract inception, the future cost of rent (as a function of storage), and then design a contract that will _provably_ survive under certain conditions, irrespective of exogenous variables like rent price.\n\nOne way to accomplish this certainty is through derivatives on the price of rent (simple forwards). But that would likely be too cumbersome for the average contract.\n\nAnother alternative is a **rent insurance market** where contracts can buy \"lifetime\" or at least long-dated rent for a fixed cost. Rent insurance contracts could even have variable storage allowances (i.e. fix a price for a flexible storage size, not a precise amount), as moral hazard can be significantly mitigated by the immutability of the contract's code. Of course insurance markets have tail risk and may need to be bailed out (or crash) if not regulated.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159637557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159639457",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159639457",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159639457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYzOTQ1Nw==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:23:14Z",
    "updated_at": "2015-11-25T15:23:14Z",
    "author_association": "NONE",
    "body": "@vbuterin Are we talking arbitrarily-settable (by the contract) k? I could see that being very useful. I'm working on a game where the players will probably not care about the state a week afterwards.\n\nFor the sake of argument, suppose you prepaid storage costs in current gas (i.e. SSTORE costs an additional (c \\* k) gas, with some (big) flat rate for permanent hosting). The system would have to have some way of detecting/clearing/deleting the unpaid, but at least it's reasonably possible to determine when a contract will lose its storage.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159639457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159639554",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159639554",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159639554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTYzOTU1NA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:23:37Z",
    "updated_at": "2015-11-25T15:23:37Z",
    "author_association": "MEMBER",
    "body": "> I think I don't understand what you mean by \"lifetime 1\". A cheque might go a long time without being cashed, so it will need a lifetime of longer than 1 block.\n\nI am specifically referring to the use case of paying for contract functions in subcurrency; in this case cheques only need to last for long enough to persist between the parent and child execution, ie. just the block during which the ancestor transaction is included. For other cases, yes, cheques should probably have a medium-length expiry.\n\n> @vbuterin Are we talking arbitrarily-settable (by the contract) k?\n\nYes.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159639554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159641800",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159641800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159641800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY0MTgwMA==",
    "user": {
      "login": "PeterBorah",
      "id": 2374327,
      "node_id": "MDQ6VXNlcjIzNzQzMjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2374327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PeterBorah",
      "html_url": "https://github.com/PeterBorah",
      "followers_url": "https://api.github.com/users/PeterBorah/followers",
      "following_url": "https://api.github.com/users/PeterBorah/following{/other_user}",
      "gists_url": "https://api.github.com/users/PeterBorah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PeterBorah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PeterBorah/subscriptions",
      "organizations_url": "https://api.github.com/users/PeterBorah/orgs",
      "repos_url": "https://api.github.com/users/PeterBorah/repos",
      "events_url": "https://api.github.com/users/PeterBorah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PeterBorah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:30:49Z",
    "updated_at": "2015-11-25T15:30:49Z",
    "author_association": "NONE",
    "body": "That will work until scalability creates mandatory asynchrony. :)\n\nIt's worth pointing out that you as the user don't have control over when your transactions are included in a block. If there's a big gas price spike, or a networking issue, or just bad luck, you might miss even a deadline you thought was generous.\n\nI am skeptical that self-destructing data is ever a good idea, but as long as there is the option for permanent data as well, I can just ignore the existence of the unreliable version, and advocate that others do the same, the way we ignore half of Javascript. Not ideal, but acceptable.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159641800/reactions",
      "total_count": 4,
      "+1": 2,
      "-1": 0,
      "laugh": 2,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159642939",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159642939",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159642939,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY0MjkzOQ==",
    "user": {
      "login": "alanpog",
      "id": 265086,
      "node_id": "MDQ6VXNlcjI2NTA4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/265086?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alanpog",
      "html_url": "https://github.com/alanpog",
      "followers_url": "https://api.github.com/users/alanpog/followers",
      "following_url": "https://api.github.com/users/alanpog/following{/other_user}",
      "gists_url": "https://api.github.com/users/alanpog/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alanpog/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alanpog/subscriptions",
      "organizations_url": "https://api.github.com/users/alanpog/orgs",
      "repos_url": "https://api.github.com/users/alanpog/repos",
      "events_url": "https://api.github.com/users/alanpog/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alanpog/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T15:35:13Z",
    "updated_at": "2015-11-25T15:40:33Z",
    "author_association": "NONE",
    "body": "> Ok, so it seems like parametrizing contract storage lifetime with 0 = current log, ∞ = current sstore and 0 < k < ∞ = new hybrid option might be a route worth exploring\n\n@vbuterin , wouldn't accepting anything different than k=0 just reduce the scale of (but not solve) the problem we have now (lack of incentive compatibility for storage) as any price for k>0 would be a guess that gets more uncertain as k -> ∞ ?\n\n**edit:** what I mean by _accepting_ is setting today a price for. In this sense the original EIP proposal would only accept k=0 pricing.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159642939/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159655423",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159655423",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159655423,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY1NTQyMw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T16:03:45Z",
    "updated_at": "2015-11-25T16:03:45Z",
    "author_association": "MEMBER",
    "body": "Yes, accepting anything other than k=0 would still lead to some degree of lack of incentive compatibility or inter-temporal arbitrage. But judging from comments, very many people consider this an acceptable price to pay for certainty.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159655423/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159657053",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159657053",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159657053,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY1NzA1Mw==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T16:10:12Z",
    "updated_at": "2015-11-25T16:10:12Z",
    "author_association": "NONE",
    "body": ">  I have visions of a tiny utility contract used in a fundamental layer of contracts being forgotten about, and years later running out of funds, causing a quarter of active contracts to stop working. \n\nThis is something that can really happen, specially since solidity now supports libraries, which could create a cascading sheet of dependencies that no one is paying attention until one of the sub contracts get deleted.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159657053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159667889",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159667889",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159667889,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY2Nzg4OQ==",
    "user": {
      "login": "simonjanin",
      "id": 14198527,
      "node_id": "MDQ6VXNlcjE0MTk4NTI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14198527?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/simonjanin",
      "html_url": "https://github.com/simonjanin",
      "followers_url": "https://api.github.com/users/simonjanin/followers",
      "following_url": "https://api.github.com/users/simonjanin/following{/other_user}",
      "gists_url": "https://api.github.com/users/simonjanin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/simonjanin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/simonjanin/subscriptions",
      "organizations_url": "https://api.github.com/users/simonjanin/orgs",
      "repos_url": "https://api.github.com/users/simonjanin/repos",
      "events_url": "https://api.github.com/users/simonjanin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/simonjanin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T16:45:39Z",
    "updated_at": "2015-11-25T16:48:40Z",
    "author_association": "NONE",
    "body": "I think this is a great proposal.\n\nBut there is something that bothers me a little, which is a related argument to @alanpog's : at the time of creation, a contract with permanent storage has a cost C[t], which will be linearly more expensive than renting one for a given amount of time. The thing is, if the gas prices change non-linearly, then this makes for a very asymmetrical situation in the long run -- where miners/validators would have to store the data of the first contract permanently essentially for free, while newly created contracts would pay non-linearly more; i.e. C[t+k] >= λ*(C[t])^(1 + ε) for ε > 0.\n\nIn a word, the argument is that if the gas prices change super-linearly over time, then this is not only unfair to the new miners/validators, it also makes it very difficult to insure against (insurance relies on costs being at most linear in the number of objects insured).\n\nIf we know for sure that only linear changes of gas prices are possible, then this is fine.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159667889/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159680203",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159680203",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159680203,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY4MDIwMw==",
    "user": {
      "login": "pipermerriam",
      "id": 824194,
      "node_id": "MDQ6VXNlcjgyNDE5NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/824194?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pipermerriam",
      "html_url": "https://github.com/pipermerriam",
      "followers_url": "https://api.github.com/users/pipermerriam/followers",
      "following_url": "https://api.github.com/users/pipermerriam/following{/other_user}",
      "gists_url": "https://api.github.com/users/pipermerriam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pipermerriam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pipermerriam/subscriptions",
      "organizations_url": "https://api.github.com/users/pipermerriam/orgs",
      "repos_url": "https://api.github.com/users/pipermerriam/repos",
      "events_url": "https://api.github.com/users/pipermerriam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pipermerriam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T17:25:00Z",
    "updated_at": "2015-11-25T17:25:16Z",
    "author_association": "MEMBER",
    "body": "I'd like to echo some of what @PeterBorah and @alexvandesande said.\n\nI'm really hesitant about much of what this proposes.  I'd like this a lot more if we keep a permanent storage system alongside a new ephemeral storage system.  However, switching to a purely paid storage system opens up attack vectors and the potential for disastrous cascading failures and it isn't immediately clear to me how these issues are going to be resolvable.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159680203/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159686544",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159686544",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159686544,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY4NjU0NA==",
    "user": {
      "login": "niran",
      "id": 106437,
      "node_id": "MDQ6VXNlcjEwNjQzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/106437?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/niran",
      "html_url": "https://github.com/niran",
      "followers_url": "https://api.github.com/users/niran/followers",
      "following_url": "https://api.github.com/users/niran/following{/other_user}",
      "gists_url": "https://api.github.com/users/niran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/niran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/niran/subscriptions",
      "organizations_url": "https://api.github.com/users/niran/orgs",
      "repos_url": "https://api.github.com/users/niran/repos",
      "events_url": "https://api.github.com/users/niran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/niran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T17:51:05Z",
    "updated_at": "2015-11-25T18:06:30Z",
    "author_association": "NONE",
    "body": "What if there were a way to revive an evicted contract? There's consensus on what the contract's state was when it was evicted, and if I'm willing to pay the gas costs and rent to get miners to store it and keep it around again, that could work around some of the terrifying scenarios where dependencies disappear. Transactions would just fail until someone revived the dependency contract.\n\nIf the revive mechanism is a bounty that any miner of future blocks can collect, most miners can continue to only store the active state while bounty hunter miners maintain quick access to older state that might be revived.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159686544/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159691023",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159691023",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159691023,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY5MTAyMw==",
    "user": {
      "login": "pipermerriam",
      "id": 824194,
      "node_id": "MDQ6VXNlcjgyNDE5NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/824194?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pipermerriam",
      "html_url": "https://github.com/pipermerriam",
      "followers_url": "https://api.github.com/users/pipermerriam/followers",
      "following_url": "https://api.github.com/users/pipermerriam/following{/other_user}",
      "gists_url": "https://api.github.com/users/pipermerriam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pipermerriam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pipermerriam/subscriptions",
      "organizations_url": "https://api.github.com/users/pipermerriam/orgs",
      "repos_url": "https://api.github.com/users/pipermerriam/repos",
      "events_url": "https://api.github.com/users/pipermerriam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pipermerriam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T18:11:23Z",
    "updated_at": "2015-11-25T18:11:23Z",
    "author_association": "MEMBER",
    "body": "> What if there were a way to revive an evicted contract?\n\nI'm not sure this solves anything.  This assumes a lot of things about people paying attention to these things, as well as there being a benevolent source of funds to pay for ongoing storage.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159691023/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159692612",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159692612",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159692612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY5MjYxMg==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T18:18:43Z",
    "updated_at": "2015-11-25T18:18:43Z",
    "author_association": "NONE",
    "body": "@alanpog \n\n> Another alternative is a rent insurance market where contracts can buy \"lifetime\" or at least long-dated rent for a fixed cost.\n\n@chriseth \n\n> Also with EIP-101 in mind - would it make sense to use a \"storage token\" that is different from ether and used to pay for storage? \n\n@vbuterin \n\n> I suppose you can set up a system where a contract accumulates a \"debt\" of gas fees and that debt has to be paid off before you can interact with the contract\n\nNotice that all these things are being implemented in swarm/ipfs. It would probably be cautionary to see how these solutions pan out in the long term and then see how it can be used in the case of the blockchain. Swarm doesn't implement a token, but rather a debt system where nodes keep debts to each other and if they are past a limit and aren't paid these nodes are cut out. It also implements an insurance market where you can buy \"promises to store\" something and you risk a deposit if that ever goes offline.\n\nIf nodes could rely on swarm/ipfs instead of having full nodes then they could store locally only chunks of the blockchain that are often requested and leave other chunks on the \"cloud\". This could solve the issue of blockchain rent on the client level, instead of the protocol level.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159692612/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159698179",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159698179",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159698179,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY5ODE3OQ==",
    "user": {
      "login": "niran",
      "id": 106437,
      "node_id": "MDQ6VXNlcjEwNjQzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/106437?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/niran",
      "html_url": "https://github.com/niran",
      "followers_url": "https://api.github.com/users/niran/followers",
      "following_url": "https://api.github.com/users/niran/following{/other_user}",
      "gists_url": "https://api.github.com/users/niran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/niran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/niran/subscriptions",
      "organizations_url": "https://api.github.com/users/niran/orgs",
      "repos_url": "https://api.github.com/users/niran/repos",
      "events_url": "https://api.github.com/users/niran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/niran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T18:44:18Z",
    "updated_at": "2015-11-25T18:44:18Z",
    "author_association": "NONE",
    "body": "> This assumes a lot of things about people paying attention to these things, as well as there being a benevolent source of funds to pay for ongoing storage.\n\nThe dapp pays attention to those things. The users are the benevolent source of funds. Consider a prediction market. Every transaction has fees, so the client software lets users know how much they're paying to take actions. If the user is attempting to redeem some of their winning shares but a required contract has been evicted, the client software includes the revival fees as part of the transaction fees. Alternatively, it lets the user participate in a crowdfund to revive the contract.\n\nThe perpetual blockchain storage world we live in is a seductive mirage. It is unsustainable to force future users to subsidize storage. Transaction costs in such a system will be higher than those in blockchains that charge rent, so it will be outcompeted. We are perfectly capable of building systems that collect enough revenue to fund their operations—this is how the whole world works.\n\nUnrecoverable eviction does seem problematic, though.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159698179/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159699257",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159699257",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159699257,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTY5OTI1Nw==",
    "user": {
      "login": "nmushegian",
      "id": 924397,
      "node_id": "MDQ6VXNlcjkyNDM5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/924397?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nmushegian",
      "html_url": "https://github.com/nmushegian",
      "followers_url": "https://api.github.com/users/nmushegian/followers",
      "following_url": "https://api.github.com/users/nmushegian/following{/other_user}",
      "gists_url": "https://api.github.com/users/nmushegian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nmushegian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nmushegian/subscriptions",
      "organizations_url": "https://api.github.com/users/nmushegian/orgs",
      "repos_url": "https://api.github.com/users/nmushegian/repos",
      "events_url": "https://api.github.com/users/nmushegian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nmushegian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T18:49:23Z",
    "updated_at": "2015-11-25T18:50:47Z",
    "author_association": "NONE",
    "body": "throwing support behind @PeterBorah and @pipermerriam .\n\nThis EIP has the potential to introduce a lot of technical debt for DAOs working on ethereum.\n\nThe \"rent vs own\" discussion is the only one I would entertain, since then you could say all contracts prior to the upgrade own their storage and the semantics don't change. Even making ownership a special case for ETH 1.0 contracts is acceptable, as inelegant as that is.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159699257/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159713252",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159713252",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159713252,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTcxMzI1Mg==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T19:47:26Z",
    "updated_at": "2015-11-25T19:47:26Z",
    "author_association": "NONE",
    "body": "Thinking about @niran's idea for reviving contracts.\n\nLet's call this process archiving. When a contract is left untouched (by whatever metric) for long enough it can be archived, at which point it is replaced in the state by a notice of the block the contract was archived. It can be added back by providing a SPV proof of that contract's state at the block it was archived. Note that we still can't remove the existence of the contract entirely from the state, because there needs to be some way of determining its last true state to prevent an attacker from providing an old but still techncially valid SPV proof.\n\nI think the idea has merit, but I'm not sure what odd technical problems it might present.\n\n@nmushegian: If we do go with ownership, I would discourage it being a special ETH-1.0 case. Otherwise, smart investors would create thousands of contracts before the upgrade, and sell their permastorage post-upgrade.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159713252/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159717204",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159717204",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159717204,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTcxNzIwNA==",
    "user": {
      "login": "ethers",
      "id": 6937903,
      "node_id": "MDQ6VXNlcjY5Mzc5MDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6937903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ethers",
      "html_url": "https://github.com/ethers",
      "followers_url": "https://api.github.com/users/ethers/followers",
      "following_url": "https://api.github.com/users/ethers/following{/other_user}",
      "gists_url": "https://api.github.com/users/ethers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ethers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ethers/subscriptions",
      "organizations_url": "https://api.github.com/users/ethers/orgs",
      "repos_url": "https://api.github.com/users/ethers/repos",
      "events_url": "https://api.github.com/users/ethers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ethers/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T20:03:24Z",
    "updated_at": "2015-11-25T20:03:24Z",
    "author_association": "MEMBER",
    "body": "> I am skeptical that self-destructing data is ever a good idea, but as long as there is the option for permanent data as well, I can just ignore the existence of the unreliable version, and advocate that others do the same, the way we ignore half of Javascript. Not ideal, but acceptable.\n\n+1 behind @PeterBorah \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159717204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159720140",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159720140",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159720140,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTcyMDE0MA==",
    "user": {
      "login": "niran",
      "id": 106437,
      "node_id": "MDQ6VXNlcjEwNjQzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/106437?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/niran",
      "html_url": "https://github.com/niran",
      "followers_url": "https://api.github.com/users/niran/followers",
      "following_url": "https://api.github.com/users/niran/following{/other_user}",
      "gists_url": "https://api.github.com/users/niran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/niran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/niran/subscriptions",
      "organizations_url": "https://api.github.com/users/niran/orgs",
      "repos_url": "https://api.github.com/users/niran/repos",
      "events_url": "https://api.github.com/users/niran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/niran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T20:16:09Z",
    "updated_at": "2015-11-25T20:18:43Z",
    "author_association": "NONE",
    "body": "~~I'm not sure that it makes sense to have a portion of a contract's state be temporary. The behavior of a contract after a portion of its state has been deleted would be pretty hard to get right. It also complicates reviving the state (if that turns out to be feasible and desirable).~~ Oh wait, no one is proposing this.\n\nContracts could opt in to temporary storage on creation, which would give them access to a cheaper storage opcode, but the entire contract gets archived if rent isn't paid.\n\nAs long as permanent storage remains expensive enough that any rational actor would choose Amazon Glacier instead, we avoid bloating the blockchain while allowing contracts to opt in to paying less for storage up front, but paying rent over time.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159720140/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159731949",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-159731949",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 159731949,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTczMTk0OQ==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-25T21:09:20Z",
    "updated_at": "2015-11-25T21:09:20Z",
    "author_association": "NONE",
    "body": "If there are some contracts with permanent storage, and some without (because of grandfathering in old or some switch) it's still possible to mix the two by having a DApp store some of its data in the permastorage contract and some in the tempstorage contract.\n\nIf archiving is a thing, I think it would be best to have archiving be the sole method of blockchain bloat reduction. If there's a way to remove it completely from the state while remaining able to determine when it was removed (and how to prove it back into existence) even better.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/159731949/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/160131097",
    "html_url": "https://github.com/ethereum/EIPs/issues/35#issuecomment-160131097",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/35",
    "id": 160131097,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MDEzMTA5Nw==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-27T12:34:54Z",
    "updated_at": "2015-11-27T12:36:12Z",
    "author_association": "NONE",
    "body": "👍🏻 for figuring out an archiving process instead of rent. A contract that hasn't been called upon for more than X blocks could be entered in an \"archive\" state and the economics of processing archived transactions could be different and have different gas costs.\n\nOne could imagine that miners could ignore transactions (maybe for a small deposit?) that would call archived contracts, and the miners who process them could charge more (and get the deposits?) and then expose the storage and contract code to the next miners, who would then reincorporate the now-unarchived contract. But I'm not sure how effective this would be (if I call a transaction once every X blocks then it never gets archived) or what security implications it might have (censorship by prematurely archiving contracts?)..\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/160131097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
