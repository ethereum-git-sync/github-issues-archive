{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1238",
  "id": 343018076,
  "node_id": "MDU6SXNzdWUzNDMwMTgwNzY=",
  "number": 1238,
  "title": "ERC1238: Non-transferrable Non-Fungible Tokens (NTT)",
  "user": {
    "login": "nicola",
    "id": 1424850,
    "node_id": "MDQ6VXNlcjE0MjQ4NTA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1424850?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nicola",
    "html_url": "https://github.com/nicola",
    "followers_url": "https://api.github.com/users/nicola/followers",
    "following_url": "https://api.github.com/users/nicola/following{/other_user}",
    "gists_url": "https://api.github.com/users/nicola/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nicola/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nicola/subscriptions",
    "organizations_url": "https://api.github.com/users/nicola/orgs",
    "repos_url": "https://api.github.com/users/nicola/repos",
    "events_url": "https://api.github.com/users/nicola/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nicola/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": true,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 63,
  "created_at": "2018-07-20T08:29:13Z",
  "updated_at": "2023-03-05T13:18:17Z",
  "closed_at": "2022-06-11T07:08:51Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "```\r\neip: 1238\r\ntitle: Non-transferrable Non-Fungible Tokens (badges)\r\nauthor: Nicola Greco (and future others)\r\nstatus: WIP\r\ncategory: ERC\r\ncreated: 2018-07-20\r\n```\r\n\r\n# Non-transferable tokens\r\n\r\n## Simple Summary\r\nA *badge* is a token that once assigned it cannot be transferred. Badges can be accumulated through time and put at stake. Simply speaking, badges are statements about a public key, they can be quantitative (e.g. reputation, experience) or qualitative (badges, titles).\r\n\r\n## Abstract\r\nThe *Non-transferrable token* standard defines a set of standard APIs allowing the identification of statements (called *badges*) attributed to a public key, such that different dapps and smart contract can use to filter users or to provide user with different badges different experiences. More importantly, this standard defines a way for which users can put their badges at stake. Badges cannot be transferred but can be lost (after staking) or can expire.\r\n\r\n## Motivation\r\nThe inspiration for designing badges comes from a conversation with Andrew Miller. The idea is to have a token that once assigned it cannot be transferred (like reputation) and that it can be used by websites, or contracts to make me perform some actions. For example, if a user accumulates paper submissions at conferences, then they can use their paper badges to request grants. It's important that they can never share these badges.\r\n\r\nThis is the equivalent of a variety of other use cases\r\n- Accumulating badges: degrees from academic institutions, paper publications for conferences, badges that allow for access in a building or in a special chat.\r\n- Experience points: points accumulated in a game, points accumulated by being honest in a decentralized system for some time\r\n- Statements: more broadly, any statement that is issued or signed by a contract, a dao, a single user that requires to be on-chain\r\n- Subscription: badges can represent the validity of a paid subscription\r\n\r\n## Requirements for specification\r\n- **Quantity**: a badge can have the form of 1-many, meaning that a badge can represent a single value (Degree from CS, 1), or can a quantity (Experience in Fortnite, 2000)\r\n- **Stake**: it should be simple to put at stake contingent on a smart contract execution (however, it is understandable that this could be done by a different standard)\r\n- **Backwards compatibility**: This standard should have similar apis to existing standards (e.g. #20, #721), I makes sense for an NFT viewer to also view badges\r\n- **Off-chain tokens**: This specification should work also for tokens that are not issued on chain (say by a third party signer) and can be presented on chain only when necessary (it's understandable that this is an edge case and could fall off the spec, but it's an interesting one!)\r\n\r\n## Next steps\r\nThere are two main steps here:\r\n- Specification\r\n- Implementation\r\n\r\nHowever, I will have very little time to actually bring this to life. It would be awesome if any contributor here feels strong and empowered to take over this standard and make this their own. I started this while thinking on a fun project for academia (namely called [research coin](https://nicola.io/research-coin/2017)), maybe someone wants to help there!",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1238/reactions",
    "total_count": 32,
    "+1": 32,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406558348",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-406558348",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 406558348,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjU1ODM0OA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-20T10:19:58Z",
    "updated_at": "2018-07-20T10:19:58Z",
    "author_association": "MEMBER",
    "body": "I like the idea of badges, but I think it's a mistake to tie them to a single address. Over time people will have multiple accounts, and making them non-transferrable will discourage people from switching to a more secure account (eg, from a software wallet to a hardware one).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406558348/reactions",
      "total_count": 24,
      "+1": 23,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406570374",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-406570374",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 406570374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjU3MDM3NA==",
    "user": {
      "login": "nicola",
      "id": 1424850,
      "node_id": "MDQ6VXNlcjE0MjQ4NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1424850?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicola",
      "html_url": "https://github.com/nicola",
      "followers_url": "https://api.github.com/users/nicola/followers",
      "following_url": "https://api.github.com/users/nicola/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicola/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicola/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicola/subscriptions",
      "organizations_url": "https://api.github.com/users/nicola/orgs",
      "repos_url": "https://api.github.com/users/nicola/repos",
      "events_url": "https://api.github.com/users/nicola/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicola/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-20T11:12:38Z",
    "updated_at": "2018-07-20T11:12:38Z",
    "author_association": "NONE",
    "body": "I guess you can always ask the issuer to re-issue a new badge, or maybe you can only transfer a badge if the issuer agrees on the transfering. The problem is with decentralized issuing, this might be an issue!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406570374/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406896137",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-406896137",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 406896137,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjg5NjEzNw==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-22T20:57:13Z",
    "updated_at": "2018-07-23T01:54:20Z",
    "author_association": "NONE",
    "body": "I think a way to escape the address restriction is to utilize the proxy implementation #121 or identity from #725  such that the proxy/identity has the badge and such the owner can have access with any of the owned addresses",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/406896137/reactions",
      "total_count": 7,
      "+1": 7,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407001029",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-407001029",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 407001029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzAwMTAyOQ==",
    "user": {
      "login": "chiro-hiro",
      "id": 8078873,
      "node_id": "MDQ6VXNlcjgwNzg4NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8078873?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chiro-hiro",
      "html_url": "https://github.com/chiro-hiro",
      "followers_url": "https://api.github.com/users/chiro-hiro/followers",
      "following_url": "https://api.github.com/users/chiro-hiro/following{/other_user}",
      "gists_url": "https://api.github.com/users/chiro-hiro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chiro-hiro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chiro-hiro/subscriptions",
      "organizations_url": "https://api.github.com/users/chiro-hiro/orgs",
      "repos_url": "https://api.github.com/users/chiro-hiro/repos",
      "events_url": "https://api.github.com/users/chiro-hiro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chiro-hiro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T09:44:29Z",
    "updated_at": "2018-07-23T09:44:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "@nicola will the reputation be decayed overtime? \r\n\r\nThe same thing happens in real world :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407001029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407017331",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-407017331",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 407017331,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzAxNzMzMQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T10:49:45Z",
    "updated_at": "2018-07-23T10:49:45Z",
    "author_association": "MEMBER",
    "body": "@adibas03 That demonstrates how pointless preventing transfers would be - it's easily evaded, and so just makes life more difficult for users.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407017331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407055959",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-407055959",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 407055959,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzA1NTk1OQ==",
    "user": {
      "login": "nicola",
      "id": 1424850,
      "node_id": "MDQ6VXNlcjE0MjQ4NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1424850?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicola",
      "html_url": "https://github.com/nicola",
      "followers_url": "https://api.github.com/users/nicola/followers",
      "following_url": "https://api.github.com/users/nicola/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicola/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicola/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicola/subscriptions",
      "organizations_url": "https://api.github.com/users/nicola/orgs",
      "repos_url": "https://api.github.com/users/nicola/repos",
      "events_url": "https://api.github.com/users/nicola/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicola/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T13:22:39Z",
    "updated_at": "2018-07-23T13:22:47Z",
    "author_association": "NONE",
    "body": "@chiro-hiro it would be up to you, how you implement it\r\n\r\n@Arachnid I agree and disagree, the identity would be an ID where you can decide the set of keys that own that ID, you can't transfer badges across IDs.. For example, when playing in a game, you only have one ID per player and you only have some experience. In other words, I believe there is something useful here.\r\n\r\nnote: re-issuing is still a valid option for some usecases",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407055959/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407131735",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-407131735",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 407131735,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzEzMTczNQ==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-23T17:09:40Z",
    "updated_at": "2018-07-23T22:36:48Z",
    "author_association": "NONE",
    "body": "@Arachnid I see your point about the `non-transferable` attribute. Similar to game credits, which are not natively transferrable, but the accounts with the credits and repuation can be sold. So, the proxy/Identity accounts can be transferred in a way.\r\n@nicola I think @Arachnid has a point here.\r\nAlso, could the badges be an example of a claim as described in #735 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407131735/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407974947",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-407974947",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 407974947,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzk3NDk0Nw==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T04:46:40Z",
    "updated_at": "2018-07-26T04:46:40Z",
    "author_association": "MEMBER",
    "body": "There is a big difference between transferring individual badges and transferring all badges associated with a key.  I think there is noue in allowing users to transfer all of their badges to a new key, while also preventing individual badges from being transferred away.\r\n\r\nOne can think of the set of badges as identifying a user, and you cannot split the user into parts and have it be the same user, but you can transfer a user to a new private key. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407974947/reactions",
      "total_count": 9,
      "+1": 9,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408005437",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-408005437",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 408005437,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODAwNTQzNw==",
    "user": {
      "login": "vongohren",
      "id": 1012055,
      "node_id": "MDQ6VXNlcjEwMTIwNTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1012055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vongohren",
      "html_url": "https://github.com/vongohren",
      "followers_url": "https://api.github.com/users/vongohren/followers",
      "following_url": "https://api.github.com/users/vongohren/following{/other_user}",
      "gists_url": "https://api.github.com/users/vongohren/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vongohren/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vongohren/subscriptions",
      "organizations_url": "https://api.github.com/users/vongohren/orgs",
      "repos_url": "https://api.github.com/users/vongohren/repos",
      "events_url": "https://api.github.com/users/vongohren/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vongohren/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T07:35:40Z",
    "updated_at": "2018-07-26T07:35:40Z",
    "author_association": "NONE",
    "body": "What differences do you see between badges and claims? \r\nRef: https://medium.com/uport/erc1056-erc780-an-open-identity-and-claims-protocol-for-ethereum-aef7207bc744\r\n\r\nBoth #735 and uPort uses the wording of claims.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408005437/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408036922",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-408036922",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 408036922,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODAzNjkyMg==",
    "user": {
      "login": "nicola",
      "id": 1424850,
      "node_id": "MDQ6VXNlcjE0MjQ4NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1424850?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicola",
      "html_url": "https://github.com/nicola",
      "followers_url": "https://api.github.com/users/nicola/followers",
      "following_url": "https://api.github.com/users/nicola/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicola/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicola/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicola/subscriptions",
      "organizations_url": "https://api.github.com/users/nicola/orgs",
      "repos_url": "https://api.github.com/users/nicola/repos",
      "events_url": "https://api.github.com/users/nicola/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicola/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T09:29:23Z",
    "updated_at": "2018-07-26T09:29:23Z",
    "author_association": "NONE",
    "body": "#735 looks very similar, if not identical to that, I will reach out to them.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408036922/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408558315",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-408558315",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 408558315,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODU1ODMxNQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-27T22:54:29Z",
    "updated_at": "2018-07-27T22:54:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "I worked on some \"badge\" token stuff to quantify participation events for fun and also opted for \"transfer all or none scheme\" as @MicahZoltu proposes, which I think is good enough for the intent here. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408558315/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410405668",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-410405668",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 410405668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQwNTY2OA==",
    "user": {
      "login": "jcksncllwy",
      "id": 626533,
      "node_id": "MDQ6VXNlcjYyNjUzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/626533?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcksncllwy",
      "html_url": "https://github.com/jcksncllwy",
      "followers_url": "https://api.github.com/users/jcksncllwy/followers",
      "following_url": "https://api.github.com/users/jcksncllwy/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcksncllwy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcksncllwy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcksncllwy/subscriptions",
      "organizations_url": "https://api.github.com/users/jcksncllwy/orgs",
      "repos_url": "https://api.github.com/users/jcksncllwy/repos",
      "events_url": "https://api.github.com/users/jcksncllwy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcksncllwy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-04T00:10:54Z",
    "updated_at": "2018-08-04T00:10:54Z",
    "author_association": "NONE",
    "body": "@vongohren A significant difference between #735 claims and #1238 badges is information ownership. In #735 the Claim Holder owns any claims made about themselves. The problem with this is that there is no way for a Claim Issuer to revoke or alter a claim once it has been issued. While #735 does specify a `removeClaim` method, a malicious implementation could simply ignore that method call, because _they own the claim_.\r\n\r\nImagine that SafeEmploy™, a background checking company, issues a claim about Timmy. The claim states that Timmy has never been convicted of any felonies. Timmy makes some bad decisions, and now that claim is no longer true. SafeEmploy™ executes `removeClaim`, but Timmy's #735 contract just ignores it, because Timmy wants to stay employed (and is crypto-clever).\r\n\r\n#1238 badges do not have this problem. Ownership of a badge/claim is entirely determined by the contract **issuing** the badges, not the one **receiving** them. The issuer is free to remove or change those badges as they see fit. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410405668/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411668123",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-411668123",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 411668123,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTY2ODEyMw==",
    "user": {
      "login": "conejoninja",
      "id": 475423,
      "node_id": "MDQ6VXNlcjQ3NTQyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/475423?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/conejoninja",
      "html_url": "https://github.com/conejoninja",
      "followers_url": "https://api.github.com/users/conejoninja/followers",
      "following_url": "https://api.github.com/users/conejoninja/following{/other_user}",
      "gists_url": "https://api.github.com/users/conejoninja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/conejoninja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/conejoninja/subscriptions",
      "organizations_url": "https://api.github.com/users/conejoninja/orgs",
      "repos_url": "https://api.github.com/users/conejoninja/repos",
      "events_url": "https://api.github.com/users/conejoninja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/conejoninja/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-09T07:44:40Z",
    "updated_at": "2018-08-09T07:44:40Z",
    "author_association": "NONE",
    "body": "@jcksncllwy In #725 (along with #735) The claim issuer could remove the key (from their own identity) that signed the claim to revoke it.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411668123/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/412422044",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-412422044",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 412422044,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjQyMjA0NA==",
    "user": {
      "login": "OFRBG",
      "id": 8671781,
      "node_id": "MDQ6VXNlcjg2NzE3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8671781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/OFRBG",
      "html_url": "https://github.com/OFRBG",
      "followers_url": "https://api.github.com/users/OFRBG/followers",
      "following_url": "https://api.github.com/users/OFRBG/following{/other_user}",
      "gists_url": "https://api.github.com/users/OFRBG/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/OFRBG/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/OFRBG/subscriptions",
      "organizations_url": "https://api.github.com/users/OFRBG/orgs",
      "repos_url": "https://api.github.com/users/OFRBG/repos",
      "events_url": "https://api.github.com/users/OFRBG/events{/privacy}",
      "received_events_url": "https://api.github.com/users/OFRBG/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-13T06:41:13Z",
    "updated_at": "2018-08-13T06:41:13Z",
    "author_association": "NONE",
    "body": "Reputation system are likely to be abused. Cutting the explanation and straight to the example:\r\n\r\n> A major org around Ethereum decides to screen users. The screening process may only be performed by said org, since they set the rules for their own DApp. Being the first mover with a household name.\r\n> \r\n> Since Ethereum doesn't have truly private methods and attributes, other DApp groups can easily read the badges other users have. If the major org with first mover advantage creates its own version of crypto-TSA, other groups will simply save time and resources, piggybacking on what's available.\r\n> \r\n> If the problem isn't already blatantly obvious, think about the reputation bottleneck this causes: the major org or orgs that work as a crypto-TSA become gatekeepers for the whole system. We know from history that some things we do aren't the best, but they stuck because they were the most comfortable. When going from a reputation-less system into a reputation-based system, whatever comes first is most likely to stay. \r\n\r\nOn a trustless network every address should be no different from any other. I think a measured reputation system goes against what crypto should be. In other words, creating an issued-reputation ERC is opening Pandora's Box.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/412422044/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432613586",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-432613586",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 432613586,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjYxMzU4Ng==",
    "user": {
      "login": "cbruguera",
      "id": 2256202,
      "node_id": "MDQ6VXNlcjIyNTYyMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256202?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cbruguera",
      "html_url": "https://github.com/cbruguera",
      "followers_url": "https://api.github.com/users/cbruguera/followers",
      "following_url": "https://api.github.com/users/cbruguera/following{/other_user}",
      "gists_url": "https://api.github.com/users/cbruguera/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cbruguera/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cbruguera/subscriptions",
      "organizations_url": "https://api.github.com/users/cbruguera/orgs",
      "repos_url": "https://api.github.com/users/cbruguera/repos",
      "events_url": "https://api.github.com/users/cbruguera/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cbruguera/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-24T11:09:12Z",
    "updated_at": "2018-10-24T11:09:12Z",
    "author_association": "NONE",
    "body": "I think this is an interesting idea. It's definitely related to the concept of _claims_, but I can see an interoperability advantage in defining the behavior of these \"claims\" in a contract specific to the claim \"type\" (i.e. badge), instead of residing in the claim holder or issuer contracts (similar to how ERC20 and ERC721 work).\r\n\r\nWith regard to not limiting badge ownership to a single address, that's where we start getting into _identity_ territory, which is not a trivial one. I came across [this proposal](https://github.com/ethereum/EIPs/issues/1495) recently, perhaps you guys might be interested in having a look at it and it would be good to know your feedback on the matter.\r\n\r\nOne question about defining this as a standard: should badge issuers be able to arbitrarily revoke the badge? Or would this stay outside the scope of a standard and be more a matter of particular implementation?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432613586/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432688918",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-432688918",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 432688918,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjY4ODkxOA==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-24T14:47:23Z",
    "updated_at": "2018-10-24T14:47:23Z",
    "author_association": "NONE",
    "body": "@OFRBG You are right about the danger of Reputation, but as you mentioned, the implementation plays a big role.All or null transfer-ability as suggested by @MicahZoltu still seems the best possible option.\r\nAlso, the two main preferable  implementation I believe are (I am using `claim` t refer to both `claims`  #735 and `badges` #1238),\r\n- Claim registry contract which allows contract owner create claims on address which can be approved or rejected by the address owner. The state of the contract concerning the claim can be regarded as final, as the contract gets more approved claimed, it reputation increases, and that is when things can get interesting\r\n- Claimant makes a claim on an address, which is approved by the address by publishing the claim identifier (needs a standard). The claimant can at any time withdraw the claim and the address can at any time have the claim identifier information unpublished, thereby voiding the claim. In this case, both Claimant (contract) and address (Identity contract #725 ) both have to publish the same information to be considered approved- This is a whole lot more complicated, but I think quenches mot of the worries attached to the security concerns.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/432688918/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433547740",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-433547740",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 433547740,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzU0Nzc0MA==",
    "user": {
      "login": "jahowle",
      "id": 16561063,
      "node_id": "MDQ6VXNlcjE2NTYxMDYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16561063?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jahowle",
      "html_url": "https://github.com/jahowle",
      "followers_url": "https://api.github.com/users/jahowle/followers",
      "following_url": "https://api.github.com/users/jahowle/following{/other_user}",
      "gists_url": "https://api.github.com/users/jahowle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jahowle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jahowle/subscriptions",
      "organizations_url": "https://api.github.com/users/jahowle/orgs",
      "repos_url": "https://api.github.com/users/jahowle/repos",
      "events_url": "https://api.github.com/users/jahowle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jahowle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-26T21:25:04Z",
    "updated_at": "2018-10-26T21:25:04Z",
    "author_association": "NONE",
    "body": "Full Disclosure: I work at www.uport.me\r\n\r\n@nicola I think the most important thought in your original posting is this \r\n\r\n> Off-chain tokens: This specification should work also for tokens that are not issued on chain (say by a third party signer) and can be presented on chain only when necessary (it's understandable that this is an edge case and could fall off the spec, but it's an interesting one!)\r\n\r\nWhy put reputation claims on-chain at all? \r\n\r\nMy assumption is that it reduces the friction between the party consuming the reputation and the party with the reputation, but that can potentially be solved at the UX/application level through easy selective, progressive, and active disclosure. \r\n\r\nI worry about the privacy of users in any implementation of an on-chain claims registry.\r\n\r\nI'd like to hear your's or anyone's argument for on-chain claims over off-chain claims.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433547740/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469764886",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-469764886",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 469764886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTc2NDg4Ng==",
    "user": {
      "login": "snaketh4x0r",
      "id": 48221232,
      "node_id": "MDQ6VXNlcjQ4MjIxMjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/48221232?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snaketh4x0r",
      "html_url": "https://github.com/snaketh4x0r",
      "followers_url": "https://api.github.com/users/snaketh4x0r/followers",
      "following_url": "https://api.github.com/users/snaketh4x0r/following{/other_user}",
      "gists_url": "https://api.github.com/users/snaketh4x0r/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snaketh4x0r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snaketh4x0r/subscriptions",
      "organizations_url": "https://api.github.com/users/snaketh4x0r/orgs",
      "repos_url": "https://api.github.com/users/snaketh4x0r/repos",
      "events_url": "https://api.github.com/users/snaketh4x0r/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snaketh4x0r/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-05T17:05:32Z",
    "updated_at": "2019-06-17T12:57:49Z",
    "author_association": "NONE",
    "body": "nice eip @nicola \r\nI just got some free time from my busy college so I decided to contribute to decentralize web.\r\nso here is example code with non transferable functionality implemented.\r\n\r\nBadge is **NON transferable token** issued by owner to a particular identity.\r\n\r\nbadges are issued only once to new identities.\r\nto issue new badges new contracts have to be deployed.\r\nthere can be a new function introduced to remove a identity from transfer restriction so it can be issued more badge tokens(which is of no use) but then it will have drawbacks as described in second way further below.\r\n\r\nThere were two ways to implement it,\r\n\r\nfirst by preventing transfer for each identity which uses lot of gas as each identity is stored on blockchain.\r\nsecondly by freezing transfer function of contract,its gas efficient but it had few drawbacks\r\nconsider owner unfreezed transfer to issue new badge token for particular new identity,during this time any existing token holder could transfer token,onlyOwner modifier on transfer is of no use as owner would be able to transfer a token between identities hence owner can be bribed by token holders to transfer their tokens to another token holder but we have to prevent that.\r\nso first way is best way plus owner can set his address as target and so no one will be able transfer any token in future not even owner hence no new token issued.\r\n\r\nowner here can be\r\nsingle address or multi-sig address contract controlled by single individual or group->centralized\r\nDAO->decentralized\r\npublic by anyone->truly decentralized\r\n\r\nRepution system is not implemented as secure,safe reputation system on chain is not proposed yet,all current iterations of reputation system on chain are exploitable,defining it into a standard will be like making a bug a standard.\r\n\r\noff chain tokens can be created thanks to create2 but it would be better to use it in universal login.\r\nso a proxy identity contract will be created for a user to which owner will issue a badge or non transferable token and it will be controlled by set of allowed keys.\r\n\r\nI disagree with @Arachnid that Non transfer function of token will discourage people from switching to more secure wallet as a solution like universal login can be used and so there will be no need to switch wallets as token will be issued to secure smart contract wallet controlled by keys selected by user.\r\n\r\n**Applications**\r\n\r\n1.can be used to issue badges to identity\r\n2.can be used for voting tokens as votes between user cannot be transferred among other user but sent to contract for voting.\r\n3.to give Credentials to identities like driver license or educational certificate from academic institutions,identity holding them won't be able to transfer their credentials like license or certificates to others.\r\n4.still to be discovered.....\r\n\r\n**->code starts here**\r\n\r\n```/*// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface extended to Non transferable token(Badge) standard\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\n/*\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function freezeAccount(address target,bool freeze) public returns (bool success);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event NonTransferable(address target, bool frozen);\r\n\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'FIXED' 'Example Fixed Supply Non Transferable Token' token contract\r\n//\r\n// Symbol      : FIXED\r\n// Name        : Example Fixed Supply Non Transferable Token\r\n// Total supply: 1,000,000.000000000000000000\r\n// Decimals    : 18\r\n//\r\n// Enjoy.\r\n//\r\n// ERC-20 standard taken from (c) BokkyPooBah / Bok Consulting Pty Ltd 2018. The MIT Licence.\r\n//thanks for your contribution to community\r\n//extended for non transferable token by Snaketh4xor\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and a\r\n// fixed supply extended to Non transferable token \r\n// ----------------------------------------------------------------------------\r\ncontract FixedSupplyToken is ERC20Interface, Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    mapping(address => bool) public frozenAccount;\r\n    \r\n    event NonTransferable(address target, bool frozen);\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        symbol = \"FIXED\";\r\n        name = \"Example Fixed Supply Token\";\r\n        decimals = 18;\r\n        _totalSupply = 1000000 * 10**uint(decimals);\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply.sub(balances[address(0)]);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    //stops transfer of tokens for identity.\r\n    function freezeAccount(address target, bool freeze) onlyOwner public returns (bool success) {\r\n        frozenAccount[target] = freeze;\r\n        emit NonTransferable(target, freeze);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) onlyOwner public returns (bool success) {\r\n        require(!frozenAccount[to]);\r\n        require(!frozenAccount[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        freezeAccount(to, true);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) onlyOwner public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) onlyOwner public returns (bool success) {\r\n        require(!frozenAccount[to]);\r\n        require(!frozenAccount[from]);\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        freezeAccount(to, true);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n    // `receiveApproval(...)` is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes memory data) onlyOwner public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/469764886/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/480384101",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-480384101",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 480384101,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDM4NDEwMQ==",
    "user": {
      "login": "winnal",
      "id": 33274296,
      "node_id": "MDQ6VXNlcjMzMjc0Mjk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/33274296?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/winnal",
      "html_url": "https://github.com/winnal",
      "followers_url": "https://api.github.com/users/winnal/followers",
      "following_url": "https://api.github.com/users/winnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/winnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/winnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/winnal/subscriptions",
      "organizations_url": "https://api.github.com/users/winnal/orgs",
      "repos_url": "https://api.github.com/users/winnal/repos",
      "events_url": "https://api.github.com/users/winnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/winnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-05T18:49:23Z",
    "updated_at": "2019-04-05T19:36:34Z",
    "author_association": "NONE",
    "body": "I was thinking of a use-case for a non-transferable token for the purposes of a founders token, where tokens are bound to the user account, and the user can use the tokens for voting, private access to the platform (like beta testing) and spending/burning to redeem a benefit, but cannot trade or transfer the token, which would make a founders token sale (FTO) exempt from securities regulation as the token cannot be traded, yet would enable there to be a development fund through a token sale.\r\n\r\nThe concept comes from many traditional industries that sell a product before it’s been developed, like a founder’s or limited edition and preorder. They are able to do this because these sales cannot be transferred and is essentially a purchase rather than an investment. And in the case of non-transferable tokens with utility, you can effectively conduct a sale of tokens as an exclusive feature or benefits that cannot be traded therefore not considered an investment.\r\n\r\nCreating such a token will have tremendous potential for ICOs (designated as a FTO) to be conducted for development funding that won’t be deemed a security. It could completely change the way startups get seed funding without the limitations of an investment deal.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/480384101/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592030529",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-592030529",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 592030529,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjAzMDUyOQ==",
    "user": {
      "login": "xuhcc",
      "id": 1660460,
      "node_id": "MDQ6VXNlcjE2NjA0NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1660460?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/xuhcc",
      "html_url": "https://github.com/xuhcc",
      "followers_url": "https://api.github.com/users/xuhcc/followers",
      "following_url": "https://api.github.com/users/xuhcc/following{/other_user}",
      "gists_url": "https://api.github.com/users/xuhcc/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/xuhcc/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/xuhcc/subscriptions",
      "organizations_url": "https://api.github.com/users/xuhcc/orgs",
      "repos_url": "https://api.github.com/users/xuhcc/repos",
      "events_url": "https://api.github.com/users/xuhcc/events{/privacy}",
      "received_events_url": "https://api.github.com/users/xuhcc/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T15:50:47Z",
    "updated_at": "2020-02-27T15:50:47Z",
    "author_association": "NONE",
    "body": "I think that it is sufficient to provide a single method that returns boolean value indicating transferrability of a token. All other details should be left to implementers. Such interface will be compatible with ERC20, ERC721, ERC1155 and other token standards.\r\n\r\nHere's an example:\r\n\r\n```js\r\ncontract ERC1238 is ERC165 {\r\n\r\n    bool internal _transfersEnabled;\r\n\r\n    /*\r\n     *     bytes4(keccak256('transfersEnabled()')) == 0xbef97c87\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC1238 = 0xbef97c87;\r\n\r\n    constructor () public {\r\n        _registerInterface(_INTERFACE_ID_ERC1238);\r\n    }\r\n    \r\n    function transfersEnabled() external view returns (bool) {\r\n        return _transfersEnabled;\r\n    }\r\n}\r\n```\r\n\r\nThe name `trasfersEnabled` is borrowed from [MiniMe token contract](https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol#L81). It is also used by [Aragon](https://github.com/aragon/aragon-apps/blob/shared-minime-v1.0.2/shared/minime/contracts/MiniMeToken.sol#L101) to designate non-transerrable reputation and membership tokens in DAOs.\r\n\r\nTransferrability of ERC1238 token can change depending on some condition, so it allows complex logic like the \"all or none\" scheme described earlier in this thread.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/592030529/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675075652",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-675075652",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 675075652,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3NTA3NTY1Mg==",
    "user": {
      "login": "rosspeili",
      "id": 39490881,
      "node_id": "MDQ6VXNlcjM5NDkwODgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/39490881?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rosspeili",
      "html_url": "https://github.com/rosspeili",
      "followers_url": "https://api.github.com/users/rosspeili/followers",
      "following_url": "https://api.github.com/users/rosspeili/following{/other_user}",
      "gists_url": "https://api.github.com/users/rosspeili/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rosspeili/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rosspeili/subscriptions",
      "organizations_url": "https://api.github.com/users/rosspeili/orgs",
      "repos_url": "https://api.github.com/users/rosspeili/repos",
      "events_url": "https://api.github.com/users/rosspeili/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rosspeili/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-17T19:44:57Z",
    "updated_at": "2020-08-17T19:44:57Z",
    "author_association": "NONE",
    "body": "I am not sure how viable this contract can be, but having in mind potential future use-cases, I assume it should be abuse-proof. For example, We create a biometric web3 ID by completing a DNA sequencing, we upload this data to a bioinformatics related blockchain like Zenome, ARNA, or Encrypgen. The respective DLT platform could mint NTTs based on a KYC procedure that includes the genomic data. This NTT could be used as a web3 ID, and it can also be used to retrieve a wallet in case of loss of all recovery methods including private key and seed phrase. Eg. I lost my web3 wallet that has a biometric NTT, I perform a new test or request my test from the lab, or blockchain that created the initial contract using real-time KYC. Proving our new or retrieved DNA test, we could retrieve our wallet, again, considering the ERC is secure and truly nontransferable. That for, if once I mint my own biometric ID and manage to transfer it to your wallet, I could easily create a second test to claim access to your wallet that will basically indicate it bears my DNA. NTT must be obsolete. It's nice to have NTTs with expiration data, but biometric IDs could be only one time mint, one time transfer, nonfungible, and not transferable tokens. That's one of the most exciting ERCs and its a shame DeFi dudes are not paying attention. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675075652/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675088314",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-675088314",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 675088314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3NTA4ODMxNA==",
    "user": {
      "login": "Genobank",
      "id": 37123601,
      "node_id": "MDEyOk9yZ2FuaXphdGlvbjM3MTIzNjAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/37123601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Genobank",
      "html_url": "https://github.com/Genobank",
      "followers_url": "https://api.github.com/users/Genobank/followers",
      "following_url": "https://api.github.com/users/Genobank/following{/other_user}",
      "gists_url": "https://api.github.com/users/Genobank/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Genobank/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Genobank/subscriptions",
      "organizations_url": "https://api.github.com/users/Genobank/orgs",
      "repos_url": "https://api.github.com/users/Genobank/repos",
      "events_url": "https://api.github.com/users/Genobank/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Genobank/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "created_at": "2020-08-17T20:11:06Z",
    "updated_at": "2020-08-17T20:11:06Z",
    "author_association": "NONE",
    "body": "@rosspeili please review our peer reviewed article.  Happy to collaborate. \n\n\"Privacy Laws, Genomic data and Non-fungible-tokens\"\nhttps://jbba.scholasticahq.com/article/13164.pdf\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675088314/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675088502",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-675088502",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 675088502,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3NTA4ODUwMg==",
    "user": {
      "login": "Genobank",
      "id": 37123601,
      "node_id": "MDEyOk9yZ2FuaXphdGlvbjM3MTIzNjAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/37123601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Genobank",
      "html_url": "https://github.com/Genobank",
      "followers_url": "https://api.github.com/users/Genobank/followers",
      "following_url": "https://api.github.com/users/Genobank/following{/other_user}",
      "gists_url": "https://api.github.com/users/Genobank/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Genobank/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Genobank/subscriptions",
      "organizations_url": "https://api.github.com/users/Genobank/orgs",
      "repos_url": "https://api.github.com/users/Genobank/repos",
      "events_url": "https://api.github.com/users/Genobank/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Genobank/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "created_at": "2020-08-17T20:11:25Z",
    "updated_at": "2020-08-17T20:11:25Z",
    "author_association": "NONE",
    "body": "@rosspeili please review our peer reviewed article.  Happy to collaborate. \n\n\"Privacy Laws, Genomic data and Non-fungible-tokens\"\nhttps://jbba.scholasticahq.com/article/13164.pdf\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/675088502/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/726998953",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-726998953",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 726998953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjk5ODk1Mw==",
    "user": {
      "login": "fulldecent",
      "id": 382183,
      "node_id": "MDQ6VXNlcjM4MjE4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/382183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fulldecent",
      "html_url": "https://github.com/fulldecent",
      "followers_url": "https://api.github.com/users/fulldecent/followers",
      "following_url": "https://api.github.com/users/fulldecent/following{/other_user}",
      "gists_url": "https://api.github.com/users/fulldecent/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fulldecent/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fulldecent/subscriptions",
      "organizations_url": "https://api.github.com/users/fulldecent/orgs",
      "repos_url": "https://api.github.com/users/fulldecent/repos",
      "events_url": "https://api.github.com/users/fulldecent/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fulldecent/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-13T19:50:57Z",
    "updated_at": "2020-11-13T19:50:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "If anybody is interested in an implementation of the concepts discussed in this thread, please see our publication:\r\n\r\nhttps://genobank.io/biosample-permission-token-with-non-fungible-tokens\r\n\r\n---\r\n\r\nHere we are creating tokens that allow the creator to edit them at any time.\r\n\r\nAll tokens are created as ERC-721s and are namespaced to the account owner. i.e. bits 1...160 are the address of `msg.sender` and the remaining 96 bits are chosen by the token creator.\r\n\r\nEffectively this allows anybody to create badges/tokens and they are not transferred.\r\n\r\n---\r\n\r\nAnd in other words, it is creating a public data structure:\r\n\r\nmapping (OWNER address => mapping (uint96 => (TOKEN METADATA, ADDRESS)))",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/726998953/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/844330510",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-844330510",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 844330510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0NDMzMDUxMA==",
    "user": {
      "login": "ra-phael",
      "id": 10075759,
      "node_id": "MDQ6VXNlcjEwMDc1NzU5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10075759?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ra-phael",
      "html_url": "https://github.com/ra-phael",
      "followers_url": "https://api.github.com/users/ra-phael/followers",
      "following_url": "https://api.github.com/users/ra-phael/following{/other_user}",
      "gists_url": "https://api.github.com/users/ra-phael/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ra-phael/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ra-phael/subscriptions",
      "organizations_url": "https://api.github.com/users/ra-phael/orgs",
      "repos_url": "https://api.github.com/users/ra-phael/repos",
      "events_url": "https://api.github.com/users/ra-phael/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ra-phael/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-19T17:48:15Z",
    "updated_at": "2021-05-20T09:46:40Z",
    "author_association": "NONE",
    "body": "Partly inspired by this issue, @arcalinea and I are working on a reputation service that uses non-transferrable, non-fungible tokens as on-chain proofs of reputation. The token, which we call a “badge”, gets issued to an address that a user wants to link to a centralized service (i.e. Twitter, Github), through our third-party reputation verification service.\r\n\r\nWe are still playing with this concept, and have created a contract issuing these badges to the [Kovan testnet.](https://kovan.etherscan.io/address/0xb3e404E8BCbc2af1683da73f14A558662346119F) Any feedback is welcome!\r\n\r\nAt first, we drafted a version that is ERC-721 compliant, but that adds unnecessary overhead to the simple concept of a badge, which does not need approve and transfer functions, or a tokenURI field with associated metadata. The badge contract we have deployed has different requirements. These are the basic things we believe a badge contract implementation needs to have:\r\n\r\n- non-transferability of the token\r\n- a clear link to the issuer of the badge\r\n- a “burn” function to revoke badges\r\n- a timestamp at time of issuance\r\n\r\nIf this type of token becomes useful for applications, it would be great to standardize non-transferrable, non-fungible tokens.\r\n\r\nSome contract code is below. The version below does not have a token struct with id and timestamp - doing so makes querying for the time the badge was created easier, but costs more in gas. An alternate version with timestamps can be found [here](https://github.com/ra-phael/badge-token/blob/main/contracts/withTimestamp/IBadge.sol).\r\n\r\n**Version without timestamp:**\r\n\r\n```solidity=\r\ninterface IBadge {\r\n    // @dev Emitted when `tokenId` token is minted to `to`, an address.\r\n    event Minted(\r\n        address indexed to,\r\n        bytes32 indexed tokenId,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // @dev Emitted when `tokenId` token is burned.\r\n    event Burned(\r\n        address indexed owner,\r\n        bytes32 indexed tokenId,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // @dev Returns the badge's name\r\n    function name() external view returns (string memory);\r\n\r\n    // @dev Returns the badge's symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    // @dev Returns the ID of the token owned by `owner`, if it owns one, and 0 otherwise\r\n    function tokenOf(address owner) external view returns (bytes32);\r\n\r\n    // @dev Returns the owner of the `tokenId` token.\r\n    function ownerOf(bytes32 tokenId) external view returns (address);\r\n}\r\n\r\ncontract Badge is IBadge {\r\n    // Badge's name\r\n    string private _name;\r\n\r\n    // Badge's symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner's address\r\n    mapping(bytes32 => address) private _owners;\r\n\r\n    // Mapping from owner's address to token ID\r\n    mapping(address => bytes32) private _tokens;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    // Returns the badge's name\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    // Returns the badge's symbol\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    // Returns the token ID owned by `owner`, if it exists, and 0 otherwise\r\n    function tokenOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bytes32)\r\n    {\r\n        require(owner != address(0), \"Invalid owner at zero address\");\r\n\r\n        return _tokens[owner];\r\n    }\r\n\r\n    // Returns the owner of a given token ID, reverts if the token does not exist\r\n    function ownerOf(bytes32 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        require(tokenId != 0, \"Invalid tokenId value\");\r\n\r\n        address owner = _owners[tokenId];\r\n\r\n        require(owner != address(0), \"Invalid owner at zero address\");\r\n\r\n        return owner;\r\n    }\r\n\r\n    // Checks if a token ID exists\r\n    function _exists(bytes32 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    // @dev Mints `tokenId` and transfers it to `to`.\r\n    function _mint(address to, bytes32 tokenId) internal virtual {\r\n        require(to != address(0), \"Invalid owner at zero address\");\r\n        require(tokenId != 0, \"Token ID cannot be zero\");\r\n        require(!_exists(tokenId), \"Token already minted\");\r\n        require(tokenOf(to) == 0, \"Owner already has a token\");\r\n\r\n        _tokens[to] = tokenId;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Minted(to, tokenId, block.timestamp);\r\n    }\r\n\r\n    // @dev Burns `tokenId`.\r\n    function _burn(bytes32 tokenId) internal virtual {\r\n        address owner = Badge.ownerOf(tokenId);\r\n\r\n        delete _tokens[owner];\r\n        delete _owners[tokenId];\r\n\r\n        emit Burned(owner, tokenId, block.timestamp);\r\n    }\r\n}\r\n\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/844330510/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/858575014",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-858575014",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 858575014,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1ODU3NTAxNA==",
    "user": {
      "login": "cryptoregtech",
      "id": 11443514,
      "node_id": "MDQ6VXNlcjExNDQzNTE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/11443514?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cryptoregtech",
      "html_url": "https://github.com/cryptoregtech",
      "followers_url": "https://api.github.com/users/cryptoregtech/followers",
      "following_url": "https://api.github.com/users/cryptoregtech/following{/other_user}",
      "gists_url": "https://api.github.com/users/cryptoregtech/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cryptoregtech/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cryptoregtech/subscriptions",
      "organizations_url": "https://api.github.com/users/cryptoregtech/orgs",
      "repos_url": "https://api.github.com/users/cryptoregtech/repos",
      "events_url": "https://api.github.com/users/cryptoregtech/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cryptoregtech/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-10T12:23:42Z",
    "updated_at": "2021-06-10T12:23:42Z",
    "author_association": "NONE",
    "body": "It is standard still live?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/858575014/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/875781068",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-875781068",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 875781068,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg3NTc4MTA2OA==",
    "user": {
      "login": "htadashi",
      "id": 2355491,
      "node_id": "MDQ6VXNlcjIzNTU0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2355491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/htadashi",
      "html_url": "https://github.com/htadashi",
      "followers_url": "https://api.github.com/users/htadashi/followers",
      "following_url": "https://api.github.com/users/htadashi/following{/other_user}",
      "gists_url": "https://api.github.com/users/htadashi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/htadashi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/htadashi/subscriptions",
      "organizations_url": "https://api.github.com/users/htadashi/orgs",
      "repos_url": "https://api.github.com/users/htadashi/repos",
      "events_url": "https://api.github.com/users/htadashi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/htadashi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-07-07T17:14:17Z",
    "updated_at": "2021-07-07T17:14:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "With the recent NFT boom, I think this standard could make a comeback.  Besides @ra-phael use case, here is another recent example: \r\n\r\nhttps://blog.questbook.app/2021/05/29/introducing-the-decentralized-learning-economy-whitepaper-draft/#:~:text=We%20introduce%20a%20new%20class%20of%20NFT%20called%20NFT-Ls.%20These%20are%20Non%20Fungible%20Tokens%20of%20Learning.%20These%20differ%20from%20the%20standard%20NFTs%20in%20the%20sense%20that%20they%20are%20non%20tradable.%20Once%20you%20earned%20it%2C%20it%20is%20yours%20forever.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/875781068/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950350831",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-950350831",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 950350831,
    "node_id": "IC_kwDOAq426M44pTPv",
    "user": {
      "login": "mark-smartseal",
      "id": 62183883,
      "node_id": "MDQ6VXNlcjYyMTgzODgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/62183883?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mark-smartseal",
      "html_url": "https://github.com/mark-smartseal",
      "followers_url": "https://api.github.com/users/mark-smartseal/followers",
      "following_url": "https://api.github.com/users/mark-smartseal/following{/other_user}",
      "gists_url": "https://api.github.com/users/mark-smartseal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mark-smartseal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mark-smartseal/subscriptions",
      "organizations_url": "https://api.github.com/users/mark-smartseal/orgs",
      "repos_url": "https://api.github.com/users/mark-smartseal/repos",
      "events_url": "https://api.github.com/users/mark-smartseal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mark-smartseal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-24T16:07:06Z",
    "updated_at": "2021-10-24T16:07:06Z",
    "author_association": "NONE",
    "body": "> I like the idea of badges, but I think it's a mistake to tie them to a single address. Over time people will have multiple accounts, and making them non-transferrable will discourage people from switching to a more secure account (eg, from a software wallet to a hardware one).\r\n\r\nI think they should be tied to a single address. The actions of each address represent a persona which is a subset of a person's identity. Whatever actions you decide to do with that wallet (buying, selling, borrowing, etc) can be rated by another wallet. So if you build a persona with a single wallet, you can now use the social credit that has been issued to this wallet through NTTs to do trusted actions like borrowing money or selling physical assets through an online marketplace. \r\n\r\nIf you switch wallets, you have to build up these NTTs on your new wallet. That's a feature. Banks and governments can issue NTTs against your wallet that represents your identity. So you still may be able to prove that these badges belong to you as long as a trusted third-party determines that both wallets belong to you.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/950350831/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/961703245",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-961703245",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 961703245,
    "node_id": "IC_kwDOAq426M45Um1N",
    "user": {
      "login": "sandys",
      "id": 76883,
      "node_id": "MDQ6VXNlcjc2ODgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/76883?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sandys",
      "html_url": "https://github.com/sandys",
      "followers_url": "https://api.github.com/users/sandys/followers",
      "following_url": "https://api.github.com/users/sandys/following{/other_user}",
      "gists_url": "https://api.github.com/users/sandys/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sandys/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sandys/subscriptions",
      "organizations_url": "https://api.github.com/users/sandys/orgs",
      "repos_url": "https://api.github.com/users/sandys/repos",
      "events_url": "https://api.github.com/users/sandys/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sandys/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-05T08:17:45Z",
    "updated_at": "2021-11-05T08:17:45Z",
    "author_association": "NONE",
    "body": "Goldfinch is already doing this. It has issued non-transferable NFT via off-chain verification.\n\nhttps://medium.com/goldfinch-fi/introducing-unique-identity-uid-the-first-nft-for-identity-830a89207509",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/961703245/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/965096253",
    "html_url": "https://github.com/ethereum/EIPs/issues/1238#issuecomment-965096253",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1238",
    "id": 965096253,
    "node_id": "IC_kwDOAq426M45hjM9",
    "user": {
      "login": "vongohren",
      "id": 1012055,
      "node_id": "MDQ6VXNlcjEwMTIwNTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1012055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vongohren",
      "html_url": "https://github.com/vongohren",
      "followers_url": "https://api.github.com/users/vongohren/followers",
      "following_url": "https://api.github.com/users/vongohren/following{/other_user}",
      "gists_url": "https://api.github.com/users/vongohren/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vongohren/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vongohren/subscriptions",
      "organizations_url": "https://api.github.com/users/vongohren/orgs",
      "repos_url": "https://api.github.com/users/vongohren/repos",
      "events_url": "https://api.github.com/users/vongohren/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vongohren/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-10T12:42:38Z",
    "updated_at": "2021-11-10T12:43:04Z",
    "author_association": "NONE",
    "body": "<img width=\"450\" alt=\"Screenshot 2021-11-10 at 13 40 25\" src=\"https://user-images.githubusercontent.com/1012055/141114898-52613f15-bd48-4632-9642-f9c981b11b48.png\"> \r\n\r\n\r\nThis was the feedback on such an ID as goldfinch, from the SSI community, who do identity thourougly and using blockchain in a feasable manner",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/965096253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
