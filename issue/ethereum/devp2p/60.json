{
  "url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
  "repository_url": "https://api.github.com/repos/ethereum/devp2p",
  "labels_url": "https://api.github.com/repos/ethereum/devp2p/issues/60/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/devp2p/issues/60/comments",
  "events_url": "https://api.github.com/repos/ethereum/devp2p/issues/60/events",
  "html_url": "https://github.com/ethereum/devp2p/issues/60",
  "id": 416682005,
  "node_id": "MDU6SXNzdWU0MTY2ODIwMDU=",
  "number": 60,
  "title": "discv5 packet signatures / handshake",
  "user": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/devp2p/milestones/2",
    "html_url": "https://github.com/ethereum/devp2p/milestone/2",
    "labels_url": "https://api.github.com/repos/ethereum/devp2p/milestones/2/labels",
    "id": 4220807,
    "node_id": "MDk6TWlsZXN0b25lNDIyMDgwNw==",
    "number": 2,
    "title": "Discovery v5.1",
    "description": "",
    "creator": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 22,
    "state": "closed",
    "created_at": "2019-04-11T11:36:18Z",
    "updated_at": "2020-10-07T19:09:49Z",
    "due_on": null,
    "closed_at": "2020-10-07T19:09:49Z"
  },
  "comments": 11,
  "created_at": "2019-03-04T08:20:30Z",
  "updated_at": "2019-04-16T10:16:16Z",
  "closed_at": "2019-04-16T10:16:16Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "In discv5, we aim to support multiple cryptosystems for node identity. These are called 'identity schemes' in the ENR EIP. In the v4 wire protocol all packets are signed by the node's secp256k1 identity key. If we can't assume secp256k1 identity anymore, how do we create and verify packet signatures?\r\n\r\nA couple options below, please submit more:\r\n\r\n1. We can leave off the signature most of the time if the ['conversation nonce'](https://github.com/ethereum/devp2p/blob/master/discv5/discv5-wire.md#conversation-nonce) is strong enough. The signature would only be needed on packets that mess with conversation nonce like `ping`, `iAm`, ...\r\n2. Specify something like a 'signature type' and define the verification such that it can be traced back to the node id. For the \"v4\" identity scheme (which is secp256k1/keccak256 as used in v4) this would be `verify(sig, id) -> keccak256(recover(sig)) == id`. It's unclear to me how well this works with ed25519 identities because recovering the public from the signature isn't a commonly exposed operation for this curve. If signature recovery isn't possible (it likely isn't), we'd need to know the sender node id for every packet to even verify the signature, something we could avoid so far. Maybe `whoareyou`/`iAm` packets can help with this.\r\n3. Maybe sender node id and id scheme should be part of the packet header.\r\n4. Defer the whole thing for later and require secp256k1.\r\n\r\n",
  "closed_by": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/60/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/devp2p/issues/60/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469161925",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-469161925",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 469161925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTE2MTkyNQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T08:29:23Z",
    "updated_at": "2019-03-04T08:30:49Z",
    "author_association": "MEMBER",
    "body": "Note that there is the additional requirement to avoid storing session state, i.e. state related to communication with individual nodes as much as possible. I'm trying to avoid establishing a 'session key' in `whoareyou`/`iAm` because we'd need to store it indefinitely or renegotiate all the time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469161925/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469221261",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-469221261",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 469221261,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTIyMTI2MQ==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T11:35:55Z",
    "updated_at": "2019-03-04T11:35:55Z",
    "author_association": "MEMBER",
    "body": "On the above suggestions\r\n1. I think leaving off the signature might allow for eavesdroppers to hijack a conversation. For example if the FindNode / WhoAreYou/ Iam/ Neighbours flow was eavesdropped, then the IAm could be faked.\r\n2. I guess it's healthiest to avoid assumptions that pubkeys will always be recoverable. This means that one way or another the pubkey will need to be known.....\r\n3. …..then yes but only for those message types that initiate a conversation, otherwise after that the conversation nonce can temporarily identify the node.\r\n4. Last resort, IMO\r\n\r\nSo I think because the FindNode, Ping and then the topic discovery requests are the only messages currently able to _start_ a conversation, they can contain the sender pubkey and scheme. If the sender is initially unknown to the recipient, the subsequent WhoAreYou will result in an IAm ENR that will need to be consistent with that initial message.\r\n\r\nI think there will always need to be conversation state in the sense that messages in a conversation will need to be correlated. Eg: (FindNode->), (<-WhoAreYou?), (IAm->),(<-Neighbors) . WhoAreYou as a standalone call to an unknown node returns a large IAm and is therefore an amplification vector, which is why it must be encapsulated in the FindNode / TopicQuery conversation. I think it's also desirable to log 'conversations' as 'things' with their own rules and timeouts, and simple request-reply timeouts represent the same thing. Having said that though, there might be ways of implementing conversation nonce that involve some function of the previous message....\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469221261/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469247755",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-469247755",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 469247755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTI0Nzc1NQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T13:11:32Z",
    "updated_at": "2019-03-04T13:11:32Z",
    "author_association": "MEMBER",
    "body": "It's fine to keep temporary (conversation-scoped) state, just want to avoid a dependency on long-term state we must keep on disk.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469247755/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469265882",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-469265882",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 469265882,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTI2NTg4Mg==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T14:10:45Z",
    "updated_at": "2019-03-04T14:10:45Z",
    "author_association": "MEMBER",
    "body": "Will add a note about this to requirements document when I'm done reformatting it. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469265882/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469289243",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-469289243",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 469289243,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTI4OTI0Mw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T15:16:14Z",
    "updated_at": "2019-03-04T15:16:14Z",
    "author_association": "MEMBER",
    "body": "Sure? I can add a PR for it now. If you are in progress reformatting I will wait though.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/469289243/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/477246008",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-477246008",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 477246008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NzI0NjAwOA==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-27T16:42:39Z",
    "updated_at": "2019-03-27T22:19:30Z",
    "author_association": "MEMBER",
    "body": "After some thinking, here is a proposal for a signature-less scheme using one-time asymmetric encryption. This is vaguely similar to the RLPx handshake but uses simple key-exchange instead of ECDH:\r\n\r\nWhen B wants to send a FINDNODE packet to A, it first checks whether it has secrets for\r\nconversation with A. If secrets are present, the packet uses those for\r\nauthentication/encryption. Otherwise the first packet sent is TALKTOME. In either case A\r\nmay ask for identification using WHOAREYOU.\r\n\r\nA's WHOAREYOU includes a nonce value (`id_nonce`) to be signed by B and the highest known\r\nsequence number of B's record (`enr_seq_b`). B sends back an asymmetrically encrypted\r\nresponse (`auth_reponse`) containing `mac_key`, `enc_key_up`, `enc_key_down` as well as the current version\r\nof its node record if `enr_seq_b` is lower than the current sequence number. `auth_response` is encrypted to one of A's public keys listed in A's ENR.\r\n\r\n```text\r\nA <-- B    TALKTOME [node_id_b]\r\n\r\nA --> B    WHOAREYOU [enr_seq_b, id_nonce]\r\n\r\nA <-- B    FINDNODE [[enc_scheme_name, auth_response, auth], sym_encrypt(enc_key_up, ...)]\r\n   where enc_scheme_name = name of encryption scheme used for auth_response & further comms\r\n         auth_response = encrypt(auth_data)\r\n         auth_data = [id_nonce_sig, mac_key, enc_key_up, enc_key_down, record_of_b]\r\n         id_nonce_sig = signature over id_nonce using identity scheme of record\r\n         record_of_b = current ENR of B or empty list if enr_seq_b is current seq\r\n         mac_key, enc_key_up, enc_key_down = random values\r\n         auth = HMAC(mac_key, packet_hash)\r\n```\r\n\r\nA decrypts `auth_response` and checks `id_nonce_sig` against `node_id_b` using identity\r\nscheme of B's record. It can then authenticate/decrypt the actual packet.\r\n\r\nTALKTOME and WHOAREYOU can be replayed.\r\nReplaying TALKTOME doesn't really buy the attacker anything:\r\n\r\n- WHOAREYOU is very small: amplification attacks are infeasible\r\n- `id_nonce` can't be signed without possession of the node key\r\n\r\nReplaying WHOAREYOU cannot lead to impersonation because the attacker won't be able to\r\ndecrypt the reply, but it can be used for DoS purposes. Maybe some of that risk could be\r\navoided by transmitting another nonce in TALKTOME.\r\n\r\nAll packets following TALKTOME/WHOAREYOU from B to A are mutually authenticated and\r\nencrypted. They can be replay-protected using a simple sequence number.\r\n\r\n```\r\nA --> B    NEIGHBORS [auth, sym_encrypt(enc_key_down, ...)]\r\n   where auth = HMAC(mac_key, packet_hash)\r\n\r\nA <-- B    PING [auth, sym_encrypt(enc_key_up, ...)]\r\n   where auth = HMAC(mac_key, packet_hash)\r\n...\r\n```\r\n\r\nThere are a couple nice things about this idea: \r\n\r\n- We can change encryption/authentication scheme at any time because they are identified\r\n  by name. Support on A's side can be announced through ENR because B has to know A's\r\n  record before attempting communication.\r\n- Initial encryption/authentication scheme can be HMAC + AES-CTR, but we could also go with\r\n  AES-GCM which provides both and is HW-accelerated.\r\n- Obfuscation and all the complexity associated with it is not needed because we can use\r\n  real encryption.\r\n- Either side can rekey at any time by sending WHOAREYOU\r\n  \r\nThere are some downsides to this:\r\n\r\n- Asymmetric encryption is expensive.\r\n- We need to store and recall key material for every packet sent.\r\n- Need to be really careful about `id_nonce` because it shouldn't open up attack vectors\r\n   where any data can be signed with node key.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/477246008/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/477957377",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-477957377",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 477957377,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3Nzk1NzM3Nw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-29T10:59:59Z",
    "updated_at": "2019-03-29T10:59:59Z",
    "author_association": "MEMBER",
    "body": "OK so I spent some time looking at this and right now it's too vague for me to get my head around:\r\n1) TalkToMe advertises IP + node id combination to eavesdroppers or any kind of logger. \r\n2) Still requires obfuscation as it is easy for censors or traffic monitors to look for this unobfuscated packet and then block all subsequent traffic\r\n3) Needs several detailed explanations of differing scenarios. Eg: where is the correlator between TalkToMe and WhoAreYou messages? Is WhoAreYou a mandatory response to TalkToMe or not?\r\n4) I have been under the impression that encryption for Discovery was something we wanted to avoid or make optional, as we've talking about that for literally months now and that was supposedly overkill, hence the entire Obfuscation use case\r\n5) Why not DTLS or encrypted transports if we are going this route\r\n6) I think we can and should explore this further why not, but I am getting increasingly conscious of the fact that solving the original issue is fairly trivial and that time is passing by....., but in its current presentation it seems that what you are proposing is a radically different protocol that needs another round of specification, review and discussion.\r\n\r\nMy response is that I think because you are implementing a prototype of this and refining your spec, let's wait until you have this in a more concrete form and review next week. In the meantime I would consider the original solution of just adding the key/scheme in conversation-starting messages, and then pitch that against your alternative protocol when it's clearer.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/477957377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479476449",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-479476449",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 479476449,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTQ3NjQ0OQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-03T12:54:34Z",
    "updated_at": "2019-04-03T13:17:51Z",
    "author_association": "MEMBER",
    "body": "I have implemented this to confirm that the idea is viable. It works, but several details still need work.\r\nLet me describe what I have and how it influences the spec so far:\r\n\r\nEncoding of TALKTOME:\r\n\r\n    message          = magic || [src-node-id]\r\n    magic            = sha256(\"TALKTOME\" || dest-node-id)\r\n\r\nEncoding of WHOAREYOU:\r\n\r\n    message          = magic || [src-node-id, id-nonce, enr-seq]\r\n    magic            = sha256(\"WHOAREYOU\" || dest-node-id)\r\n\r\nAll other messages:\r\n\r\n    message          = src-node-id || message-auth || message-body\r\n    message-body     = encrypt_aesgcm(write-key, ptype || rlp(message))\r\n    message-auth     = {auth-tag, [auth-tag, auth-scheme-name, auth-response]}\r\n    id-tag           = identifier assigned in handshake\r\n    auth-tag         = AES-GCM nonce\r\n    auth-scheme-name = \"gcm\"\r\n    auth-response    = ecies_encrypt(dest-node-pubkey, [id-nonce-sig, record, read-key, write-key])\r\n    id-nonce-sig     = sign(sha256(\"discovery-id-nonce\" || id-nonce))\r\n\r\nThe handshake works as described above (scenario: B wants to talk to A)\r\n\r\n1. B sends TALKTOME\r\n2. A sends WHOAREYOU including id-nonce challenge\r\n3. B sends its first real message (e.g. FINDNODE) and includes encrypted `auth-response` in the header.\r\n4. A first verifies `auth-response`, then `auth-tag` and then replies to the message if it's valid.\r\n\r\nAbout the spec changes needed: The spec would include the new packets and a longer description of the handshake. The asymmetric encryption scheme is already described in rlpx.md, we could just link it. Info about obfuscation can be removed from the spec. The IAM packet would also be removed.\r\n\r\n------------------------------------------------------------------------------------------------\r\n\r\nAddressing your concerns one by one:\r\n\r\n> TalkToMe advertises IP + node id combination to eavesdroppers or any kind of logger.\r\n\r\nI'm still trying to find a solution, but communication must include the source node ID in order to\r\nbe readable by the recipient. My solution above doesn't address this yet, but I'm aware I need to look into this more.\r\n\r\n> Still requires obfuscation as it is easy for censors or traffic monitors to look for this unobfuscated packet and then block all subsequent traffic.\r\n\r\nThis is resolved now because plaintext packets have a unique prefix per destination node.\r\n\r\n> Needs several detailed explanations of differing scenarios. Eg: where is the correlator between TalkToMe and WhoAreYou messages? Is WhoAreYou a mandatory response to TalkToMe or not?\r\n\r\nYes, in this scheme WHOAREYOU is a mandatory response to TALKTOME. Correlating the two is simple because there cannot be any other communication between the to participants until the handshake is over.\r\n\r\n> I have been under the impression that encryption for Discovery was something we wanted to avoid or make optional, as we've talking about that for literally months now and that was supposedly overkill, hence the entire Obfuscation use case.\r\n\r\nIt depends on how cheap it is. I would certainly prefer standard encryption over a weird custom obfuscation scheme if the encryption is light on resources.\r\n\r\nSince AES-GCM is a lot cheaper than verifying an ECDSA signature, packet authentication using this scheme is more efficient than v4. The asymmetric encryption step is more expensive than signature verification though. This means the remaining question is how quickly we can offset this one time cost.\r\nI will determine this with a benchmark.\r\n\r\n> Why not DTLS or encrypted transports if we are going this route\r\n\r\nIf you take a deeper look at DTLS, you'll find that it is very complicated and not widely used/implemented.\r\n\r\n> I think we can and should explore this further why not, but I am getting increasingly conscious of the fact that solving the original issue is fairly trivial and that time is passing by.....\r\n\r\nI can understand you are getting impatient. It has taken me one week to explore this idea and I think it is worth thinking this scheme through because it solves packet authentication, encryption/obfuscation in a fundamental way, with minimum number of round-trips needed. It also bakes ENR exchange into the protocol in a way that makes sharing your record mandatory if you want to talk to anyone. \r\n\r\n> in its current presentation it seems that what you are proposing is a radically different protocol that needs another round of specification, review and discussion.\r\n\r\nI was never really certain about how the whole WHOAREYOU / IAM flow would work. This scheme is my attempt to define how it can work. (It turns out IAM is not needed)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479476449/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479818172",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-479818172",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 479818172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTgxODE3Mg==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-04T09:15:28Z",
    "updated_at": "2019-04-04T09:15:28Z",
    "author_association": "MEMBER",
    "body": "Maybe the TalkToMe can just be XORd with the destid. If the destination node is trying to evade DPI, then once its own node id is identified at that IP, it is already compromised. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479818172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479827683",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-479827683",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 479827683,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTgyNzY4Mw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-04T09:43:04Z",
    "updated_at": "2019-04-04T09:43:04Z",
    "author_association": "MEMBER",
    "body": "Also, can we please try to still incorporate a byte or something over the encrypted channel describing the conversation? I do think that this might still evolve to allow multiple concurrent communications between nodes and some conversation correlator allows for extensibility.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/479827683/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/480746159",
    "html_url": "https://github.com/ethereum/devp2p/issues/60#issuecomment-480746159",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/60",
    "id": 480746159,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDc0NjE1OQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-08T08:59:14Z",
    "updated_at": "2019-04-08T08:59:14Z",
    "author_association": "MEMBER",
    "body": "Yes, we still need a request/response correlator.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/480746159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
