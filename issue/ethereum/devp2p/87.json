{
  "url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
  "repository_url": "https://api.github.com/repos/ethereum/devp2p",
  "labels_url": "https://api.github.com/repos/ethereum/devp2p/issues/87/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/devp2p/issues/87/comments",
  "events_url": "https://api.github.com/repos/ethereum/devp2p/issues/87/events",
  "html_url": "https://github.com/ethereum/devp2p/issues/87",
  "id": 434419146,
  "node_id": "MDU6SXNzdWU0MzQ0MTkxNDY=",
  "number": 87,
  "title": "Minimal networking requirements for browser environments",
  "user": {
    "login": "dryajov",
    "id": 1094341,
    "node_id": "MDQ6VXNlcjEwOTQzNDE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dryajov",
    "html_url": "https://github.com/dryajov",
    "followers_url": "https://api.github.com/users/dryajov/followers",
    "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
    "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
    "organizations_url": "https://api.github.com/users/dryajov/orgs",
    "repos_url": "https://api.github.com/users/dryajov/repos",
    "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dryajov/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-04-17T18:15:13Z",
  "updated_at": "2020-10-07T20:07:05Z",
  "closed_at": "2020-10-07T19:36:12Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Browsers, have become powerful and full featured runtimes, but due to various security considerations, browsers don't allow direct access to low level networking primitives such as sockets. This restriction makes common operations involving UDP or TCP impossible,for example, programmatic domain name resolution is not possible, as well as NAT techniques involving UDP based interactions, such as hole punching or standard UDP based protocols such as PMP and UpNP. It also restricts listening for direct connections, with the only exception being WebRTC, but even then, a direct connection is not guaranteed.\r\n\r\nNevertheless, this should not prevent browser's direct access to the devp2p protocols such as eth/*, les, pip and possibly others, and should allow non-browser clients to communicate directly with browser clients, such that browser clients are first class citizens in the underlying p2p network.\r\n\r\nIn addition, enabling browser runtimes would lower the bar of entry for other less capable devices, such as IoT. In this regard, this issue isn't constrained to browsers only, but should be used as a good baseline to target other runtimes.\r\n\r\nFor more context please take a look at https://github.com/ethereum/devp2p/issues/71 and in particular to https://github.com/ethereum/devp2p/issues/71#issuecomment-482796738.\r\n\r\nThe high level requirements for such a stack would be:\r\n\r\n- Allow multiple transport protocols. For example, it should be possible to use WS or WebRTC alongside TCP and UDP, to establish communications.\r\n- Allow a single client to communicate over multiple transport channels concurrently. A single client would be able to listen for WS, WebRTC and TCP connections at the same time.\r\n- Enable fallback mechanisms such as relays when a direct connection is not possible.\r\n\r\nSome additional considerations brought up by @FrankSzendzielarz:\r\n\r\n- Drawing the line between minimum protocol requirements on Ethereum implementations and the toolsets (eg libp2p)\r\n- ENRs at the discovery level and how they drive multiaddr\r\n- Discv5 aes-gcm channel re-use for the eth protocol\r\n- Micropayment incentivization and relay-only nodes or implementation wrappers to make standard implementations support multiple transports\r\n\r\n\r\n",
  "closed_by": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/87/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/devp2p/issues/87/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486161337",
    "html_url": "https://github.com/ethereum/devp2p/issues/87#issuecomment-486161337",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
    "id": 486161337,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NjE2MTMzNw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-24T10:11:09Z",
    "updated_at": "2019-04-24T13:36:58Z",
    "author_association": "MEMBER",
    "body": "Was thinking about this today.\r\n\r\nGiven the following....\r\n\r\n- Some types of **light client** want to be able to participate in the discovery protocol (even though it might be suboptimal) and to do so the discovery protocol will need to operate over different transports.\r\n\r\n- There are other **full nodes** under development that operate under unusual network constraints, eg: UDP is blocked, TOR etc.\r\n\r\n- Discv5 also recommends certain [ implementation strategies](https://github.com/ethereum/devp2p/blob/master/discv5/discv5-rationale.md#implementation-recommendations) for mitigating risks around validation of node information. When a Kademlia 'find neighbours' request results in a Neighbours message containing new information, those new ENRs need validation, with the how and when of that validation being a tricky task (see link).\r\n\r\nâ€¦.we need to consider these impacts:\r\n\r\nIf nodes heterogeneously implemented/enabled discovery transports, we'd have a situation where some nodes were unable to validate node information (because the newly discovered peer would be available on an unsupported transport). \r\n\r\nIn order for the node to prevent attacks and protect its own 'reputation' (reputation in quotes because the recommendation in the spec is more about limits on nodeids per IP per learned from source) , the node would have to make sure that it only accepts nodes it can validate. \r\n\r\nHowever, this would lead to network partitioning . Let's say we have TransportX and TransportY (eg: UDP and WebRTC). Some nodes can only communication over TransportX. Some nodes only over TransportY. Some nodes communicate over both. Over time the network would evolve to resemble a Venn diagram, where the smaller number of bridge nodes would be in between.\r\n\r\nThis immediately raises some questions:\r\n\r\n- If the ENR is from a light client, should it be redistributed at all? For light clients, should the light ENR be omitted from the Kad DHT?\r\n- What happens if an intersection node passes an ENR containing id information for TransportX and Y to a node that only supports TransportY, for example? Does the recipient declare that the endpoint information cannot be validated for TransportX and reject the ENR? In this case, the subnetworks cannot be bridged. \r\n- If the recipient validates TransportX , cannot validate TransportY, but then redistributes the ENR back to a TransportY node, it is itself potentially involved in an attack where TransportX credibility is used to fake TransportY nodes to DoS a TransportY victim.\r\n- How does an intersection node carry out a lookup from a TransportY node? The incoming FindNode would need to to filter results to only return neighbours with TransportY ability, which could lead to lookup process stalling if the numbers are insufficient. In effect, we would have multiple parallel DHTs, but with the k-bucket sizes being restricted to single k. _It would be more appropriate perhaps to treat each transport as its own Kademlia network, and nodes would need to maintain a per-transport DHT._\r\n\r\n**_So, it begins to look like that if heterogenous transports are implemented, there should probably be per transport DHTs, with ENRs being transport/DHT-specific.  (By DHT I mean a Kademlia system instance or routing table)_**\r\n\r\n_In that case though, implementations that support multiple transports would need to populate multiple DHTs. Assuming a common discovery protocol, a mechanism for doing would be an optimal re-use of keys/handshake established over one transport, with a FindNeigbours request over a common (eg: UDP) transport resulting in Neighbours responses for multiple DHTs. i.e  A total of 2k neighbours received over UDP, with k being for UDP and k for WebRTC, for example. This approach would perhaps be an added benefit compared to parallel bootstrapping as it would allow WebRTC nodes to be discovered indirectly via the UDP network_\r\n\r\nThe alternative to all the above would be to guarantee that implementations agree to maintain a commonly available set of transports. \r\n\r\nThoughts?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486161337/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486335659",
    "html_url": "https://github.com/ethereum/devp2p/issues/87#issuecomment-486335659",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
    "id": 486335659,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NjMzNTY1OQ==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-24T17:06:30Z",
    "updated_at": "2019-04-24T17:06:30Z",
    "author_association": "NONE",
    "body": "> If nodes heterogeneously implemented/enabled discovery transports, we'd have a situation where some nodes were unable to validate node information (because the newly discovered peer would be available on an unsupported transport).\r\n\r\n> However, this would lead to network partitioning . Let's say we have TransportX and TransportY (eg: UDP and WebRTC). Some nodes can only communication over TransportX. Some nodes only over TransportY. Some nodes communicate over both. Over time the network would evolve to resemble a Venn diagram, where the smaller number of bridge nodes would be in between.\r\n\r\nThis are valid concerns and can be mitigated with something like circuit-relaying (https://github.com/libp2p/specs/blob/master/relay/README.md), this was the main requirement for libp2p when originally implemented. \r\n\r\nAs a separate questions (I'll create the issue, but want to bring up in this context as well), are there any real numbers/metrics on the current state of the network? Something that allows us to visualize its current state - detect partitions, number of unreachable peers (ie NATs), average response times, etc? I would say this is extremely valuable data that should be factored in the overall discv5 design.\r\n\r\n> This immediately raises some questions:\r\n> ...\r\n\r\nI'll try to elaborate on circuit relaying a bit here. \r\n\r\nThe relay is simply a node that relays traffic for other peers. This mitigates the issue of incompatible transports and also allows to further aid in negotiating a better channel overall. For example, if the ENR record for peer B only advertised TransportX, when peer A on TransportY tries to connect to it, it would fallback to a relayed connection, but if peer B _now_ happens to be able to speak TransportY as well, they can both upgrade the channel and establish a direct connection. \r\n\r\nThis is even more pervasive with NATed connections, when a peer might advertise erroneous address because of multiple levels of NATs. In this case other peers would fail dialing it, a relay could provide a temporary fallback channel, where a dedicated channel is negotiated. This is the intent behind the proposed dial-me protocol (https://github.com/libp2p/specs/pull/64).\r\n\r\nI want to emphasize that a relay does not have to be a centralized service, in the libp2p stack any peer can be a relay.\r\n\r\n> So, it begins to look like that if heterogenous transports are implemented, there should probably be per transport DHTs, with ENRs being transport/DHT-specific. (By DHT I mean a Kademlia system instance or routing table)\r\n\r\nI want to emphasize that this problem is not limited to different transports, this is a problem that will exist no matter how heterogeneous the transports are, simply because clients and in particular clients that run on consumer hardware are going to be exposed to widely different network topologies, and in this context the only viable solution is relays. \r\n\r\nAlso, transport locking IMHO, is not very different from the arguments I've heard with regards to storage, where one of the main requirements is to keep the client consumer hardware friendly as to avoid lockout and centralization issues. In this context, network is not much different.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486335659/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486425270",
    "html_url": "https://github.com/ethereum/devp2p/issues/87#issuecomment-486425270",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
    "id": 486425270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NjQyNTI3MA==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-24T21:04:00Z",
    "updated_at": "2019-04-24T21:04:00Z",
    "author_association": "NONE",
    "body": "> In that case though, implementations that support multiple transports would need to populate multiple DHTs. Assuming a common discovery protocol, a mechanism for doing would be an optimal re-use of keys/handshake established over one transport, with a FindNeigbours request over a common (eg: UDP) transport resulting in Neighbours responses for multiple DHTs. i.e A total of 2k neighbours received over UDP, with k being for UDP and k for WebRTC, for example. This approach would perhaps be an added benefit compared to parallel bootstrapping as it would allow WebRTC nodes to be discovered indirectly via the UDP network\r\n\r\nI'm not too keen on the idea of multiple DHTs, this would for sure lead to de-facto network fragmentation, IMO. \r\n\r\nWhat I would propose is that each layer of the stack, discovery included, is agnostic of the other, and discovery, DHT specifically runs on top of any existing channel. This is possible with a properly multiplexed connection.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/486425270/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705150446",
    "html_url": "https://github.com/ethereum/devp2p/issues/87#issuecomment-705150446",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
    "id": 705150446,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNTE1MDQ0Ng==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-07T19:36:06Z",
    "updated_at": "2020-10-07T19:36:06Z",
    "author_association": "MEMBER",
    "body": "I'm not sure what this issue is really about because there are so many suggestions about potential directions. It would be nice to have a solution for browser access to LES for example, but this issue goes way beyond that and proposes that every protocol we define should somehow be accessible\r\nfrom the browser. We won't have that, and this is why I'm closing this issue now. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705150446/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705165439",
    "html_url": "https://github.com/ethereum/devp2p/issues/87#issuecomment-705165439",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/87",
    "id": 705165439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNTE2NTQzOQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-07T20:07:05Z",
    "updated_at": "2020-10-07T20:07:05Z",
    "author_association": "MEMBER",
    "body": "See #166 for a narrower issue which is specifically about LES in the browser.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705165439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
