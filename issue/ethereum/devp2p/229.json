{
  "url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
  "repository_url": "https://api.github.com/repos/ethereum/devp2p",
  "labels_url": "https://api.github.com/repos/ethereum/devp2p/issues/229/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/devp2p/issues/229/comments",
  "events_url": "https://api.github.com/repos/ethereum/devp2p/issues/229/events",
  "html_url": "https://github.com/ethereum/devp2p/issues/229",
  "id": 1650259064,
  "node_id": "I_kwDOAcJRYs5iXPR4",
  "number": 229,
  "title": "discv5: sub-protocol data transmission",
  "user": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 12,
  "created_at": "2023-04-01T02:53:56Z",
  "updated_at": "2023-05-15T09:33:03Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This is a proposal for a discv5 protocol extension that supports transferring\r\narbitrary sub-protocol data over an encrypted connection.\r\n\r\n### Motivation\r\n\r\nThe motivation for this protocol is putting Portal Network's uTP connections on a\r\nmore solid foundation. At this time, [uTP transfers in the Portal Network](https://github.com/ethereum/portal-network-specs/blob/master/discv5-utp.md) use\r\ndiscv5 TALKREQ messages as a uTP packet enclosure. There are some downsides to that.\r\n\r\n- The discv5 packet frame + TALKREQ message add overhead of ~90 bytes per packet, and\r\n  processing of message packets is relatively expensive. The discv5 wire protocol is\r\n  not designed for high-throughput data transfer connections. It is designed to\r\n  efficiently perform short request/response exchanges with many different nodes. It\r\n  is for this reason that every message packet sent must carry enough information to\r\n  start a handshake.\r\n\r\n- TALKREQ is a request message and requires a response. discv5 messaging and the\r\n  handshake are based on the assumption that every request message triggers at least\r\n  one response. TALKREQ is defined to have exactly one TALKRESP response, and for\r\n  good reason: talk exchanges are intended as an upgrade path into another wire\r\n  protocol (like the [HTTP/1.1 Upgrade header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism) and there is no guarantee on the\r\n  ordering of responses. Allowing multiple responses [is being discussed](https://github.com/ethereum/devp2p/issues/192), but\r\n  would create additional complexity in implementation APIs. If no TALKRESP response\r\n  is observed, it is undecidable whether the recipient of TALKREQ has failed to\r\n  receive the request, has decided not to respond, or the response got lost. Leaving\r\n  out the response also breaks security assumptions in the handshake if TALKREQ is\r\n  the initial message in a discv5 session (key confirmation does not occur).\r\n\r\n### Proposal\r\n\r\n#### Session Table\r\n\r\nImplementations should keep a *sub-protocol session table*, containing session\r\nrecords. Sessions are identified by the IP address of the remote node and the\r\n`ingress-id` value. Inactive sessions are removed from the table as\r\nthey time out. Suitable session timeouts depend on the sub-protocol.\r\n\r\nA session record contains:\r\n\r\n- `ip`, the IP address of the remote node\r\n- `ingress-id`, used to locate the session\r\n- `ingress-key`, used for decrypting received packets\r\n- `egress-id`, used as the session ID value in sent packets\r\n- `egress-key` and `nonce-counter`, used for encrypting sent packets\r\n- the sub-protocol that initiated the session\r\n\r\n#### Establishing a Session\r\n\r\nIt is expected that sessions will be established through an existing encrypted and\r\nauthenticated channel, such as discv5 TALKREQ/TALKRESP. **There is no in-band way to\r\ncreate a session.**\r\n\r\nWe assume that the implementation provides a procedure `newsession` which derives\r\nkeys and creates a new entry in the table. Keys and ID values are created as follows.\r\n\r\n    newsession(initiator-secret, recipient-secret, protocol-name)\r\n        initiator-secret :: bytes16\r\n        recipient-secret :: bytes16\r\n        protocol-name :: bytes\r\n\r\n        ikm    = initiator-secret || recipient-secret\r\n        salt   = \"\"\r\n        info   = \"discv5 sub-protocol session\" || protocol-name\r\n        length = 48\r\n        kdata  = HKDF(salt, ikm, info, length)\r\n\r\n        initiator-key = kdata[0:16]\r\n        recipient-key = kdata[16:32]\r\n        initiator-id = kdata[32:40]\r\n        recipient-id = kdata[40:48]\r\n\r\n        When called on the initiator side:\r\n          egress-id, egress-key = recipient-id, recipient-key\r\n          ingress-id, ingress-key = initiator-id, initiator-key\r\n\r\n        When called on the recipient side:\r\n          egress-id, egress-key = initiator-id, initiator-key\r\n          ingress-id, ingress-key = recipient-id, recipient-key\r\n\r\nIn order to establish a sub-protocol session, the initiator creates its\r\n`initiator-secret` using a secure random number generator. It sends an appropriate\r\nTALKREQ message containing `initiator-secret` and any other information necessary for\r\nrequesting a sub-protocol connection.\r\n\r\nIf the recipient agrees with the creation of the connection, it generates the\r\n`recipient-secret` and calls `newsession()` to create a session. It then sends an\r\naffirmative TALKRESP message containing the `recipient-key`, and possibly other\r\nsub-protocol specific data.\r\n\r\nWhen the initiator receives TALKRESP containing the `recipient-secret`, it also calls\r\n`newsession()` to create and store the session. At this point the session is established\r\npackets can be sent in both directions.\r\n\r\nNote that the first sub-protocol packet must be sent by the session initiator, since\r\nthe session recipient doesn't know if and when the TALKRESP message will arrive. This\r\nlimitation can be inconvenient for sub-protocols using a request/response scheme\r\nwhere data is to be served by the session recipient immediately after establishment.\r\nThe first sub-protocol packet can have an empty payload in this case, but it really\r\nmust be sent to confirm validity of the session.\r\n\r\nThe listing below shows an example packet exchange where node `A` is the initiator\r\nand node `B` is the recipient.\r\n\r\n    A -> B  TALKREQ (... initiator-secret ...)\r\n    A <- B  TALKRESP (... recipient-secret ...)\r\n    A -> B  sub-protocol packet\r\n    A <- B  sub-protocol packet\r\n    A <- B  sub-protocol packet\r\n    ...\r\n\r\n#### Packets\r\n\r\nSub-protocol packets have a simple structure with total overhead of 36 bytes,\r\nincluding the GCM tag (which is a part of `ciphertext`).\r\n\r\n    packet = session-id || nonce || ciphertext\r\n      session-id :: uint64\r\n      nonce      :: uint96\r\n      ciphertext :: bytes\r\n\r\nTo send a sub-protocol packet for an existing session, the `session-id` of the packet\r\nis assigned from the `egress-id` of the session. `nonce` is selected by incrementing\r\nthe session's `nonce-counter` value. It is recommended to also fill a part of the\r\n`nonce` using a secure random number generator. Now the ciphertext is created:\r\n\r\n    ciphertext = aesgcm_encrypt(egress-key, nonce, payload, egress-id)\r\n\r\nWhen the node receives a UDP packet, it first checks that the packet data has a\r\nlength of at least 20 bytes. It then performs a lookup into the *sub-protocol session\r\ntable* by interpreting the first 8 bytes of the packets as a `session-id`. This value\r\nis used to look for an active session with a matching `ingress-id` and IP address\r\nvalue.\r\n\r\nIf there is no matching session, the packet is considered off-protocol and is\r\nsubmitted for processing as a regular discv5 packet.\r\n\r\nIf a session exists, the node performs AES/GCM decryption/authentication. Packets\r\nfailing this step are discarded. If authentication succeeds, the session's idle timer\r\nis extended and the decrypted plaintext is dispatched to the sub-protocol\r\nimplementation.\r\n\r\n#### Security Considerations\r\n\r\nThis section explores some of the design choices from a security point-of-view.\r\n\r\n- The key agreement scheme assumes an existing encrypted and authenticated\r\n  communication channel. As such, key material is passed directly between\r\n  participants. Any breach of session keys for this channel is also a breach of\r\n  sub-protocol session keys.\r\n\r\n- Both parties contribute key material used for session identifiers and keys. This is\r\n  done to ensure that plain-text packet data cannot be predetermined or assigned with\r\n  malicious intent by the initiator or recipient. It's also convenient because only a\r\n  single value needs to be communicated across during session establishment.\r\n\r\n- Sessions can be created with little overhead. Implementations should place limits\r\n  on the number of concurrent sessions that can be created. It is good practice to\r\n  have a limit on the total number of active sessions, because an attacker could use\r\n  a large number of nodes to work around address-based limits.\r\n\r\n- Since `session-id` values are transmitted plain-text, an observer in a privileged\r\n  network position will be able to determine which packets belong to a single session.\r\n\r\n- The protocol does not provide any ordering or transfer reliability guarantees.\r\n  Sub-protocols are expected to provide such guarantees if needed.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/229/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/devp2p/issues/229/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1493075377",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1493075377",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1493075377,
    "node_id": "IC_kwDOAcJRYs5Y_oWx",
    "user": {
      "login": "pipermerriam",
      "id": 824194,
      "node_id": "MDQ6VXNlcjgyNDE5NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/824194?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pipermerriam",
      "html_url": "https://github.com/pipermerriam",
      "followers_url": "https://api.github.com/users/pipermerriam/followers",
      "following_url": "https://api.github.com/users/pipermerriam/following{/other_user}",
      "gists_url": "https://api.github.com/users/pipermerriam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pipermerriam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pipermerriam/subscriptions",
      "organizations_url": "https://api.github.com/users/pipermerriam/orgs",
      "repos_url": "https://api.github.com/users/pipermerriam/repos",
      "events_url": "https://api.github.com/users/pipermerriam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pipermerriam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-01T18:56:40Z",
    "updated_at": "2023-04-01T18:56:40Z",
    "author_association": "MEMBER",
    "body": "Rough/loose internal plan from portal network side is to do a POC implementation of UTP on top of this protocol change so that we can get some hands-on experience with the ergonomics.\r\n\r\nThe only \"concern\" that I have is the plain-text `session-id` and the possibility of network level packet filtering, however, such filtering would only end up applying to a single session and its likely that we would do something like use a new session for each UTP stream... so I'm not really sure that it would even be very effective/feasible for someone to try and do this kind of filtering.  Do you have any additional thoughts here?  I assume that the overhead of making the packets fully opaque adds unwanted overhead to the packet and maybe was deemed un-justified given the limited effectiveness of this kind of filtering (since establishing a new session is reasonably trivial...).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1493075377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1493095565",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1493095565",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1493095565,
    "node_id": "IC_kwDOAcJRYs5Y_tSN",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-01T20:02:12Z",
    "updated_at": "2023-04-01T20:47:00Z",
    "author_association": "MEMBER",
    "body": "Nice that you are considering to implement it! I personally haven't tried to implement it yet...\r\n\r\nI think it's not possible to apply filtering to this protocol, for a single session or at all, because:\r\n\r\n- Session IDs used by the are random numbers that can't be guessed ahead of time.\r\n- Session/stream tagging is very common in all kinds of protocols. It's not like we're the only protocol that sends UDP packets where the first field is a number identifying the data stream.\r\n- Everything else in the packet is random data. We have a dedicated obfuscation mechanism in discv5 because the packet frame has multiple identifying features, i.e. specific byte offsets that will always have the same value in every packet, but that's not the case for this protocol.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1493095565/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499031737",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1499031737",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1499031737,
    "node_id": "IC_kwDOAcJRYs5ZWWi5",
    "user": {
      "login": "emhane",
      "id": 58548332,
      "node_id": "MDQ6VXNlcjU4NTQ4MzMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/58548332?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emhane",
      "html_url": "https://github.com/emhane",
      "followers_url": "https://api.github.com/users/emhane/followers",
      "following_url": "https://api.github.com/users/emhane/following{/other_user}",
      "gists_url": "https://api.github.com/users/emhane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emhane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emhane/subscriptions",
      "organizations_url": "https://api.github.com/users/emhane/orgs",
      "repos_url": "https://api.github.com/users/emhane/repos",
      "events_url": "https://api.github.com/users/emhane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emhane/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-06T13:02:30Z",
    "updated_at": "2023-04-06T13:02:30Z",
    "author_association": "MEMBER",
    "body": "Why divide up the receiving and sending with two encryption keys? It doesn't clearly state here where the sub-protocol session management should be done. I think it should be done by the app running discv5 and packets should be passed directly through to the app as the tuple (src-addr, encrypted-packet), and down to the discv5 socket as (dst-addr, encrypted-packet). This means that encryption is a black box to discv5 and the app can tell discv5 to blacklist certain malicious peers if it so wishes based on failure to match a session or whatnot. What I think belongs to discv5 protocol of this is\r\n- the packet decoding and encoding at socket level as (connection-id, nonce, encrypted-data), to enforce mechanisms to circumvent packet filtering so discv5 can guarantee delivery of packets to the app,\r\n- key sharing via TALKREQ responded with TALKRESP. A TALKREQ is always answered with TALKRESP as not to disturb original discv5 flow. After that what goes inside should be a black box to discv5 and up to the app based on how it wishes to encrypt its sessions. It could be as simple as TALKREQ { let's use this key(s) } and TALKRESP { roger }.\r\n\r\nHow to do session management I think serves as a suggestion but doesn't belong in the discv5 protocol.\r\n\r\n I started implementing this in rust here: https://github.com/emhane/discv5/tree/tunnel-discv5.2 and here https://github.com/emhane/tunnel",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499031737/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499517748",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1499517748",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1499517748,
    "node_id": "IC_kwDOAcJRYs5ZYNM0",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-06T19:27:45Z",
    "updated_at": "2023-04-06T21:14:48Z",
    "author_association": "MEMBER",
    "body": "Just to clarify: the proposal is not intended to be a part of the discv5 wire protocol spec. It is just intended to show how sub-protocol sessions/multiplexing can be done at all, because doing this safely isn't entirely trivial.\r\n\r\nThe extent of discv5 integration here is: discv5 is the transport for session establishment, and both protocols can run on the same port.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499517748/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499637712",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1499637712",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1499637712,
    "node_id": "IC_kwDOAcJRYs5ZYqfQ",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-06T21:12:59Z",
    "updated_at": "2023-04-06T21:17:24Z",
    "author_association": "MEMBER",
    "body": "> Why divide up the receiving and sending with two encryption keys?\r\n\r\nIt is a common practice to do that. Having a separate write key on each side avoids issues where the nonce could be reused, among other things. TLS does this too. You can read more about it in [this StackExchange answer](https://crypto.stackexchange.com/questions/2878/separate-read-and-write-keys-in-tls-key-material). The discv5 wire protocol also uses a separate write key for each side.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1499637712/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1509041835",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1509041835",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1509041835,
    "node_id": "IC_kwDOAcJRYs5Z8iar",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-14T18:10:15Z",
    "updated_at": "2023-04-14T18:10:15Z",
    "author_association": "MEMBER",
    "body": "I have created a working prototype implementation over at https://github.com/fjl/discv5-streams/tree/main/session.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1509041835/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1546951477",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1546951477",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1546951477,
    "node_id": "IC_kwDOAcJRYs5cNJs1",
    "user": {
      "login": "emhane",
      "id": 58548332,
      "node_id": "MDQ6VXNlcjU4NTQ4MzMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/58548332?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emhane",
      "html_url": "https://github.com/emhane",
      "followers_url": "https://api.github.com/users/emhane/followers",
      "following_url": "https://api.github.com/users/emhane/following{/other_user}",
      "gists_url": "https://api.github.com/users/emhane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emhane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emhane/subscriptions",
      "organizations_url": "https://api.github.com/users/emhane/orgs",
      "repos_url": "https://api.github.com/users/emhane/repos",
      "events_url": "https://api.github.com/users/emhane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emhane/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-14T17:17:58Z",
    "updated_at": "2023-05-14T17:18:19Z",
    "author_association": "MEMBER",
    "body": "I've been implementing this crypto so rust and go can interface. Under heading **Packets**, it's 22 bytes right? the tag is u16?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1546951477/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547021786",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1547021786",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1547021786,
    "node_id": "IC_kwDOAcJRYs5cNa3a",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-14T23:04:58Z",
    "updated_at": "2023-05-14T23:07:41Z",
    "author_association": "MEMBER",
    "body": "GCM tag size used in the Go code is 16 bytes (i.e. u128).\r\n\r\nThe packet header is 20 bytes (8 bytes `session-id`, 12 bytes `nonce`). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547021786/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547022493",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1547022493",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1547022493,
    "node_id": "IC_kwDOAcJRYs5cNbCd",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-14T23:08:14Z",
    "updated_at": "2023-05-14T23:08:45Z",
    "author_association": "MEMBER",
    "body": "We could go with a smaller `session-id`. 4 bytes is probably sufficient. But let's try interop with ID size 8 bytes for now.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547022493/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547190022",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1547190022",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1547190022,
    "node_id": "IC_kwDOAcJRYs5cOD8G",
    "user": {
      "login": "emhane",
      "id": 58548332,
      "node_id": "MDQ6VXNlcjU4NTQ4MzMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/58548332?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emhane",
      "html_url": "https://github.com/emhane",
      "followers_url": "https://api.github.com/users/emhane/followers",
      "following_url": "https://api.github.com/users/emhane/following{/other_user}",
      "gists_url": "https://api.github.com/users/emhane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emhane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emhane/subscriptions",
      "organizations_url": "https://api.github.com/users/emhane/orgs",
      "repos_url": "https://api.github.com/users/emhane/repos",
      "events_url": "https://api.github.com/users/emhane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emhane/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-15T04:57:29Z",
    "updated_at": "2023-05-15T04:57:29Z",
    "author_association": "MEMBER",
    "body": "> GCM tag size used in the Go code is 16 bytes (i.e. u128).\r\n> \r\n> The packet header is 20 bytes (8 bytes `session-id`, 12 bytes `nonce`).\r\n\r\nin rust too it's 16 bytes, my bad, got confused at the end yesterday with the aes-gcm crate's own type for unsigned ints. nice, yeah let's interop with 8 bytes id.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547190022/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547331762",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1547331762",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1547331762,
    "node_id": "IC_kwDOAcJRYs5cOmiy",
    "user": {
      "login": "emhane",
      "id": 58548332,
      "node_id": "MDQ6VXNlcjU4NTQ4MzMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/58548332?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emhane",
      "html_url": "https://github.com/emhane",
      "followers_url": "https://api.github.com/users/emhane/followers",
      "following_url": "https://api.github.com/users/emhane/following{/other_user}",
      "gists_url": "https://api.github.com/users/emhane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emhane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emhane/subscriptions",
      "organizations_url": "https://api.github.com/users/emhane/orgs",
      "repos_url": "https://api.github.com/users/emhane/repos",
      "events_url": "https://api.github.com/users/emhane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emhane/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-15T07:30:52Z",
    "updated_at": "2023-05-15T07:30:52Z",
    "author_association": "MEMBER",
    "body": "[utp accounts for the unordered arrival of udp packets](https://github.com/jacobkaufmann/utp/blob/a2f61be75727c8880b36054c1f762d5ceded6bc2/src/recv.rs#L69-L97) and we can make utp transmit an event to a session manager when a `seq_num` [has already been seen](https://github.com/jacobkaufmann/utp/blob/a2f61be75727c8880b36054c1f762d5ceded6bc2/src/recv.rs#LL50C15-L50C15) so the session is failed, I'm expecting the code looks somewhat similar in go. so the nonce counter is purely to make sure that the packet is unique so the cipher can't be broken with analysis, correct?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547331762/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547511476",
    "html_url": "https://github.com/ethereum/devp2p/issues/229#issuecomment-1547511476",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/229",
    "id": 1547511476,
    "node_id": "IC_kwDOAcJRYs5cPSa0",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-15T09:33:03Z",
    "updated_at": "2023-05-15T09:33:03Z",
    "author_association": "MEMBER",
    "body": "Yes, the nonce of the outer packet frame is for encryption/authentication purposes only. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/1547511476/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
