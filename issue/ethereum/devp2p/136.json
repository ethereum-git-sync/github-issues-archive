{
  "url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
  "repository_url": "https://api.github.com/repos/ethereum/devp2p",
  "labels_url": "https://api.github.com/repos/ethereum/devp2p/issues/136/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/devp2p/issues/136/comments",
  "events_url": "https://api.github.com/repos/ethereum/devp2p/issues/136/events",
  "html_url": "https://github.com/ethereum/devp2p/issues/136",
  "id": 551417901,
  "node_id": "MDU6SXNzdWU1NTE0MTc5MDE=",
  "number": 136,
  "title": "discv5: topic index design thread",
  "user": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/devp2p/milestones/3",
    "html_url": "https://github.com/ethereum/devp2p/milestone/3",
    "labels_url": "https://api.github.com/repos/ethereum/devp2p/milestones/3/labels",
    "id": 5938443,
    "node_id": "MDk6TWlsZXN0b25lNTkzODQ0Mw==",
    "number": 3,
    "title": "Discovery v5.2",
    "description": null,
    "creator": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 6,
    "closed_issues": 0,
    "state": "open",
    "created_at": "2020-10-01T12:45:21Z",
    "updated_at": "2020-10-07T19:12:22Z",
    "due_on": null,
    "closed_at": null
  },
  "comments": 9,
  "created_at": "2020-01-17T13:33:13Z",
  "updated_at": "2020-10-01T12:45:51Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "In order to register a node for a certain topic, it must place ads for itself on other nodes. In the current version of the spec, the process of registering with a single node is very well described, but distributing ads among registrar nodes is still unsolved.\r\n\r\nThere are two sub-problems here: (1) is HOW MANY ads a single node should place, (2) is WHERE they should be placed. \r\n\r\nFor (1), what we need is an algorithm that places ads such that the node can be 'found enough', where the notion of 'enough' is application-specific. \r\n\r\nIntuitively, if every registrant node was targeting a fixed number of live ads, the odds of finding any particular node would be the same and the system would stay balanced. Unfortunately, this can be gamed too easily by simply registering on more nodes than everyone else.\r\n\r\nOur current best guess for doing this better is to compute the notion of 'found enough' based on\r\npeer activity outside of the discovery protocol.  We can assume that every participant is able decide whether the current amount of incoming useful peer connections is too high or too low. If the incoming peer connection rate is too low, we can simply increase the number of live ads we target. This can still be gamed, but ensures that nodes will correct for imbalances automatically. The remaining issue here is to find out how this measurement can be implemented in practice. If an application uses multiple topics, it might not be possible to attribute incoming connections to a particular topic, for example. \r\n\r\nFor problem (2), which is where ads should be placed, we want the algorithm to pick registrars such that the set of considered registrar nodes shrinks and grows according to some estimation of topic size, i.e. popular topics provided by many participants should use a larger subset of the whole network to store ads. \r\n\r\nTo do this, we decided early on that ad distribution should use Kademlia distance to determine a subset of all nodes, the size of which we called the 'topic radius'. The radius was to be estimated by checking ticket waiting times, but then we found multiple issues (#111, #112) and concluded that using the waiting time is a dead end because it can vary for reasons other than topic popularity.\r\n\r\nInstead, it seems that the number of nodes in the topic queue of each registrar is a better indicator. If registrants could obtain this number in some way, they could walk the network for a while to find registrars which have space available and fill it. How exactly this should happen, and whether this approach will converge on a good distribution ads is still an open question.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/136/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/devp2p/issues/136/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/576602870",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-576602870",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 576602870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NjYwMjg3MA==",
    "user": {
      "login": "jannikluhn",
      "id": 29854669,
      "node_id": "MDQ6VXNlcjI5ODU0NjY5",
      "avatar_url": "https://avatars.githubusercontent.com/u/29854669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jannikluhn",
      "html_url": "https://github.com/jannikluhn",
      "followers_url": "https://api.github.com/users/jannikluhn/followers",
      "following_url": "https://api.github.com/users/jannikluhn/following{/other_user}",
      "gists_url": "https://api.github.com/users/jannikluhn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jannikluhn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jannikluhn/subscriptions",
      "organizations_url": "https://api.github.com/users/jannikluhn/orgs",
      "repos_url": "https://api.github.com/users/jannikluhn/repos",
      "events_url": "https://api.github.com/users/jannikluhn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jannikluhn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-21T09:52:07Z",
    "updated_at": "2020-01-21T09:52:07Z",
    "author_association": "MEMBER",
    "body": "> Our current best guess for doing this better is to compute the notion of 'found enough' based on peer activity outside of the discovery protocol.\r\n\r\nThis seems very hard to implement in practice. I guess it's possible to notice if peer activity drops significantly over time, but I don't see how one could come up with an absolute estimate, especially for new and small topics.\r\n\r\nIf the goal is for all network participants to place roughly the same amount of ads, can we simply try to sample this number directly? Pick some random nodes and ask around for ads placed by these nodes. And then place the same amount.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/576602870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/582323120",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-582323120",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 582323120,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4MjMyMzEyMA==",
    "user": {
      "login": "harnen",
      "id": 7314908,
      "node_id": "MDQ6VXNlcjczMTQ5MDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7314908?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/harnen",
      "html_url": "https://github.com/harnen",
      "followers_url": "https://api.github.com/users/harnen/followers",
      "following_url": "https://api.github.com/users/harnen/following{/other_user}",
      "gists_url": "https://api.github.com/users/harnen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/harnen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/harnen/subscriptions",
      "organizations_url": "https://api.github.com/users/harnen/orgs",
      "repos_url": "https://api.github.com/users/harnen/repos",
      "events_url": "https://api.github.com/users/harnen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/harnen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-05T09:42:44Z",
    "updated_at": "2020-02-05T09:42:44Z",
    "author_association": "NONE",
    "body": "Wouldn't it be simpler if the registrant tried to register on every node (without any radius estimation) during its random walk towards `H(t)` and let the nodes on the path decide whether to accept it or not? \r\n\r\nThe decision could be taken based on the node's distance from  `H(t)` (the closer, the higher chance of accepting) and the current number of registration among all the topics (the more registrations, the lower chance of accepting). It would create a balanced system where, if there are not many registrations in the system, nodes would accept any registration, but when the traffic is increasing, each node would start to specialize in topics close to its own ID. \r\n\r\nIf the registrant finds that it doesn't have incoming connection, it can repeat the process using alternative paths (or repeat on the same one if the registration decision is made nondeterministic). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/582323120/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583120993",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-583120993",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 583120993,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4MzEyMDk5Mw==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-06T21:32:11Z",
    "updated_at": "2020-02-06T21:32:11Z",
    "author_association": "MEMBER",
    "body": "@harnen This is a very nice idea to try. I'll try to implement this next week to see if there is any downside to that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583120993/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583890195",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-583890195",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 583890195,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4Mzg5MDE5NQ==",
    "user": {
      "login": "yiannisbot",
      "id": 52073247,
      "node_id": "MDQ6VXNlcjUyMDczMjQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/52073247?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiannisbot",
      "html_url": "https://github.com/yiannisbot",
      "followers_url": "https://api.github.com/users/yiannisbot/followers",
      "following_url": "https://api.github.com/users/yiannisbot/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiannisbot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiannisbot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiannisbot/subscriptions",
      "organizations_url": "https://api.github.com/users/yiannisbot/orgs",
      "repos_url": "https://api.github.com/users/yiannisbot/repos",
      "events_url": "https://api.github.com/users/yiannisbot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiannisbot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-09T20:35:55Z",
    "updated_at": "2020-02-09T20:35:55Z",
    "author_association": "NONE",
    "body": "The first issue of HOW MANY ads a single node should place sounds to me a bit contradictory to the fact that nodes can advertise any number of topics. Am I missing something here @fjl. \r\n\r\nAssuming that at some point nodes will get overloaded, it might make sense for this to be capped somehow. If there is a cap, then how about a [max-min fair](https://en.wikipedia.org/wiki/Max-min_fairness) approach to the number of nodes a topic should be advertised to. According to max-min fairness popular topics will be advertised more, but will not starve un-popular topics. Popularity (or any other metric used) can be obtained by the peer activity outside the discovery protocol, as mentioned earlier in this discussion by @fjl. \r\n\r\nImplementing this might be a bit less straightforward, as there will need to be common knowledge of: i) the network size (number of nodes), ii) the number of topics that exist at any given moment, and iii) the popularity (in terms of demand for advertising space) of every topic. Each node can then run the max-min fair algorithm locally, determine its allowance in terms of the number of nodes where it can advertise and then run @harnenâ€™s (or any other) algorithm to place them. The system will also adjust automatically as the three parameters above change. I suspect that even rough estimates of the network size, number of topics and topic popularity should be ok.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583890195/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583892233",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-583892233",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 583892233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4Mzg5MjIzMw==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-09T20:56:00Z",
    "updated_at": "2020-02-09T20:58:06Z",
    "author_association": "MEMBER",
    "body": "> The first issue of HOW MANY ads a single node should place sounds to me a bit contradictory to the fact that nodes can advertise any number of topics. Am I missing something here @fjl.\r\n\r\nWhat I meant is 'how many ads per topic'. The way we've been thinking about the registration process here is always per-topic. Nodes would basically run the same process for every topic individually.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583892233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583892557",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-583892557",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 583892557,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4Mzg5MjU1Nw==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-09T20:59:09Z",
    "updated_at": "2020-02-09T20:59:09Z",
    "author_association": "MEMBER",
    "body": "> here will need to be common knowledge of: i) the network size (number of nodes), ii) the number of topics that exist at any given moment, and iii) the popularity (in terms of demand for advertising space) of every topic\r\n\r\nWe can't have this because these parameters can change at any time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/583892557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/585935561",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-585935561",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 585935561,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4NTkzNTU2MQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-13T19:37:35Z",
    "updated_at": "2020-02-13T19:37:35Z",
    "author_association": "MEMBER",
    "body": "I just figured out that we can measure total network size pretty accurately by tracking the avg distance of lookup results from the lookup target.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/585935561/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/586183746",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-586183746",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 586183746,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4NjE4Mzc0Ng==",
    "user": {
      "login": "yiannisbot",
      "id": 52073247,
      "node_id": "MDQ6VXNlcjUyMDczMjQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/52073247?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiannisbot",
      "html_url": "https://github.com/yiannisbot",
      "followers_url": "https://api.github.com/users/yiannisbot/followers",
      "following_url": "https://api.github.com/users/yiannisbot/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiannisbot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiannisbot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiannisbot/subscriptions",
      "organizations_url": "https://api.github.com/users/yiannisbot/orgs",
      "repos_url": "https://api.github.com/users/yiannisbot/repos",
      "events_url": "https://api.github.com/users/yiannisbot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiannisbot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-14T09:51:03Z",
    "updated_at": "2020-02-14T09:51:03Z",
    "author_association": "NONE",
    "body": "> I just figured out that we can measure total network size pretty accurately by tracking the avg distance of lookup results from the lookup target.\r\n\r\nYes, exactly, there are several different techniques proposed in the literature (see [1] and [2]). And in any case, a relatively close estimate of the size will do in this case I believe.\r\n\r\n[1] [RFC7363: Self-Tuning DHT for REsource LOcation And Discovery (RELOAD)](https://tools.ietf.org/html/rfc7363#page-12)\r\n[2] [Measuring Large-Scale Distributed Systems: Case of BitTorrent Mainline DHT](https://www.cl.cam.ac.uk/~lw525/publications/P2P2013_13.pdf)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/586183746/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/687053198",
    "html_url": "https://github.com/ethereum/devp2p/issues/136#issuecomment-687053198",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/136",
    "id": 687053198,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzA1MzE5OA==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-04T10:04:47Z",
    "updated_at": "2020-09-04T10:57:10Z",
    "author_association": "MEMBER",
    "body": "New proposal time! Some of the text below just re-states stuff that's in the spec, the new things in this proposal are:\r\n\r\n- Radius estimation removed\r\n- Implementable descriptions of advertisement and search algorithms\r\n- Topic queue traffic control through cumulative wait time tracking\r\n\r\nI think the ideas below are a good starting point for simulation. We still need to work out the details (e.g. time constants, bucket sizes, topic table limits) and some edge cases.\r\n\r\n## Terms\r\n\r\n- A 'topic' is an identifier for a service provided by a node.\r\n- An 'advertiser' is a node providing a service that wants to be found.\r\n- An 'ad' is the registration of an advertiser for a topic on another node.\r\n- An 'advertisement medium' is a node on which an ad is stored.\r\n- A 'searcher' is a node looking for ads for a topic.\r\n\r\n## Ad Storage & Tickets\r\n\r\nIn order to place an ad, the advertiser must present a valid ticket to the advertiser.\r\n\r\nTickets are opaque objects issued by the advertisement medium. When the advertiser first tries to place an ad without a ticket, it receives an initial ticket and a 'waiting time' which it needs to spend. The advertiser must come back after the waiting time has elapsed and present the ticket again. When it does come back, it will either place the ad successfully or receive another ticket and waiting time.\r\n\r\nWhile tickets are opaque to advertisers, they are readable by the advertisement medium. The medium uses the ticket to store the cumulative waiting time, which is sum of all waiting times the advertiser spent. Whenever a ticket is presented and a new one issued in response, the cumulative waiting time is increased and carries over into the new ticket.\r\n\r\nAll nodes act as advertisement media and keep a table of 'topic queues'. This table stores the ads. The table has a limit on the number of ads in the whole table, and also has a limit on the number of ads in each queue. Ads move through the queue at a fixed rate. When the queue is full, and the last ad expires, a new ad can be stored at the beginning of the queue. An advertiser can only have a single ad in the queue, duplicate placements are rejected.\r\n\r\nTopic queues are subject to competition. To keep things fair, the advertisement medium prefers tickets which have the longest cumulative waiting time. In addition to the ads, each queue also keeps the current 'best ticket', i.e. the ticket with the longest cumulative waiting time. When a ticket with a better time is submitted, it replaces the current best ticket. Once an ad in the queue expires, the best ticket is admitted into the queue and the node which submitted it is notified.\r\n\r\nTickets cannot be used beyond their lifetime. If the advertiser does not come back after the waiting time, all cumulative waiting time is lost and it needs to start over.\r\n\r\nTo keep ticket traffic under control, an advertiser requesting a ticket for the first time gets a waiting time equal to the cumulative time of the current best ticket. For a placement attempt with a ticket, the new waiting time is assigned to be the best time minus the cumulative waiting time on the submitted ticket.\r\n\r\n## Advertiser Algorithm\r\n\r\nThe above description explains the storage and placement of ads on a single medium, but advertisers need to place ads redundantly on multiple nodes in order to be found.\r\n\r\nThe advertiser keeps a 'ticket table' to track its ongoing placement attempts. This table is made up of k-buckets of logarithmic distance to the topic hash, i.e. the table stores `k` advertisement media for every distance step. It is sufficient to use a small value of `k` such as `k = 3`. The ticket table is initialized and refreshed by performing lookups for the topic hash using the main node table.\r\n\r\nFor every node stored in the ticket table, the advertiser attempts to place an ad on the node and keeps the latest ticket issued by that node. It also keeps references to all tickets in a priority queue keyed by the expiry time of the ticket so it can efficiently access the next ticket for which a placement attempt is due.\r\n\r\nNodes/tickets are removed from their ticket table bucket when the ad is placed successfully or the medium goes offline. The removed entry is replaced when the ticket table is refreshed by a lookup.\r\n\r\n## Search Algorithm\r\n\r\nThe purpose of placing ads is being discovered by searchers.\r\n\r\nSearchers on a topic also keep a table, the 'search table'. Like the 'ticket table', this table also stores k-buckets of advertisement media by distance to the topic hash. The `k` factor of the search table should be relatively large in order to make the search efficient. Tickets are not required for search. The search table is initialized and refreshed by performing lookups for the topic hash on using the main node table.\r\n\r\nTo find ads, the searcher simply queries the nodes in the search table for ads. In order to find new results, bucket entries are replaced when the node fails to answer or when it answers with an empty list of ads. Bucket entries of the search table should also be replaced whenever the table is refreshed by a lookup.\r\n\r\n## How does this deal with topic popularity?\r\n\r\nIn earlier research, we kept trying to estimate the 'radius' (i.e. popularity) of the topic in order to determine the advertisement media.\r\n\r\nI think the proposed advertisement algorithm will track popularity automatically because the cumulative waiting time required for placement just grows the closer you get to the topic hash. Nodes will keep trying to out-wait each other close to the center. Further away from the topic, waiting times will be more reasonable and everyone will be able to find their place there. When the topic shrinks, the required 'best time' will shrink also.\r\n\r\nFor search, estimation is less necessary and we should try to see how efficient it is in the way specified above. I think it might just work out.\r\n\r\n## Beyond the simple proposal\r\n\r\nThere is a minor problem with the simple placement and search scheme outlined above: the nodes which are close to the topic hash will get a lot of traffic because they'll be in everyone's ticket and search tables. We previously tried to eliminate this problem using the concept of 'minimum radius'. It might work to use network density estimation for this. If we have a rough estimate on network size, we can determine a lower bound on the distance to the topic hash such that the number of nodes in the 'center' is > 256, for example.\r\n\r\nThe log-distance based tables might not be precise enough to accurately track advertisement media. We could use the more precise tree-based k-bucket design (as used in BitTorrent DHT, for example) for these tables.\r\n\r\nAnother question is how well this system can cope with many different topics at the same time. @harnen's idea to prioritize ads based on the distance of the advertisement medium from the topic could be used for that. The general idea with the topic table system is that there is a global limit on the number of ads that can be stored across the entire DHT. When the limit is reached, the waiting times will just go up. It's a tradeoff. We need to explore this and set the parameters (especially the topic table limits) so the system will be usable with a large number of topics.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/687053198/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
