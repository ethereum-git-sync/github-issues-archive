{
  "url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
  "repository_url": "https://api.github.com/repos/ethereum/devp2p",
  "labels_url": "https://api.github.com/repos/ethereum/devp2p/issues/71/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/devp2p/issues/71/comments",
  "events_url": "https://api.github.com/repos/ethereum/devp2p/issues/71/events",
  "html_url": "https://github.com/ethereum/devp2p/issues/71",
  "id": 423153542,
  "node_id": "MDU6SXNzdWU0MjMxNTM1NDI=",
  "number": 71,
  "title": "Low-level transport protocol based on TLS+yamux",
  "user": {
    "login": "ferranbt",
    "id": 30872539,
    "node_id": "MDQ6VXNlcjMwODcyNTM5",
    "avatar_url": "https://avatars.githubusercontent.com/u/30872539?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ferranbt",
    "html_url": "https://github.com/ferranbt",
    "followers_url": "https://api.github.com/users/ferranbt/followers",
    "following_url": "https://api.github.com/users/ferranbt/following{/other_user}",
    "gists_url": "https://api.github.com/users/ferranbt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ferranbt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ferranbt/subscriptions",
    "organizations_url": "https://api.github.com/users/ferranbt/orgs",
    "repos_url": "https://api.github.com/users/ferranbt/repos",
    "events_url": "https://api.github.com/users/ferranbt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ferranbt/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1272598186,
      "node_id": "MDU6TGFiZWwxMjcyNTk4MTg2",
      "url": "https://api.github.com/repos/ethereum/devp2p/labels/proposal",
      "name": "proposal",
      "color": "bffc9f",
      "default": false,
      "description": "Ideas and proposals related to devp2p"
    },
    {
      "id": 2408299443,
      "node_id": "MDU6TGFiZWwyNDA4Mjk5NDQz",
      "url": "https://api.github.com/repos/ethereum/devp2p/labels/transport",
      "name": "transport",
      "color": "bfc90c",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 27,
  "created_at": "2019-03-20T09:40:31Z",
  "updated_at": "2020-10-31T05:20:29Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "\r\nThe current devp2p stack provides an inefficient interface to protocol applications that end up having to use a fixed message format to communicate. This is due to the fact that the layers that compose the stack are not independent from each other. This document proposes a different modular stack based on the abstraction layers mechanism followed in the OSI network protocol stack. \r\n\r\nIn the OSI model [[1]](https://en.wikipedia.org/wiki/OSI_model), different protocols are built one under another, each layer designed with a single purpose in mind. This modularization makes design and evaluation easier. Upper layers are unaware about the logic of lower layers and communicate with a specific interface. This transparency makes it possible to build FTP, DNS or TLS under the same TCP interface.\r\n\r\nThe new proposed stack has two layers. First, the security layer establishes a secure connection with a remote peer, it is based on TLS. Second, once the connection is established the signal is multiplexed in different streams. Both of this layers take as input a batch of binary data without any specific format. Thus, it is possible to change any layer at any time. Application protocols can use this flexible input format to build any type of communication protocol: FTP, SSH, RPC or [[2]](https://github.com/ethereum/devp2p/issues/70).\r\n\r\n## Objectives\r\n\r\n- The transport protocol should care exclusively about securing a connection with the other peer and providing different streams for the protocols. It should not introduce any other logic like flow control, congestion avoidance... It should be up to the higher layers to introduce this logic if they require it on their application protocols.\r\n\r\n- The transport protocol should be application protocol independent. Higher-level protocols can layer on top of it transparently.\r\n\r\n## DevP2P\r\n\r\nA small recap on the workings of devp2p. First, both peers start a handshake process to agree on a set of mac and cipher stream keys. Second, a secure transport connection is established with the former keys. Messages are sent with the format (code int, data bytes), each message is compressed, hashed with a mac and encrypted before being written to the insecure channel (RLPX protocol). Third, the peers agree on a set of protocols (i.e. eth64) and for each one start an independent stream on the secure channel (multiplexing). The protocols send messages to the stream also with the format (code, data). The code in the message is used to send the data to the correct stream.\r\n\r\n### Limitations:\r\n\r\n- Rlpx macs and encrypts all the message at the same time. This may be a burden for big messages.\r\n\r\n- The upper protocols that use the transport (i.e. eth64) end up having to use a fixed message format (code, message). This limits their flexibility and the type of communication they can use.\r\n\r\n## Proposal\r\n\r\nThis new transport proposal follows the same methodology as devp2p but applies a different set of protocols for each layer.\r\n\r\nHandshake is still TBD. It is assumed that the peers agree on a set of mac and cipher stream keys. Next, the TLS record protocol [[3]](https://docs.microsoft.com/en-us/windows/desktop/secauthn/tls-record-protocol) secures the application data. It behaves similar to RLPX, it macs and encrypts the data and then writes it to the insecure connection. However, the main benefit is that it divides the outgoing message into manageable blocks and reassembles incoming messages. Thus, it consumes less memory. The only input the record protocol takes is a message (bytes) to be transmitted.\r\n\r\nWe then use the yamux protocol [[4]](https://github.com/hashicorp/yamux/blob/master/spec.md) to multiplex the secure signal into different streams. Those streams are the ones exposed to the upper layers (protocols). Again, the created streams only take bytes as input.\r\n\r\n### Benefits\r\n\r\n- It provides a flexible interface for the protocol backends to implement any type of exchange mechanism (i.e. rpc, pub/sub).\r\n\r\n- It uses well known and production hardened protocols (TLS record and yamux).\r\n\r\n- Encrypting and sending data in blocks makes it more performant in terms of speed and memory. Benchmarks show that TLS is 10x faster than RLPX.\r\n\r\n- Every major language has already optimal implementations of TLS and the record protocol.\r\n\r\n- It would be faster and easier to build new protocols [[5]](https://github.com/yperbasis/silkworm/blob/master/doc/sync_protocol.pdf).\r\n\r\n### References\r\n\r\n[1]. https://en.wikipedia.org/wiki/OSI_model\r\n[2]. https://github.com/ethereum/devp2p/issues/70\r\n[3]. https://docs.microsoft.com/en-us/windows/desktop/secauthn/tls-record-protocol\r\n[4]. https://github.com/hashicorp/yamux/blob/master/spec.md\r\n[5]. https://github.com/yperbasis/silkworm/blob/master/doc/sync_protocol.pdf\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/71/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/devp2p/issues/71/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/475199661",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-475199661",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 475199661,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTE5OTY2MQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-21T11:49:26Z",
    "updated_at": "2019-03-21T11:49:26Z",
    "author_association": "MEMBER",
    "body": "I don't fully understand the limitations you listed:\n\n> Rlpx macs and encrypts all the message at the same time. This may be a burden for big messages.\n\nHow is that different with TLS? I mean, TLS also encrypts and authenticates every message\nsent. I agree that RLPx MAC is overly complicated and could be faster but it's\nfundamentally the same thing that TLS also does.\n\n> The upper protocols that use the transport (i.e. eth64) end up having to use a fixed\n> message format (code, message). This limits their flexibility and the type of\n> communication they can use.\n\nI don't understand this part. The eth protocol uses numbered messages, but you'd need a\nway to identify the specific message in any transport protocol. Using TLS as the transport\ndoesn't change this aspect.\n\nAre you going to work on the handshake?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/475199661/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/475272023",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-475272023",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 475272023,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTI3MjAyMw==",
    "user": {
      "login": "ferranbt",
      "id": 30872539,
      "node_id": "MDQ6VXNlcjMwODcyNTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/30872539?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ferranbt",
      "html_url": "https://github.com/ferranbt",
      "followers_url": "https://api.github.com/users/ferranbt/followers",
      "following_url": "https://api.github.com/users/ferranbt/following{/other_user}",
      "gists_url": "https://api.github.com/users/ferranbt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ferranbt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ferranbt/subscriptions",
      "organizations_url": "https://api.github.com/users/ferranbt/orgs",
      "repos_url": "https://api.github.com/users/ferranbt/repos",
      "events_url": "https://api.github.com/users/ferranbt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ferranbt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-21T15:17:36Z",
    "updated_at": "2019-03-21T15:17:36Z",
    "author_association": "NONE",
    "body": "> How is that different with TLS? I mean, TLS also encrypts and authenticates every message\r\n> sent. I agree that RLPx MAC is overly complicated and could be faster but it's\r\n> fundamentally the same thing that TLS also does.\r\n\r\n\r\nFrom my point of view, RlPx is like UDP and TLS like TCP.\r\n\r\nQuoting from [here](https://stackoverflow.com/questions/17446491/tcp-stream-vs-udp-message):\r\n\r\n> UDP\r\n> \r\n> Message oriented, you have an API (send/recv and similar) that provide you with the ability to send one datagram, and receive one datagram. 1 send() call results in 1 datagram sent, and 1 recv() call will recieve exactly 1 datagram.\r\n> \r\n> TCP\r\n> \r\n> Stream oriented, you have an API (send/recv and similar) that gives you the ability to send or receive a byte stream.There is no preservation of message boundaries, TCP can bundle up data from many send() calls into one segment, or it could break down data from one send() call into many segments - but that's transparent to applications sitting on top of TCP, and recv() just gives you back data, with no relation to how many send() calls produced the data you get back.\r\n\r\nSince TLS takes as input a byte stream with no specific segments, it splits the incoming stream in manageable blocks. perform the encryption on each independent block of a smaller size than the input and then sends the chunk. I think this is not only powerful in terms of reducing memory usage but also in the type of protocols that can be built on top.\r\n\r\nIn [this](https://github.com/ferranbt/transport-test) repo there are some benchmarks comparing RLPx and TLS + Yamux. \r\n\r\n> I don't understand this part. The eth protocol uses numbered messages, but you'd need a\r\n> way to identify the specific message in any transport protocol. Using TLS as the transport\r\n> doesn't change this aspect.\r\n\r\nI do not argue that protocols need a way to identify messages. My point is that it should be up to them how they want to do it. RLPx forces the protocols to use a specific format (code, message). However, if the transport takes a byte stream, the application protocols can build their own message formats specifics for their use case.\r\n\r\nFor example, the next list of protocols run on top of TCP and each one defines their own message format.\r\n\r\n- TLS https://tools.ietf.org/html/rfc5246#section-6.2.1\r\n- RPC: https://tools.ietf.org/html/rfc5531#section-9\r\n- DNS: https://tools.ietf.org/html/rfc1035#section-4\r\n- SSH: https://tools.ietf.org/html/rfc4253#section-6\r\n\r\nThis flexibility allows us to build many type of different applications for the clients. For example: use native RPC for light client calls, transfer blocks over FTP, notify new blocks with ZeroMQ...\r\n\r\n> Are you going to work on the handshake?\r\n\r\nI have a couple of ideas about the handshake but nothing clear yet.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/475272023/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/476079901",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-476079901",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 476079901,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NjA3OTkwMQ==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-25T07:11:22Z",
    "updated_at": "2019-03-25T07:11:38Z",
    "author_association": "MEMBER",
    "body": "Sorry for the delay in responding here, have been focused on other things. I will also spend some time digesting and considering this today. It's a good starting point for a conversation that needs to be had, as addressing RLPx weaknesses has been on the radar for some time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/476079901/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/481863820",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-481863820",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 481863820,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MTg2MzgyMA==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-10T21:01:25Z",
    "updated_at": "2019-04-10T21:01:25Z",
    "author_association": "NONE",
    "body": "I have the same questions as @fjl - either TSL or RLPx would need \"scramble\" the data over the physical/virtual channel, weather that happens explicitly (RLPx) or hidden away (TLS), doesn't change that fact. \r\n\r\nBut I agree with most everything else proposed by @ferranbt, having a more modularized stack has many benefits in both evolving and extending the higher level protocols. Having real multiplexing such as yamux or mplex has the added benefit of abstracting streaming from the protocol developer - things like handling the max message/packet size, congestion control, etc, move out of the way of designing an application layer protocol like eth62/63/64/etc... \r\n\r\nThat said, everything @ferranbt outlined is already available as part of https://libp2p.io/ (there are Go, Rust and Js implementations, with python and others in active development). It might be worth exploring the possibility of using it instead of \"rolling our own\", specially when Eth2 has settled on using it already. \r\n\r\nFor an example of how devp2p (eth62/63/les) could be rolled on top of libp2p take a look at - https://github.com/ethereumjs/ethereumjs-client/blob/master/lib/net/peer.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/481863820/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/481865510",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-481865510",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 481865510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MTg2NTUxMA==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-10T21:06:41Z",
    "updated_at": "2019-04-10T21:08:17Z",
    "author_association": "NONE",
    "body": "An added benefit of something like libp2p is transport abstraction, currently tcp, utp, websockets and webrtc are supported, with Quick and more exotic things like bluetooth also being a possibility. This is extremely important from the perspective of developing sustainable light client protocols for browsers, IoT, etc... \r\n\r\nWe're very interested in having this possibility @musteka-la and willing to lend a hand. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/481865510/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482479340",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482479340",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482479340,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MjQ3OTM0MA==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-12T08:02:49Z",
    "updated_at": "2019-04-12T08:42:07Z",
    "author_association": "MEMBER",
    "body": "Modularisation is certainly one argument. Some aspects of RLPx re-invent the wheel where it is now unnecessary. I am still uncertain about what the overall requirements should be for the p2p network protocol. Libp2p is definitely flexible, though it seems to me as though libp2p's design goals are to enable interoperability and extensibility. This is ideal for a platform like Polkadot, but I am not sure how that should overlap with specific implementations that just want to implement their own (eg:) optimised version of a streaming transport without the flexibility or extensibility that a toolset that libp2p provides.\r\n\r\nThe original issue though is , I think, mistaken somewhat:\r\n1) The RLPx protocol is a streaming protocol\r\n2) The message needs to be RLP encoded anyway....though in theory I think that can be made streaming (correct me if wrong)\r\n3) The cypher is AES-CTR, which is streaming\r\n\r\nSo I think you could actually stream a message without the memory impact described in the OP. \r\n\r\nIt would be good to keep talking about this topic, I think a discussion on libp2p, p2p , rlpx etc is most welcome.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482479340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482542043",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482542043",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482542043,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MjU0MjA0Mw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-12T11:36:55Z",
    "updated_at": "2019-04-12T11:36:55Z",
    "author_association": "MEMBER",
    "body": "Some other considerations and approaches.... please take a look here: #83",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482542043/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482655832",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482655832",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482655832,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MjY1NTgzMg==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-12T17:23:58Z",
    "updated_at": "2019-04-12T17:23:58Z",
    "author_association": "NONE",
    "body": "Thanks for the answer @FrankSzendzielarz! Let me try to describe libp2p in a little more detail, which will hopefully clarify some of the benefits of using the stack, and also give us specific points for discussion. I haven't looked through the issues, so if this is a duplicate of previous discussions I apologize in advance.\r\n\r\n> Libp2p is definitely flexible, though it seems to me as though libp2p's design goals are to enable interoperability and extensibility. \r\n\r\nThrough interoperability is certainly something that libp2p implementations strive for, it isn't necessarily what drives the design of the stack. Just like devp2p implementations for different languages have to be \"on the wire\" compatible, to enable ethereum interop across different clients, libp2p implementations are expected to be \"on the wire\" interoperable as well, but implementations are not forced to any specific architecture other than the input/output bytes being the same.\r\n\r\nLibp2p is build around a few concepts (this is strictly my own interpretation based on my experience as a maintainer and author of a few components):\r\n\r\n- self describing formats and addresses\r\n- swappable and modular networking components: \r\n  - transports\r\n  - protocol negotiation\r\n  - encryption\r\n  - stream multiplexing\r\n  - discovery\r\n\r\n### Self describing formats and addresses\r\n\r\nIMO this is easily one of the stronger points that makes libp2p appealing and different from previous attempts at creating a flexible networking stack. It solves the issues around transport selection and eliminates \"port lock ins\" completely. I won't cite the full [spec](https://multiformats.io/multiaddr/) here but a few examples are useful to illustrate this feature. \r\n\r\nFirst briefly, multiaddrs are self describing addresses that carry enough information to be able to infer the transport, physical address and port, as well as the specific resource being requested. Think of it as Urls (tho probably a bad analogy) for network addresses. A few examples:\r\n\r\nLet's say that our application is given an ip and port pair such as `127.0.0.1:80`, there is no way to tell whether this is `tcp` or `udp`, nor what actually runs on port `80`, sure port 80 is a _well known_ port, so we can assume it's www, but what if the port was `64555`, no way to tell what's going on there. \r\n\r\n- connecting to 127.0.0.1 on port 80 using tcp, would look like this:\r\n  - `/ip4/127.0.0.1/tcp/80/`\r\n- we can also specify what's the protocol available on that port\r\n  - `/ip4/127.0.0.1/tcp/80/http` and while we're at it we can also point to a specific resource `/ip4/127.0.0.1/tcp/80/http/baz.jpg`\r\n\r\nA few more examples:\r\n\r\n- what if we wanted to used `udp` - `/ip4/127.0.0.1/udp/80/`\r\n- how about `quick` - `/ip4/127.0.0.1/udp/9090/quic`\r\n\r\nThis scheme allows the client to decide the best way to initiate a connection to the remote and it makes changing ports, transports and other aspects of the stack _possible_ as opposed to _\"no way, it's going to break the world\"_ type of thing. Moreover, it allows each individual node to decide which port and transports they wish to/can expose. I can't stress enough how important this is in practice, I'll try to give a bit more detail around this later in this post.\r\n\r\nSay for example we want to change ethereum's port to something other than `30303`, it would require a full redeploy of all the clients and possibly break the network in several ways. Moreover, not being able to quickly and reliably switch ports and/or transports for each individual node makes for an easy target for ISP providers (i.e. governments) to filter/throttle that traffic. It might not be a problem now, but there is nothing stopping a few major providers doing just that for things to get really hairy. I don't want to make this a post full of hypothetical scares, so I'll leave it at that :)\r\n\r\n### Swappable and modular networking components\r\n\r\nFirst a quick overview of the full stack before I move on to the individual components. A typical libp2p implementation has at least a set of transports and the `multistream` negotiation protocol. When a libp2p connection is being established, the client `dials` the remote over one or more transports, if it succeeded, the connection is optionally encrypted, optionally muxed and then handed over to the high level caller (i.e. your app).\r\n\r\n- Transports. Virtually anything can be used as a transport - tcp and udp (utp, quick), websockets, webrtc, etc... With multiaddrs, clients can pick and choose which transport to use to establish the connection.\r\n\r\n- Multistream protocol negotiation. This is the mechanism used to negotiate most of the higher level interactions during the lifetime of the connection. For example, what sort of encryption and multiplexing mechanism is supported by both nodes is determined using `multistream`. This is also the mechanism used to add custom protocols. Currently, multistream uses simple strings as identifiers, so for example yamux is registered as `/yamux/1.0.0` (or something similar). There is nothing particular about the string, it's just an identifier, and eth/62 could just the same be placed under say `/devp2p/eth62`.\r\n\r\n- Encryption. Right now, the only encryption mechanisms available (AFAIK), is secio, but others can be plugged in. For example, the RLPx scheme could be potentially implemented, tho possibly not much benefit there since better mechanisms are available. I don't know `secio` well enough to point out its strengths and weaknesses, but the point is that there is nothing preventing from other schemes being plugged in instead of it.\r\n\r\n- Muxing/multiplexing. There is a variety of muxers supported by each implementation, with `mplex` being the most widely supported. Yamux is supported by Go and Rust, but not by the Js implementation, and `spdy` (as a muxer) supported by js only (AFAIK). Again, pluging your own muxer is a matter of wrapping it with a libp2p compatible interface.\r\n\r\n- Discovery. This is again optional and pluggable. Currently a modified S/Kademlia dht flavor is implemented by Go and Js, the spec is being finilized here - https://github.com/libp2p/specs/pull/108. In general tho, discovery is not locked down to the DHT and other mechanisms can be used, i.e. gossip or epidemic broadcasts, rendezvous points (think bittorrent trackers), etc... \r\n\r\n- Nat traversal, relaying connections and other fancy things. \r\n  - Nat traversal is supported to varying degrees by the different implementations. I started a js one with support for UpnP and PMP, but it isn't fully backed into the libp2p stack yet. Go's Nat support is much better. I'm not sure about Rust at all - perhaps someone from the rust libp2p team can shed some light.\r\n  - Connection relaying is implemented as well. This allows using a third node as a relay point. It's useful as an additional Nat traversal mechanism or to allow nodes that don't share the same transports to still communicate.\r\n\r\n-----------------------------\r\n\r\nI hope this overview (however long), is enough to continue the conversation. But before I wrap it up I want to state the specific reasons why I feel strongly about libp2p support - browsers. \r\n\r\nThe browser has evolved into a full featured runtime. It is a ubiquitous and very capable platform that is a natural fit for light clients, however the lack of browser compatible transport supports in devp2p makes it quite hard to implement a light client on top of devp2p, moreover, it doesn't look like devp2p was designed with multi-transport support in mind at all, I wouldn't be at all opposed in extending devp2p to bring in browser support, but the time it would take us to \"figure it out\" (design, bikeshedding, implementation) feels prohibitive especially when a worthy alternative is already available. \r\n\r\nThat said, I rather have a working solution of any sort, rather than no solution at all, so let's keep at it and keep all options on the table ;-)\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482655832/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482677765",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482677765",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482677765,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MjY3Nzc2NQ==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-12T18:30:46Z",
    "updated_at": "2019-04-12T18:38:14Z",
    "author_association": "MEMBER",
    "body": "Thanks for the lengthy write-up, it shows you are committed! :) @dryajov   I do understand your points. When I first looked into developing my own light client, the first thought I had was that the protocol design was extremely unfriendly. I think historically the design goals were just to build a v1 network as fast as possible, without a proper set of requirements related to real world long term usage.\r\n\r\nThere is much to say on this topic, so I will delay a worthy response until I have a bit more time and have mulled things over a bit, but in the meantime a quick question:\r\n\r\n_Please could you elaborate on the kind of scenarios and protocols you envisage for the light client in the browser? In particular, over which protocols and transports would you see discovery working and then how the actual light clients communicate with the full node peers?_\r\n\r\nOh and as an aside (kind of unrelated)...\r\n\r\n_Would it influence those scenarios and protocol choices in any way if the transmission of the Eth protocol messages was 'almost' transport agnostic (so long as the transport was reliable and streamed like tcp) but mandated aes-gcm encryption?_",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482677765/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482761560",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482761560",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482761560,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Mjc2MTU2MA==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-13T00:48:07Z",
    "updated_at": "2019-04-13T00:48:07Z",
    "author_association": "NONE",
    "body": "Thanks for the answers @FrankSzendzielarz and looking forward to your write up. \r\n\r\nTL;DR \r\nBrowsers don't have tcp/udp capabilities exposed. AFAIK, RLPx transport level is \"hard coded\" to tcp for data exchange and udp for discovery - correct me if I'm wrong. The protocols (eth/62/63/less) don't have any limitations and it should be possible to run them on top of any stream oriented channel.\r\n\r\n> Please could you elaborate on the kind of scenarios and protocols you envisage for the light client in the browser? In particular, over which protocols and transports would you see discovery working and then how the actual light clients communicate with the full node peers?\r\n\r\n> over which protocols and transports would you see discovery working\r\n\r\nIn the browser you're limited to HTTP, Websockets and WebRTC. In libp2p, we can use the DHT (https://github.com/libp2p/js-libp2p-kad-dht) which works on top of any channel available to it, so WS and/or WebRTC. But we can also use other means of discovery like a rendezvous point and/or more exotic/ad-hoc things like gossip discovery. \r\n\r\nSpecifically right now, WebRTC star server that doubles as a rendezvous discovery mechanism - https://github.com/libp2p/js-libp2p-webrtc-star, this will change as we evolve the implementation.\r\n\r\n> how the actual light clients communicate with the full node peers?\r\n\r\nThe current vision is to have clients with a libp2p and RLPx/devp2p stacks running side by side and bridging the two networks. Not at all ideal, but doable.\r\n\r\n> Would it influence those scenarios and protocol choices in any way if the transmission of the Eth protocol messages was 'almost' transport agnostic (so long as the transport was reliable and streamed like tcp) but mandated aes-gcm encryption?\r\n\r\nYes, most definitely and I believe this is already the case. The application level protocols _should_ (I haven't tried it, but I don't see why not) run on top of any stream oriented channel (raw sockets, websockets/webrtc, multiplexed, etc...). What caveats are there with `aes-gcm encryption`, if any?\r\n\r\nI think it @vpulim input on this would be very valuable, as it appears that he's already done the work in https://github.com/ethereumjs/ethereumjs-client/. Also pinging @holgerd77.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482761560/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482796738",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-482796738",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 482796738,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Mjc5NjczOA==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-13T10:22:11Z",
    "updated_at": "2019-04-15T11:55:08Z",
    "author_association": "MEMBER",
    "body": "@dryajov Thanks again for the response.   Well it's exciting to have this discussion for a number of reasons. \r\n\r\nOn Discovery, when trying to collect requirements for Discoveryv5 (see the rationale document in discv5 in this repo) one thing I tried to achieve was separate the protocol from the underlying transport, making it as agnostic as possible about if the underlying transport was streamed/message based or even reliable.\r\n\r\nIt is not yet documented but Felix has taken the discovery protocol even further by solving some issues related to identities where public keys are not recoverable from signatures and the impact on obfuscation, by designing a low-cost handshake that establishes an encrypted channel at the discovery level. \r\n\r\nOne thing that does seem to be happening now though is that again the direction _seems_ to be drifting towards tying discovery to UDP only. I emphasise _seems_ because I am not clear on that 100% and if so, why. If it is the case, then usually Felix has very good reasons for making certain design decisions. @fjl \r\n\r\nHowever, that's kind of the point: up until literally a few weeks ago there was no real agreed common hang-out for identifying and consolidating the requirements  for the p2p stack. Things have tended to evolve in isolation, and the underlying rationale has been opaque. But now we have the devp2p repo and an effort underway to have everyone share their voice in the direction and real world requirements here.\r\n\r\nFurther, up until recently it has always seemed to those on the core team that a very small minority of people had any interest in the p2p layers. My intuition though suggests that this is not the case, and it is more about that voices like yours and others just have not had easily accessible and open channels to connect with those working on the specs. (I do think that it would be a really good idea if the startup community established a working group in participation with EF and Parity directly to prioritise and channel goals and requirements.)\r\n\r\nHopefully this devp2p repo will now serve those aims to some extent, and any help you can offer in bringing in other stakeholders here would be much appreciated.\r\n\r\nSo with that, and putting aside the libp2p stack topics for a while (I will get back to that in time), am I correct in saying that really what we are discussing now is specifically a requirement that **the p2p protocols should be more permissive and support a more diverse set of transports to facilitate implementing a broader range of light clients** ? (If so it's a personal ambition of mine to help make light protocol serving and consumption easier and more widespread. )\r\n\r\nIf so, can I suggest you (better than if I do it, but happy to do so if you prefer) create a new Issue to that effect, where we can actually involve everyone in the discussion, invite more stakeholders, and really get in depth with it? I do have many technical things to say on the topic and I am sure @fjl will have too, but it would be good to collate them there and decide what the direction should be. \r\n\r\nIn advance of the new issue, some topics I want to discuss on that:\r\n1) Drawing the line between minimum protocol requirements on Ethereum implementations and the toolsets (eg libp2p)\r\n2) ENRs at the discovery level and how they drive multiaddr\r\n3) Discv5 aes-gcm channel re-use for the eth protocol\r\n4) Micropayment incentivization and relay-only nodes or implementation wrappers to make standard implementations support multiple transports\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/482796738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483001521",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483001521",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483001521,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzAwMTUyMQ==",
    "user": {
      "login": "GregTheGreek",
      "id": 16929357,
      "node_id": "MDQ6VXNlcjE2OTI5MzU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/16929357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GregTheGreek",
      "html_url": "https://github.com/GregTheGreek",
      "followers_url": "https://api.github.com/users/GregTheGreek/followers",
      "following_url": "https://api.github.com/users/GregTheGreek/following{/other_user}",
      "gists_url": "https://api.github.com/users/GregTheGreek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GregTheGreek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GregTheGreek/subscriptions",
      "organizations_url": "https://api.github.com/users/GregTheGreek/orgs",
      "repos_url": "https://api.github.com/users/GregTheGreek/repos",
      "events_url": "https://api.github.com/users/GregTheGreek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GregTheGreek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-14T15:40:07Z",
    "updated_at": "2019-04-14T15:40:07Z",
    "author_association": "NONE",
    "body": "Cc: @mikerah @wemeetagain",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483001521/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483010946",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483010946",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483010946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzAxMDk0Ng==",
    "user": {
      "login": "vpulim",
      "id": 100092,
      "node_id": "MDQ6VXNlcjEwMDA5Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/100092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vpulim",
      "html_url": "https://github.com/vpulim",
      "followers_url": "https://api.github.com/users/vpulim/followers",
      "following_url": "https://api.github.com/users/vpulim/following{/other_user}",
      "gists_url": "https://api.github.com/users/vpulim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vpulim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vpulim/subscriptions",
      "organizations_url": "https://api.github.com/users/vpulim/orgs",
      "repos_url": "https://api.github.com/users/vpulim/repos",
      "events_url": "https://api.github.com/users/vpulim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vpulim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-14T16:27:16Z",
    "updated_at": "2019-04-14T16:28:44Z",
    "author_association": "NONE",
    "body": "Great discussion.\r\n\r\n> The current vision is to have clients with a libp2p and RLPx/devp2p stacks running side by side and bridging the two networks. Not at all ideal, but doable.\r\n\r\n As @dryajov mentioned, https://github.com/ethereumjs/ethereumjs-client implements a working proof-of-concept that shows how a light client running in the browser is able to communicate with full nodes. Instructions are in the README, but essentially, we run two nodes:\r\n\r\n1. A full node that runs on a server and provides `libp2p` and `devp2p` transports. It connects to an ethereum network over `devp2p` and syncs the chain. It also listens for new peer connections using both `devp2p` and `libp2p` and supports `eth/62`, `eth/63` and `les` over both transports.\r\n2. A light node that runs in the browser and connects to the full node over a web socket using the 'libp2p' transport.\r\n\r\nThe ethereumjs-client is only at the proof-of-concept stage but the hope is that the Go or Rust clients would eventually also support both transports and act as bridge nodes between `devp2p` and `libp2p`-based peers.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483010946/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483047538",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483047538",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483047538,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzA0NzUzOA==",
    "user": {
      "login": "ferranbt",
      "id": 30872539,
      "node_id": "MDQ6VXNlcjMwODcyNTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/30872539?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ferranbt",
      "html_url": "https://github.com/ferranbt",
      "followers_url": "https://api.github.com/users/ferranbt/followers",
      "following_url": "https://api.github.com/users/ferranbt/following{/other_user}",
      "gists_url": "https://api.github.com/users/ferranbt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ferranbt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ferranbt/subscriptions",
      "organizations_url": "https://api.github.com/users/ferranbt/orgs",
      "repos_url": "https://api.github.com/users/ferranbt/repos",
      "events_url": "https://api.github.com/users/ferranbt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ferranbt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-14T19:34:00Z",
    "updated_at": "2019-04-14T19:34:00Z",
    "author_association": "NONE",
    "body": "\r\nJust to clarify my points and respond to some of the topics brought. \r\n\r\nI would not consider RLPx a streaming protocol. As I pointed before, a streaming protocol usually takes a stream of bytes as input, but, RLPx has a fixed interface (code, message). This makes it a bit unefficient, to send 1MB of data requires to allocate 1MB in memory. You can build more memory/cpu efficient methods with a stream protocol ([here](https://github.com/ferranbt/transport-test)). It is true that you could build a stream protocol on top of RLPx but I that does not make it a streaming protocol (otherwise, UDP would be a streaming protocol too). My point was not to use TLS per se but to use the method TLS uses to split the data.\r\n\r\nA streaming protocol interface for the transport can increase the number of protocols and use cases we can implement in the upper layers. The more abstract and low uses we do it the better and more things we can build on top. It seems that we may agree on this point.\r\n\r\nI have no experience with LibP2P whatsoever but my fear is that by having a wide abstraction interface to incorporate different protocols you may end up underperforming with respect to using a specific stack.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483047538/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483048759",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483048759",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483048759,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzA0ODc1OQ==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-14T19:41:14Z",
    "updated_at": "2019-04-14T19:41:14Z",
    "author_association": "MEMBER",
    "body": "@ferranbt  \"This makes it a bit unefficient, to send 1MB of data requires to allocate 1MB in memory.\" As far as I can tell this not actually true with RLPx. Yes, it does require that messages be transmitted, but it does not require that the message be streamed from memory.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483048759/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483154544",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483154544",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483154544,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzE1NDU0NA==",
    "user": {
      "login": "ferranbt",
      "id": 30872539,
      "node_id": "MDQ6VXNlcjMwODcyNTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/30872539?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ferranbt",
      "html_url": "https://github.com/ferranbt",
      "followers_url": "https://api.github.com/users/ferranbt/followers",
      "following_url": "https://api.github.com/users/ferranbt/following{/other_user}",
      "gists_url": "https://api.github.com/users/ferranbt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ferranbt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ferranbt/subscriptions",
      "organizations_url": "https://api.github.com/users/ferranbt/orgs",
      "repos_url": "https://api.github.com/users/ferranbt/repos",
      "events_url": "https://api.github.com/users/ferranbt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ferranbt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T08:19:47Z",
    "updated_at": "2019-04-15T08:19:47Z",
    "author_association": "NONE",
    "body": "Not sure what are you referring about \"streamed from memory\". I talk about total allocated memory by the CPU. For example [this](https://github.com/ethereum/go-ethereum/blob/master/p2p/rlpx.go#L601) and [this](https://github.com/ethereum/go-ethereum/blob/master/p2p/rlpx.go#L665). These operations require to have memory allocated the size of the message.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483154544/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483220628",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483220628",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483220628,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzIyMDYyOA==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T11:52:50Z",
    "updated_at": "2019-04-15T11:52:50Z",
    "author_association": "MEMBER",
    "body": "@ferranbt Ah snappy compression, yes. I had forgotten about that. Good catch. Snappy compression, internally, _I think_ works on 32k blocks , so in theory again you could implement the protocol in a streaming manner. But that is academic. And I think this is getting besides the point. \r\n\r\nWith the above discussion regarding light clients, I think it would be a good idea to split this into a new 'requirement' on devp2p, where we clearly describe the design goal as a new GitHub issue, so we can discuss what impact that should have concretely on discoveryv5 and on the protocols for eth, etc. (@dryajov)\r\n\r\nI think similarly, because we are pretty much exclusively dealing with messages anyway, could I please ask you @ferranbt to elaborate on some of the use cases you envisage supporting? Maybe I am not getting the motivation here. I do agree that things can and should be done to improve things.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483220628/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483295115",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483295115",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483295115,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzI5NTExNQ==",
    "user": {
      "login": "ferranbt",
      "id": 30872539,
      "node_id": "MDQ6VXNlcjMwODcyNTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/30872539?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ferranbt",
      "html_url": "https://github.com/ferranbt",
      "followers_url": "https://api.github.com/users/ferranbt/followers",
      "following_url": "https://api.github.com/users/ferranbt/following{/other_user}",
      "gists_url": "https://api.github.com/users/ferranbt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ferranbt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ferranbt/subscriptions",
      "organizations_url": "https://api.github.com/users/ferranbt/orgs",
      "repos_url": "https://api.github.com/users/ferranbt/repos",
      "events_url": "https://api.github.com/users/ferranbt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ferranbt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T15:16:38Z",
    "updated_at": "2019-04-15T15:16:38Z",
    "author_association": "NONE",
    "body": "\r\nI am working on a modular Ethereum client [here](github.com/umbracle/minimal).\r\n\r\nMy objective with the proposal is twofold. On the one hand, lower the memory and CPU requirements to run a node. On the other hand, to have protocol backends (eth64, les, pip...) that can be added on runtime with ease. This could increase the number of use cases that can be applied on clients.\r\n\r\nA couple of examples:\r\n\r\n- Transfer data (headers, bodies, receipts...) at high speeds (maybe FTP) between two nodes that know each other.\r\n- [Private transactions](https://wiki.parity.io/Secret-Store).\r\n- Support to create clusters of nodes.\r\n\r\nThese cases are more easily achievable if the transport uses a generic streaming interface.\r\n\r\nA final note on the snappy issue. There are two types of snappy compression: normal and streaming. Each one uses his own format and they are not compatible. RLPx uses the normal mode so its not possible to do snappy streaming with RLPx.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483295115/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483364828",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483364828",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483364828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzM2NDgyOA==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T18:26:08Z",
    "updated_at": "2019-04-15T18:26:08Z",
    "author_association": "NONE",
    "body": "So I think this is a valid question to ask, is the current incarnation of devp2p/RLPx stack streamed or is it not? There are several places where streaming might break - transport level, application level, encryption, compression, etc... \r\n\r\nIn general, if at any point in the message/packet flow, the assumption that a message/packet can't be processed as it comes, without waiting for all of its parts to arrive breaks, the stack stops being streaming - i.e. if you have to wait for the full message before you can make sense of it, you're not streaming anymore. Ofcourse, each level will still need to be able to interpret the packet in some way, but only up to the point it cares about.\r\n\r\nFor example, a streaming stack can look something like this:\r\n\r\n```                                                                                         \r\n +-----------------+                                                                                                            \r\n |    Application  |   Application wants to send a number of blocks                                                             \r\n +--------|--------+   The message can contain a hint to how many blocks there would be,                                         \r\n          |            or use some termination tag to signal the end of the sequence (stream). \r\n          |             (Note how having a message size for all the blocks here breaks the streaming assumption, as we don't know what the final size is before fetching all of them)\r\n   +------------+                                                                                                               \r\n   | Blocks Msg |     Sends the first few in a message, while it fetches the next few                                           \r\n   +------|-----+                                                                                                               \r\n          |                                                                                                                     \r\n +--------|--------+                                                                                                            \r\n |     Muxing      | The muxer takes the message and negotiates a new virtual channel with the remote                           \r\n +-----------------+                                                                                                            \r\n                                                                                                                                \r\n     +-------+                                                                                                                  \r\n     | chan1 |                                                                                                                  \r\n     | Pak1  |                                                                                                                  \r\n     +-------+     Takes the incoming sequence of bytes and splits into chunks of say 512kb, prepends the chunk with                     \r\n                   the channel id and writes it over the virtual channel                                                         \r\n     +-------+                                                                                                                  \r\n     | chan1 |                                                                                                                  \r\n     | Pak2  |                                                                                                                  \r\n     +-------+                                                                                                                  \r\n+-----------------+                                                                                                             \r\n|     .......     |  Any number of additional processor can process the packets, e.g. compression, etc...                       \r\n+--------|--------+                                                                                                             \r\n         |                                                                                                                      \r\n         |                                                                                                                      \r\n+--------|--------+                                                                                                             \r\n|    Encryption   |  Encryption takes the chunks from the muxer/prev processor and encrypts it with some scheme, adding its own meta info on top            \r\n+--------|--------+                                                                                                             \r\n         |                                                                                                                      \r\n         |                                                                                                                      \r\n+--------|--------+  Finally the transport picks up the packet and sends it over a socket, which could be reliable or unreliable. \r\n|                 |  It could choose to further break the packets into smaller chunks, or the other way around, buffer a few of them before writing to the socket \r\n|    Transport    |  \r\n+-----------------+ \r\n```\r\n\r\n- a reliable protocol/transport (e.g. tcp) will take care of packet drops, ordering, etc...                \r\n- an unreliable (e.g. udp) protocol/transport won't take care of packet drops, ordering, etc... \r\n\r\nFurthermore, you can build a reliable protocol on top of udp (quick, utp, rudp)\r\n\r\nIn order to understand if RLPx/devp2p can support streaming flow, each layer needs to be revised.\r\n\r\nSo, let me rephrase the question as follows - do any of the layer of the RLPx/devp2p stack break the streaming assumptions or not?\r\n\r\n- RLP encoding, is it streaming and if so does it propagate all the way down to the protocol/transport\r\n- eth/X application level protocols, which messages are/should be streamable\r\n- compression?\r\n- encryption?\r\n- muxing\r\n- transport, etc...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483364828/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483368031",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483368031",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483368031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzM2ODAzMQ==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T18:35:33Z",
    "updated_at": "2019-04-15T18:35:33Z",
    "author_association": "NONE",
    "body": "I'll create a separate issue for - https://github.com/ethereum/devp2p/issues/71#issuecomment-483364828",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483368031/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483380933",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483380933",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483380933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzM4MDkzMw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T19:14:11Z",
    "updated_at": "2019-04-15T19:14:11Z",
    "author_association": "MEMBER",
    "body": "Also @dryajov Will you create a new issue for the requirement here https://github.com/ethereum/devp2p/issues/71#issuecomment-482796738 ? I thought it might be more appropriate if you formulate the driver/business goal/requirement how you want it. I don't mind doing it of course.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483380933/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483385218",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483385218",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483385218,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzM4NTIxOA==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T19:26:35Z",
    "updated_at": "2019-04-15T19:29:01Z",
    "author_association": "MEMBER",
    "body": "You might all want to review the Handshake part of the new discv5 proposals here https://github.com/ethereum/devp2p/blob/22b3b00d70d1ef507cfaa2d2d68aa66288da3546/discv5/discv5-wire.md\r\n\r\nMy current thinking goes like this:\r\n\r\n- We will have an encrypted channel established at the level of discovery\r\n- I think the discovery protocol need not (should not) be tied to UDP\r\n- The encrypted channel may be re-used for any message exchange, so long as the underlying transport is selected appropriately for the 'capability'. Eg: eth messages with 10MB payload can be sent over tcp using the same aes-gcm channel, while the handshaking can continue in parallel over UDP.\r\n\r\nRight now there is no capability that really requires streaming. However, should it be required, aes-gcm is a streamed (but message oriented) cypher.\r\n\r\nSo, I do wonder, if this was the route to take, the ENR would specify what transport(s) was/were in use, on which ports, and for which capabilities. The choice of if to use libp2p or any other toolset would be an arbitrary one. \r\n\r\nThoughts? (https://github.com/ethereum/devp2p/issues/83)\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483385218/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483798329",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-483798329",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 483798329,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Mzc5ODMyOQ==",
    "user": {
      "login": "dryajov",
      "id": 1094341,
      "node_id": "MDQ6VXNlcjEwOTQzNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1094341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dryajov",
      "html_url": "https://github.com/dryajov",
      "followers_url": "https://api.github.com/users/dryajov/followers",
      "following_url": "https://api.github.com/users/dryajov/following{/other_user}",
      "gists_url": "https://api.github.com/users/dryajov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dryajov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dryajov/subscriptions",
      "organizations_url": "https://api.github.com/users/dryajov/orgs",
      "repos_url": "https://api.github.com/users/dryajov/repos",
      "events_url": "https://api.github.com/users/dryajov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dryajov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-16T18:49:42Z",
    "updated_at": "2019-04-16T18:50:24Z",
    "author_association": "NONE",
    "body": "> - We will have an encrypted channel established at the level of discovery\r\n\r\nI'm not sure why encryption has to be tied to the underlying discovery mechanism? Isn't it possible to treat discovery as a totally separate element in the stack from the transport channel? Otherwise I agree, the channel should be reused _when possible_ - I'll elaborate bellow.\r\n\r\n> - I think the discovery protocol need not (should not) be tied to UDP\r\n\r\nThis is another great topic for a discussion issue. \r\n\r\nTotally agree. Although I believe the reasons behind restricting discovery to UDP is usually related to the chattiness of DHTs and kademlia in particular. By restricting traffic to a low overhead transport such as UDP, and furthermore decreasing the size of the payload to fit in an ethernet frame (mtu <=1500b), according to the discovery v5 spec, the max packet size is 1280b, this is somewhat mitigated. This are valid reasons, but they should not limit entry of platforms that don't have UDP capabilities. If anything this should be advisory? \r\n\r\nThis further reinforces my feeling that discovery should not leak its internals to other components and instead expose a high level interfaces to be consumed.\r\n\r\n> - The encrypted channel may be re-used for any message exchange, so long as the underlying transport is selected appropriately for the 'capability'. Eg: eth messages with 10MB payload can be sent over tcp using the same aes-gcm channel, while the handshaking can continue in parallel over UDP.\r\n\r\n👍 \r\n\r\n> So, I do wonder, if this was the route to take, the ENR would specify what transport(s) was/were in use, on which ports, and for which capabilities. The choice of if to use libp2p or any other toolset would be an arbitrary one.\r\n\r\nAbsolutely! I think we're thinking along the same lines, I'll go as far as suggesting that ENR records should be the lowest common denominator that all stacks agree to consume, i.e. how they are located, retrieved and stored should not be a concern of the transport layer nor the multiplexer, nor some other part of the stack.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/483798329/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/487090301",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-487090301",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 487090301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzA5MDMwMQ==",
    "user": {
      "login": "subtly",
      "id": 6557250,
      "node_id": "MDQ6VXNlcjY1NTcyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6557250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/subtly",
      "html_url": "https://github.com/subtly",
      "followers_url": "https://api.github.com/users/subtly/followers",
      "following_url": "https://api.github.com/users/subtly/following{/other_user}",
      "gists_url": "https://api.github.com/users/subtly/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/subtly/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/subtly/subscriptions",
      "organizations_url": "https://api.github.com/users/subtly/orgs",
      "repos_url": "https://api.github.com/users/subtly/repos",
      "events_url": "https://api.github.com/users/subtly/events{/privacy}",
      "received_events_url": "https://api.github.com/users/subtly/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-26T15:04:39Z",
    "updated_at": "2019-04-26T15:04:39Z",
    "author_association": "MEMBER",
    "body": "Hi @ferranbt, there's a simple solution to what you've proposed. Just put whatever your protocol is inside the message and use a messagetype of 0. RLPx is a streaming protocol with dynamically sized messages and framing (as opposed to fixed length). This way, and because the wireline is binary RLP, you can use your own encapsulation – such as protocol buffers, thrift, json, or whatever you want. If the framing doesn't work for you, you can also make your own. Re: limits, you'll see the same with UDP and TCP via MTU and other mechanisms.\r\n\r\n@dryajov and others re: #87 , please do reconsider the idea of running everything in a browser. The last thing we need is the decentralized Internet to only be available via Google Chrome or Microsoft Edge – their support for cryptography sucks, piping everything over HTTP and TLS is a regression, the CA system is broken, and they can drop support for crypto, wss, etc. whenever they feel like it.\r\n\r\n#89 Discovery wasn't intended to be restricted to UDP nor the transport restricted to TCP, but, it was intentional that this is how it was first implemented. The most significant factor though was that there wasn't enough time to develop the two protocols in such a way that they could run over either TCP or UDP. There are peculiar challenges that pop-up, like, what happens if there aren't enough nodes running discovery on one protocol or the other, and what happens if the peer you connected to before can no longer use one or the other.\r\n\r\n#90 RLPx can be used for streaming and that was the intention on day one. Should run voice or video without any problems.\r\n\r\n@ferranbt The benchmark probably has TLS using hardware-accelerated AES-GCM.\r\n\r\nA lot of whats being asked for here is orders of magnitude easier said than done. Creating, implementing and upgrading transport and discovery protocols is quite difficult and requires quite a bit of time. Have fun implementing an ethereum client and do remember to mac-then-encrypt!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/487090301/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/487091637",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-487091637",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 487091637,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzA5MTYzNw==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-26T15:08:16Z",
    "updated_at": "2019-04-26T15:08:16Z",
    "author_association": "MEMBER",
    "body": "@subtly What a lovely response. This just made my Friday evening. :-) ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/487091637/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705143031",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-705143031",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 705143031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNTE0MzAzMQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-07T19:21:01Z",
    "updated_at": "2020-10-07T19:21:01Z",
    "author_association": "MEMBER",
    "body": "Looking back at this issue, libp2p has now moved toward TLS 1.3 as the 'best' default, with a Noise-based protocol as an alternative. I would certainly be happy to remove RLPx in the long run, and since ENR support is now available in most clients, we have the means to experiment with other transports.\r\n\r\nAt the same time, it's important to understand that the numeric code + binary data message format has worked extremely well for us, and I would prefer we keep that system. It'd be nice to have a specification defining a modern transport protocol which can carry the capabilities we already have and use.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/705143031/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/719886834",
    "html_url": "https://github.com/ethereum/devp2p/issues/71#issuecomment-719886834",
    "issue_url": "https://api.github.com/repos/ethereum/devp2p/issues/71",
    "id": 719886834,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxOTg4NjgzNA==",
    "user": {
      "login": "subtly",
      "id": 6557250,
      "node_id": "MDQ6VXNlcjY1NTcyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6557250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/subtly",
      "html_url": "https://github.com/subtly",
      "followers_url": "https://api.github.com/users/subtly/followers",
      "following_url": "https://api.github.com/users/subtly/following{/other_user}",
      "gists_url": "https://api.github.com/users/subtly/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/subtly/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/subtly/subscriptions",
      "organizations_url": "https://api.github.com/users/subtly/orgs",
      "repos_url": "https://api.github.com/users/subtly/repos",
      "events_url": "https://api.github.com/users/subtly/events{/privacy}",
      "received_events_url": "https://api.github.com/users/subtly/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-31T05:20:28Z",
    "updated_at": "2020-10-31T05:20:28Z",
    "author_association": "MEMBER",
    "body": "Perhaps open a new issue, linking this one, since this is for TLS?\n\nI don't think we finished what we started with the network layer but maybe... just maybe, we can carry on from where we left off. I was hoping to have met again by now, since Osaka, but the world had other plans.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/devp2p/issues/comments/719886834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
