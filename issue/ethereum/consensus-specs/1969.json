{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1969",
  "id": 656886873,
  "node_id": "MDU6SXNzdWU2NTY4ODY4NzM=",
  "number": 1969,
  "title": "Consider the future of the VC/BN architecture",
  "user": {
    "login": "dankrad",
    "id": 6130607,
    "node_id": "MDQ6VXNlcjYxMzA2MDc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dankrad",
    "html_url": "https://github.com/dankrad",
    "followers_url": "https://api.github.com/users/dankrad/followers",
    "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
    "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
    "organizations_url": "https://api.github.com/users/dankrad/orgs",
    "repos_url": "https://api.github.com/users/dankrad/repos",
    "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dankrad/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    },
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    },
    {
      "id": 1252242617,
      "node_id": "MDU6TGFiZWwxMjUyMjQyNjE3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase2",
      "name": "phase2",
      "color": "90B44B",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 22,
  "created_at": "2020-07-14T20:43:12Z",
  "updated_at": "2021-07-05T15:02:49Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "At the moment, we have an architecture of a Beacon Node (BN) that does all networking, fork choice rule, state transition etc. work and a Validator Client (VC) whose very simple role is to keep the validator key and make sure that it doesn't sign any slashable messages. This is possible because slashable messages are very easy to determine, as they only consist of signing two blocks at the same height or violating the FFG attestation rules.\r\n\r\nHowever, in the coming phases, we will add more slashing conditions:\r\n * Signing attestations with invalid custody (phase 1)\r\n * Signing shard blocks with invalid state transitions (phase 2)\r\n * Signing eth1 blocks with invalid state transitions (phase 1.5)\r\n * Signing beacon blocks with invalid state transitions (?)\r\n\r\nIn order to be able to provide slashing protection the VC needs to include all the state transition logic. To also be able to prevent slashing due to invalid beacon chain transition, we either need a stateless beacon chain (That I think is unlikely) or the VC needs to be able to hold the beacon chain state. This will add a lot of complexity to the VC and a large part of this is duplicated from the BN.\r\n\r\nCurrently I see the following possible alternatives for the BN/VC architecture split:\r\n1. Fully maintain the current VC \"no-slash\" guarantees, meaning that the VC will have to validate all of the above properties\r\n2. Change the VC/BN relationship to a trusted one; the VC is guaranteed to keep the key, but it cannot guarantee protection from slashing if the BN is bad\r\n3. Decide that safe and easy staking is more valuable than the additional guarantees we get from fraud proofs.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658411636",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658411636",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658411636,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQxMTYzNg==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T21:02:00Z",
    "updated_at": "2020-07-14T21:02:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think at the base, there's \"complete\" trust between BN and VC. Both processes can be viewed as one entity. It's like VC trusts BN the provide the most profitable attestations and beacon blocks to sign.\r\nFrom the base, we can further enhance its security, examples like use self-signed secure gRPC connect by default and connect validator client to a remote slashing protection service are generally what we have been recommending to users.\r\nComes phase 1, the remote [slashing protection service](https://github.com/prysmaticlabs/prysm/tree/master/slasher) will need more work to support catching and preventing invalid custody attestations",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658411636/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658415929",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658415929",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658415929,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQxNTkyOQ==",
    "user": {
      "login": "mcdee",
      "id": 511384,
      "node_id": "MDQ6VXNlcjUxMTM4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/511384?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcdee",
      "html_url": "https://github.com/mcdee",
      "followers_url": "https://api.github.com/users/mcdee/followers",
      "following_url": "https://api.github.com/users/mcdee/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcdee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcdee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcdee/subscriptions",
      "organizations_url": "https://api.github.com/users/mcdee/orgs",
      "repos_url": "https://api.github.com/users/mcdee/repos",
      "events_url": "https://api.github.com/users/mcdee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcdee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T21:11:42Z",
    "updated_at": "2020-07-14T21:11:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I think at the base, there's \"complete\" trust between BN and VC\r\n\r\nI don't agree with that.  In phase 0 there is no requirement for trust between a VC and BN to prevent slashing.  A BN could feed a VC whatever lies it likes but the VC can still protect against being slashed.\r\n\r\nIn phase 0 the slashing constraint is basically \"don't change your mind\".  This is a clear instruction that requires neither trust nor knowledge of the chain state to accomplish.  An invalid block proposal (or attestation) comes with no slashing risk but does cost the proposer in terms of their lost income.  Can not the same principle be applied to subsequent phases?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658415929/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658420646",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658420646",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658420646,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQyMDY0Ng==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T21:22:57Z",
    "updated_at": "2020-07-14T21:22:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "> In phase 0 the slashing constraint is basically \"don't change your mind\". This is a clear instruction that requires neither trust nor knowledge of the chain state to accomplish. An invalid block proposal (or attestation) comes with no slashing risk but does cost the proposer in terms of their lost income. Can not the same principle be applied to subsequent phases?\r\n\r\nWhich is why I'm not advocating the VC to be protected using a local DB (\"don't change your mind\") scheme. I'm advocating VC to be connected to a remote slashing protection service. This approach is superior and also prevents duplicated validator processes signing the same attestations. In our current scheme, local DB does not protect against that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658420646/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658430769",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658430769",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658430769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQzMDc2OQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T21:48:40Z",
    "updated_at": "2020-07-14T21:48:40Z",
    "author_association": "MEMBER",
    "body": "> Comes phase 1, the remote [slashing protection service](https://github.com/prysmaticlabs/prysm/tree/master/slasher) will need more work to support catching and preventing invalid custody attestations\r\n\r\nThis is not a viable alternative, because in order to prevent invalid custody attestations, the remote service will need to know your custody secret, which can get you slashed. So you might as well completely cede trust to the remote service.\r\n\r\n> Can not the same principle be applied to subsequent phases?\r\n\r\nWell, that would be arguing for point 3 in my list. Many projects go this way, which basically means forgoing any protections from malicious supermajorities. Currently, the philosophy is different, and to minimize the potential of fraud for malicious supermajorities. This has the advantage that a much smaller stake can protect very valuable assets (as the value of the stake is not required to exceed the value of the protected assets).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658430769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658432935",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658432935",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658432935,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQzMjkzNQ==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T21:54:40Z",
    "updated_at": "2020-07-14T21:54:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This is not a viable alternative, because in order to prevent invalid custody attestations, the remote service will need to know your custody secret, which can get you slashed. So you might as well completely cede trust to the remote service.\r\n> \r\n\r\nMakes sense. We'll have to think about this one... ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658432935/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658448577",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658448577",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658448577,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODQ0ODU3Nw==",
    "user": {
      "login": "mcdee",
      "id": 511384,
      "node_id": "MDQ6VXNlcjUxMTM4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/511384?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcdee",
      "html_url": "https://github.com/mcdee",
      "followers_url": "https://api.github.com/users/mcdee/followers",
      "following_url": "https://api.github.com/users/mcdee/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcdee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcdee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcdee/subscriptions",
      "organizations_url": "https://api.github.com/users/mcdee/orgs",
      "repos_url": "https://api.github.com/users/mcdee/repos",
      "events_url": "https://api.github.com/users/mcdee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcdee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-14T22:41:43Z",
    "updated_at": "2020-07-14T22:41:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Well, that would be arguing for point 3 in my list. Many projects go this way, which basically means forgoing any protections from malicious supermajorities.\r\n\r\nDoes it lose all such protection?  Surely regardless of the weight behind it, an invalid state transition (for example) would be rejected by all nodes.\r\n\r\n> So you might as well completely cede trust to the remote service.\r\n\r\nIs this not ultimately what we expect to happen, though?  \"Remote service\" could be an MPC configuration where no minority of the parties has enough power to subvert the result.  _Something_ is going to hold the power to create a signature, but that something can be distributed enough that trust of whatever required level (within reason) can be obtained.\r\n\r\nThat said, if we move the trust relationship to be between VC and signer rather than the BN and VC, that doesn't help significantly: in phase 0 the signer doesn't need to trust the VC so we're still creating additional requirements on the signing entity.  The phase 0 slashing protection requirements are relatively straightforward and can operate without access to chain data.  If this changes in phase 1 it could cause a significant reduction in the number and safety of stakers.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658448577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658668434",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658668434",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658668434,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODY2ODQzNA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-15T09:48:52Z",
    "updated_at": "2020-07-16T11:36:08Z",
    "author_association": "MEMBER",
    "body": "> Does it lose all such protection? Surely regardless of the weight behind it, an invalid state transition (for example) would be rejected by all nodes.\r\n\r\nWell, an incorrect state transition on a shard could not be detected by most nodes, because most nodes don't follow all shards. In fact if all nodes had to follow all shards to detect invalid state transitions, sharding would not scale. Future shard blocks building on this invalid state transition would not have any evidence about a previous state transition being invalid.\r\n\r\nFor the beacon chain it's slightly more differentiated, because at least all full nodes would follow the beacon chain. So an invalid state transition would only concern beacon chain light clients. I'm still strongly in favour of protecting them from a dishonest majority of validators by having beacon chain fraud proofs.\r\n\r\nDo we need to do slashings if we have fraud proofs? It turns out that we do. The only way to have fraud proof and not make them DOS vectors is that each fraud proof comes with a guarantee that someone gets slashed:\r\n * Either the creator of the fraud proof, if it's an incorrect fraud proof (there was no actual fraud)\r\n * Or the offender (if the fraud proof turns out correct)\r\n\r\nThere is a secondary effect of doing slashings via fraud proofs, which we explicitly use in the proof of custody: It strongly discourages signing anything that you haven't actually checked (the lazy validator problem).\r\n\r\n> If this changes in phase 1 it could cause a significant reduction in the number and safety of stakers.\r\n\r\nI agree that this is a concern and that's why I mentioned option 3. We can potentially get a bit more decentralisation (by making secure staking more accessible), by leaving out all these extra fraud proofs. The disadvantage is that we lose a lot of protection from dishonest majorities that we were planning to have with Eth2. I reckon that the latter are more important and that it's ok to have a slightly higher bar for staking.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658668434/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658818971",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-658818971",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 658818971,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODgxODk3MQ==",
    "user": {
      "login": "mcdee",
      "id": 511384,
      "node_id": "MDQ6VXNlcjUxMTM4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/511384?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcdee",
      "html_url": "https://github.com/mcdee",
      "followers_url": "https://api.github.com/users/mcdee/followers",
      "following_url": "https://api.github.com/users/mcdee/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcdee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcdee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcdee/subscriptions",
      "organizations_url": "https://api.github.com/users/mcdee/orgs",
      "repos_url": "https://api.github.com/users/mcdee/repos",
      "events_url": "https://api.github.com/users/mcdee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcdee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-15T14:57:07Z",
    "updated_at": "2020-07-15T14:57:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thank you for the detailed response; I now have a better understanding of the utility of fraud proofs.\r\n\r\nI remain concerned about the difference in requirements between phase 0 and phase 1 for a signer to be able to provide slashing protection.  In phase 0 all a signer needs to protect against proposer slashing (for example) is the `BeaconBlockHeader` it is meant to sign.  This is a small data structure that does not need verification with respect to the state of the chain and allows slashing protection to be embedded relatively cheaply (inside hardware signers, for example).\r\n\r\nIf in phase 1 the signer needs to be aware of the current state of the chains (eth1 and shard), along with the ability to validate the state transitions, all while signing within the appropriate window, that seems like a big hike in terms of storage, bandwidth and computation, as well as the step change from the signer not needing to have connectivity to anything but the validator client to the signer needing full network connectivity.  This feels like a large and significant change to the requirements for a signer rather than a slight increase.\r\n\r\n(An alternative way of looking at this is that in phase 0 the validator client does not need to trust the beacon node, and the signer does not need to trust the validator, for them to operate: if a beacon node lies to a validator, for example, the validator can work this out after the fact and find another beacon node to work with.  With phase 1 there will be a much higher trust requirement because of the extended slashing events, which increases the footprint of the trusted software and reduces the ability for smaller stakers to operate effectively.)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/658818971/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659008908",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-659008908",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 659008908,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1OTAwODkwOA==",
    "user": {
      "login": "adiasg",
      "id": 25324105,
      "node_id": "MDQ6VXNlcjI1MzI0MTA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/25324105?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adiasg",
      "html_url": "https://github.com/adiasg",
      "followers_url": "https://api.github.com/users/adiasg/followers",
      "following_url": "https://api.github.com/users/adiasg/following{/other_user}",
      "gists_url": "https://api.github.com/users/adiasg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adiasg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adiasg/subscriptions",
      "organizations_url": "https://api.github.com/users/adiasg/orgs",
      "repos_url": "https://api.github.com/users/adiasg/repos",
      "events_url": "https://api.github.com/users/adiasg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adiasg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-15T21:03:31Z",
    "updated_at": "2020-07-15T21:08:41Z",
    "author_association": "MEMBER",
    "body": "> @dankrad\r\nAt the moment, we have an architecture of a Beacon Node (BN) that does all networking, fork choice rule, state transition etc. work and a Validator Client (VC) whose very simple role is to keep the validator key and make sure that it doesn't sign any slashable messages.\r\n\r\nAs @CarlBeek pointed out in the last spec call, the primary purpose of VC/BN separation is to isolate the module that handles validator keys from the one that is exposed to the network. It just so happens that the Phase 0 slashing rules do not need inputs about the state, and that slashing protection is possible on the VC. \r\n\r\nI think you want to have the VC and BN as separate actors in the validator setup. Two points about this:\r\n\r\n- Retrofitting this requirement in the current architecture doesn't seem to have any good approaches. Option 1 is redundancy without reward -- the same level of trusting the BN would be required if the BN is something that only relays messages from the p2p network to the VC (to achieve network separation of the keys), and everything else is done in the VC.\r\n\r\n- What is the advantage of this over having (BN + VC) as a single actor? The ability to use an untrusted BN-as-a-Service could be one, but anyone running a VC would have to do the expensive task of verifying their BN's suggested state transitions anyway.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659008908/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659352979",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-659352979",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 659352979,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1OTM1Mjk3OQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-16T11:33:56Z",
    "updated_at": "2020-07-16T11:33:56Z",
    "author_association": "MEMBER",
    "body": ">  This feels like a large and significant change to the requirements for a signer rather than a slight increase.\r\n\r\nAbsolutely, it's a huge increase, that's why I started this thread because I want to highlight that the current framework will not do.\r\n\r\n> What is the advantage of this over having (BN + VC) as a single actor? The ability to use an untrusted BN-as-a-Service could be one, but anyone running a VC would have to do the expensive task of verifying their BN's suggested state transitions anyway.\r\n\r\nThere is still a difference in needing to be a full participant in the P2P network vs. just validating ready made blocks that someone sends you together with parts of the history, where necessary. It would be interesting how much the difference actually is -- in terms of CPU usage, memory use and bandwidth. I would expect at least a factor of 2 in each, but likely much more. I'm hoping for some feedback from client teams on this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659352979/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659679337",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-659679337",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 659679337,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1OTY3OTMzNw==",
    "user": {
      "login": "adiasg",
      "id": 25324105,
      "node_id": "MDQ6VXNlcjI1MzI0MTA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/25324105?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adiasg",
      "html_url": "https://github.com/adiasg",
      "followers_url": "https://api.github.com/users/adiasg/followers",
      "following_url": "https://api.github.com/users/adiasg/following{/other_user}",
      "gists_url": "https://api.github.com/users/adiasg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adiasg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adiasg/subscriptions",
      "organizations_url": "https://api.github.com/users/adiasg/orgs",
      "repos_url": "https://api.github.com/users/adiasg/repos",
      "events_url": "https://api.github.com/users/adiasg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adiasg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-16T21:19:34Z",
    "updated_at": "2020-07-16T21:19:34Z",
    "author_association": "MEMBER",
    "body": "> There is still a difference in needing to be a full participant in the P2P network vs. just validating ready made blocks that someone sends you together with parts of the history, where necessary. It would be interesting how much the difference actually is -- in terms of CPU usage, memory use and bandwidth. \r\n\r\nAgreed! \r\n\r\nHowever, the most performant architecture for validators is very much dependent on the use case:\r\n\r\n1. Self-hosted validator\r\n    - Objective: Simplicity\r\n    - Use case: Hobbyist stakers running this on their home machine/cloud instance\r\n    - Architecture: Single, trusted (BN+VC) combination\r\n\r\n2. Self-hosted secret-shared validator (SSV)\r\n    - Objective: Preventing validator failure\r\n    - Use case: More serious stakers running this across their machines/cloud instances\r\n    - Architecture: BNs as p2p relay, and SSVCs that do everything else\r\n\r\n3. Staking platform\r\n    - Objective: Enabling commercialized validator services\r\n    - Use case: Untrusted BN-as-a-Service and running your own SSVs or combining SSVs from multiple custodial validator services\r\n    - Architecture: Option 1 from original post",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659679337/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659739271",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-659739271",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 659739271,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1OTczOTI3MQ==",
    "user": {
      "login": "unixpi",
      "id": 5483559,
      "node_id": "MDQ6VXNlcjU0ODM1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5483559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unixpi",
      "html_url": "https://github.com/unixpi",
      "followers_url": "https://api.github.com/users/unixpi/followers",
      "following_url": "https://api.github.com/users/unixpi/following{/other_user}",
      "gists_url": "https://api.github.com/users/unixpi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unixpi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unixpi/subscriptions",
      "organizations_url": "https://api.github.com/users/unixpi/orgs",
      "repos_url": "https://api.github.com/users/unixpi/repos",
      "events_url": "https://api.github.com/users/unixpi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unixpi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-16T23:48:11Z",
    "updated_at": "2020-07-16T23:48:11Z",
    "author_association": "MEMBER",
    "body": "> We can potentially get a bit more decentralisation (by making secure staking more accessible)\r\n\r\nThere seems to be a lot resting on this assumption. Why *a bit*, and not *a lot*?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/659739271/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660178456",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-660178456",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 660178456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDE3ODQ1Ng==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-17T15:42:38Z",
    "updated_at": "2020-07-17T15:42:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Self-hosted secret-shared validator (SSV)\r\n\r\nAnother benefit for approach 2 is network bandwidth saving. Having 1 p2p relay for N SSVCs versus  N p2p relays (approach 1)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660178456/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660369824",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-660369824",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 660369824,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDM2OTgyNA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-17T22:50:17Z",
    "updated_at": "2020-07-17T22:53:22Z",
    "author_association": "MEMBER",
    "body": "> There seems to be a lot resting on this assumption. Why _a bit_, and not _a lot_?\r\n\r\nI am going to paste my answers from the secret shared validators chat here:\r\n \r\n\r\n>    So I cannot quantify the exact difference this makes in decentralization. I can only say that I have always seen staking as having some minimal technical competence requirement -- that of setting up a Linux box, keeping it up to date, securely generating keys etc. This will essentially stay the same.\r\n>    What I however can emphasize is that it makes a huge difference to the actual security. Without these fraud proofs, one random shard assignment that puts in a dishonest majority in a shard and votes for an invalid state transition, can mess up the whole system forever -- it's an unrecoverable fault. It could create a trillion ETH. I think that is simply unacceptable.\r\n>    The second thing is that it means that without those fraud proofs, Ethereum simply cannot secure assets that are far beyond its own market cap. That is crazy. If the world's financial system will eventually run on Ethereum (not a definite but something I would like to be possible), then it would be insane to have as a first \"requirement\" for that that the ETH market cap is half of the value of that whole system. Simply not gonna happen.\r\n>    In the end, we are talking about the balance of making things easy for users or making things easy for validators. Because if things are easy for validators (no fraud proofs), they are hard for users: They will suddenly have to check huge amounts of data to be sure that no fraud has happened. I think that's the wrong tradeoff. I think when we encounter this kind of tradeoff, it should always be resolved in favour of users\r\n\r\n\r\nOne more thing to add, perhaps, is that super-easy staking -- in the form of a ready-made HSM that supposedly perfectly protects you from slashing -- may lead to more validators, but we now have essentially placed our trust in that HSM.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660369824/reactions",
      "total_count": 4,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660493196",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-660493196",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 660493196,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDQ5MzE5Ng==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-18T14:41:43Z",
    "updated_at": "2020-07-18T14:41:43Z",
    "author_association": "MEMBER",
    "body": "Here is another suggestion to get the best of both worlds:\r\nExplicitly split Beacon Nodes into the part that verifies state transitions and all the rest. Allow compiling a \"State Transition Verification\" (STV) node as a particular target. This give the flexibility:\r\n1) Somewhat more capable hardware can, in addition to running a VC, run and STV node.\r\n2) The STV node can be explicitly audited on its own, and needs to change less often than the rest of the BN code.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660493196/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660711524",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-660711524",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 660711524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDcxMTUyNA==",
    "user": {
      "login": "adiasg",
      "id": 25324105,
      "node_id": "MDQ6VXNlcjI1MzI0MTA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/25324105?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adiasg",
      "html_url": "https://github.com/adiasg",
      "followers_url": "https://api.github.com/users/adiasg/followers",
      "following_url": "https://api.github.com/users/adiasg/following{/other_user}",
      "gists_url": "https://api.github.com/users/adiasg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adiasg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adiasg/subscriptions",
      "organizations_url": "https://api.github.com/users/adiasg/orgs",
      "repos_url": "https://api.github.com/users/adiasg/repos",
      "events_url": "https://api.github.com/users/adiasg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adiasg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-19T21:20:02Z",
    "updated_at": "2020-07-19T21:20:02Z",
    "author_association": "MEMBER",
    "body": "Expanding on the last comment -- the ideal validator architecture would be microservices-based. Each major validator service would be it's own module:\r\n- Networking & P2P\r\n- State Transition\r\n- Fork Choice & Chain Management\r\n- Slashing Prevention\r\n- Signer\r\n\r\nThis has 3 major advantages:\r\n1. Allows for highly configurable clients\r\n2. Allows for easily building clients that are resilient against **any** selection of SSV requirements\r\n3. Enables a marketplace of validator microservices that is much more decentralized than simple \"custodial staking\" services\r\n\r\nOf course, this is a long-term goal given the considerable design & implementation effort involved.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/660711524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661099851",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-661099851",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 661099851,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTA5OTg1MQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-20T15:10:35Z",
    "updated_at": "2020-07-20T15:10:35Z",
    "author_association": "MEMBER",
    "body": "A quick recap of what I said during today's call:\r\n\r\n1. The only _consensus-layer_ decision is whether or not to have fraud proofs. If we have fraud proofs (which seem necessary especially since we're looking at the ethereum blockchain be used to secure assets much more valuable than ETH itself), then there's then the _client-side_ decision of how to adapt to this.\r\n2. There are two ways a client could adapt. First, it could assume the BN and VC are both trusted. Second, it could include into the VC a state transition verifier. The latter strategy would increase verification costs by 2x, but it would preserve all the invariants that VCs have today. The fact that it's a client-side choice is nice; we're not forcing either tradeoff on users.\r\n3. If a client takes the \"VC verifies state transitions\" route, this actually serves a double purpose: the state transitions could be verified using a different implementation on the VC vs on the BN, adding redundancy and more graceful degradation in the event that one of the implementations has a consensus bug. This is actually a pretty major benefit of having the VC verify state transitions.\r\n4. In response to @dankrad mentioning that slashing for fraud could exacerbate the verifier's dilemma, as it would make validators want to wait to see others' signatures to make sure they don't have a client bug, I suggested that we could always expand proof of custody to cover an execution trace.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661099851/reactions",
      "total_count": 5,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 5,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661823583",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-661823583",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 661823583,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTgyMzU4Mw==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T12:24:06Z",
    "updated_at": "2020-07-21T12:24:06Z",
    "author_association": "MEMBER",
    "body": ">     4\\. In response to @dankrad mentioning that slashing for fraud could exacerbate the verifier's dilemma, as it would make validators want to wait to see others' signatures to make sure they don't have a client bug, I suggested that we could always expand proof of custody to cover an execution trace.\r\n\r\nThere's still an interesting think to consider with respect to this: The PoC can indeed ensure that you have to do your own verification, but you may still want to wait for other signatures to ensure that it's not slashable, to be extra safe. You may also ask a centralized service that executes using all different clients and tells you if any of them fail -- leading to a situation that if any client fails, a block can't get a signature. Probably not a huge problem, but something to consider.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661823583/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/664012881",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-664012881",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 664012881,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDAxMjg4MQ==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-26T16:53:57Z",
    "updated_at": "2020-07-26T16:53:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "one design that we've been exploring, in addition to colocating BN and VC in a single process (being a single moving part has simplicity advantages - options add complexity) is that only an absolutely minimal API driven by the BN would be used for key handing - basically, it would have trivial, functional RPC calls that are given data to sign and return a signature and that's it (with full trust).\r\n\r\nThis is driven by a desire to support hardware with a minimal \"plugin\" interface so that anything underlying BLS implementation can be used to sign - in part it's because we want to encourage that the surface area of the \"thing\" that touches keys is minimized.\r\n\r\nNotably, both VC and BN could use this \"signing service\".\r\n\r\n> The state transitions could be verified using a different implementation on the VC vs on the BN\r\n\r\nwho wins in case of disagreement? In terms of risk, this means being affected by failures in either of the implementations.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/664012881/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/665804944",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-665804944",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 665804944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2NTgwNDk0NA==",
    "user": {
      "login": "unixpi",
      "id": 5483559,
      "node_id": "MDQ6VXNlcjU0ODM1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5483559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unixpi",
      "html_url": "https://github.com/unixpi",
      "followers_url": "https://api.github.com/users/unixpi/followers",
      "following_url": "https://api.github.com/users/unixpi/following{/other_user}",
      "gists_url": "https://api.github.com/users/unixpi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unixpi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unixpi/subscriptions",
      "organizations_url": "https://api.github.com/users/unixpi/orgs",
      "repos_url": "https://api.github.com/users/unixpi/repos",
      "events_url": "https://api.github.com/users/unixpi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unixpi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-29T17:42:41Z",
    "updated_at": "2020-07-30T21:58:28Z",
    "author_association": "MEMBER",
    "body": "> The only consensus-layer decision is whether or not to have fraud proofs. If we have fraud proofs (which seem necessary especially since we're looking at the ethereum blockchain be used to secure assets much more valuable than ETH itself), then there's then the client-side decision of how to adapt to this.\r\n\r\n I don't see how we can make a good decision on this until we have a better understanding of whether or not (beacon chain) fraud proofs will be too unwieldy for light clients to handle (the bottleneck may well be the data requirements rather than the verification costs).\r\n\r\nTo paste from [a comment](https://github.com/ethereum/eth2.0-specs/issues/1950#issuecomment-663830366) in [this issue](https://github.com/ethereum/eth2.0-specs/issues/1950):\r\n\r\n> If ethereum truly aspires to be the base layer of the new financial system, then we can expect most users will interact with eth2 using light clients, and probably from areas with bad coverage (rural south america, parts of africa, etc) -- if this is true, then acquiring the data, rather than the actual crypto verification, may well be the bottleneck [to verifying a fraud proof]\r\n\r\nTo quote from @dankrad's [response](https://github.com/ethereum/eth2.0-specs/issues/1950):\r\n\r\n> For the beacon chain, we haven't considered the problem that much in the past. There are some operations that require large parts of the state... The simplest way to make these fraud-proof-friendly would be to turn each of these operations into smaller steps, and commit to the state after every step. This guarantees fraud proofs of reasonable size exist, but actually constructing them will be quite complex. However, there are some other ideas that could achieve this in more elegant ways... Currently we don't know yet how difficult this will be for beacon blocks. Next step would be for someone to make a construction and see how much work it actually is :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/665804944/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/668536007",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1969#issuecomment-668536007",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1969",
    "id": 668536007,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2ODUzNjAwNw==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-04T11:16:55Z",
    "updated_at": "2020-08-04T11:16:55Z",
    "author_association": "MEMBER",
    "body": "> I don't see how we can make a good decision on this until we have a better understanding of whether or not (beacon chain) fraud proofs will be too unwieldy for light clients to handle\r\n\r\nNote that even if we don't have beacon chain fraud proofs we will still have shard chain fraud proofs. These are arguable way more necessary than beacon chain fraud proofs (because there are so many shard chains, and their individual security is lower than beacon chain security).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/668536007/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
