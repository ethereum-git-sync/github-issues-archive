{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1046",
  "id": 440445893,
  "node_id": "MDU6SXNzdWU0NDA0NDU4OTM=",
  "number": 1046,
  "title": "Little-endian vs big-endian (take 2)",
  "user": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    },
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 11,
  "created_at": "2019-05-05T13:41:02Z",
  "updated_at": "2019-07-30T14:48:51Z",
  "closed_at": "2019-07-30T14:48:51Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "In the [last endianness debate](https://github.com/ethereum/eth2.0-specs/pull/139) we decided to favour little-endianness. Since then there have been various developments (see points 1-4 in favour of big-endianness) that warrant revisiting that decision.\r\n\r\n**Pros of little-endian**\r\n\r\n1) Consistent with WASM\r\n2) Friendly to commodity hardware\r\n3) Consistent with `parity-codec`\r\n\r\n**Pros of big-endian**\r\n\r\n1) Friendly to mathematical purity and spec readability/reasonability (we get nice things such as the `i`th bit corresponding to `2**i`)\r\n2) Friendly to generalised indices and bigints (see [here](https://github.com/ethereum/eth2.0-specs/pull/1019#issuecomment-489315781))\r\n3) Consistent with SHA256 (both external and internal serialisation), and potentially friendlier to MPCs and SNARKs/STARKs that involve hashed data.\r\n4) Consistent with BLS12-381 ([Zcash's big-endian implementation](https://github.com/zkcrypto/pairing/tree/master/src/bls12_381#serialization) is likely to get standardised)\r\n5) Consistent with big number implementations\r\n6) Consistent with RLP\r\n\r\nAll things considered, big-endianness may now to be favoured option. Brief counter-arguments to the little-endianness arguments: \r\n\r\n1) \"Consistent with WASM\" is the big one that made the scales favour of little-endianness last time. Would be good to get thoughts from WASM people. cc @wanderer, @axic, @jakelang, @lrettig, @cdetrio\r\n2) As I understand \"Friendly to commodity hardware\" is a non-issue for dual-endian hardware, and a minor performance penalty for little-endian hardware.\r\n3) As I understand \"Consistent with `parity-codec`\" is an annoyance for the Parity team and can be worked around relatively easily.",
  "closed_by": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489429621",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489429621",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489429621,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQyOTYyMQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T14:04:50Z",
    "updated_at": "2019-05-05T14:04:50Z",
    "author_association": "MEMBER",
    "body": "### big-endian\r\n\r\n> Consistent with SHA256 (both external and internal serialisation)\r\n\r\nThis is crypto black-box that shouldn't affect us.\r\n\r\n> potentially friendlier to MPCs and SNARKs/STARKs that involve hashed data\r\n\r\nI understand this is your hunch, but is there any actual evidence of this? source or something?\r\n\r\n> Consistent with BLS12-381\r\n\r\ncrypto black-box. Not sure it's relevant\r\n\r\n> Consistent with big number implementations\r\n\r\nIn general? Across languages? What big int implementations are you talking about?\r\n\r\n> Consistent with RLP\r\n\r\nConsistency with VM serialization (single-endianness from top to bottom) trumps backwards compatibility imo \r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489429621/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489435794",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489435794",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489435794,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQzNTc5NA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T15:17:45Z",
    "updated_at": "2019-05-05T15:31:36Z",
    "author_association": "MEMBER",
    "body": "> This is crypto black-box that shouldn't affect us.\r\n\r\n> crypto black-box. Not sure it's relevant\r\n\r\nSerialisation of crypto black boxes may matter when those black boxes are implemented as MPC/SNARK/STARK circuits. One generally wants to reduce the depth and complexity of these circuits so avoiding unnecessary \"flip\" circuitry may help. Imagine an MPC circuit that does bigint arithmetic (naturally done using big-endian) and then does some hashing with the same bigint interpreted as data and SSZ little-endianness forces a bunch of unnecessary flipping. Imperceptible performance degradations in silicon circuits can turn out to be hugely significant in MPC or SNARK circuits.\r\n\r\n> this is your hunch, but is there any actual evidence of this? source or something?\r\n\r\nYes, just a hunch. The thought is literally from a few hours ago—arguably FUD at this point 😂 To be confirmed/denied by an MPC expert. (I will be meeting Muthu from Ligero at MIT mid-May and will discuss with him.)\r\n\r\n> In general? Across languages? What big int implementations are you talking about?\r\n\r\nMy source is @mkalinin (see [here](https://github.com/ethereum/eth2.0-specs/pull/139#issuecomment-445231093)). He writes: \"all big number implementations in Java that I've seen uses big-endian to encode/decode numbers to/from byte arrays. So does Milagro, even in C implementation\". I'm not qualified to comment beyond that.\r\n\r\n> Consistency with VM serialization trumps backwards compatibility imo\r\n\r\nAgreed. The good news that we may *not* have to enshrine VM serialisation inside consensus.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489435794/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436006",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489436006",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489436006,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQzNjAwNg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T15:20:41Z",
    "updated_at": "2019-05-05T15:21:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "Contrary to other debates like cough *signed vs unsigned*, I don't have any preference of big vs little endian but it is not true that big number implementations are big-endian:\r\n\r\n- GMP, which is probably the most used bigint library, is little endian: https://gmplib.org/manual/Integer-Internals.html\r\n- BearSSL is little-endian: https://bearssl.org/bigint.html#representation\r\n\r\nThe serialization of their internal representation is big-endian however (but even if it was little-endian you would need a specific serialization pass for most bigint/crypto libraries)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436006/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436377",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489436377",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489436377,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQzNjM3Nw==",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T15:24:59Z",
    "updated_at": "2019-05-05T15:24:59Z",
    "author_association": "MEMBER",
    "body": "From a performance point of view, most architectures support some instruction which efficiently reverses the byte order of a register value (see [BSWAP](https://c9x.me/x86/html/file_module_x86_id_21.html) on x86 or [REV](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/Cihjgdid.html) on ARM). This is specifically to support fast decoding of network packets which are received in big-endian, but could be applicable to passing and retrieving data from our WASM VM.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436535",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489436535",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489436535,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQzNjUzNQ==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T15:26:47Z",
    "updated_at": "2019-05-05T15:26:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "> dual-endian hardware\r\n\r\nvery rare, in particular, x86 and wasm are not on the list - x86 has instructions to help with bigendian (`movbe`, `bswap`), but they all work by converting back and forth, instead of operating on the data \"natively\" (there's no `addbe`).\r\n\r\n> wasm\r\n\r\nwasm in particular does not have a native byte-swapping instruction, meaning that whenever you have to \"read\" big-endian data and convert to an integer, you have to do so byte-by-byte which takes (a lot of) space - here's a trivial example of implementing a simple add function operating on data serialized as BE and LE: https://gcc.godbolt.org/z/Dlcd46 \r\n\r\ncompare how, if the data arrives in bigendian format, we have to use a lot of (contract) space to convert to little-endian and back, to perform an the operation. \r\n\r\n> Consistent with big number implementations\r\n\r\nnot sure what this means - big number implementations will typically use native endian internally for operations on the limbs (machine-word-size chunks) and compose these operations however is convenient - endianess doesn't come into play. for interoperability, big-endian is sometimes/often used during serialization, but that also depends. Here's GMP, popular bigint library supporting both endians in serialization: https://gmplib.org/manual/Integer-Import-and-Export.html - it supports both, and \"native\" for maximum efficiency when on a single platform. Most importantly, the serialization is completely arbitrary / disconnected from what goes on inside the library - it's up to the protocol to choose a serialization and be consistent.\r\n\r\nif/when we implement a bigint library for wasm, it will first convert everything to little-endian words (like the add example above), perform the operation and convert back to store it. less conversion = smaller code size.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489436535/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489437022",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489437022",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489437022,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQzNzAyMg==",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T15:32:38Z",
    "updated_at": "2019-05-05T15:32:38Z",
    "author_association": "MEMBER",
    "body": "> compare how, if the data arrives in bigendian format, we have to use a lot of (contract) space to convert to little-endian and back, to perform an the operation.\r\n\r\nWould this conversion not happen on the native machine before handing off the data to the WASM runtime via the linear memory buffer?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489437022/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489443190",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489443190",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489443190,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQ0MzE5MA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T16:48:40Z",
    "updated_at": "2019-05-05T16:48:40Z",
    "author_association": "MEMBER",
    "body": "whoops, accidentally closed. Reopened!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489443190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489629482",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489629482",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489629482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTYyOTQ4Mg==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-06T13:55:49Z",
    "updated_at": "2019-05-06T13:55:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Would this conversion not happen on the native machine before handing off the data to the WASM runtime via the linear memory buffer?\r\n\r\nI guess that depends on where the data comes from and who does the interpreting of that data - a  conversion de facto has to happen somewhere unless there's mechanical sympathy between the parts that make up the whole, something to consider when choosing the parts. I'd think we want as much as possible to be possible at the execution layer, where \"possible\" includes the notion of efficient - for example so we don't have to add to many black boxes and precompiles.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489629482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489644907",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-489644907",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 489644907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTY0NDkwNw==",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-06T14:38:26Z",
    "updated_at": "2019-05-06T14:38:35Z",
    "author_association": "MEMBER",
    "body": "> I guess that depends on where the data comes from and who does the interpreting of that data\r\n\r\nSince the data will flow into and out of the the WASM runtime via the [EEI](https://github.com/ewasm/design/blob/master/eth_interface.md), I figured a reverse operation could occur at that boundary in the native client.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489644907/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/490430294",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-490430294",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 490430294,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MDQzMDI5NA==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-08T10:12:34Z",
    "updated_at": "2019-05-08T10:12:34Z",
    "author_association": "MEMBER",
    "body": "> not sure what this means - big number implementations will typically use native endian internally for operations on the limbs (machine-word-size chunks) and compose these operations however is convenient - endianess doesn't come into play\r\n\r\nSpeaking of big numbers endianness may be used to specify an order of limbs in its representation. That what I meant in the post about Java big number impl; it uses an order with most significant byte (limb = byte) first ~ _big-endian_ with no other options. \r\n\r\nWhy big numbers may matter? Cause, starting from `UIntN, N > 64` type any language will have to use big number impl to carry values of these type as they are bigger than a word that processor's register can handle. But it's hardly the case that such types will come into play.\r\n\r\nFor `UInt64` types _little-endian_ is obviously a win for languages that able to work with memory pointers (C, C++, Go, Rust, etc.).\r\n\r\nWith regard to crypto black boxes. The best way for SSZ would be to serialise them as pure byte string which represents serialisation format of particular crypto black box, just in the same way we do it for BLS points.\r\n\r\n> I guess that depends on where the data comes from and who does the interpreting of that data \r\n\r\nThe only way for WASM to benefit from keeping SSZ _little-endian_ that I can see is avoiding flipping in SSZ implementation written in WASM.\r\n\r\nbig-endian pros:\r\n- conformance with some big number implementations (maybe most significant part of them), a case that has low probability due to our needs\r\n\r\nlittle-endian pros:\r\n- often win for a number of languages\r\n- win for WASM implementation of SSZ\r\n\r\nComparing both pros makes me think of keeping _little-endian_ for SSZ as a rational decision.\r\n\r\nP.S. A discussion on endianness in different systems that I've found an interesting one https://news.ycombinator.com/item?id=9451284",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/490430294/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/491500528",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-491500528",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 491500528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MTUwMDUyOA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-11T10:47:38Z",
    "updated_at": "2019-05-11T10:50:34Z",
    "author_association": "MEMBER",
    "body": "A couple more pros for big endian:\r\n\r\n* Big-endianness feels more natural to humans that are accustomed with decimal place value\r\n* The standard way to serialize big endian into hex doesn't have the awkward mixed endian effect that little endian does (eg. the number `2 * 2**12 + 3 * 2**8 + 4 * 2**4 + 5` in big endian is `0x2345` but in little endian is `0x4523` which is just so hard to read)\r\n* With big endians, we have the invariant `(a > b)` <-> `(int_to_bytesn(a) > int_to_bytesn(b))`\r\n\r\n> Since the data will flow into and out of the the WASM runtime via the EEI, I figured a reverse operation could occur at that boundary in the native client.\r\n\r\nIt's worth noting that most of the serialization is going to happen on layers higher than the base protocol; eg. in the phase 2 proposal the \"transaction\" that gets passed into the top-level execution is just a bytearray. So if WASM is little endian and SSZ is big endian there is going to be _a lot_ of byte flipping code at _many_ levels of the stack.\r\n\r\nAnd this is honestly a big pro for little endian especially given our goals with abstraction. So it does seem like WASM is forcing our hand....\r\n\r\nAgree that BLS-12-381 and SHA256 are black boxes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/491500528/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/516453024",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1046#issuecomment-516453024",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1046",
    "id": 516453024,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNjQ1MzAyNA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-30T14:48:51Z",
    "updated_at": "2019-07-30T14:48:51Z",
    "author_association": "MEMBER",
    "body": "Closed as phase 0 spec is frozen",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/516453024/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
