{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1449",
  "id": 513006258,
  "node_id": "MDU6SXNzdWU1MTMwMDYyNTg=",
  "number": 1449,
  "title": "Slowing down shard activity if crosslinking fails",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2019-10-27T18:58:57Z",
  "updated_at": "2019-11-03T17:23:17Z",
  "closed_at": "2019-11-03T17:23:17Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "In the case where blocks from a shard are not crosslinked for a long time, there is a chain of shard blocks of growing length that must eventually be included in a shard block. Currently, the intention is that these blocks can be included a maximum of 256 at a time.\r\n\r\nHowever, there are challenges to this approach:\r\n\r\n* In an attestation, we have to choose between either (i) creating an attestation with many custody bits, adding complexity and overhead to handle this or (ii) using one custody bit over many blocks, requiring a 2-round game for fraud proofs.\r\n* In an attestation, a large amount of data representing shard blocks and intermediate state roots would need to be included\r\n* There are two cases in which crosslinking can be delayed:\r\n  1. There are very few validators online so only a few shards are processed every slot, requiring many slots to cycle back to any given shard (eg. at 256k ETH, it takes the maximum 64 slots)\r\n  2. There is an active attack due to committees being >1/3 inactive\r\n* In the first case, there are very few validators, so it is not reasonable to ask them to verify so much data, so a reduction in the shard chain capacity seems correct. In the second case, reduction in capacity during an attack also seems like a reasonable safety measure, especially in the case where an attack happens due to network DoS.\r\n* There is limited value in preserving high performance for intra-shard communication when cross-shard communication is stalled.\r\n\r\nTo remedy these issues, I suggest adding the following rule. Suppose the current slot is `CURRENT_SLOT` and the shard chain on a given shard was included up to `LAST_INCLUDED_SLOT`. We define a set of offsets, eg. `offsets = [1, 2, 4, 8, 16, 32, 64, 128, 256]`, and require an attestation to include blocks for slot `LAST_INCLUDED_SLOT + offset` for any offset in `offsets` such that `LAST_INCLUDED_SLOT + offset < CURRENT_SLOT`. That is, if crosslinks stop happening, the slots on a shard chain that are allowed to be nonempty start to back-off exponentially.\r\n\r\nOffsets can be chosen to be more \"forgiving\" at the beginning, eg. one could choose Fibonacci numbers instead of 2: `[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]` or even `[1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 32, 64, 128]`.\r\n\r\n### Why not shrink shard blocks instead of increasing inter-shard-block distances?\r\n\r\n* Simpler: does not require logic for fitting multiple shard blocks into a single custody bit or fraud proof object\r\n* Removing capability of including large transactions may well be _more_ harmful than increasing block times, eg. consider large fraud proofs, STARKs, etc\r\n* We lose fast cross-shard tx times in these circumstances anyway",
  "closed_by": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449/reactions",
    "total_count": 4,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 2,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/546990812",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1449#issuecomment-546990812",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449",
    "id": 546990812,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0Njk5MDgxMg==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-10-28T15:07:35Z",
    "updated_at": "2019-10-28T15:07:35Z",
    "author_association": "MEMBER",
    "body": "I think this is a good idea! I think I've suggested the reduction mechanism before, with my main reason being that otherwise, the load on validators will increase by an unreasonable amount when crosslinking stops. This might create negative feedback loops that lead to more validators dropping out in bad network conditions, and might also be exploitable by an attacker.\r\n\r\n>     * In an attestation, we have to choose between either (i) creating an attestation with many custody bits, adding complexity and overhead to handle this or (ii) using one custody bit over many blocks, requiring a 2-round game for fraud proofs.\r\n\r\nI actually quite like suggestion (i), I think it will be a lot less complex than dynamically introducing a two-round custody game.\r\n\r\nAlso, I think realistically, the two-round custody proof will not be executable by MPC validators in the given time now (except if they are in colocation). But since these custody bits can be computed independently, the load will actually not increase with solution (i). So that's a big advantage -- I think it\r\n\r\n> Why not shrink shard blocks instead of increasing inter-shard-block distances?\r\n\r\nI think the idea to skip block instead of shrinking them is great! Processing a block will presumably also have its own overhead so this is a much more efficient way of shedding load.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/546990812/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547058200",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1449#issuecomment-547058200",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449",
    "id": 547058200,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzA1ODIwMA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-10-28T17:27:46Z",
    "updated_at": "2019-10-28T17:27:46Z",
    "author_association": "MEMBER",
    "body": "> I actually quite like suggestion (i), I think it will be a lot less complex than dynamically introducing a two-round custody game.\r\n\r\nI agree! And it's not that complex at all, here is a design that ensures that the increase in pairings for N custody bits is linear rather than exponential: https://github.com/ethereum/eth2.0-specs/issues/1448\r\n\r\nGlad that we're still on the same page re sticking to one-round custody games; I think the ability to have \"one fraud proof to rule them all\" is a huge simplification that we should try hard to stick to.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547058200/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547376874",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1449#issuecomment-547376874",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1449",
    "id": 547376874,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzM3Njg3NA==",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-10-29T11:30:36Z",
    "updated_at": "2019-10-29T11:52:59Z",
    "author_association": "MEMBER",
    "body": "> There are two cases in which crosslinking can be delayed:\r\n\r\nIs there also a case: if the beacon chain block slot is skipped?\r\n(*edited*) If so, it seems the new approach would give the beacon chain proposer some power to suspend the shard attestations inclusion.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547376874/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
