{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1950",
  "id": 650009929,
  "node_id": "MDU6SXNzdWU2NTAwMDk5Mjk=",
  "number": 1950,
  "title": "Beacon chain fraud proofs",
  "user": {
    "login": "dankrad",
    "id": 6130607,
    "node_id": "MDQ6VXNlcjYxMzA2MDc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dankrad",
    "html_url": "https://github.com/dankrad",
    "followers_url": "https://api.github.com/users/dankrad/followers",
    "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
    "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
    "organizations_url": "https://api.github.com/users/dankrad/orgs",
    "repos_url": "https://api.github.com/users/dankrad/repos",
    "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dankrad/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    },
    {
      "id": 1252242617,
      "node_id": "MDU6TGFiZWwxMjUyMjQyNjE3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase2",
      "name": "phase2",
      "color": "90B44B",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2020-07-02T15:10:23Z",
  "updated_at": "2020-08-04T11:22:34Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Without beacon chain fraud proofs, light clients cannot be protected against incorrect beacon chain state transitions. This means a dishonest majority of validators can create a beacon chain with an incorrect state transition, for example creating lots of Ether and giving it to some validators.\r\n\r\nIn addition, since signing incorrect beacon blocks cannot be made slashable without a fraud proof mechanism, it means that validators can do this in parallel to building on the \"honest\" beacon chain without risk, even creating a justified (but not a finalized) alternative chain. All they need to do is miss a few attestations on the valid chain to build an attack chain with an incorrect state transition.\r\n\r\nAlso, not having beacon block fraud proofs creates an incentive problem where the dominant strategy is signing without validating blocks.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/662152907",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-662152907",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 662152907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjE1MjkwNw==",
    "user": {
      "login": "unixpi",
      "id": 5483559,
      "node_id": "MDQ6VXNlcjU0ODM1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5483559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unixpi",
      "html_url": "https://github.com/unixpi",
      "followers_url": "https://api.github.com/users/unixpi/followers",
      "following_url": "https://api.github.com/users/unixpi/following{/other_user}",
      "gists_url": "https://api.github.com/users/unixpi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unixpi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unixpi/subscriptions",
      "organizations_url": "https://api.github.com/users/unixpi/orgs",
      "repos_url": "https://api.github.com/users/unixpi/repos",
      "events_url": "https://api.github.com/users/unixpi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unixpi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T23:12:30Z",
    "updated_at": "2020-07-22T13:02:44Z",
    "author_association": "MEMBER",
    "body": "I'm still trying to grasp all the moving parts, but i guess my main concern right now is the following:\r\n\r\nIf ethereum truly aspires to be the base layer of the new financial system, then we can expect most users will interact with eth2 using light clients, and probably from areas with bad coverage (rural south america, parts of africa, etc) -- if  this is true, then acquiring the data, rather than the actual crypto verification, may well be the bottleneck.\r\n\r\nFrom what i understand so far, it just seems like light-client security isn't all that good if we only rely on on-chain fraud-proofs (and that this is particularly true in the dishonest majority case) because it may take a while for the light-client to realise that the network is under attack (and very long rollbacks are possible).**\r\n\r\nSo i guess I see two problems:\r\n\r\n1. Data as a bottleneck\r\n2. Long rollbacks of transactions performed by unaware users\r\n\r\nI don't have any good ideas to address the first (although i do think it's something we need to think harder about).\r\n\r\nTo try and address the second, I suggest we consider gossiping fraud proofs (while this won't prevent rollbacks, it will at least allow clients to be aware that the network is under attack).\r\n\r\n---------\r\n**To elaborate a little here, if the majority of full nodes are dishonest, then the majority of block producers are dishonest, so you might have to wait a while for a fraud-proof to be included on-chain. In the meantime, light-clients are transacting as if nothing has happened. I think it's important to minimise the time delay between the attack and users being aware that the attack is happening so they don't perform potentially irreversible (or hard-to-reverse) transactions in the non-crypto world. In sum, if a light-client can be made aware of an attack quicker, it can help prevent users from shooting themselves in the foot.\r\n\r\n### Resources\r\n- [Fraud proofs — Secure on-chain scalability](https://hackernoon.com/fraud-proofs-secure-on-chain-scalability-f96779574df)\r\n- [Compact Fraud Proofs for UTXO Chains Without Intermediate State Serialization](https://ethresear.ch/t/compact-fraud-proofs-for-utxo-chains-without-intermediate-state-serialization/5885)\r\n- [Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities](https://arxiv.org/abs/1809.09044)\r\n- [Bitcoin: A Peer-to-Peer Electronic Cash System (section 8)](https://bitcoin.org/bitcoin.pdf)\r\n\r\n(Thank you @adiasg  for your infinite patience, and for helping me better understand my own concerns :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/662152907/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/662325369",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-662325369",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 662325369,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjMyNTM2OQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-22T08:41:19Z",
    "updated_at": "2020-07-22T08:41:19Z",
    "author_association": "MEMBER",
    "body": "> To try and address the second, I suggest we consider gossiping fraud proofs (while this won't prevent rollbacks, it will at least allow clients to be aware that the network is under attack).\r\n\r\nAbsolutely -- it is essential that fraud proofs are gossiped and respected without being on chain. The on-chain exclusion is only for punishment. And since in this case it's on an invalid chain, it would actually not matter whether it's included on that chain. It's included on the \"honest\" chain to remove the stake of the attackers.\r\n\r\n\r\n> To elaborate a little here, if the majority of full nodes are dishonest, then the majority of block producers are dishonest, so you might have to wait a while for a fraud-proof to be included on-chain.\r\n\r\nMuch worse that this, since the malicious nodes are in the majority, they can easily stop the fraud proof from ever being included.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/662325369/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/663773484",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-663773484",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 663773484,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2Mzc3MzQ4NA==",
    "user": {
      "login": "unixpi",
      "id": 5483559,
      "node_id": "MDQ6VXNlcjU0ODM1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5483559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unixpi",
      "html_url": "https://github.com/unixpi",
      "followers_url": "https://api.github.com/users/unixpi/followers",
      "following_url": "https://api.github.com/users/unixpi/following{/other_user}",
      "gists_url": "https://api.github.com/users/unixpi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unixpi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unixpi/subscriptions",
      "organizations_url": "https://api.github.com/users/unixpi/orgs",
      "repos_url": "https://api.github.com/users/unixpi/repos",
      "events_url": "https://api.github.com/users/unixpi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unixpi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-24T23:34:18Z",
    "updated_at": "2020-07-24T23:34:18Z",
    "author_association": "MEMBER",
    "body": "Happy to hear :)\r\nTrying to get a better handle on the size of the proofs.\r\n\r\nAre we planning on using intermediate states (outlined in [this paper](https://arxiv.org/pdf/1809.09044.pdf))?\r\n\r\nIf so, how do we handle the problem articulated [here](https://ethresear.ch/t/compact-fraud-proofs-for-utxo-chains-without-intermediate-state-serialization/5885):\r\n\r\n > If P [the interval between intermediate states] is too large, then fraud proofs quickly become unwieldy for light clients in practice despite identical asymptotic costs. If P is too small, state serialization costs grow. It turns out there’s no good way of picking P...\r\n\r\nif not, do we have a design that ensures fraud proofs don't become too unwieldy for light clients?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/663773484/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/663830366",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-663830366",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 663830366,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MzgzMDM2Ng==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-25T08:51:12Z",
    "updated_at": "2020-07-25T08:51:12Z",
    "author_association": "MEMBER",
    "body": "(Note that for shard chains, this will not be a problem -- since we are constructing them to be stateless, the shard block itself is already a suitable fraud proof).\r\n\r\nFor the beacon chain, we haven't considered the problem that much in the past. There are some operations that require large parts of the state:\r\n1. The balance updates at the end of every epoch.\r\n2. Checking attestations requires the state of many validators (key, effective balance, slashed).\r\n(There may be more that can't think off right now).\r\n\r\nThe simplest way to make these fraud-proof-friendly would be to turn each of these operations into smaller steps, and commit to the state after every step. This guarantees fraud proofs of reasonable size exist, but actually constructing them will be quite complex. However, there are some other ideas that could achieve this in more elegant ways:\r\n\r\n1. For the balance updates, we could make them probabilistic -- say only update 1/100th of the balances each block (and give those 100x the reward). This is ok, since validators are expected to be in the game for much more than 100 epochs.\r\n2. Change some of the commitments to linear ones -- for example, if we make the balances Kate commitments, then a large number of updates could just become a vector addition (however, there would still be the problem of creating the difference vector, which could be done more iteratively in the beacon blocks before the update).\r\n\r\nCurrently we don't know yet how difficult this will be for beacon blocks. Next step would be fore someone to make a construction and see how much work it actually is :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/663830366/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/665781356",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-665781356",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 665781356,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2NTc4MTM1Ng==",
    "user": {
      "login": "unixpi",
      "id": 5483559,
      "node_id": "MDQ6VXNlcjU0ODM1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5483559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unixpi",
      "html_url": "https://github.com/unixpi",
      "followers_url": "https://api.github.com/users/unixpi/followers",
      "following_url": "https://api.github.com/users/unixpi/following{/other_user}",
      "gists_url": "https://api.github.com/users/unixpi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unixpi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unixpi/subscriptions",
      "organizations_url": "https://api.github.com/users/unixpi/orgs",
      "repos_url": "https://api.github.com/users/unixpi/repos",
      "events_url": "https://api.github.com/users/unixpi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unixpi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-29T16:54:55Z",
    "updated_at": "2020-07-29T16:54:55Z",
    "author_association": "MEMBER",
    "body": "> This guarantees fraud proofs of reasonable size exist, but actually constructing them will be quite complex.\r\n\r\nCould you elaborate a little on this?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/665781356/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/668538324",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1950#issuecomment-668538324",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1950",
    "id": 668538324,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2ODUzODMyNA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-04T11:22:34Z",
    "updated_at": "2020-08-04T11:22:34Z",
    "author_association": "MEMBER",
    "body": "> Could you elaborate a little on this?\r\n\r\nBasically, all of the spec logic would have to be extremely modularized so that it can be run on small diffs of the state. Additionally, some operations will currently read almost all of the state, and we would need to find more elaborate data structures that make caches of computations so that they can be broken up into smaller steps that don't access too much of the state.\r\n\r\nAll of this is possible but it's a deep rabbit hole. If the spec logic were \"inspectable\" (like VM code), then some of this could be automated, but it isn't, so I expect this to be a rather laborious process. [Yes, it's specified as python code and you could see that as a form of inspectable code -- the problem is that concrete client implementations don't use this form and could have a very different logic]",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/668538324/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
