{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1713",
  "id": 596680626,
  "node_id": "MDU6SXNzdWU1OTY2ODA2MjY=",
  "number": 1713,
  "title": "Invalid empty attestation signatures consensus split",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043866,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:bug",
      "name": "general:bug",
      "color": "DD1C1A",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 1534063048,
      "node_id": "MDU6TGFiZWwxNTM0MDYzMDQ4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:BLS",
      "name": "scope:BLS",
      "color": "fef2c0",
      "default": false,
      "description": ""
    },
    {
      "id": 1725628406,
      "node_id": "MDU6TGFiZWwxNzI1NjI4NDA2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase0",
      "name": "phase0",
      "color": "c2e0c6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 18,
  "created_at": "2020-04-08T15:49:25Z",
  "updated_at": "2020-07-20T15:04:09Z",
  "closed_at": "2020-07-20T14:09:27Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Some context:\r\n- v0.11.1 had a test helper function change an empty signature from 0xc000... to 0x0000. Completely zero, instead of valid but empty.\r\n- Up to v0.11.0 attestations with no participants were considered valid for some reason, and we had a testcase covering it. (I don't agree with it being a valid case though)\r\n- v0.11.1 also misses the post-state file for some reason, making the empty aggregation bits an anvalid case. And clients pass it, not because they added the rule, but because the 0x0000 signature is invalid.\r\n- I stumbled on this after testing it in a 3rd implementation (ZRNT, Go still, but with different state representation, more like remerkleable)\r\n\r\nThe scope of the bug:\r\n- The BLS spec has a pre-condition that states that verifying with 0 pubkeys are undefined behavior. [`   Precondition: n >= 1, otherwise return INVALID.`](https://tools.ietf.org/html/draft-irtf-cfrg-bls-signature-02#section-2.9) (Thanks @hwwhww for retrieving this from the specs)\r\n- The previous Eth2 spec versions considered empty attestations included in blocks valid. There was an `empty_aggregation_bits` test case that described it as valid: https://github.com/ethereum/eth2.0-spec-tests/tree/v0.11.0/tests/minimal/phase0/operations/attestation/pyspec_tests/empty_aggregation_bits\r\n- Py-ecc previously handled the 0 pubkeys case as a valid case; the `0xc00000....` signature is valid for no pubkeys.\r\n- The network spec requires attestations on gossip to have exactly 1 bit set, so the network spec is not affected\r\n- The beacon spec just verifies the empty signature. Not all empty signatures are valid. `0x000...` is not. `0xc000...` is.\r\n- Prysm and ZRNT ignore the signature if no bits are set. (ZRNT with a TODO statement): [Prysm](https://github.com/prysmaticlabs/prysm/blob/cdac3d61ea1a4839ce7292bd7006580f10bc4e93/beacon-chain/core/blocks/block_operations.go#L861) [ZRNT](https://github.com/protolambda/zrnt/blob/1a36b8d455d02ac5146c607217b10f931fd1db89/eth2/beacon/attestations/indexed.go#L67)\r\n- Lighthouse puts the attestation signatures in a `SignatureSet`, and then verifies it as a whole. This would allow the `0xc000` signature to pass without pubkeys I think. But not other invalid signatures.\r\n- Other clients have to be checked, there could be more edge cases. If we can agree on what it should be, I will write new spec tests to cover it.\r\n\r\nAction points:\r\n- Empty signatures are a dangerous new edge case to attestation processing. Requiring the BLS library to handle the undefined behavior well, or the client to implement the edge case correctly (not like Prysm and ZRNT). We need to be more explicit about this behavior, and possible make it invalid. There should be no reason to include no-participant attestations on chain. Size is not the problem as proposers can already fill their block with duplicates, but just having the empty-signature case at all is bad.\r\n- A chain split could be caused between Prysm and Lighthouse if someone mines a block with an attestation containing an empty bitfield, but an invalid signature. (Which could be a valid looking one still, but not valid for empty set of pubkeys). Prysm will stay on that chain, lighthouse will split away from that chain.\r\n\r\nLabeling it as a bug, although the spec is not necessarily wrong, it is definitely a case that should get attention to avoid clients splitting chains in the future.\r\n\r\n@djrtwo @CarlBeek",
  "closed_by": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611049757",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-611049757",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 611049757,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTA0OTc1Nw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-08T16:11:17Z",
    "updated_at": "2020-04-08T16:11:47Z",
    "author_association": "MEMBER",
    "body": "There are going to be places in the protocol in the future where there will be a single aggregate signature, and not a list of aggregates; for example even in phase 1 there's the light client aggregate. And so in such a situation, the degenerate case is not going to be an empty list of attestations as it is elsewhere, it will be a single aggregate signature that is empty. To avoid requiring higher-layer extra logic around that case, it seems to me reasonable to make zero a valid signature for an empty list of pubkeys and messages. This case would get actually triggered when eg. somehow no one from the light client committee shows up to get included in a block.\r\n\r\nWe could add a separate rule banning empty attestations from phase 0 if desired; seems pointless to allow them.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611049757/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611052443",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-611052443",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 611052443,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTA1MjQ0Mw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-08T16:16:30Z",
    "updated_at": "2020-04-08T16:16:30Z",
    "author_association": "MEMBER",
    "body": "> We could add a separate rule banning empty attestations from phase 0 if desired; seems pointless to allow them.\r\n\r\nBut leaving them in does not break anything, and introducing breaking changes at this point should imo only be done to fix serious issues.\r\n\r\n-------------\r\n\r\nPreventing 0 attestations barely affects the scope of behavior and attack surface.\r\n\r\nA rational actor would find more valuable attestations anyway, and not want to pack the block overly full, increasing the size of the block and time to compute.\r\n\r\nAs for the argument of “packing” the block with crap, the proposer could easily just put duplicate attestations (of high participation and thus more computational load) or just put a bunch of single bit attestations.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611052443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611055648",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-611055648",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 611055648,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTA1NTY0OA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-08T16:22:18Z",
    "updated_at": "2020-04-08T16:22:55Z",
    "author_association": "MEMBER",
    "body": "I am not concerned about the spam as much, but about it being a weird edge case that already has clients to disagree now, and likely in the future if we leave it as-is. Being more explicit about validity conditions would be good, especially because the BLS spec itself has its own requirements (the `>= 1` case). And many libraries, such as the two Go version, simply crash or give undefined answers on empty pubkey list inputs. Having clients improvise to interpret the spec is what caused the current potential chain split.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611055648/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611174320",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-611174320",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 611174320,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTE3NDMyMA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-08T20:23:19Z",
    "updated_at": "2020-04-08T20:23:19Z",
    "author_association": "MEMBER",
    "body": "> But leaving them in does not break anything, and introducing breaking changes at this point should imo only be done to fix serious issues.\r\n\r\nThat's fair. Especially with compression, an empty attestation is close to zero overhead anyway. So I'd be happy with specifying that BLS aggregate signatures with 0 pubkeys are in general allowed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611174320/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611272123",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-611272123",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 611272123,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTI3MjEyMw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-09T01:08:23Z",
    "updated_at": "2020-04-09T01:08:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "Giving some feedback as per @protolambda's request :)\r\n\r\n> it seems to me reasonable to make zero a valid signature for an empty list of pubkeys and messages\r\n\r\nThis also seems reasonable to me. I assume the intention is that _only_ `0x00..00` is valid for 0 pubkeys? I prefer this otherwise we have some weird form of signature malleability. \r\n\r\n> I am not concerned about the spam\r\n\r\nSame for me.\r\n\r\n> Being more explicit about validity conditions would be good\r\n\r\nAgreed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/611272123/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/613817061",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-613817061",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 613817061,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzgxNzA2MQ==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-15T05:00:29Z",
    "updated_at": "2020-04-15T05:00:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Being more explicit about validity conditions would be good, especially because the BLS spec itself has its own requirements (the >= 1 case).\r\n\r\nThis would make sense and I would agree with this, being explicit here is a definite plus. I would be ok with verifying that a signature was `0xc00...` if no bits were set in the accompanying bitfield. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/613817061/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/618319475",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-618319475",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 618319475,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxODMxOTQ3NQ==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-23T10:24:08Z",
    "updated_at": "2020-04-23T10:24:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "There are 2 layers where invalid signatures are handled:\r\n1. Low-level: Milagro, MCL\r\n2. High-level: The client\r\n\r\nCurrently due to testing, fuzzing (and invalid signatures in deposits?) we have a wrapper to handle valid signatures at a low-level (i.e. point on the G2 curve) and invalid signatures but that we accept because of protocol or test/fuzzing requirements. We may add in the future another case with lazy loaded signatures (i.e. we stored it in a database on shutdown and reload it in the future).\r\n```Nim\r\ntype\r\n  BlsValueType* = enum\r\n    Real\r\n    OpaqueBlob\r\n\r\n  BlsValue*[N: static int, T] = object\r\n    # N = 48 for public keys and N = 96 for Signature\r\n    case kind*: BlsValueType\r\n    of Real:\r\n      blsValue*: T\r\n    of OpaqueBlob:\r\n      blob*: array[N, byte]\r\n```\r\n\r\nIn the low-level layer, it is very easy to check if a signature is valid or not: it's not a point on the curve and the underlying library will not parse it. For example `0x0000...` (full-zero) is invalid while `0xc000...` is valid and a point at infinity. This is derived from elliptic curve maths and so does not need to be specified.\r\n\r\nAt the high-level layer, there is a huge potential for divergence and as @nisdas said, being explicit is important as are test cases.\r\nIn particular what is the zero signature:\r\n- a point at infinity `0xc000`\r\n- a binary zero blob `0x0000`\r\n- in which case is it valid?\r\n  - when accompanied by an empty aggregation bitset?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/618319475/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620959262",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-620959262",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 620959262,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMDk1OTI2Mg==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-29T02:33:43Z",
    "updated_at": "2020-04-29T02:33:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "Have we reached a conclusion yet?\r\n\r\nFrom my point of view I think we have two options which I prefer option 1:\r\n\r\n# Option 1\r\nRequest a change to the BLS specs such that if n = 0 i.e. `PublicKeys = []` then `[]` aggregates to the identity. As it makes aggregation simpler i.e. \r\n```python\r\naggregate_public_key = 0\r\nfor key in public_keys:\r\n    aggregate_public_key += key\r\n```\r\nRather than specifically handling the `n = 0` case.\r\n\r\nIf this were the case we would simply have \r\n- AggregateSignature = 0x00... always return false as it is not a valid point on curve.\r\n- AggregateSignature = 0xc00... return true for PublicKeys `[]` and `[0xc00...]` (i.e. PublicKey at point 0)\r\n\r\n# Option 2\r\nLeave BLS spec as is and handle in the Ethereum layer the case where `AggregateSignature = 0x00` and `publickeys = []` specifically to return true before interacting with the BLS layer.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620959262/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620961500",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-620961500",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 620961500,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMDk2MTUwMA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-29T02:44:34Z",
    "updated_at": "2020-04-29T02:44:34Z",
    "author_association": "MEMBER",
    "body": "I am opposed to Option 1 as it requires changes in the BLS spec (big or not, it's friction), and it doesn't solve for the real issue: clients have to get this right and not rely on libraries to work-around. If one library accepts 0 pubkeys, the other doesn't, and yet another is somewhere in between, then clients have to track those edge cases to stay in consensus. And properly implement work arounds.\r\n\r\nOption 2 is better, as it does not require anything from the BLS spec, and is super straigtforward to implement and test:\r\n- `0` participants is invalid case, unless signature is `0x000...`\r\n- `> 0` participants is valid only if the signature is valid for those pubkeys.\r\n\r\nAnd better (IMHO) would be an Option 3, to remove one branch of decision making:\r\n- `0` participants is an invalid case, no exceptions\r\n- `> 0` participants is valid only if the signature is valid for those pubkeys.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620961500/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620969610",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-620969610",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 620969610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMDk2OTYxMA==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-29T03:23:23Z",
    "updated_at": "2020-04-29T03:23:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I am opposed to Option 1 as it requires changes in the BLS spec (big or not, it's friction), and it doesn't solve for the real issue: clients have to get this right and not rely on libraries to work-around. If one library accepts 0 pubkeys, the other doesn't, and yet another is somewhere in between, then clients have to track those edge cases to stay in consensus. And properly implement work arounds.\r\n\r\nFrom this option all logic would now be in the BLS layer and none in the Ethereum layer which is appealing. However, as you mentioned you would like public keys `[]` to return false which this will not.\r\n\r\nI like this option mostly as I think the BLS spec is not implementation friendly in its current form and I would like to change it anyway.\r\n\r\n> And better (IMHO) would be an Option 3, to remove one branch of decision making:\r\n>\r\n> `0` participants is an invalid case, no exceptions\r\n> `> 0` participants is valid only if the signature is valid for those pubkeys.\r\n\r\nI do see the appeal of option 3 over option 2 in avoiding changes to BLS spec. And in that `AggregateSignature 0x00..` will always be false and as the BLS spec is `PublicKeys []` will also always be false.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620969610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621022664",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-621022664",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 621022664,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMTAyMjY2NA==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-29T06:53:44Z",
    "updated_at": "2020-04-29T06:53:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "> From this option all logic would now be in the BLS layer and none in the Ethereum layer which is appealing. However, as you mentioned you would like public keys [] to return false which this will not.\r\n\r\n> I like this option mostly as I think the BLS spec is not implementation friendly in its current form and I would like to change it anyway.\r\n\r\nDo you anticipate that it would be easy enough to get this included in the spec ? I would prefer to have everything under our control if possible,and the best way to do that would be to handle this in the application layer.\r\n\r\nI would prefer option 3 as it is mostly straightforward to implement and I do not see any valid case for having an attestation with 0 participants. Its effectively just junk in the block that client's will have to process and verify.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621022664/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621033578",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-621033578",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 621033578,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMTAzMzU3OA==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-29T07:23:43Z",
    "updated_at": "2020-04-29T07:23:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Do you anticipate that it would be easy enough to get this included in the spec ? I would prefer to have everything under our control if possible,and the best way to do that would be to handle this in the application layer.\r\n\r\nI'm confident at this stage if we wished to change the BLS spec it would get done. Though we are looking to freeze phase 0 and BLS spec is a bottleneck so maybe it's best to go with option 3 which as you say will also give us more control. \r\n\r\nAdditionally, if we go with option 3 and handle this case without interacting with BLS then it will be irrelevant if BLS makes any changes in this regard.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621033578/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/622358884",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-622358884",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 622358884,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMjM1ODg4NA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-01T11:54:00Z",
    "updated_at": "2020-05-01T11:54:00Z",
    "author_association": "MEMBER",
    "body": "Ok, I'm making a PR for option 3 (empty set of participants is invalid as attestation to go onchain). If we need it to behave differently for some unforeseen phase 1+ case, we can simply start allowing the type of attestation we need, with backwards compatibility in regards to attestations already on-chain. Also, we indeed avoid being affected by BLS changes and library issues in any way, which is great.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/622358884/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623568336",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-623568336",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 623568336,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMzU2ODMzNg==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-04T16:29:47Z",
    "updated_at": "2020-05-04T18:34:58Z",
    "author_association": "MEMBER",
    "body": "What about the issue brought up by vitalik early in the thread? We know of cases where empty signatures will have to be included on chain.\r\n\r\nIn such a case, I suppose we have to be explicit -- e.g. `if light_sig == 0x00: return` at the top of process light sigs function.\r\n\r\nEDIT: The fix in #1780 is specific to this one issue. If we go Option 3, we'll need to address each type of potentially empty aggregate specifically. This is probably fine\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623568336/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/628518937",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-628518937",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 628518937,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyODUxODkzNw==",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-14T09:36:08Z",
    "updated_at": "2020-05-14T09:37:49Z",
    "author_association": "MEMBER",
    "body": "Copy-paste the discussion on #1799 https://github.com/ethereum/eth2.0-specs/pull/1799/files#r424421674\r\n\r\n> @mratsim:\r\nDo we define the empty signature somewhere? Is that 0xc000...\r\n\r\n> @protolambda:\r\n> The python here would mean all zeroes (every ssz type is all zeroes by default). But agree that this is way to vague and can be confused with an empty signature.\r\n\r\n> @hwwhww:\r\n> I remember we had `EMPTY_SIGNATURE` constant in 2019. I would be happy to add it back.\r\n\r\n> @mratsim:\r\n> We can have, `NO_SIGNATURE`(0x0000...) and `EMPTY_SIGNATURE` (0xc000...) for clarity\r\n\r\n> @kirk-baird: \r\n> I've been treating `EMPTY_SIGNATURE` as (0x0000...) as I believe that's what we called in it the spec in 2019. I'm happy to do a re-name and make\r\n> * `NO_SIGNATURE` (0x0000...) (always verifies false)\r\n> * `EMPTY_SIGNATURE` (0xc000...) \r\n\r\n> However, we have to be careful here as `AggregatePublicKeys([])` will always verify false according to the BLS Standard.\r\n\r\n> So `EMPTY_SIGNATURE` will only verify true against a list of `EMPTY_PUBLIC_KEYS`. We must have `1..*` `EMPTY_PUBLIC_KEYS` verifying true. (Note: or some other combination of public keys that add to 0 mod r).\r\n\r\n> @mratsim:\r\n> Or `EMPTY_SIGNATURE`(0x0000) and `ZERO_SIGNATURE` (0xc000) I'm not married to any name.\r\n\r\n---\r\n\r\n### So far, we have two non-signature cases in phase 1:\r\n1. `BeaconBlockBody.light_client_signature`, when `len(signer_pubkeys) == 0`\r\n\t* It is [currently handled](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase1/beacon-chain.md#light-client-processing) with the following code when verifying:\r\n\t```python\r\n        if len(signer_pubkeys) == 0:\r\n            assert block_body.light_client_signature == BLSSignature()\r\n            return\r\n        else:\r\n            assert bls.FastAggregateVerify(signer_pubkeys, signing_root, signature=block_body.light_client_signature)\r\n\t```\r\n2. `ShardTransition.proposer_signature_aggregate`, when `len(shard_blocks) == 0`\r\n\t* It’s currently  `assert bls.AggregateVerify(pubkeys, signing_roots, signature=transition.proposer_signature_aggregate)`\r\n\r\n### My 2 cents\r\n\r\nOptional 3 is good for attestation aggregation, however, for phase 1 cases, IMO I'm inclined to apply option 2 for these cases.\r\n* It's clear that `AggregateVerify(PKs, messages, signature)`/`FastAggregateVerify(PKs, message, signature)` is invalid when `PKs = []` according to the BLS standard, so we cannot set the non-signature to 0xc0... and make it pass the verification.\r\n* 0x00.. is an invalid signature in BLS verification, and it can remind us to explicitly take care of the non-signature case. We can define some Eth2-only helpers:\r\n\r\n```python\r\ndef optional_fast_aggregate_verify(pubkeys, message, signature) -> bool:\r\n    if len(pubkeys) == 0:\r\n        return signature == NO_SIGNATURE\r\n    else:\r\n        return bls.FastAggregateVerify(pubkeys, message, signature)\r\n```\r\n\r\n```python\r\ndef optional_aggregate_verify(pubkeys, messages, signature) -> bool:\r\n    if len(pubkeys) == 0:\r\n        return signature == NO_SIGNATURE\r\n    else:\r\n        return bls.AggregateVerify(pubkeys, messages, signature)\r\n```\r\n\r\nSo it would be crystal clear that `PKs == []` is possible. 🙂 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/628518937/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/628875256",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-628875256",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 628875256,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyODg3NTI1Ng==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-14T20:40:11Z",
    "updated_at": "2020-05-14T20:40:11Z",
    "author_association": "MEMBER",
    "body": "Yes, being explicit like that is great, and avoids weird edge cases between implementations in the BLS spec, as readers have many different assumptions about 0 pubkeys, and the BLS spec does not cover it. With phase0 I prefer option 3, as it is easier to open it back up, than restrict it (since existing signatures still would need to be valid). For phase 1 that approach looks good.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/628875256/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661063304",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-661063304",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 661063304,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTA2MzMwNA==",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-20T14:09:26Z",
    "updated_at": "2020-07-20T14:09:26Z",
    "author_association": "MEMBER",
    "body": "@protolambda I think it's okay to close this issue?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661063304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661096162",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1713#issuecomment-661096162",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1713",
    "id": 661096162,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTA5NjE2Mg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-20T15:04:09Z",
    "updated_at": "2020-07-20T15:04:09Z",
    "author_association": "MEMBER",
    "body": "@hwwhww yes, this was resolved. There are still surprises with the infinity-point pubkey/signature for implementers though, especially when changing to new BLS libraries (BLST). @paulhauner was looking into this. If you've any edge cases or things that should be documented/tested, please make a new issue and we'll look into it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/661096162/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
