{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/34",
  "id": 366374305,
  "node_id": "MDU6SXNzdWUzNjYzNzQzMDU=",
  "number": 34,
  "title": "Misc questions",
  "user": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1063043872,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODcy",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:question",
      "name": "general:question",
      "color": "FAD689",
      "default": false,
      "description": "Further information is requested"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 8,
  "created_at": "2018-10-03T14:40:54Z",
  "updated_at": "2018-11-14T21:44:10Z",
  "closed_at": "2018-11-14T21:44:10Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "**Questions**\r\n\r\n* [ ] 1) Should there be a check in the queuing logic that the number of validators is less than `MAX_VALIDATOR_COUNT`?\r\n* [ ] 2) Should `slot` and `dynasty` be set to `int32` (as opposed to `int64`)? With 8 second slot durations 32 bits gives us 1000+ years. (Same for `justified_streak`, `justified_slot`, etc.)\r\n* [ ] 3) Is `pubkey` being a `int256` too small for BLS12-381?\r\n* [ ] 4) What happens if a shard block gets sufficient attestations to become a crosslink, but that shard block conflicts with an existing crosslink in the beacon chain?\r\n* [ ] 5) What calculation led to \"~39.4%\" in \"the amount of time it takes for the quadratic leak to cut deposits of non-participating validators by ~39.4%\"? Consider detailing with the constants.\r\n* [ ] 6) What calculation led to \"~3.88%\" in \"~3.88% annual interest assuming 10 million participating ETH\"? Consider details with the constants.\r\n* [ ] 7) Should we allow deposits greater than `DEPOSIT_SIZE`? What about top-ups and penalties for being under the `DEPOSIT_SIZE`?\r\n* [ ] 8) What is the maximum bias to the global clock that we are assuming honest validators to have?\r\n* [ ] 9) Is it still possible that a dynasty transition can happen within a cycle?\r\n* [ ] 10) What happens if a validator deregisters and then wants to re-register?\r\n* [ ] 11) Do we need to define a `SpecialObject` to change the `withdrawal_shard_id`, `withdrawal_address` or `randao_commitment`?\r\n* [ ] 12) Should we deprecate Wei with 64-bit balances? Indeed, 64 bits of granualarity is enough for balances, and is consistent with a 64-bit EVM2.0?\r\n\r\n**Nitpicks**\r\n\r\n* [ ] 1) Add \"type codes\" for the possible `SpecialObject` types to clean up `obj.type == 0` and `obj.type == 1`.\r\n* [ ] 2) Consider adding a table of contents after the introduction for the top-level sections.",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426705363",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-426705363",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 426705363,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjcwNTM2Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-03T16:32:44Z",
    "updated_at": "2018-10-03T16:32:44Z",
    "author_association": "MEMBER",
    "body": ">  1) Should there be a check in the queuing logic that the number of validators is less than MAX_VALIDATOR_COUNT?\r\n\r\nMAX_VALIDATOR_COUNT is not even used in the spec anywhere; we could just remove it.\r\n\r\n>  2) Should slot and dynasty be set to int32 (as opposed to int64)? With 8 second slot durations 32 bits gives us 1000+ years. (Same for justified_streak, justified_slot, etc.)\r\n\r\nPersonally, I'm inclined to favor int64 over int32 for everything except data structures that get repeated a huge number of times; simplifies things that way. Though that's only my own preference; I'm ok with adding a millennium bug too.\r\n\r\n>  3) Is pubkey being a int256 too small for BLS12-381?\r\n\r\nYep! Happy to make it an int384 when we switch over :smile: \r\n\r\n>  4) What happens if a shard block gets sufficient attestations to become a crosslink, but that shard block conflicts with an existing crosslink in the beacon chain?\r\n\r\nThis theoretically makes the entire beacon chain from that point invalid.\r\n\r\n>  5) What calculation led to \"~39.4%\" in \"the amount of time it takes for the quadratic leak to cut deposits of non-participating validators by ~39.4%\"? Consider detailing with the constants.\r\n\r\n0.606 ~= e ** -0.5. It's the easiest constant to work with in this context; basically, if we have a rule that deposits are cut by a factor of n/k^2 after n slots of inactivity leak, then after k slots deposits are\r\n\r\n>  6) What calculation led to \"~3.88%\" in \"~3.88% annual interest assuming 10 million participating ETH\"? Consider details with the constants.\r\n\r\nCalculating maximum rewards based on the given constants .\r\n\r\n>  7) Should we allow deposits greater than DEPOSIT_SIZE? What about top-ups and penalties for being under the DEPOSIT_SIZE?\r\n\r\nI brought up the possibility of making the deposit size variable earlier in our chat; I suppose it's a reasonable idea theoretically.\r\n\r\n>  8) What is the maximum bias to the global clock that we are assuming honest validators to have?\r\n\r\n< 16 seconds, though given other people want a smaller slot duration I guess it's <8 seconds :smile: \r\n\r\n>  9) Is it still possible that a dynasty transition can happen within a cycle?\r\n\r\nNope!\r\n\r\n>  10) What happens if a validator deregisters and then wants to re-register?\r\n\r\nThey have to wait the ~3 months and then restart?\r\n\r\n>  11) Do we need to define a SpecialObject to change the withdrawal_shard_id, withdrawal_address or randao_commitment?\r\n\r\nIMO the withdrawal address and withdrawal shard should just be immutable; this way you can have a hot signing key and cold hodling key without risking the signing key being able to fully steal funds.\r\n\r\n>  12) Should we deprecate Wei with 64-bit balances? Indeed, 64 bits of granualarity is enough for balances, and is consistent with a 64-bit EVM2.0?\r\n\r\nWithin the beacon chain, seems reasonable (use gwei as a unit?). Within shards, I'd say keep the use of bignums and wei for currency.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426705363/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426764152",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-426764152",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 426764152,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjc2NDE1Mg==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-03T19:16:33Z",
    "updated_at": "2018-10-03T19:45:48Z",
    "author_association": "MEMBER",
    "body": "> I'm inclined to favor int64 over int32 for everything except data structures that get repeated a huge number of times; simplifies things that way\r\n\r\nI'm happy with keeping things clean 👍. That suggests homogenising `deposits_penalized_in_period`, `SpecialObject.type`, `ValidatorRecord.status`, `shard_id `, `withdrawal_shard` and `balance` (with the suggestion of using Gwei as a unit) to `int64`.\r\n\r\n> This theoretically makes the entire beacon chain from that point invalid\r\n\r\nDon't we expect conflicting crosslinks from time to time? Suppose for example a committee almost creates crosslink for a shard block but one of the signatures required to reach the committee threshold takes a bit of time to get into the beacon chain. Shortly after the following happen:\r\n\r\n* The shard forks\r\n* Another committee is sampled, and creates a crosslink for the fork\r\n* The missing signature for the \"old chain\" makes it onchain\r\n\r\n> < 16 seconds, though given other people want a smaller slot duration I guess it's <8 seconds 😄\r\n\r\nI think we should be precise about timing assumptions:\r\n\r\n1) Are you suggesting that the subjective clocks of honest player be within UTC ± `SLOT_DURATION` (absolute bias around real time at most `SLOT_DURATION`) or within UTC ± `SLOT_DURATION / 2` (relative bias between two honest players at most `SLOT_DURATION`)?\r\n2) Does the above model include any networking latency? What are the networking latency assumptions?\r\n\r\n> They have to wait the ~3 months and then restart?\r\n\r\nHow do they restart? As currently specced the only way to register is via the one-deposit on the PoW chain. If deregistration happens near the launch of the beacon chain (prior to shards having state) it may take years for that validator to be able to restart. I guess my question is: do we want to add a `SpecialObject` for re-registration to avoid validators from being stuck for significantly longer than 3 months? If so, then we might as well have a unified `SpecialObject` for both registration and re-registration, and further simplify the registration contract on the PoW chain.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426764152/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426862956",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-426862956",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 426862956,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjg2Mjk1Ng==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-04T02:16:18Z",
    "updated_at": "2018-10-04T02:18:34Z",
    "author_association": "MEMBER",
    "body": "> Don't we expect conflicting crosslinks from time to time? Suppose for example a committee almost creates crosslink for a shard block but one of the signatures required to reach the committee threshold takes a bit of time to get into the beacon chain.\r\n\r\nAh I see. I was operating under the assumption that it's not possible to include a transaction for one committee by the time that it's possible to include a transaction for \"the next committee\" for that same shard, and particularly messages that contribute to committee N+1 must point to, and therefore be aware of, any blocks that could have included a transaction for committee N, so there's no room for honest misunderstandings from latency getting two conflicting committees into a beacon chain. I think that if we reduce the max committees per slot by a factor of at least 3 we get that invariant back; IMO that's the cleanest solution.\r\n\r\nIn any case, I really want to enforce the norm that if the beacon chain includes a crosslink from a given shard block, then that means the beacon chain attests to that shard block being part of the canonical history, and the ultimate validity of the beacon chain from that point on now is now conditional on the validity of the shard chain up until that point. Allowing conflicting crosslinks would make all of that impossible as the beacon chain would effectively be attesting to two conflicting beacon chains. \r\n\r\n> I think we should be precise about timing assumptions:\r\n\r\nTechnically, we want networking latency plus clock disparity between all honest nodes to be <= 1 slot, so if honest node A sends a message at subjective time T, honest node B will receive the message within the subjective time interval (T - 8, T + 8) (negatives possible due to clock disparity).\r\n\r\nThough my simulations suggest things will be ok with clock disparity and/or network latency even going up to 3-4x slot duration or more, the chain just won't look as clean :laughing: \r\n\r\nBTW I think we should consider whether or not a default client timing rule that adapts to some guess of what the majority of the network thinks the time is would make sense; will think more before making a concrete proposal.\r\n\r\n> How do they restart? \r\n\r\nUsing the shard-to-beacon-chain deposit procedure, which is TBD :smile:",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426862956/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426877916",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-426877916",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 426877916,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjg3NzkxNg==",
    "user": {
      "login": "rawfalafel",
      "id": 202157,
      "node_id": "MDQ6VXNlcjIwMjE1Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/202157?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rawfalafel",
      "html_url": "https://github.com/rawfalafel",
      "followers_url": "https://api.github.com/users/rawfalafel/followers",
      "following_url": "https://api.github.com/users/rawfalafel/following{/other_user}",
      "gists_url": "https://api.github.com/users/rawfalafel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rawfalafel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rawfalafel/subscriptions",
      "organizations_url": "https://api.github.com/users/rawfalafel/orgs",
      "repos_url": "https://api.github.com/users/rawfalafel/repos",
      "events_url": "https://api.github.com/users/rawfalafel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rawfalafel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-04T04:02:30Z",
    "updated_at": "2018-10-04T04:02:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "> BTW I think we should consider whether or not a default client timing rule that adapts to some guess of what the majority of the network thinks the time is would make sense; will think more before making a concrete proposal.\r\n\r\nPrysm was planning on having clients sync with an NTP server: https://github.com/prysmaticlabs/prysm/issues/511#issuecomment-421209988",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/426877916/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427002043",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-427002043",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 427002043,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzAwMjA0Mw==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-04T12:36:35Z",
    "updated_at": "2018-10-05T13:12:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > 3) Is pubkey being a int256 too small for BLS12-381?\r\n>\r\n> Yep! Happy to make it an int384 when we switch over\r\n\r\nThe private key is 48 bytes (384-bit) but the ~public keys are 96 bytes, or 97 bytes if there is a recovery byte.~\r\n\r\nEdit: Ah, I was thinking about signatures not public keys, recovery bytes is on signatures.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427002043/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427025933",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-427025933",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 427025933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzAyNTkzMw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-04T13:49:15Z",
    "updated_at": "2018-10-04T13:49:15Z",
    "author_association": "MEMBER",
    "body": "@mratsim Out of curiosity, what is a recovery byte?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427025933/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427359632",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-427359632",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 427359632,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzM1OTYzMg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-05T13:06:46Z",
    "updated_at": "2018-10-05T13:13:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "Taking from bitcoin's [secp256k1](https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1_recovery.h):\r\n\r\n```C\r\n/** Opaque data structured that holds a parsed ECDSA signature,\r\n *  supporting pubkey recovery.\r\n *\r\n *  The exact representation of data inside is implementation defined and not\r\n *  guaranteed to be portable between different platforms or versions. It is\r\n *  however guaranteed to be 65 bytes in size, and can be safely copied/moved.\r\n *  If you need to convert to a format suitable for storage or transmission, use\r\n *  the secp256k1_ecdsa_signature_serialize_* and\r\n *  secp256k1_ecdsa_signature_parse_* functions.\r\n *\r\n *  Furthermore, it is guaranteed that identical signatures (including their\r\n *  recoverability) will have identical representation, so they can be\r\n *  memcmp'ed.\r\n */\r\ntypedef struct {\r\n    unsigned char data[65];\r\n} secp256k1_ecdsa_recoverable_signature;\r\n\r\n/** Parse a compact ECDSA signature (64 bytes + recovery id).\r\n *\r\n *  Returns: 1 when the signature could be parsed, 0 otherwise\r\n *  Args: ctx:     a secp256k1 context object\r\n *  Out:  sig:     a pointer to a signature object\r\n *  In:   input64: a pointer to a 64-byte compact signature\r\n *        recid:   the recovery id (0, 1, 2 or 3)\r\n */\r\nSECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact(\r\n    const secp256k1_context* ctx,\r\n    secp256k1_ecdsa_recoverable_signature* sig,\r\n    const unsigned char *input64,\r\n    int recid\r\n) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\r\n```\r\n\r\nvs signature without recovery:\r\n\r\n```C\r\n/** Opaque data structured that holds a parsed ECDSA signature.\r\n *\r\n *  The exact representation of data inside is implementation defined and not\r\n *  guaranteed to be portable between different platforms or versions. It is\r\n *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\r\n *  If you need to convert to a format suitable for storage, transmission, or\r\n *  comparison, use the secp256k1_ecdsa_signature_serialize_* and\r\n *  secp256k1_ecdsa_signature_parse_* functions.\r\n */\r\ntypedef struct {\r\n    unsigned char data[64];\r\n} secp256k1_ecdsa_signature;\r\n\r\n...\r\n\r\n/** Parse an ECDSA signature in compact (64 bytes) format.\r\n *\r\n *  Returns: 1 when the signature could be parsed, 0 otherwise.\r\n *  Args: ctx:      a secp256k1 context object\r\n *  Out:  sig:      a pointer to a signature object\r\n *  In:   input64:  a pointer to the 64-byte array to parse\r\n *\r\n *  The signature must consist of a 32-byte big endian R value, followed by a\r\n *  32-byte big endian S value. If R or S fall outside of [0..order-1], the\r\n *  encoding is invalid. R and S with value 0 are allowed in the encoding.\r\n *\r\n *  After the call, sig will always be initialized. If parsing failed or R or\r\n *  S are zero, the resulting sig value is guaranteed to fail validation for any\r\n *  message and public key.\r\n */\r\nSECP256K1_API int secp256k1_ecdsa_signature_parse_compact(\r\n    const secp256k1_context* ctx,\r\n    secp256k1_ecdsa_signature* sig,\r\n    const unsigned char *input64\r\n) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\r\n```\r\n\r\nIn implementation, secp256k1 signature are represented with v, r and s and v is the recovery byte while r and s are 32 bytes for a total of 1 + 32 + 32 = 65 bytes.\r\n\r\nEdit - here is additional explanation: https://github.com/ethereum/EIPs/issues/155#issuecomment-366262103 by @jhoenicke\r\n\r\n> An ECDSA signature (r,s) is computed from a random nonce k: compute R = kG and set r = (R.x mod ORDER) and throw away R.y. To recover the public key one can use the formula 1/r(sR-hG), but that requires to recover R from the signature. If R.x < ORDER (which is almost always the case), then the missing part is R.y and there are two possibilities (one with low bit 0, one with low bit 1).\r\nSo one has to store the low bit of R.y in v.\r\n>\r\n> low s normalization: If (r,s) is a valid signature then (r,(ORDER-s)) is also a valid signature, but it uses the \"other R\". Ethereum (and Bitcoin) require for some time that one always uses the smaller value for s, and then one has to flip R.y bit.\r\n>\r\n> See also https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106\r\n\r\nEdit 2: I was mixing public keys and signatures, the recovery byte is on signatures, public keys are 96 bytes. Signatures are 96 or 97 bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427359632/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438829682",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/34#issuecomment-438829682",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/34",
    "id": 438829682,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODgyOTY4Mg==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-14T21:44:10Z",
    "updated_at": "2018-11-14T21:44:10Z",
    "author_association": "MEMBER",
    "body": "All issues addressed elsewhere 👍 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438829682/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
