{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1293",
  "id": 467676049,
  "node_id": "MDU6SXNzdWU0Njc2NzYwNDk=",
  "number": 1293,
  "title": "Shard persistent committee selection",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-07-13T05:50:37Z",
  "updated_at": "2019-07-18T09:11:30Z",
  "closed_at": "2019-07-18T09:11:30Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Setup\r\n\r\n* There is a function `get_period_committee(shard, period) -> List[ValidatorIndex]` which returns the period persistent committee for a shard (1 period = PERIOD_LENGTH slots ~= 9 days)\r\n* Every validator has a private \"switchover block\", `0 <= x_i < PERIOD_LENGTH`. A validator switches over from their period-n responsibility to their period-(n+1) responsibility at slot `n * PERIOD_LENGTH + x_i`. This staggered transition mechanism facilitates smooth transitions between committees, so only a few validators enter or leave at a time.\r\n* Hence, the validators active at any given slot `s` in any given shard are a combination of some members of some committees `prev_committee` and `post_committee`.\r\n\r\nQuestion: how to choose (i) the proposer and (ii) the attester committee for slot `s`?\r\n\r\n### A quick note on light clients and committee sizes\r\n\r\nA crosslink committee has size ~4096 in the worst case, ~915 in the 30 million ETH case, ~305 in the 10 million ETH case. A validator record is ~56 bytes, and a period is 2048 384-second epochs or ~9 days. A light client _can_ just download the record for the entire persistent committee every period, achieving a worst-case data overhead of `56 * 4096 / (308 * 2048) ~= 0.2917` bytes per second, plus extra overhead for verifying specific blocks (by comparison, Bitcoin block headers are about `80 / 565 = 0.142` bytes per second).\r\n\r\nBut we don't want the entire committee validating every block because that would be inefficient, and we can tolerate occasional faults because the crosslink committee would reject them anyway. Instead, we can try to target ~64 persistent committee validators validating any given block.\r\n\r\nBut if we do this, then we have smaller signatures, and we can try to enable the possibility of light clients that are even lighter, downloading only the first ~64 members of a persistent committee and in exchange only being able to verify shard blocks once in a while. This could be an optimal arrangement for light clients inside highly constrained environments. Such a light client would have a data overhead of `56 * 64 / (308 * 2048) = 0.00568` bytes per second or 490 bytes per day. This is what we mean by \"ultra-light client\".\r\n\r\n## Choosing the attester committee\r\n\r\n### Option 1: status quo\r\n\r\nLet `N = max(len(prev_committee), len(post_committee)) // 64`. Split `prev_committee` and `post_committee` both into N pieces. Combine the `(s % N)`'th piece of the active portions of each committee, to get the attesters.\r\n\r\nPros:\r\n\r\n* Is status quo\r\n* Not too complex\r\n* Light clients can download 1/N of each committee and still keep up with the shard chain, but with N-slot latency (this is optimal)\r\n\r\nCons:\r\n\r\n* Attester set size not exactly fixed\r\n* Attester sets fully predictable\r\n* Validation responsibility evenly spread across slots; higher efficiency would be assigning longer contiguous slices (that is, a validator validates `.....*.....*.....*.....*.....`)\r\n\r\n### Option 2: status quo but attester sets are per-epoch, not per-slot\r\n\r\nPros: validation responsibility compressed into contiguous ranges of slots (that is, a validator validates `..........***...............***.........`)\r\n\r\nCons:\r\n\r\n* The entire attester sub-committee changes at the same time\r\n* Attester sets fully predictable\r\n* Ultra-light-client latency goes up to N epochs\r\n\r\n### Option 3: fractional staggering\r\n\r\nLet `ROTATION_PERIOD = 1024` slots. A validator with index `i` in either committee (with `L` being the total length of that committee) is an active attester for slot `s` if `(i + L - x) % L <= 64` where `x = ((s * L) // ROTATION_PERIOD) % L`.\r\n\r\nPros: same as option 2, but smoother transition\r\n\r\nCons: same as option 2 (but validation contiguousness vs ultra-light-client latency can be easily parametrized via `ROTATION_PERIOD`)\r\n\r\n### Option 4: use randomness\r\n\r\nLet `x` be the root of the previous period committee. Let the seed for epoch `i` be `seed = h(x, r, shard)` where `shard` is the shard ID and `r` is the randao mix in the state at the start of epoch `i`. Use `seed` to randomly select a size-64 committee for each slot.\r\n\r\nPros: unpredictable\r\nCons:\r\n\r\n* Much worst ultra-light-client capacity as there's no specific size-64 committee you can download to guarantee verifying a particular block\r\n* Light clients have to trust attackers to give them a seed, and attackers could manipulate the seed (though VDFs may mitigate this)\r\n\r\n### Option 5: use randomness plus fractional staggering\r\n\r\nChoose the epoch committees as above, but make the attesters for slot `s` be `prev_epoch_committee[((s // 2) % 64):] + cur_epoch_committee[:(s // 2) % 64]`.\r\n\r\nPros: gradual replacement\r\nCons: a bit more complexity\r\n\r\n## Proposers vs attesters\r\n\r\nIt seems likely that we care more about unpredictability of proposers versus unpredictability of attesters. So one could favor using options 1-3 to choose attester committees, and randomly choose proposers, as light clients don't particularly need to securely verify who the proposer is.\r\n\r\n### Implementation alternative\r\n\r\nThe spirit of options 2 and 3 above can also be implemented by:\r\n\r\n* Reducing the max persistent committee size to 64 (so often most validators will just formally not be part of any persistent committee)\r\n* Reducing the max persistent committee period to ~12 hours\r\n* Making the period committee function repeat its outputs often (ie. make outputs in the pattern ABCABCABCABCDEFDEFDEFDEFGHIGHIGHIGHI...)\r\n\r\nThis will reduce the complexity of these options by ~2x as we get to reuse a lot of logic",
  "closed_by": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/511650307",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1293#issuecomment-511650307",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293",
    "id": 511650307,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTY1MDMwNw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-16T03:28:40Z",
    "updated_at": "2019-07-16T03:28:40Z",
    "author_association": "MEMBER",
    "body": "Generally in favor of the alternative described at the bottom knowing that even with smaller persistent committees, we have the (larger) crosslink committees as gatekeepers on bad/unavailable data. Components of options 3-5 seem too complex and the tradeoffs not in the right direction.\r\n\r\nAnd agreed on the persistent committee repeating itself for longer usage of a single persistent committee in light clients.\r\n\r\nDo we see any potential downside in having a small known set that can act highly performant in block production/attestation in the ~1 day time period? Smaller set is easier to bribe but the crosslink committees act as gatekeepers. I suppose one concern would be a smaller set that can be the target of DoS attacks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/511650307/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/511707172",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1293#issuecomment-511707172",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1293",
    "id": 511707172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTcwNzE3Mg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-16T07:51:48Z",
    "updated_at": "2019-07-16T07:51:48Z",
    "author_association": "MEMBER",
    "body": "I'm not especially worried about DoS attacks; if you knock down 2/3 of a committee then the other 1/3 are still standing and can form a chain. Light clients having trouble with a committee of one shard could even seamlessly switch to another shard.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/511707172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
