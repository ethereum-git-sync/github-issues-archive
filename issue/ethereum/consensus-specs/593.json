{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/593",
  "id": 408302869,
  "node_id": "MDU6SXNzdWU0MDgzMDI4Njk=",
  "number": 593,
  "title": "Minimal Phase 0 Wire API",
  "user": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1234124284,
      "node_id": "MDU6TGFiZWwxMjM0MTI0Mjg0",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:v-guide",
      "name": "scope:v-guide",
      "color": "113285",
      "default": false,
      "description": "Validator guide"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-02-08T20:00:49Z",
  "updated_at": "2021-10-13T11:55:39Z",
  "closed_at": "2019-02-26T22:25:23Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Minimal Phase 0 Wire API [WIP]\r\n\r\nThis is the minimal wire API required for Phase 0 of Eth2.0. Note that this is _not_ the wire protocol but the interface right above. Once we settle on the API required, we can specify the underlying protocol.\r\n\r\nAll API methods are specified as the plural `list` version, assuming that if singular objects are sent or requested that the input will just be a list of length 1.\r\n\r\n\"Bad form\" is any action that is not explicitly against the protocol but is not in the best interest of one's peers or the protocol in general. Messages/requests that are considered bad form may reduce the reputation of the sending node and may result in being dropped.\r\n\r\n_TODO_:\r\n* add tentative light client proposal #459 after merging in phase 1 PRs\r\n* specify requesting and serving state via tree hash and state root\r\n* vet sync proposal with 1.0 sync masters and vet alternatives\r\n\r\n## Dependencies\r\n\r\nThis document depends on:\r\n* [SSZ spec](https://github.com/ethereum/eth2.0-specs/blob/master/specs/simple-serialize.md)\r\n* [Phase 0 spec](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md)\r\n\r\n## Network topology\r\n\r\nEthereum 2.0 network topology consists of a pubsub mapping of peers to \"topics\". These topics along with peer mappings effectively form subnets.\r\n\r\nThe primary topics of core protocol consideration are:\r\n* `beacon`: All messages for the beacon chain are mapped to topic `beacon`.\r\n* `shard-{number}` for all integers `number` in `[0, SHARD_SUBNET_COUNT)`: Messages for a given shard defined by `shard_number` are mapped to topic `shard-{shard_number % SHARD_SUBNET_COUNT}`.\r\n\r\nWe use `discv5` to discover peers of select topics, and we use `gossipsub`, a libp2p routing protocol, to route messages of a particular topic to the subnet in question.\r\n\r\nNote: attempting to broadcast or request messages about a topic not subscribed to by the peer is considered bad form. For example, running `send_attestations(attestations)` where one or more of the attestations have `attestation.data.shard == 5` to a peer not subscribed to `shard-5` might result in that peer dropping the sending node.\r\n\r\n## Compression\r\n\r\nShould conform on a compression standard early on. Libp2p does not ship with anything built in and recommends just adding compression over the libp2p stream.\r\n\r\n## API\r\n\r\nEDIT: much of this API has not been specified noting the distinction between 1-on-1 RPC requests/responses between peers vs. pubsub broadcasts. Some methods below are implicitly doing both. This implicitness needs to be made explicit in the wire protocol.\r\n\r\n### Sync\r\n\r\nThe following is a basic sync protocol akin to [eth1.0](https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol#basic-chain-syncing). This sync assumes that client has some `latest_finalized_root`/`epoch` acquired either from a previous sync or out-of-band. This data should be no older than the weak-subjectivity period of the network at that finalized checkpoint  (dynamic based upon validator set size).\r\n\r\nA `status` message is sent in the initial handshake between two peers. After handshake and status exchange, the peer with higher `latest_finalized_epoch` or, if epochs are equal, the higher `best_slot` sends a list of `beacon_block_roots` via `send_beacon_block_roots`. It is assumed that clients store and serve blocks at least as old as the network's current weak-subjectivity period.\r\n\r\n* If `latest_finalized_root`/`epoch` from each peer are in separate chains, then the two peers _cannot_ sync and should terminate connection.\r\n* If time between `latest_finalized_root`/`epoch` of each peer is greater than the weak-subjectivity period, then the peer behind _cannot_ safely sync and should terminate connection.\r\n\r\nStatus handshake fields:\r\n* `protocol_version`: type/format TBD\r\n* `network_id`: type/format TBD\r\n* `latest_finalized_root`: bytes32\r\n* `latest_finalized_epoch`: uint64\r\n* `best_root`: bytes32\r\n* `best_slot`: uint64\r\n\r\n#### From state snapshot\r\n\r\nIf client has state up until `latest_finalized_root`/`epoch` (from a previous sync or from a snapshot acquired out-of-band), client can process the per-block state transitions from the `latest_finalized_root` to reach the head.\r\n\r\n#### Fast sync state\r\n\r\nIf client does _not_ have state at `latest_finalized_root`/`epoch`, then the client should perform a fast sync akin to [eth1.0 fast synchronization](https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol#fast-synchronization-pv63) to the `latest_finalized_root`/`epoch` provided by the peer.\r\n\r\n### Beacon Blocks\r\n\r\nSupported pubsub topics:\r\n* `beacon`\r\n\r\nThe following definitions are used in the API:\r\n* `block_header`: a serialized `BeaconBlock` in which `BeaconBlock.body` is the `hash_tree_root` of the associated `BeaconBlockBody`.\r\n* `block_body`: a serialied `BeaconBlockBody`.\r\n* `block_root`: the `hash_tree_root` of a `BeaconBlock`.\r\n\r\nAPI:\r\n* `send_beacon_block_roots(block_roots_and_slots)`: Sends list of `(block_root, slot)` to peer.\r\n* `send_beacon_block_headers(block_headers)`: Sends list of `block_headers` to peer.\r\n* `request_beacon_block_headers(block_root, slot, max_headers, skip_slots)`: Requests the `block_headers` starting at `(block_root, slot)` skip slots apart (if no block at the expected slot, return the next block at or above the expected slot) from peer. Reply must contain _at most_ `max_headers` headers.\r\n* `send_beacon_block_bodies(block_bodies)`: Sends list of `block_bodies` to peer.\r\n* `request_beacon_block_bodies(block_roots)`: Requests the associated `block_bodies` for the given `block_roots` from peer.\r\n\r\nNotes:\r\n* It is assumed that both the associated `BeaconBlock` and `BeaconBlockBody` can be looked up via `block_root`.\r\n* We need to model out the various uses of `request_beacon_block_headers` and make sure the skip mechanism suits our needs. (I'm not sure it's particularly useful without specifying requesting info about state).\r\n\r\n### Attestations\r\n\r\nSupported pubsub topics:\r\n* `beacon`\r\n* all `shard-{number}` topics\r\n\r\nThe following definitions are used in the API:\r\n* `attestation`: a serialized `Attestation` with full serialized `AttestationData` for `attestation.data`.\r\n\r\nAPI:\r\n* `send_attestations(attestations)`: Sends list of `attestations` to peer.\r\n\r\nNotes:\r\n* It is expected that an attestation is only broadcast to either `beacon` topic or `shard-{attestation.data.shard}` topic. Broadcasting to mismatched shard topics is considered bad form.\r\n* It is expected that only aggregate attestations are broadcast to the `beacon` topic. Repeated broadcasting of attestations with a single signer to the `beacon` topic is considered bad form.\r\n* There is a shard subnet design decision here. Due to the likelihood of `attestation.data` to be highly repeated across a committee during a given slot, it could be valuable to just send the `attestation` with a `root` in the `attestation.data` field. If the recipient does not already have an `AttestationData` for the received `root`, then the recipient would explicitly request the root. This reduces the total data passed by 184 bytes in the case that the recipient has already received the `attestation.data` but increases the rounds of communication when they haven't.\r\n* We do not currently specify a getter method for an attestation by its `root`. Due to the diverse ways attestations might both be aggregated and stored, it is not feasible to reliably lookup via a `root`. The attestations that a client cares about are (1) those that made it on-chain into a `BeaconBlock` and (2) the most recent set of attestations being actively broadcast on the wire. We might provide a `request_attestations(slot)` or `request_attestations(epoch)` but do not provide it in this minimal API specification.\r\n\r\n### Exits\r\n\r\nSupported pubsub topics:\r\n* `beacon`\r\n\r\nThe following definitions are used in the API:\r\n* `exit`: a serialized `Exit`.\r\n\r\nAPI:\r\n* `send_exits(exits)`: Sends a list of `exits` to peer.\r\n\r\nNotes:\r\n* We do not specify a getter for an exit by its `root`. Standard usage is for a validator to broadcast when attempting to exit and for the exit to be soon added to a block.\r\n\r\n### State\r\n\r\nTODO: Specify handling requests of subsections of state given a `block.state_root`",
  "closed_by": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/462047670",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/593#issuecomment-462047670",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593",
    "id": 462047670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjA0NzY3MA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-09T14:09:23Z",
    "updated_at": "2019-02-09T14:12:14Z",
    "author_association": "MEMBER",
    "body": ">     `send_exit(exits)`\r\n\r\n>     `send_attestations(attestations)`\r\n\r\nCan we rename it to `send_exits` for consistency in plurality?\r\n\r\n>  specify requesting and serving state via tree hash and state root\r\n\r\n> TODO: Specify handling requests of subsections of state given a `block.state_root`\r\n\r\nCan you give an example where this would be used aside from light clients? Why not just define it as a SSZ encoded subsection of state, referred to by its `state_root`, and hash in the respective tree hash? With a `send_substate(ssz encoded substate)` and a `request_substate(state_root, tree_hash of substate)`?\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/462047670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467639488",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/593#issuecomment-467639488",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/593",
    "id": 467639488,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzYzOTQ4OA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T22:25:23Z",
    "updated_at": "2019-02-26T22:25:23Z",
    "author_association": "MEMBER",
    "body": "closing in favor of  #692 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467639488/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
