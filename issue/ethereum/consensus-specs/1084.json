{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1084",
  "id": 444003283,
  "node_id": "MDU6SXNzdWU0NDQwMDMyODM=",
  "number": 1084,
  "title": "Discussion on BeaconNode <--> ValidatorClient alternatives",
  "user": {
    "login": "mkalinin",
    "id": 1892772,
    "node_id": "MDQ6VXNlcjE4OTI3NzI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mkalinin",
    "html_url": "https://github.com/mkalinin",
    "followers_url": "https://api.github.com/users/mkalinin/followers",
    "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
    "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
    "organizations_url": "https://api.github.com/users/mkalinin/orgs",
    "repos_url": "https://api.github.com/users/mkalinin/repos",
    "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mkalinin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-05-14T16:10:17Z",
  "updated_at": "2019-08-20T13:54:44Z",
  "closed_at": "2019-08-20T13:54:31Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This issue is created in order to get back to validator separation discussion and as a request for comments from implementers and researchers. As I am personally has no strong opinion on whether it is worthwhile to follow current approach or it is not.\r\n\r\nThe idea of separation was originally discussed during [Client Architecture Roundtable](https://hackmd.io/s/rJl05Lk6X#Beacon-Node--Validator-Client-Separation) in Prague and has following reasons:\r\n- avoid private key management in a software that is connected to the wire\r\n- mitigate DoS attacks on validators\r\n- anything else missed here?\r\n\r\nCurrent solution involves:\r\n- Beacon node (BN) a regular beacon chain node\r\n- Validator client (VC) a piece of software that manages private keys and validator duties\r\n\r\nValidator client has its own slot ticker and on each new slot it sends a request to get a list of validator duties. According to listed duties VC requests BN to produce a block or an attestation, then it signs off on a block or an attestation and send it back to beacon node for propagation sake. In order to mitigate DoS attacks on particular validator instance it should be connected to a number of trusted nodes.\r\n\r\nA strong advantage of this scheme is that BN doesn't communicate back with VC which significantly reduces an attacking surface on message signer, it looks near the same as a surface of general attacks on regular machine. Also, the tinier software is the less points of failure it has which is either good for highly reliable software like a validator client.\r\n\r\nHowever, this approach has a number of disadvantages:\r\n- Maintaining yet another communication protocol. \r\nThis protocol looks simple for Phase 0, but the more duties VC has the more complex the protocol is. For example, Phase 1 introduces shards and custody game duties which has certain implication on this protocol.\r\n- Duplicate responsibilities between VC and BN.\r\nThis is only a matter of slot ticker and several data structures for Phase 0. But what would be involved in next phases? Phase 1 adds a requirement to store data that validator has signed off on which means storage functionality will get duplicated.\r\n- Data freshness and integrity. \r\nAs VC will highly likely be connected to several nodes it has to maintain integrity of data received from different sources and be sure that it works with fresh data. It requires additional functionality added to VC instance. Basically, it should actively communicate with all nodes it's connected to in order to monitor nodes' chain state and send requests to a node that has longest chain in a particular moment of time.\r\n\r\nAn alternative to current approach could be a scheme with validator node (VN) as a full beacon chain node with several restrictions on networking layer and segregated message signer service.\r\n\r\nValidator node is connected to regular beacon node via private connection from which VN is neither discoverable nor reachable for inbound connections from _any_ beacon nodes. In other words only VN is able to initiate connection to BN. This could be achieved by swapping transport protocol to a protocol that supports closed connections like TLS or keep usage of same transport protocol as BN with adding a number of restricting rules. Knowing that it communicates with validator, honest beacon node may use different propagation rules to deliver blocks and attestations to VN faster and may not penalize validator node for incorrect behaviour in the wire. Hence, VN may not have a mechanism to handle incoming requests (for headers, bodies, etc.) at all reducing an attacking surface on it.\r\n\r\nMessage signer is a service that manages private keys and signs messages on demand by processing requests from validator node. The best option for message signer would be HW wallet but I guess we will see HW wallet featured with BLS only afte some time passed since BLS12-381 scheme gets standardized.\r\n\r\nMain disadvantage of this scheme is that it increases an attacking surface on message signer. Theoretically, it becomes possible to sign malicious message by exploiting vulnerability in beacon node and validator node. But this surface looks pretty small to me. This scheme, also, adds complexity to network layer but it's a matter of using different transports and rules for connections with validator nodes; swapping parts of network stack is pretty doable thing. The same with message signer service which never gonna be something else than a routine that signs messages and manages private keys.\r\n\r\nOn the other side we have a full validator node that solves data freshness and availability problems and addresses a bunch of possible issues related to separated VC that may arise in the future.\r\n\r\nWhat worries me with regard to current approach is its uncertain degree of complexity defined by changes of validator responsibilities in future phases. We can clearly define VC for Phase 0, we can plan some changes in it for Phase 1. But wouldn't maintaining this scheme become a big problem since e.g. Phase 2 and up next?\r\n\r\nWhat disadvantages in approach with full validator node over restricted network layer do others see?",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/492382390",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1084#issuecomment-492382390",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084",
    "id": 492382390,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MjM4MjM5MA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-14T19:45:35Z",
    "updated_at": "2019-05-14T19:45:35Z",
    "author_association": "MEMBER",
    "body": "The main issue I see in tightly coupling is reducing optionality in validator design. Treating a validator as a separate entity allows for any number of sophisticated setups. For example a validator might connect to multiple nodes to query the state of the world. If a validator is confined within one node, the design is more set in stone.\r\n\r\nAnother reason to avoid it for the ecosystem is client lock-in. If the VC is considered a separate piece of software that communicates with a BN, then a VC can easily swap the underlying node if an issue arises with their general provider. In the eth1 world, the miner software is generally separate and mining pools have much less lock-in and are more agile with respect to upgrades/vulnerabilities/etc.\r\n\r\nI agree there are some trade-offs in separating and it might not be the proper route for each project depending on constraints and design goals. Although there is much conversation around conforming on this API and communication medium, it is certainly _not_ a requirement to be a consensus following and consensus forming node.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/492382390/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523025946",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1084#issuecomment-523025946",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1084",
    "id": 523025946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzAyNTk0Ng==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-20T13:54:31Z",
    "updated_at": "2019-08-20T13:54:44Z",
    "author_association": "MEMBER",
    "body": "I would agree with @djrtwo (and the majority of implementers, I believe) that decoupling beacon processing and shard processing is the way forward :)\r\n\r\nClosing because I think implementers have reached rough consensus on the best architecture (and because of the lack of further discussion).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523025946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
