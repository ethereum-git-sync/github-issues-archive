{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1160",
  "id": 454193133,
  "node_id": "MDU6SXNzdWU0NTQxOTMxMzM=",
  "number": 1160,
  "title": "Reforming dynamic lists in SSZ",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    },
    {
      "id": 1407853194,
      "node_id": "MDU6TGFiZWwxNDA3ODUzMTk0",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/milestone:June%2030%20freeze%20%F0%9F%A5%B6",
      "name": "milestone:June 30 freeze ðŸ¥¶",
      "color": "729acc",
      "default": false,
      "description": "Phase 0 spec freeze for long-lived cross-client testnet"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2019-06-10T14:16:02Z",
  "updated_at": "2019-06-26T12:08:25Z",
  "closed_at": "2019-06-26T12:08:25Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Background reading: https://github.com/ethereum/eth2.0-specs/issues/1115\r\n\r\nFrom my experience implementing SSZ partials (https://github.com/ethereum/eth2.0-specs/blob/ssz-impl-rework/test_libs/pyspec/eth2spec/utils/ssz/ssz_partials.py), I've come to the conclusion that the fact that paths do not correspond to specific generalized indices (as generalized indices depend on the depth of a tree which for dynamic-sized lists is dynamic) leads to a large amount of complexity in the SSZ partials implementation. `append` and `pop` and the complexities around rebalancing lists around powers of 2 are particularly problematic.\r\n\r\nMy proposed solution to this is as follows. From the perspective of SSZ _hashing_, we remove lists, so the only data types are (i) base types, (ii) fixed-size vectors, (iii) containers (we could also add unions by hashing a `Union[A, B... Z]` identically to `Container(a=Vector[A, 1], b=Vector[B, 1] ... z=Vector[Z, 1])`).\r\n\r\nAll existing lists in the spec (validator list in the state, transaction lists in blocks...) get converted to fixed-size lists of some size (for lists in blocks, we know the maximums already; for the validator set we can pick a very generous limit, eg. 2**40). Hence, from the perspective of hashing, all data types become constant-sized types, and so the generalized index that a given path (eg. `state -> state.validator_registry[123514].pubkey`) corresponds to is always the same value.\r\n\r\nHowever, in the SSZ vector data type, we now add a flag, \"serialization type\". To start off, the serialization types are FULL and DYNAMIC; a third one to be added later is SPARSE. A FULL vector is serialized like vectors are today; a DYNAMIC vector is serialized by serializing the items in the vector up until the highest nonzero item the same way that a list is serialized today. This makes DYNAMIC vectors essentially equivalent to current lists in terms of serialization, except that a maximum length must be specified. A SPARSE vector would be serialized by prepending the list of items with a (item, position) table of what all of the nonzero items are. Current vectors would become vectors with a FULL serialization type, current lists would become vectors with a DYNAMIC or possibly SPARSE serialization type (if DYNAMIC is used, then it may make sense to add a validation rule in those cases that verifies that there is no non-empty object that appears after any empty object in the list).",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160/reactions",
    "total_count": 2,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 1,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500453990",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-500453990",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 500453990,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDQ1Mzk5MA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-10T15:13:33Z",
    "updated_at": "2019-06-10T15:13:33Z",
    "author_association": "MEMBER",
    "body": "I would like to make an alternative proposal: Replace list by a type `List[A, max_length]`, which is still a dynamic list type but with maximum length `max_length`.\r\n\r\n- Merkleization would be like a Vector **but** with the length mixed in (in other words: it is the hash tree root where on the left is a static vector filled with zeroes and on the right there is the length as a uint64)\r\n- Serialization is just like a List at the moment\r\n\r\nThe reason why I would propose this is that I think it is preferable that the type is aware of its current dynamic length. The code for this is much easier to write, reason about, and check statically and dynamically. It is also consistent with the other changes we are making to SSZ (like unions and bitlists) which go into the direction of externalising typing work into SSZ and making it work \"naturally\" as you would expect from a modern programming language.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500453990/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500514421",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-500514421",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 500514421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDUxNDQyMQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-10T17:52:06Z",
    "updated_at": "2019-06-10T17:52:06Z",
    "author_association": "MEMBER",
    "body": "> Merkleization would be like a Vector but with the length mixed in (in other words: it is the hash tree root where on the left is a static vector filled with zeroes and on the right there is the length as a uint64)\r\n\r\nI can see how this can be valuable. But there is one question: do we want length mixed in as an item at the top, or as an element of the list? Huffman theory would say that mixing length in at the top is only optimal if half of all queries to the list are queries of its length, but that seems implausibly high. It would also say that reserving the first element of the array to represent length is only optimal if a length query is only as common as a query to a randomly selected element, which seems implausibly low. Which of these two extremes is less bad? The former is better from the PoV of not changing things as much as possible, the latter is better from the PoV of simplicity.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500514421/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500525398",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-500525398",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 500525398,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDUyNTM5OA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-10T18:12:45Z",
    "updated_at": "2019-06-10T18:12:45Z",
    "author_association": "MEMBER",
    "body": "> Huffman theory would say that mixing length in at the top is only optimal if half of all queries to the list are queries of its length, but that seems implausibly high.\r\n\r\nI'm not sure, but if we assume that Merkle proofs typically access one element, and every proof hast to come with a proof of the length of the list, then actually half the accesses are to the length.\r\n(We could skip this if we use zero-checking logic instead of checking the length, but this might need nasty special cases for lists where zero is a valid value. Not what I would prefer from a simplicity point of view)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500525398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500539846",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-500539846",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 500539846,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDUzOTg0Ng==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-10T18:37:46Z",
    "updated_at": "2019-06-10T18:37:46Z",
    "author_association": "MEMBER",
    "body": ">  and every proof hast to come with a proof of the length of the list\r\n\r\nAh, I suppose if we want our list get proofs to return what `list[i]` would _actually_ return, which is `IndexError` if the index is out of bounds, then you're right. OK, I can see the rationale for mixing in at the top as in the status quo.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/500539846/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501480271",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-501480271",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 501480271,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTQ4MDI3MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-12T22:39:04Z",
    "updated_at": "2019-06-13T01:03:48Z",
    "author_association": "MEMBER",
    "body": "See if we can describe the new extended SSZ better/more minimally (or at least my idea of it, all just an idea):\r\n\r\n-----\r\n\r\nAny collection is defined as `<header><body>`\r\n\r\n`<body>` is always defined as the concatenation of the serialized elements in the collection.\r\n\r\nBitfields require the `<body>` to be exactly bit-length bits, padded to the next multiple of 8. With the right-most byte left-padded to a full byte.\r\nBigInts are the same as bitfields, but interpreted as little-endian integer.\r\n\r\nThere are 4 different types, specialized in `<header>` and hash-tree-root definition:\r\n\r\n- Known, header: `` (zero bytes), root: `merkle(pad_right(elements, M))`\r\n  *Body size and elements location are known on compile time.*\r\n    - fixed-size element containers\r\n    - fixed-size element full vectors\r\n- Dynamic, root: `H(merkle(pad_right(elements, M)), len)`\r\n  - Implicit,  header: `` (zero bytes)\r\n    *Body size known from context (decoders use read bound)*\r\n    - fixed-size element dynamic vectors (a \"list\")\r\n    - Bitfield *(new)*\r\n  - Explicit: `<offset>*`\r\n    - variable-size element containers\r\n    - variable-size element full vectors\r\n    - dynamic vectors (a \"list\")\r\n- Sparse, root: `merkle(pad_sparse(elements, indices, M))`:\r\n    Indirectly: header: `<<index><offset>>*`:\r\n      - Sparse variable-size element vector *(new)*\r\n    Directly: header: `<index>*`\r\n      - Sparse fixed-size element vector *(new)*\r\n- Selected: header: `<index>`, root: `H(H(element), index)`:\r\n  - Option/Union\r\n\r\n`*` indicates zero or more elements, concatenated.\r\n\r\n`<index>`, `<offset>` and `<length>` are always 4 byte little endian integers (i.e. `uint32`).\r\n\r\nOffsets always count the bytes up to (but not including) the element.\r\n\r\n`M` is defined as the power of 2 defined as collection limit.\r\n\r\n`merkle` chunkifies (partition elements into 32 byte chunks) the input if it is of a basic type or a bitfield.\r\n`merkle` computes the binary-merkle-root of the given elements. \r\n\r\n`pad_right(elements, M)` pads the elements with zeroes to the given power of 2. \\*\\*\r\n`pad_sparse` pads the gaps and ends to match the given power of 2. \\*\\*\r\n\r\n\\*\\*: Optimized away within merkleization in real-world implementations.\r\n\r\n-------\r\n\r\n- **note on Sparse-Indirectly**: we can do `<index>*<offset>*` too, if we want to merkle just part of the header (`<index>*`) efficiently for basic presence proofs (not quite like hard inclusion proofs still) constructed in limited contexts (contracts?).\r\n- note on `<body>`: encoders for bodies can be remixed with different header types to implement all the types easily:\r\n  - read by offsets\r\n  - read by stride (fixed increment per element)\r\n  - read by element size (variable increment per element).\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501480271/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501496457",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-501496457",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 501496457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTQ5NjQ1Nw==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-12T23:54:25Z",
    "updated_at": "2019-06-12T23:54:33Z",
    "author_association": "MEMBER",
    "body": "I'm very confused by your post... at least it does not feel like a simplification to me ;)\r\nHave we defined sparse objects yet?\r\nAlso the bitfields is not how it works (we pad them on the left)\r\n\r\n> Dynamic, root: H(len, merkle(pad_right(elements, M)))\r\n\r\nMixing in the length is always on the right",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501496457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501509049",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-501509049",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 501509049,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTUwOTA0OQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-13T01:02:12Z",
    "updated_at": "2019-06-13T01:02:12Z",
    "author_association": "MEMBER",
    "body": "> Have we defined sparse objects yet?\r\n\r\nNo, but I posted this serialization earlier in the chat, as it is consistent with offsets, and simple. But improvements are very welcome. (also see note on ordering of indices)\r\n\r\n> Also the bitfields is not how it works (we pad them on the left)\r\n\r\nSee edits, that is what I did previously. But that's not consistent with the current verify-bitfield behavior, which is like a little endian int. Also, a big little endian integer sounds more consistent too me. But considered big-endian for formatting/reading reasons (prefer it too, as there's no \"gap\" in the bits when you align a 9 bit integer in bytes)\r\n\r\n> Mixing in the length is always on the right\r\n\r\nWhoops, wrote it a bit quick, but you get the idea",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501509049/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501751755",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-501751755",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 501751755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTc1MTc1NQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-13T15:25:53Z",
    "updated_at": "2019-06-13T15:26:05Z",
    "author_association": "MEMBER",
    "body": "> But that's not consistent with the current verify-bitfield behavior, which is like a little endian int. \r\n\r\nOh yes, forgot it's little endian. Then it should be on the right.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/501751755/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504093452",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-504093452",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 504093452,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNDA5MzQ1Mg==",
    "user": {
      "login": "ethers",
      "id": 6937903,
      "node_id": "MDQ6VXNlcjY5Mzc5MDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6937903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ethers",
      "html_url": "https://github.com/ethers",
      "followers_url": "https://api.github.com/users/ethers/followers",
      "following_url": "https://api.github.com/users/ethers/following{/other_user}",
      "gists_url": "https://api.github.com/users/ethers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ethers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ethers/subscriptions",
      "organizations_url": "https://api.github.com/users/ethers/orgs",
      "repos_url": "https://api.github.com/users/ethers/repos",
      "events_url": "https://api.github.com/users/ethers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ethers/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-20T16:27:07Z",
    "updated_at": "2019-06-20T16:27:07Z",
    "author_association": "MEMBER",
    "body": "I may add information here to help others who just arrive.\r\n\r\n### What is an SSZ Partial?\r\n\r\nAn SSZ partial is an object that can stand in for an SSZ object in any function, but which only contains some of the elements in the SSZ object. It also contains Merkle proofs that prove that the values included in the SSZ partial actually are the values from the original SSZ object; this can be verified by computing the Merkle root of the SSZ partial and verifying that it matches the root of the original SSZ object.\r\n\r\nSource: https://github.com/ethereum/research/tree/master/ssz_research/partials",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504093452/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/505846853",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1160#issuecomment-505846853",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1160",
    "id": 505846853,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNTg0Njg1Mw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-26T12:08:25Z",
    "updated_at": "2019-06-26T12:08:25Z",
    "author_association": "MEMBER",
    "body": "Addressed in #1180",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/505846853/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
