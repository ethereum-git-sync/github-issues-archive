{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/129",
  "id": 380728064,
  "node_id": "MDU6SXNzdWUzODA3MjgwNjQ=",
  "number": 129,
  "title": "Proposal to use SSZ for consensus only",
  "user": {
    "login": "rawfalafel",
    "id": 202157,
    "node_id": "MDQ6VXNlcjIwMjE1Nw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/202157?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rawfalafel",
    "html_url": "https://github.com/rawfalafel",
    "followers_url": "https://api.github.com/users/rawfalafel/followers",
    "following_url": "https://api.github.com/users/rawfalafel/following{/other_user}",
    "gists_url": "https://api.github.com/users/rawfalafel/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rawfalafel/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rawfalafel/subscriptions",
    "organizations_url": "https://api.github.com/users/rawfalafel/orgs",
    "repos_url": "https://api.github.com/users/rawfalafel/repos",
    "events_url": "https://api.github.com/users/rawfalafel/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rawfalafel/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 16,
  "created_at": "2018-11-14T14:39:10Z",
  "updated_at": "2019-01-17T15:40:34Z",
  "closed_at": "2019-01-17T15:40:34Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Instead of using ssz for both network and consensus, I think we should use ssz only for consensus and standardize around protobuf at the network layer. \r\n\r\n**Benefits**\r\n* Eliminates the ssz decoder since there's no need for the encoding to be reversible.\r\n* Eliminates the need for a length prefix in the ssz encoder. Same reason as above.\r\n* Allows the ssz encoder to be space inefficient (e.g. padding) since the result doesn't need to be stored or sent over the wire.\r\n* protobuf is already battle-tested and fits this use case well.\r\n* protobuf supports schemas and versioning out of the box.\r\n* protobuf already has solid libraries for many languages. \r\n* protobuf's code generation provides good ergonomics for developers.\r\n\r\n**Potential conerns**\r\n* Supporting two serializers increases complexity\r\n    * In my opinion, inventing a serializer that satisfies the needs of both consensus and networking is much more complex.\r\n    * Using protobuf for networking is way simpler. This is definitely true for Prysm, and I imagine this is true for other implementation teams as well, but I'd like to hear other team's opinions.\r\n    * ssz becomes simpler if its only used for consensus.\r\n* Re-encoding a block from the wire is inefficient\r\n    * The cost of re-encoding is negligible when compared to the other steps necessary for verification. The byte array needs to be decoded, the encoding needs to be hashed, and the signature needs to be verified.\r\n* Protobuf is bad because [insert opinion here]\r\n    * I'm open to other libraries, but protobuf seems like a good fit for the reasons stated above.\r\n\r\n**Previous discussions** \r\n* [ethresear.ch: P2P message serialization standard](https://ethresear.ch/t/discussion-p2p-message-serialization-standard/2781/2) \r\n* https://github.com/ethereum/beacon_chain/issues/94",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129/reactions",
    "total_count": 5,
    "+1": 3,
    "-1": 2,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438913900",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-438913900",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 438913900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODkxMzkwMA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T04:31:38Z",
    "updated_at": "2018-11-15T04:31:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "Recapping, non-determinism (unspecified field ordering, overlong encodings allowed) and complexity of additional dependency were cited reasons for discarding it the first time around, while machine-readable schema and compactness of varint encoding were main positives. The data-type fit is also not that good, with no native types for fixed-length arrays (hashes, addresses) and unnecessary types like zigzags and floats adding surface area - this can be seen in the maximum value tests @paulhauner points to here: https://ethresear.ch/t/discussion-p2p-message-serialization-standard/2781/16\r\n\r\n> other team's opinions\r\n\r\nFor nimbus, we'll end up writing custom decoders regardless of chosen format - generated protobuf code tends to be optimized for generic use cases and given data type mismatch will need a fair bit of \"manual\" processing anyway. No net simplicity gain, quite the opposite for the client itself (not considering 3rd party tooling).\r\n\r\nWire encoding is an aspect of the protocol that's easy to change once the semantics nailed - thus we're also happy to delay a final decision for when more hard data is available.\r\n\r\nGood points on keeping the two concerns (network/consensus) separate, during the design phase at least.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438913900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438958007",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-438958007",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 438958007,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODk1ODAwNw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T08:29:05Z",
    "updated_at": "2018-11-15T08:29:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "So I see two points here; \r\n- p2p and hashing should use distinct serialization schemes.\r\n- p2p serialization should be protobuf.\r\n\r\n## Distinct serialization schemes\r\n\r\nRegarding using distinct serialization schemes, I have the following points:\r\n\r\n1. I agree that hashing would be more space/time efficient if we don't serialize the length bytes. I don't have a clear idea as to the volume of this efficiency.\r\n2. I don't see any reasoning here why we _shouldn't_ use SSZ for the p2p format. E.g., it's bloated or slow.\r\n3. Implementing a SSZ decoder is not very difficult. I've implemented one myself and I know a few other teams have also.\r\n\r\n## Protobuf\r\n\r\nHere are my reservations regarding using protobuf: \r\n\r\n1. It is externally-defined. I like that the RLP and SSZ specifications are designed and maintained by Ethereum and their design scope is limited strictly to Ethereum.\r\n2. I don't see using protobuf as simplifying the spec by removing the SSZ decoder. Instead, I see it as adding complexity to the spec by effectively importing the entire protobuf spec. With protobuf we'd have 2x encoders and 1x decoder. The protobuf spec is generic and I understand it has features that we don't require.\r\n3. It is maintained by Google. This is a bit philosophical and murky, but baking Google-maintained code into the P2P layer seems to go somewhat against the grain of the \"decentralized web\". (It's my understanding that libp2p uses protobuf, so maybe this has already happened?).\r\n4. It's non-deterministic. \"Consensus hashing\" is now merkelized, but one could still keep records of non-merkelized SSZ blobs to determine if they're known or not. I'm not sure if this will be required, but it seems like a nice feature to have up our sleeves.\r\n\r\n## Summary\r\n\r\nI can see there would be some gains in hashing speed by dropping length bytes from SSZ, but I'm uncertain as to how significant they are. It's my understanding that this spec targets simplicity over hardcore optimisation and my concern is that introducing a new p2p serialization format lies too far on the side of optimization.\r\n\r\nI'd like to see the following before I'd consider a switch to separate P2P and hashing serialization:\r\n\r\n- Clear reasoning as to why SSZ shouldn't be used on the wire.\r\n- Benchmarks that demonstrate the speed gains in merkle hashing that are obtained from dropping the length bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/438958007/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439017338",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439017338",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439017338,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTAxNzMzOA==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T12:02:37Z",
    "updated_at": "2018-11-15T12:02:37Z",
    "author_association": "MEMBER",
    "body": "#### Considerations\r\n- IMO, whatever serialization algorithm is used its implementation _should_ be a part of client's codebase to eliminate risks occurring with usage of external libs; these risks are pretty big in our context.\r\n- Hashing algorithm that is about to get merged soon https://github.com/ethereum/eth2.0-specs/pull/120. \r\n  This hashing algorithm is a kind of serialization+hashing out of the box. It is, also, much more memory efficient than plain `hash(SSZ(obj))`.\r\n\r\n#### Benefits\r\n> - Eliminates the ssz decoder.\r\n  \r\nBut introduces protobuf spec implementation (in the light of maintaining own protobuf impls).\r\n\r\n> - Eliminates the need for a length prefix. \r\n\r\n  As I understand it relates to faster hashing. Hashing algorithm mentioned above _doesn't_ work with lengths prefixes and it, also, does not create copies of object's data.\r\n\r\n> - Allows the ssz encoder to be space inefficient.\r\n\r\n  New hashing algorithm uses paddings but they don't affect SSZ anyhow.\r\n\r\n> - protobuf is already battle-tested and fits this use case well.\r\n\r\n  This is a real thing. There should be a bunch of tests for SSZ including those that check overflows which are effectively discovered by fuzz testing. But in case of custom protobug implementation we're getting to the same problem here as with SSZ.\r\n\r\n> - protobuf supports schemas and versioning out of the box.\r\n\r\n  SSZ serializes objects in a pretty deterministic way without schema definitions which IMO is enough for eth 2.0 needs. Versioning is a good thing, SSZ is not forward compatible in terms of schema update.\r\n\r\n#### Summary\r\nAs a p2p serialization format SSZ lacks forward compatibility in message schemas. It could become a real problem in the future cause even after several versions of PoC there might occur a need of adding something to block, attestation or whatever other messages. A good example is `chainId` field that had to be added to `TransactionMessage` in eth 1.0.\r\n\r\nSSZ spec is pretty simple and with good test coverage it should be easy implementable with high level of reliability. And in my opinion it's important that the spec is maintained by Ethereum community.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439017338/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439569677",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439569677",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439569677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTU2OTY3Nw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-17T00:36:09Z",
    "updated_at": "2018-11-17T00:36:09Z",
    "author_association": "MEMBER",
    "body": "Is this advocating that data structures like blocks should be decomposed and then re-serialized using protobuf instead of SSZ over the wire? If so, that seems like a large increase in complexity...\r\n\r\nWhat's wrong with the current approach of sending consensus objects around in the same byte format in which they appear in consensus? The network protocol that's used to wrap the objects could still be protobuf or whatever else if desired.\r\n\r\n> I agree that hashing would be more space/time efficient if we don't serialize the length bytes. I don't have a clear idea as to the volume of this efficiency.\r\n\r\nIt's tiny. The main hashing cost is state recalculations, and in this case, account objects are fixed size and lists tend to be very long so the marginal contribution of length prefixes is very low.\r\n\r\nIn general, sacrificing the property that every object has exactly one way to encode it as bytes and going down this path reeks of sacrificing essential simplicity for a little temporary over-optimization....",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439569677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439676398",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439676398",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439676398,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTY3NjM5OA==",
    "user": {
      "login": "rawfalafel",
      "id": 202157,
      "node_id": "MDQ6VXNlcjIwMjE1Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/202157?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rawfalafel",
      "html_url": "https://github.com/rawfalafel",
      "followers_url": "https://api.github.com/users/rawfalafel/followers",
      "following_url": "https://api.github.com/users/rawfalafel/following{/other_user}",
      "gists_url": "https://api.github.com/users/rawfalafel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rawfalafel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rawfalafel/subscriptions",
      "organizations_url": "https://api.github.com/users/rawfalafel/orgs",
      "repos_url": "https://api.github.com/users/rawfalafel/repos",
      "events_url": "https://api.github.com/users/rawfalafel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rawfalafel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-18T08:35:55Z",
    "updated_at": "2018-11-18T08:35:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the feedback everyone!\r\n\r\n> What's wrong with the current approach of sending consensus objects around in the same byte format in which they appear in consensus? The network protocol that's used to wrap the objects could still be protobuf or whatever else if desired.\r\n\r\nIs it important that the network sends consensus objects in the same format that they're hashed in? I was arguing that it isn't, since the clients themselves should be handling the consensus objects in some data structure, not the encoding. Its handy when monitoring the network, and there may be other important reasons that I'm missing.\r\n\r\n> It is externally-defined. I like that the RLP and SSZ specifications are designed and maintained by Ethereum and their design scope is limited strictly to Ethereum.\r\n\r\nI agree that this is a risk. There's always the chance that we want a feature that isn't provided, and we're forced to hack around it or fork.\r\n\r\nA big concern I'm hearing is that protobuf's surface area is too large for our use case. I kinda agree, and we would have to do a more thorough audit if we want to adopt protobuf (or another 3rd party library), but I would also argue that there's less risk from a security perspective, since its not used for consensus. \r\n\r\nThe second concern I see is that the benefits I listed above aren't enough to justify switching over from ssz to protobuf. I can only speak about Go, where an implementation of ssz will be slower and harder to use/debug without significant effort. But part of the reason for this is because Golang lacks generics, which isn't relevant to other languages, and maybe I should keep this to myself :) I'm curious how protobuf would compare to ssz in Rust, so I may try that at some point.\r\n\r\nThe mood that I'm feeling in this thread is that everyone's okay with using ssz for both consensus and the network. If so, I'm okay with maintaining the status quo. However, my concern is that ssz continues to be used for all encoding/decoding in Ethereum 2.0, including non-consensus objects, and at some points it stops living up to the \"simple serializer\" name.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439676398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439707276",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439707276",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439707276,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTcwNzI3Ng==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-18T16:50:56Z",
    "updated_at": "2018-11-18T16:50:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It is maintained by Google. This is a bit philosophical and murky, but baking Google-maintained code into the P2P layer seems to go somewhat against the grain of the \"decentralized web\". (It's my understanding that libp2p uses protobuf, so maybe this has already happened?).\r\n\r\nGoogle can't force you to update protobuf version and you are free to fork it at any time. Git based projects are as decentralized as you would like them to be and I think this a poor argument against a technology. To take this to the extreme would mean writing everything from the ground up. Go is also maintained by Google and subject to change at any time, but it doesn't mean using it goes against the virtues of decentralized technology. \r\n\r\nI agree that there needs to be a clear argument for using protobuf over SSZ, and I would be interested to see benchmarks between the two strategies at scale. \r\n\r\nGoing forward, Prysm clients may support both wire protocols and prefer protobuf for `prysm <> prysm` client communication. This might provide some helpful metrics in the future. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439707276/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439734995",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439734995",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439734995,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTczNDk5NQ==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-18T23:15:11Z",
    "updated_at": "2018-11-18T23:19:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "DELETED",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439734995/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439735264",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439735264",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439735264,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTczNTI2NA==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-18T23:19:08Z",
    "updated_at": "2018-11-18T23:22:15Z",
    "author_association": "CONTRIBUTOR",
    "body": ">...you are free to fork it at any time. Git based projects are as decentralized as you would like them to be and I think this a poor argument against a technology\r\n\r\nI realise it can be forked, but developing and maintaining a succinct, application specific component could be much less effort than forking and maintaining a much larger, generalised component.\r\n\r\n>To take this to the extreme would mean writing everything from the ground up. Go is also maintained by Google and subject to change at any time, but it doesn't mean using it goes against the virtues of decentralized technology.\r\n\r\nI mentioned this point was philosophical and I think it’s reasonable that a philosophy becomes nonsensical when taken to the extreme. I was trying to avoid having external components baked into the spec, not avoiding using external components in the implementation at all costs.\r\n\r\nRegardless of all of this, it seems that protobuf is baked into the libp2p spec so my objections to it are futile. Paul: 0, Google: 1.\r\n\r\nI don’t want to end up bikeshedding about libp2p so I’m happy to accept protobuf as a cool piece of tech that we’re going to use. I honestly do think it’s cool and would use it without hesitation in other scenarios.\r\n\r\nI’m still open for technical discussions on why we shouldn’t push consensus-serialised objects around the network, if more information comes to light :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439735264/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439736619",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-439736619",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 439736619,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTczNjYxOQ==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-18T23:38:09Z",
    "updated_at": "2018-11-18T23:38:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "Speaking from experience, reimplementing the wire encoding part of protobuf - which is what you actually need to work with protobuf-encoded data (\"minimal protobuf\") - is trivial. It's comparable to ssz in terms of complexity. I wouldn't worry too much about it from an \"3rd party libraries are bad\" perspective.\r\n\r\nThe fact that libp2p uses protobuf is not a reason to put it in the application protocol, just like you wouldn't consider the TCP packed binary fields to be a constraint on the design.\r\n\r\nProtobuf being a key-value format, and not supporting fixed-lengths arrays, are solid arguments not to go with it however - you will need to perform \"encoding\" and \"decoding\" steps to get from consensus data to protobuf-typed data (\"hashes are encoded as variable-length byte buffers\" is an encoding step!), _and then_ do the protobuf wire encoding. \r\n\r\nI like that prysmatic, that is suggesting the feature, will be doing both - then we can get some solid numbers and make an informed choice. Until then, the numbers from Lighthouses simulations speak in SSZ's favor, as do other arguments.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/439736619/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/440480940",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-440480940",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 440480940,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDQ4MDk0MA==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-21T00:32:17Z",
    "updated_at": "2018-11-21T00:32:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Speaking from experience, reimplementing the wire encoding part of protobuf - which is what you actually need to work with protobuf-encoded data (\"minimal protobuf\") - is trivial. \r\n\r\nAwesome, I would be keen to do this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/440480940/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/440484974",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-440484974",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 440484974,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDQ4NDk3NA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-21T00:47:13Z",
    "updated_at": "2018-11-21T00:47:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "http://jpa.kapsi.fi/nanopb/ is a fairly easy role model implementation, though even that one strives to be more \"generic\" than you have to be, if you really want to specialize",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/440484974/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/441388670",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-441388670",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 441388670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTM4ODY3MA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-24T19:01:16Z",
    "updated_at": "2018-11-24T19:01:16Z",
    "author_association": "MEMBER",
    "body": "It's worth noting that if we go this way, then the only part of SSZ we would actually be using is the tree hashing, which is actually a fairly small and compact part of the protocol.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/441388670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/443507251",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-443507251",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 443507251,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MzUwNzI1MQ==",
    "user": {
      "login": "conor10",
      "id": 2148266,
      "node_id": "MDQ6VXNlcjIxNDgyNjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2148266?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/conor10",
      "html_url": "https://github.com/conor10",
      "followers_url": "https://api.github.com/users/conor10/followers",
      "following_url": "https://api.github.com/users/conor10/following{/other_user}",
      "gists_url": "https://api.github.com/users/conor10/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/conor10/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/conor10/subscriptions",
      "organizations_url": "https://api.github.com/users/conor10/orgs",
      "repos_url": "https://api.github.com/users/conor10/repos",
      "events_url": "https://api.github.com/users/conor10/events{/privacy}",
      "received_events_url": "https://api.github.com/users/conor10/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-02T13:23:11Z",
    "updated_at": "2018-12-02T13:23:11Z",
    "author_association": "NONE",
    "body": "It would be great to see protobufs used for the network layer. @rawfalafel does your proposal include gRPC too?\r\n\r\nWhen you throw [gRPC](https://grpc.io/) into the mix, it's trivial move beyond simple RPC and have streaming services between components backed by HTTP/2, which is another significant value-add.\r\n\r\nI've seen countless developer hours wasted on getting different network serialisation protocols to work between services. Protobufs provide a concise, straight forwards interface language with great cross-platform support. I've seen multiple projects switch to using it and never look back.\r\n\r\nIt will also save a lot of time for those of us developing and maintaining Ethereum integration libraries as we transition to eth2.0 support ... 😉 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/443507251/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/443557667",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-443557667",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 443557667,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MzU1NzY2Nw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-03T00:35:11Z",
    "updated_at": "2018-12-03T00:37:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It's worth noting that if we go this way, then the only part of SSZ we would actually be using is the tree hashing, which is actually a fairly small and compact part of the protocol.\r\n\r\nWe would still need an SSZ encoder to go from language-specific-object to bytes though, right? Protobuf as a whole makes no guarantees about byte level determinism, however there seem to be [some people who achieved](https://havoc.io/post/deterministic-protobuf/) it in a \"hackish\" way (their words, not mine). Maybe there's an elegant way?\r\n\r\n@conor10 I think everyone agrees about using established protocol (e.g., protobufs) for talking between \"internal\" components, like beacon-node to validator-client. As I understand it, this discussion is around whether p2p nodes should send block, attestations, etc to each other as SSZ or protobuf.\r\n\r\nIf protobuf can elegantly replace SSZ I'm not opposed to doing so. I'm ditching all my \"philosophical\" concerns after having a look at minimal protobuf. Seems pretty easy to maintain.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/443557667/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/446762475",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-446762475",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 446762475,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Njc2MjQ3NQ==",
    "user": {
      "login": "rawfalafel",
      "id": 202157,
      "node_id": "MDQ6VXNlcjIwMjE1Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/202157?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rawfalafel",
      "html_url": "https://github.com/rawfalafel",
      "followers_url": "https://api.github.com/users/rawfalafel/followers",
      "following_url": "https://api.github.com/users/rawfalafel/following{/other_user}",
      "gists_url": "https://api.github.com/users/rawfalafel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rawfalafel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rawfalafel/subscriptions",
      "organizations_url": "https://api.github.com/users/rawfalafel/orgs",
      "repos_url": "https://api.github.com/users/rawfalafel/repos",
      "events_url": "https://api.github.com/users/rawfalafel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rawfalafel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-12T22:07:06Z",
    "updated_at": "2018-12-12T22:07:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Protobuf being a key-value format, and not supporting fixed-lengths arrays, are solid arguments not to go with it however\r\n\r\nGood point. Protobuf not supporting fixed length byte arrays is pretty annoying.\r\n\r\n> It would be great to see protobufs used for the network layer. @rawfalafel does your proposal include gRPC too?\r\n\r\nPrysmatic plans to use gRPC for internal communication, but I don't know where I stand about making it a standard.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/446762475/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/455217104",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/129#issuecomment-455217104",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/129",
    "id": 455217104,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTIxNzEwNA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-17T15:40:30Z",
    "updated_at": "2019-01-17T15:40:30Z",
    "author_association": "MEMBER",
    "body": "I understand the consensus (pun unintended) is to use SSZ for both consensus and network. Feel free to reopen :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/455217104/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
