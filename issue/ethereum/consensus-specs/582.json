{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/582",
  "id": 407886539,
  "node_id": "MDU6SXNzdWU0MDc4ODY1Mzk=",
  "number": 582,
  "title": "Doubts about the monolithic BeaconState",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2019-02-07T20:37:04Z",
  "updated_at": "2019-02-09T01:02:01Z",
  "closed_at": "2019-02-09T01:02:00Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Doubts about the monolithic BeaconState\r\n\r\nSo, I'm having doubts about the current BeaconState approach in the spec.\r\n\r\nI am not so familiar with the status-quo, outside of the spec. But there is not enough resources and too many questions popping up when implementing my own beacon-chain simulation/client to not start a good discussion on this.\r\n\r\nWhat's the reasoning behind designing Eth 2.0 based on a **single object that carries all the different state information**, besides ease in computing a `state_root` (i.e. serialize everything and hash it)?\r\n\r\nWouldn't it make more sense to store things based on usage category, change interval, and special needs?\r\n\r\nBecause of the current spec-design, many clients just implemented state as a single object that is read/written for every block, or slot. As far as I know at least, please point me to clients that have different approaches (and the respective commit / branch).\r\nAll I'm finding is one-go serialization with protobufs etc., is this really affordable enough to afford the monolithic simplicity?\r\n\r\nSome of these state variables don't even change between slots or blocks, so why repeatedly store them? Would a reference to the last change of some category of sub-state not be enough?\r\n\r\nAnd I would expect things like validator balances to be much more similar to the Eth 1.0 design, with a separate merkle-tree. What's the rationale here?\r\n\r\nExcuse me for my ignorance/lack of google fu if this is already worked out somewhere.\r\n*Having doubts about something is the start of knowledge*, and documenting the rationale of current choices (*and possibly improving*) is something I think is very important. For all folks that want to contribute, and as a reference during future discussions about rationale in state design.\r\n\r\n## The problem\r\n\r\n- Big state size by design\r\n   - Long serialize time\r\n   - Long deserialize time\r\n   - The lifecycle is easy, but operations take longer. Retrieving, hashing (state root!), and storing are slower.\r\n- No encapsulation by design\r\n   - A simple API to query a balance would already require you to deserialize the full state.\r\n   - It is harder to verify changes when they are not isolated\r\n   - Adding new state while being backwards compatible may be harder without encapsulation guidelines/rules in the design.\r\n   - Encapsulation based on write-interval, may be beneficial to send state over a network connection. Some of it simply doesn't need to be transferred all the time.\r\n- Duplication of data that is encouraged by design\r\n   - The easiest way to implement the spec is to simply serialize the whole state and put it in some key-value store. *Many clients already do this*\r\n   - Data that has not changed is stored again. Every block, or every slot even.\r\n\r\nAbout serialization/deserialization/hashing: I do not know how well it works, or scales. All I see is that it can be better. See trade-offs section. Documenting the affordability of choices like these would be nice at least.\r\n\r\n## Outline of the state variables\r\n\r\nThis is the current `BeaconState`, with my comments on each part, to share my sense of amount of changes in the state, and alternatives. If you have suggestions/corrections, please share.\r\n\r\n```\r\n    # Misc\r\n    'slot': 'uint64'\r\n```\r\nDerived from block storage.\r\n\r\n```\r\n    'genesis_time': 'uint64',\r\n```\r\nStored only once, loaded on initalization\r\n```\r\n    'fork': Fork,  # For versioning hard forks\r\n```\r\nSmall data, can be repeated, but could also just be a reference to fork-data, stored elsewhere.\r\n\r\n```\r\n    # Validator registry\r\n    'validator_registry': [Validator],\r\n```\r\nCan be VERY large in worst case. As in 4M entries. Each with pub-key data. And the only thing that changes every now and then is epochs. Can't we separate activation/exit/withdrawal/penalized epochs + status flags from the identification data, similar to separation of account-data in Eth1? (i.e. the state trie) And then just store a list of participating validators per-epoch. One could even keep a separate lookup table of pubkey<->numerical validator ID, if you really want to reduce storage in a long-term worst-case scenario.\r\n\r\n```\r\n    'validator_balances': ['uint64'],\r\n```\r\nLike above, also very large, and continuously changing, I would expect balances to be in a state-trie.\r\n```\r\n\r\n    'validator_registry_update_epoch': 'uint64',\r\n```\r\nSomething small, no problem\r\n\r\n```\r\n    # Randomness and committees\r\n    'latest_randao_mixes': ['bytes32'],\r\n    'previous_epoch_start_shard': 'uint64',\r\n    'current_epoch_start_shard': 'uint64',\r\n    'previous_calculation_epoch': 'uint64',\r\n    'current_calculation_epoch': 'uint64',\r\n    'previous_epoch_seed': 'bytes32',\r\n    'current_epoch_seed': 'bytes32',\r\n```\r\nAll this RANDAO data only changes each epoch, just store this in an per-epoch state? Keyed by the first block in the epoch, that introduces the changes?\r\n \r\n```\r\n    # Finality\r\n    'previous_justified_epoch': 'uint64',\r\n    'justified_epoch': 'uint64',\r\n    'justification_bitfield': 'uint64',\r\n    'finalized_epoch': 'uint64',\r\n```\r\nAlso purely per-epoch written data.\r\n\r\n```\r\n    # Recent state\r\n    'latest_crosslinks': [Crosslink],\r\n```\r\nChanges every epoch, can be included with finality data above.\r\n\r\n```\r\n    'latest_block_roots': ['bytes32'],\r\n```\r\n\r\nChanges every slot, there is `LATEST_BLOCK_ROOTS_LENGTH` of them. `32 * 8,192 = 1/4 MB`. Doubts here.\r\n```\r\n    'latest_index_roots': ['bytes32'],\r\n```\r\nSimilar to block roots, current spec only changes it per epoch, but this may become per-block if we start supporting introduction of new validators during an epoch.\r\n```\r\n    'latest_penalized_balances': ['uint64'],  # Balances penalized at every withdrawal period\r\n```\r\nSomething that changes every block. Just 8,192 numbers, but we could also just save 3, per block: the previous, current and last epoch number. And then trail the remainder every epoch transition, similar to what happens now.\r\n```\r\n    'latest_attestations': [PendingAttestation],\r\n```\r\nUpdated every block (if it includes attestations). Only used to filter through, and derive current_epoch_attestations and previous_epoch_attestations. These may have been included in a later epoch however. The naming refers to the epoch that the attestation itself attests in, \"pending\" being that it needs to be checked for slashing. This could be stored per-epoch. An alternative to would be a DB that: indexes based on attestation-slot and inclusion-epoch-root. One can just query the attestations necessary for the epoch transition.\r\n```\r\n    'batched_block_roots': ['bytes32'],\r\n```\r\nChanges every LATEST_BLOCK_ROOTS_LENGTH slots. Can easily be in its own storage, and ignored. It's not used anywhere in the spec, and only serves purposes like syncing/verification to start a client.\r\n```\r\n    # Ethereum 1.0 chain data\r\n    'latest_eth1_data': Eth1Data,\r\n```\r\nEven less than per epoch, it changes every ETH1_DATA_VOTING_PERIOD (16) epochs, but continuously read.\r\n```\r\n    'eth1_data_votes': [Eth1DataVote],\r\n```\r\nOnly needs to be stored for unfinalized blocks (?) given the nature of the \r\n\r\n## Trade-offs\r\n\r\nThe big question before we change the state: **Is the current monolithic simplicity warranted?**\r\n\r\n- Do we finalize and throw away data quick enough to not care?\r\n- Is the state still small enough for hashing it fully, every slot?\r\n- What's the current freedom in constructing the state_root? Do we just cache hashes for unchanged data portions?\r\n\r\n\r\n## Alternative\r\n\r\nI do not think an alternative has to be very complex, but there's a lot of room for optimization.\r\n\r\n### Easy\r\n\r\nA good first step would be to simply split it up in a `BeaconEpochState` and a `BeaconSlotState`.\r\nWith the slot state referencing the epoch state.\r\n\r\nThe `BeaconEpochState` can be split up in more parts, but each could change each epoch, so outside of encapsulation, and hashing, there is not so much need to consider this much in the spec. If epoch-state hashing is defined by hashing the roots of all subcategories together category, bundling and storing related data would be easier however.\r\n\r\nNote that this could make the block/slot-transition much faster, as you would only work on a subset of memory, and deal with less serialization/hashing. And it's not far from current state of things.\r\n\r\n### Medium\r\n\r\nSplit off the validator registry, and validator balances.\r\n\r\n- Create a literal validator-registry with *static* properties of validators, i.e. their `pubkey`, `withdrawal_credentials` and whatnot. Call this the `ValidatorRegistry`. This data-structure could be optmized for insertions/deletions, changes don't have to be considered (afaik.)\r\n- Create a something similar to the \"state-trie\" in Eth1 (the one that carries nonces and balances), call it the `ValidatorTrie` that carries the dynamic validator data: entry/exit/etc. epochs, status flags, and balance.\r\n\r\nThe `ValidatorRegistry` could be referenced in the epoch-state, or in the slot-state if we're adding/removing validators more often.\r\nThe `ValidatorTrie` could be referenced in the slot-state. This has all the data that changes often, and what is immediately affected when a validator is kicked, not the validator registry.\r\n\r\n### Hard\r\n\r\n#### Attestations\r\n\r\nAn attestation DB that:\r\n- Abstracts away aggregation, to insert any collection of attestations, and lets you query total weight for a given target. (fork-choice)\r\n- Can be queried for attestations for a given slot, included at a given slot. (for slashing)\r\n\r\n#### Block roots\r\n\r\nSeparate batched block-roots, and do this in in a tree-structure to account for forks if finalization before LATEST_BLOCK_ROOTS_LENGTH slots is not possible.\r\nThe pointer to the top of the batched roots list would be included in the state.\r\n\r\nPro: small state, easy to update and hash.\r\n\r\nCon: batched block roots not included in state anymore. Do we really need to force them to be *that* available to anyone that wants to hash the state?\r\n",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461591281",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461591281",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461591281,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTU5MTI4MQ==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T20:52:37Z",
    "updated_at": "2019-02-07T20:52:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is a concern that the Nimbus team shares and actually discussed today with @djrtwo, using the terminology `God object`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461591281/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461591587",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461591587",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461591587,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTU5MTU4Nw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T20:53:37Z",
    "updated_at": "2019-02-07T20:53:37Z",
    "author_association": "MEMBER",
    "body": "@mratsim Good to hear I'm not the only one. Can I find this discussion anywhere?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461591587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461592526",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461592526",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461592526,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTU5MjUyNg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T20:56:24Z",
    "updated_at": "2019-02-07T20:56:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "It was a project sync call unfortunately.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461592526/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461597872",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461597872",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461597872,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTU5Nzg3Mg==",
    "user": {
      "login": "benjaminion",
      "id": 20796281,
      "node_id": "MDQ6VXNlcjIwNzk2Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20796281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benjaminion",
      "html_url": "https://github.com/benjaminion",
      "followers_url": "https://api.github.com/users/benjaminion/followers",
      "following_url": "https://api.github.com/users/benjaminion/following{/other_user}",
      "gists_url": "https://api.github.com/users/benjaminion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benjaminion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benjaminion/subscriptions",
      "organizations_url": "https://api.github.com/users/benjaminion/orgs",
      "repos_url": "https://api.github.com/users/benjaminion/repos",
      "events_url": "https://api.github.com/users/benjaminion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benjaminion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T21:13:33Z",
    "updated_at": "2019-02-07T21:13:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "> What's the current freedom in constructing the state_root? Do we just cache hashes for unchanged data portions?\r\n\r\nYes. This is the point of the SSZ `tree_hash` algorithm.\r\n\r\nAIUI, specifiying the state in one place just ring-fences the consensus critical parts in the spec. Implementers are free to optimise this in any way they see fit.\r\n\r\n[Historical note, there used to be two states: `crystallized_state` and `active_state` for all the reasons you mention. See #122 for the thinking behind unifying the state. It is `tree_hash` that makes this practical.]",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461597872/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461605143",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461605143",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461605143,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTYwNTE0Mw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T21:37:12Z",
    "updated_at": "2019-02-07T21:37:12Z",
    "author_association": "MEMBER",
    "body": "The short answer here is that SSZ hash tree does separate and encapsulate different objects by default. It allows a blank slate for clients to store/cache/update/hash in any number of ways. State objects can easily be stored locally as diffs with caches of hashes that prevent rehashing the majority of the state when calculating the `state_root`.\r\n\r\nI see the argument for pulling out portions of the state into separate independent objects that all need to be committed to in a beacon block for the sake of cleanliness, but again, the SSZ tree hash natively handles this via commitment to one root. \r\n\r\n> All this RANDAO data only changes each epoch, just store this in an per-epoch state? Keyed by the first block in the epoch, that introduces the changes?\r\n\r\nThe goal of the state transition function is that it satisfies `state_transition(prev_state, block) -> post_state` where `prev_state` is committed to in the parent block. The more we pull things out into their own separate commitment, `prev_state` just becomes a tuple `(epoch_state, active_state, validators, validator_balances, validator_epochs, etc)` which arguably the `BeaconState` when using the tree hash already is.\r\n\r\n> Changes every LATEST_BLOCK_ROOTS_LENGTH slots. Can easily be in its own storage, and ignored. It's not used anywhere in the spec, and only serves purposes like syncing/verification to start a client.\r\n\r\nIncluding info such as this directly committed to in the state allows for a host of techniques in serving light clients. The more we move things out into a separate DB, the less able we are to serve required info based upon the `state_root` to facilitate light syncing and validation.\r\n\r\n>   Is the state still small enough for hashing it fully, every slot?\r\n\r\nSSZ tree hash was designed for this purpose. Most of the state does not change. Hashes need only be recomputed for the portion of the state that changes (small).\r\n\r\n>   What's the current freedom in constructing the state_root? Do we just cache hashes for unchanged data portions?\r\n\r\nA client must only be able to compute the state root as the same value as other clients. They can (and should) make any number of design decisions locally to separate concerns, encapsulate, optimize, etc. \r\n\r\n## Easy\r\n\r\n> A good first step would be to simply split it up in a `BeaconEpochState` and a `BeaconSlotState`.\r\nWith the slot state referencing the epoch state.\r\n\r\nWe used to have this as `ActiveState` and `CrystallizedState`. Both roots were committed to at each block. I remember when we unified that Prysmatic Labs removed thousands of lines from their codebase. That said, a client can divide these things out as they see fit as long as they can still compute valid SSZ state roots.\r\n\r\n> Note that this could make the block/slot-transition much faster, as you would only work on a subset of memory, and deal with less serialization/hashing. And it's not far from current state of things.\r\n\r\nWith SSZ tree hash with caching, there is not a measurable reduction in serialization/hashing.\r\n\r\nAlso, regardless of how you slice it, a client is going to have to store the bulk of the current state (validator registry) in memory to validate attestations and block signatures on a per slot basis.\r\n\r\n## Medium\r\n\r\nSame arguments as above.\r\n\r\n## Hard\r\n### Attestations\r\nAn attestation DB outside of the state consensus root sounds like a fine path for a client implementation, but this now mixes/aggregates attestations that have been included on chain (thus part of the state transition function and contributing to fork choice) with those that are not yet on chain (contributing to fork choice). \r\n\r\n### Block roots\r\nThese are committed to in the `state_root` to better serve light clients. Even if you pull them out, the root would still need to be committed to in the block for servability.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461605143/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461615361",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461615361",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461615361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTYxNTM2MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T22:16:11Z",
    "updated_at": "2019-02-07T22:16:11Z",
    "author_association": "MEMBER",
    "body": "`CrystallizedState`: yes, I know what it is and heard about the changes you went through, I was not involved at all however. The complexity reduction is an overstatement in my opinion, as it introduces a lot of new questions, harder to get into when you're not so familiar with SSZ, or your chosen platform does not work as well with the requirements that come with this.\r\n\r\nAttestations: agree on separation of attestation types, a DB could still facilitate it, but probably better to handle in client-implementation if the spec is full \"SSZ everything\" anyway.\r\n\r\nBlock roots: ok, argumentation for light-clients is understandable.\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461615361/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461619721",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461619721",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461619721,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTYxOTcyMQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-07T22:29:26Z",
    "updated_at": "2019-02-07T22:29:26Z",
    "author_association": "MEMBER",
    "body": "@djrtwo \r\nI'm amazed that SSZ + tree hashing tackles so many problems, much more than I thought it was good for, but now the open questions are:\r\n\r\n- Where can I find info on networking? Does the monolithic approach force us to work out a separate different structure/bundling for efficient communication of non-duplicate data, or do we effectively just send diffs of SSZ output?\r\n- Where can I find notes on *design patterns* with SSZ, is implementation of caching and diffs really that easy?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461619721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461652170",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461652170",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461652170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTY1MjE3MA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-08T00:53:14Z",
    "updated_at": "2019-02-08T00:53:14Z",
    "author_association": "MEMBER",
    "body": "> Where can I find notes on _design patterns_ with SSZ, is implementation of caching and diffs really that easy?\r\n\r\nHere's my implementation of an SSZ list object that can compute updated Merkle roots in real time: https://github.com/ethereum/research/blob/master/ssz_hashable_list/hashable_list.py\r\n\r\nThat's pretty much the only really nontrivial part that needs to be optimized. That implementation is missing one optimization for making k updates in O(k + k * log(n / k)) time instead of O(k * log(n)) time, but that's relatively minor and may give you a 1.5x improvement at most.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461652170/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461653306",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461653306",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461653306,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTY1MzMwNg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-08T00:59:00Z",
    "updated_at": "2019-02-08T00:59:00Z",
    "author_association": "MEMBER",
    "body": "> Where can I find info on networking? Does the monolithic approach force us to work out a separate different structure/bundling for efficient communication of non-duplicate data, or do we effectively just send diffs of SSZ output?\r\n\r\nWhen do you need to send state diffs?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461653306/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461996855",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/582#issuecomment-461996855",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/582",
    "id": 461996855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MTk5Njg1NQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-09T01:02:00Z",
    "updated_at": "2019-02-09T01:02:00Z",
    "author_association": "MEMBER",
    "body": "Was thinking more about what it takes to communicate state with other clients. But attestations/blocks would be sufficient for it to run. The monolithic approach doesn't make encapsulation easy, but with the proposed optimal usage of SSZ (caching encoding and hashes, storing it as diffs, tracking changes), it works well enough.\r\n\r\nAfter my work on LMD-GHOST execution I'll start looking into these SSZ patterns, maybe it can be generalized enough to get a good storage/processing flow going. And with this, and previous work on LMD-GHOST and attestation batching, previous work on structuring (schematic) and prototyping the lifecycle (hackathon client), I may just have enough info and intuitions to get a new beacon-chain client going :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/461996855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
