{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2429",
  "id": 898294002,
  "node_id": "MDU6SXNzdWU4OTgyOTQwMDI=",
  "number": 2429,
  "title": "Light-client feedback",
  "user": {
    "login": "dapplion",
    "id": 35266934,
    "node_id": "MDQ6VXNlcjM1MjY2OTM0",
    "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dapplion",
    "html_url": "https://github.com/dapplion",
    "followers_url": "https://api.github.com/users/dapplion/followers",
    "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
    "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
    "organizations_url": "https://api.github.com/users/dapplion/orgs",
    "repos_url": "https://api.github.com/users/dapplion/repos",
    "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dapplion/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1244766996,
      "node_id": "MDU6TGFiZWwxMjQ0NzY2OTk2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:light-clients",
      "name": "scope:light-clients",
      "color": "211E55",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2021-05-21T18:07:38Z",
  "updated_at": "2023-12-26T20:44:48Z",
  "closed_at": null,
  "author_association": "COLLABORATOR",
  "active_lock_reason": null,
  "body": "After implementing a rough POC web-based light-client consumer in Lodestar, I would like to share some feedback about it.\r\n\r\n1. In `validate_light_client_update` this condition invalidates updates that are technically valid.\r\n```python\r\nif update_period == snapshot_period:\r\n        sync_committee = snapshot.current_sync_committee\r\n        assert update.next_sync_committee_branch == [Bytes32() for _ in range(floorlog2(NEXT_SYNC_COMMITTEE_INDEX))]\r\n```\r\nThe update provider (server) does not know in advance if the update_period is > snapshot_period. It could just check before if `update.next_sync_committee` is zeroed and verify it otherwise\r\n\r\n2. An update provider may want to send the light-client consumer an update for the same slot but with higher consensus. This happens frequently for finalized sync where sync committees will be producing valid updates for the same `update.header.slot` during an epoch but they may have more bits than the previous. This condition invalidates useful updates and I believe it can be omitted.\r\n```python\r\nassert update.header.slot > snapshot.header.slot\r\n```\r\n\r\n3. In `LightClientStore` the purpose of `valid_updates` is to potentially use one of those if there is an update timeout. Instead, `LightClientStore` could just keep a single `best_update` and run the logic the pick the best on every new update. To comply with SSZ it can be zeroed initially to represent a no value.\r\n\r\n4. The UX for finalized sync is not great, the distance from the header you have in the snapshot vs current chain head is way to big. I'm writing this to signal the importance of getting a safe sound protocol for a re-org capable light-client close to Altair release.\r\n\r\n5. Sharing the API we are using currently as a potential proposal for a REST API or to eventually translate it to a ReqResp protocol\r\n\r\n```\r\nGET /eth/v1/lightclient/best_updates/:periods\r\n\r\nReturn updates in batch to a range of periods. Must return exactly 1 update per period requested.\r\nThe definition of \"best-update\" is vague so nodes have the freedom to optimize what to store.\r\nFor example, to persist the latest LightclientUpdate that has the most bits within a period.\r\n\r\nGET /eth/v1/lightclient/latest_update_finalized/\r\n\r\nRequest the latest finalized update seen by the node\r\n\r\nGET /eth/v1/lightclient/latest_update_nonfinalized/\r\n\r\nRequest the latest non finalized update seen by the node\r\n```\r\n\r\nCC: @wemeetagain ",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429/reactions",
    "total_count": 2,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 2
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/859983988",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2429#issuecomment-859983988",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2429",
    "id": 859983988,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1OTk4Mzk4OA==",
    "user": {
      "login": "Besiktas19033",
      "id": 85090554,
      "node_id": "MDQ6VXNlcjg1MDkwNTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/85090554?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Besiktas19033",
      "html_url": "https://github.com/Besiktas19033",
      "followers_url": "https://api.github.com/users/Besiktas19033/followers",
      "following_url": "https://api.github.com/users/Besiktas19033/following{/other_user}",
      "gists_url": "https://api.github.com/users/Besiktas19033/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Besiktas19033/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Besiktas19033/subscriptions",
      "organizations_url": "https://api.github.com/users/Besiktas19033/orgs",
      "repos_url": "https://api.github.com/users/Besiktas19033/repos",
      "events_url": "https://api.github.com/users/Besiktas19033/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Besiktas19033/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-12T02:20:45Z",
    "updated_at": "2021-06-12T02:20:45Z",
    "author_association": "NONE",
    "body": "> After implementing a rough POC web-based light-client consumer in Lodestar, I would like to share some feedback about it.\n> \n> 1. In `validate_light_client_update` this condition invalidates updates that are technically valid.\n> ```python\n> if update_period == snapshot_period:\n>         sync_committee = snapshot.current_sync_committee\n>         assert update.next_sync_committee_branch == [Bytes32() for _ in range(floorlog2(NEXT_SYNC_COMMITTEE_INDEX))]\n> ```\n> The update provider (server) does not know in advance if the update_period is > snapshot_period. It could just check before if `update.next_sync_committee` is zeroed and verify it otherwise\n> \n> 2. An update provider may want to send the light-client consumer an update for the same slot but with higher consensus. This happens frequently for finalized sync where sync committees will be producing valid updates for the same `update.header.slot` during an epoch but they may have more bits than the previous. This condition invalidates useful updates and I believe it can be omitted.\n> ```python\n> assert update.header.slot > snapshot.header.slot\n> ```\n> \n> 3. In `LightClientStore` the purpose of `valid_updates` is to potentially use one of those if there is an update timeout. Instead, `LightClientStore` could just keep a single `best_update` and run the logic the pick the best on every new update. To comply with SSZ it can be zeroed initially to represent a no value.\n> \n> 4. The UX for finalized sync is not great, the distance from the header you have in the snapshot vs current chain head is way to big. I'm writing this to signal the importance of getting a safe sound protocol for a re-org capable light-client close to Altair release.\n> \n> 5. Sharing the API we are using currently as a potential proposal for a REST API or to eventually translate it to a ReqResp protocol\n> \n> ```\n> GET /eth/v1/lightclient/best_updates/:periods\n> \n> Return updates in batch to a range of periods. Must return exactly 1 update per period requested.\n> The definition of \"best-update\" is vague so nodes have the freedom to optimize what to store.\n> For example, to persist the latest LightclientUpdate that has the most bits within a period.\n> \n> GET /eth/v1/lightclient/latest_update_finalized/\n> \n> Request the latest finalized update seen by the node\n> \n> GET /eth/v1/lightclient/latest_update_nonfinalized/\n> \n> Request the latest non finalized update seen by the node\n> ```\n> \n> CC: @wemeetagain \n\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/859983988/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
