{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1311",
  "id": 471946267,
  "node_id": "MDU6SXNzdWU0NzE5NDYyNjc=",
  "number": 1311,
  "title": "Test orientation & distribution format issues",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295439957,
      "node_id": "MDU6TGFiZWwxMjk1NDM5OTU3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:CI/tests/pyspec",
      "name": "scope:CI/tests/pyspec",
      "color": "BDC0BA",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2019-07-23T21:02:56Z",
  "updated_at": "2019-08-20T13:54:02Z",
  "closed_at": "2019-08-20T13:54:01Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This issue is set up as a starting point to address inconveniences clients have experienced with the test distribution and/or format.\r\n\r\n## Pain points\r\n\r\nMain pain points identified so far:\r\n1) LFS deals with the large files\r\n  1.1) not that nice with CI, new dependency\r\n  1.2) clones without LFS active are troublesome\r\n  1.3) requires authentication.\r\n      - Shouldn't happen, but relatively new issue. May be forced due to rate limits / settings.\r\n2) The sizes of the files are very large\r\n  2.1) Need to read header to filter for tests, do not want to read the full thing in memory\r\n  2.2) Cannot load the full suite of tests in memory\r\n3) I need format X, because feature Y of the current format is a bad experience for me.\r\n4) Configuration is missing, do not like it in the specs repo.\r\n\r\n## File sizes 0.8.1\r\n\r\n```\r\ndu -ah tests | grep -v \"/$\" | sort -rh\r\n\r\n2.8G\ttests\r\n1.4G\ttests/operations\r\n654M\ttests/epoch_processing\r\n576M\ttests/sanity\r\n420M\ttests/sanity/blocks\r\n419M\ttests/sanity/blocks/sanity_blocks_mainnet.yaml\r\n374M\ttests/operations/attestation\r\n372M\ttests/operations/attestation/attestation_mainnet.yaml\r\n327M\ttests/operations/attester_slashing\r\n326M\ttests/operations/attester_slashing/attester_slashing_mainnet.yaml\r\n250M\ttests/epoch_processing/justification_and_finalization\r\n249M\ttests/operations/deposit\r\n249M\ttests/epoch_processing/justification_and_finalization/justification_and_finalization_mainnet.yaml\r\n248M\ttests/operations/deposit/deposit_mainnet.yaml\r\n185M\ttests/ssz_static/core\r\n185M\ttests/ssz_static\r\n171M\ttests/operations/proposer_slashing/proposer_slashing_mainnet.yaml\r\n171M\ttests/operations/proposer_slashing\r\n158M\ttests/ssz_static/core/ssz_mainnet_random.yaml\r\n156M\ttests/sanity/slots\r\n156M\ttests/operations/voluntary_exit\r\n155M\ttests/sanity/slots/sanity_slots_mainnet.yaml\r\n155M\ttests/operations/voluntary_exit/voluntary_exit_mainnet.yaml\r\n125M\ttests/epoch_processing/final_updates/final_updates_mainnet.yaml\r\n125M\ttests/epoch_processing/final_updates\r\n94M\ttests/operations/block_header\r\n94M\ttests/epoch_processing/slashings\r\n94M\ttests/epoch_processing/registry_updates\r\n94M\ttests/epoch_processing/crosslinks\r\n93M\ttests/operations/block_header/block_header_mainnet.yaml\r\n93M\ttests/epoch_processing/slashings/slashings_mainnet.yaml\r\n93M\ttests/epoch_processing/registry_updates/registry_updates_mainnet.yaml\r\n93M\ttests/epoch_processing/crosslinks/crosslinks_mainnet.yaml\r\n9.9M\ttests/ssz_static/core/ssz_minimal_lengthy.yaml\r\n6.6M\ttests/ssz_static/core/ssz_minimal_random.yaml\r\n6.3M\ttests/ssz_static/core/ssz_minimal_random_chaos.yaml\r\n3.8M\ttests/ssz_static/core/ssz_minimal_one.yaml\r\n1.9M\ttests/sanity/blocks/sanity_blocks_minimal.yaml\r\n1.7M\ttests/operations/transfer/transfer_minimal.yaml\r\n1.7M\ttests/operations/transfer\r\n1.5M\ttests/operations/attestation/attestation_minimal.yaml\r\n1.2M\ttests/operations/attester_slashing/attester_slashing_minimal.yaml\r\n968K\ttests/epoch_processing/justification_and_finalization/justification_and_finalization_minimal.yaml\r\n896K\ttests/operations/deposit/deposit_minimal.yaml\r\n608K\ttests/operations/proposer_slashing/proposer_slashing_minimal.yaml\r\n548K\ttests/operations/voluntary_exit/voluntary_exit_minimal.yaml\r\n544K\ttests/sanity/slots/sanity_slots_minimal.yaml\r\n520K\ttests/genesis\r\n444K\ttests/epoch_processing/final_updates/final_updates_minimal.yaml\r\n444K\ttests/epoch_processing/crosslinks/crosslinks_minimal.yaml\r\n400K\ttests/shuffling\r\n396K\ttests/shuffling/core\r\n332K\ttests/operations/block_header/block_header_minimal.yaml\r\n328K\ttests/epoch_processing/registry_updates/registry_updates_minimal.yaml\r\n324K\ttests/epoch_processing/slashings/slashings_minimal.yaml\r\n276K\ttests/genesis/validity\r\n272K\ttests/genesis/validity/genesis_validity_minimal.yaml\r\n240K\ttests/genesis/initialization\r\n236K\ttests/genesis/initialization/genesis_initialization_minimal.yaml\r\n212K\ttests/ssz_static/core/ssz_minimal_zero.yaml\r\n204K\ttests/ssz_static/core/ssz_minimal_max.yaml\r\n200K\ttests/ssz_static/core/ssz_minimal_nil.yaml\r\n196K\ttests/shuffling/core/shuffling_minimal.yaml\r\n196K\ttests/shuffling/core/shuffling_full.yaml\r\n92K\ttests/bls\r\n28K\ttests/ssz_generic\r\n24K\ttests/ssz_generic/uint\r\n24K\ttests/bls/sign_msg\r\n20K\ttests/bls/sign_msg/sign_msg.yaml\r\n20K\ttests/bls/aggregate_sigs\r\n16K\ttests/bls/msg_hash_g2_uncompressed\r\n16K\ttests/bls/aggregate_sigs/aggregate_sigs.yaml\r\n12K\ttests/bls/msg_hash_g2_uncompressed/g2_uncompressed.yaml\r\n12K\ttests/bls/msg_hash_g2_compressed\r\n8.0K\ttests/ssz_generic/uint/uint_wrong_length.yaml\r\n8.0K\ttests/ssz_generic/uint/uint_random.yaml\r\n8.0K\ttests/bls/priv_to_pub\r\n8.0K\ttests/bls/msg_hash_g2_compressed/g2_compressed.yaml\r\n8.0K\ttests/bls/aggregate_pubkeys\r\n4.0K\ttests/ssz_generic/uint/uint_bounds.yaml\r\n4.0K\ttests/bls/priv_to_pub/priv_to_pub.yaml\r\n4.0K\ttests/bls/aggregate_pubkeys/aggregate_pubkeys.yaml\r\n\r\n```\r\n\r\nAs you can see: mainnet files are the biggest source of trouble. Otherwise the maximum individual file size would be 10 MB (SSZ). Or just 2 MB for a single state transition suite. Compare this to the 419 MB block processing test suite for mainnet.\r\n\r\n## Solutions in status quo\r\n\r\nThese are the current solutions, not pretty, but functional:\r\n\r\n1) LFS deals with the large files\r\n  1.1) assumed to run your own docker image in CI already, should be easy to add to the image (even available to Alpine linux)\r\n  1.2) Non-LFS clones are just exactly that, we cannot have these large files in the normal Git system, some of these files are just too large to even consider diffing it.\r\n  1.3) Authentication shouldn't be required for a public repo. It worked in a CI test setting before. But this is a relatively new issue. And it may be forced due to rate limits / settings. Use the gzipped tar in CI for now instead.\r\n2) The sizes of the files are very large\r\n  2.1) The first X lines can be read, cut at the `test_cases:` line, and parsed. Not pretty, but the alternative of duplicate data / separate headers is not either. If the files were small, it wouldn't be an issue. (Legacy of early choice for yaml)\r\n  2.2) Loading it fully in memory before processing is bad, even if parsed into states, the mainnet state objects are still big, too much to keep a few hundred of them in memory. Also consider that there are pre and post states. Too much data to deal with at once really.\r\n3) Similar to cross client communication, a format that works for everyone is difficult. Status quo is to keep it:\r\n    - Simple to implement\r\n    - As readable as possible\r\n    - Generic enough to deal with it in some way or another, even if not likeable.\r\n4) Configuration is always an issue:\r\n    - Many teams / languages\r\n    - Constants in the spec that may not override as easily.\r\n      - Since there are not nearly as many spec changes anymore after freeze, keeping up manually is effectively more efficient, although \"dumb\" work.\r\n    - A client needs to deal with their language choice + other configuration anyway\r\n      - Stronger enforcement of the config in practice may not be worth it currently because of it. It will break the workflow of some teams for sure.\r\n      - Loading a yaml from the specs repo, and checking automatically if it matches the client config, may be a good temporary solution.\r\n      - Or a script to convert the yaml file in whatever format is preferred.\r\n\r\n## Attention points for new solution\r\n\r\n- Need versioning: so LFS may be the only git compatible solution. \r\n- Need configuration: but copying from spec to tests repo is error prone + duplicate code\r\n- Need to consider configuration loading: changing constants per test case, or even per suite, is inefficient and/or not supported by some clients. Compile / start time configuration should be ok. E.g. run test suite once with mainnet loaded, and skip of minimal tests. Then vice versa.\r\n- Need definition efficiency: so filtering/running tests is easy\r\n- Need storage efficiency: so I do not have to deal with a 2.8 GB clone.\r\n- Need to consider phase 1: which pushes up storage of a full state another order of magnitude in some cases.\r\n- Need well structured categorization: going through many different files is hard and inefficient\r\n- Keep layered categorization: avoid duplicate code for each suite. Instead, generalize one topic as a \"runner\", and specifics for case formats in \"handlers\"\r\n- Need config separation: may want to only use minimal tests in some settings (e.g. quick sanity check during development)\r\n- Need to consider pyspec: althoug the most tested + reviewed, the pyspec has limits as an super-unoptimized python program. Generation is working, but super slow, especially mainnet.\r\n- Need to keep BLS flexibility: currently tests are generated with BLS on, but allow for BLS to be off during running, except when the test data says not to, according to format.\r\n- Need to consider future forking. Current fork-timeline design may not work, or result in new issues. Feedback from clients necessary.\r\n- Need to consider readability. Someone is going to hit a test case that does not pass, better make it clear and easy to see what was ingested.\r\n\r\n\r\n## Ideas\r\n\r\nList of ideas, in no particular order, to think about:\r\n\r\n- Split suite files (collection of test cases) in files\r\n    - IO overhead / more nesting/files\r\n    - Less memory at a time\r\n    - Clear individual test cases\r\n    - Separate header could be good, but also a considerable change from status quo.\r\n- Compress things\r\n    - Suites could be zip archives of yaml files, each a case\r\n    - Suites could be gzipped yaml files\r\n    - Test cases themselves could be compressed\r\n    - Could use niche (and likely unsupported for some) cross-reference support of yaml, to not duplicate fields. Not readable either, but made for this.\r\n    - Could manually reduce state size, by encoding only part of the data\r\n- Use partials (no proof data, just indices + contents)\r\n    - High complexity\r\n    - unsupported by all clients currently\r\n    - pyspec may be possible in a week or two, but test-generation may need to adapt for it.\r\n    - nice isolation of fields that change, and fields that don't affect the test.\r\n- Share configuration by:\r\n    - copying to output\r\n    - moving to separate git repo, and submodule in specs repo + client repos\r\n- Ignore mainnet\r\n    - Risk of thinking everything is ok with minimal config, but silently not getting mainnet passing.\r\n    - Alleviates all immediate problems in storage size + efficiency\r\n    - Mainnet has considerably different behavior in some cases, due to constants changing. E.g. more than 1 shard per slot being handled.\r\n    - could alleviate Pyspec test generation speed too\r\n- Build out mainnet tests with Go spec\r\n    - Much higher speed, may generate tests on the fly\r\n    - No BLS support yet\r\n    - In progress 0.8.1 tests passing\r\n    - More time needed to work on test generation implementation\r\n    - Double work with pyspec\r\n        - Contradicting tests may not help clients much, but could find bugs quicker\r\n    - Possibly nice for new testing integrations\r\n        - Not like whiteblock was looking to do, this would be static testing, no networking / dynamic states.\r\n- Ditch YAML\r\n    - closes early testing legacy\r\n    - possibly more space efficiency\r\n    - need to decide on replacement. SSZ seems strict to define many test formats in, although supported by everyone.\r\n    - readability concerns\r\n\r\n## Survey\r\n\r\nPlease answer in a DM on discord or telegram:\r\n- I will keep even the most controversial suggestions anonymous\r\n- Will not judge any answer (promise)\r\n- Just need ideas/improvements, with straight forward motivation, unadjusted.\r\n- If everyone is holding back, we won't make progress. \r\n- Do not need to instigate unnecessary conflict either, hence private initially.\r\n\r\nAnd then I will publicly share anonymized aggregated findings (time TBD). And hopefully find some better solution than status quo.\r\n\r\nPlease consider answering the following questions (answers may be brief/long):\r\n\r\n1. Do all formats work? If not, which of them are a pain, or is it because of delays/late start elsewhere?\r\n1. Does the full suite of minimal configuration run reasonably?\r\n1. Does LFS work for you?\r\n1. Are you using the gzipped tarball of `tests/` in release instead of LFS clone?\r\n1. Do you cache in CI?\r\n1. Do you like YAML?\r\n1. Do you need readability in raw data, or does printing ingested information from the test runner work fine?\r\n1. Is compression difficult to handle in your test loader? What does it entail for you to handle compressed files during test runs?\r\n1. Do you run minimal tests? And how often / which scenario?\r\n1. Do you run mainnet tests? And how often / which scenario?\r\n1. Do you like to see more configurations?\r\n1. Would you support SSZ or another binary format for testing?\r\n1. What are your ideas about duplication of subsets of states in tests? Avoid? Compress?\r\n1. Pick 2 out of 3: readability, amount, quality\r\n1. Pick 3 out of 9:\r\n   - phase 0 light client tests\r\n   - phase 1 tests\r\n   - phase 1 light client tests\r\n   - fork choice tests\r\n   - rewards/penalties tests\r\n   - more BLS tests\r\n   - validator tests\r\n   - more coverage focused tests for phase0\r\n   - \\*your suggestion\\*\r\n1. Pick 1, for short term shared effort:\r\n   - active testnetwork monitoring (verify transitions live)\r\n   - SSZ and BLS fuzzer executables, non-libfuzzer\r\n   - benchmarks of transition\r\n1. Pick 1, for middle term shared effort:\r\n   - fuzzing your own state transition\r\n   - chaintests\r\n   - \\*your suggestion\\*\r\n1. Which current idea(s) do you like?\r\n1. Any no no?\r\n1. Suggested format to optimize your own use (no answer = indecisive, prefer status quo, okay with it)\r\n1. Suggested format, if optimizing for everyone (no answer = indecisive, prefer status quo, okay with it)\r\n\r\n\r\n## TLDR\r\n\r\nTesting workload and format is a lot to deal with, sharing thoughts + taking survey to make some progress.\r\n",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311/reactions",
    "total_count": 12,
    "+1": 11,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515015182",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-515015182",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 515015182,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNTAxNTE4Mg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-25T11:57:49Z",
    "updated_at": "2019-07-25T12:37:06Z",
    "author_association": "MEMBER",
    "body": "### Survey results:\r\n\r\nSurveyed most teams, thank you for the quick and extensive responses!\r\n\r\n- The test-formats (properties, functionality) themselves work. Structure, file format/size, and distribution of in tests is the bigger problem.\r\n- Minimal config runs well, not fully for some yet.\r\n- Mainnet runs for some, not for others. Suite file size is a big issue.\r\n- LFS works and is used by half of the teams. Not everyone caches the files in CI, causing slowdowns (and bandwith bills). The tar-ball alternative works well for the other teams. Good idea to use that in CI.\r\n- YAML is generally accepted, although teams struggle with size in one way or another (some just need test filtering without reading the full suite, or want more performance)\r\n- Compression can be handled, but many teams prefer zipping the whole thing, over zipping individual suites or cases. Duplication/storage is not so much a concern, memory usage is.\r\n- Advanced gzip file streaming is too much, but could generally work. Similarly, leveldb (with Snappy compression) could be used to store cases in, and fetch during testing.\r\n- Minimal tests not running in CI fully for all yet.\r\n- Mainnet tests are run in CI by some, even though the memory and being computationally slower. Others cannot handle the size, and/or the mainnet configuration well.\r\n- Everyone can handle more configurations. Some prefer linking, others load dynamically during runtime. But extra config or two are very welcome.\r\n- SSZ for testing data is generally well received, as it removes a dependency somewhat: no yaml -> intermediate -> ssz anymore. Just load bytes. \r\n  But others prefer to stick to yaml for readability and/or \"it works\". Readability is less of a concern if there was a SSZ test viewer.\r\n- Pick 2 out of 3 preferences: Quality first, then amount, then readability. Everyone had a vote for quality. Readability was a thing to work around: print parsed formatted data during test runs.\r\n- Pick 3 out of 9: fork choice tests first. Then very mixed and equally chosen preferences, but all phase 0 things.\r\n- Short term winner: process test network transitions live with executable spec.\r\n- Middle term winner: fuzzing the state transition. (Some seem biased towards middle term here, as their tests need to run first)\r\n- Liked ideas: split suites, copy configs to output, fuzzing\r\n- Keep configuration format, keep yaml for now.\r\n- suggestions: binary format support, possibly from a DB, file-tree filterable tests, an index file that lists all tests by name and properties (or like a file tree).\r\n\r\n### Plan:\r\n\r\nSplit tests into a deeply structured file tree, to filter without memory overhead, at the cost of a bit of disk reading.\r\n```\r\nFile path structure:\r\ntests/<config name>/<fork or phase name>/<test runner name>/<test handler name>/<test suite name>/<test case>/<output part>\r\n\r\n<config name>/ -- Configs are upper level. Some clients want to run minimal first, and useful for sanity checks during development too.\r\n                  As a top level dir, it is not duplicated, and the used config can be copied right into this directory as reference.\r\n<fork or phase name>/ -- This would be: \"phase0\", \"transferparty\", \"phase1\", etc. Each introduces new tests, but does not copy tests that do not change. \r\n                         If you like to test phase 1, you run phase 0 tests, with the configuration that includes phase 1 changes. Out of scope for now however.\r\n<test runner name>/   -- The well known bls/shuffling/ssz_static/operations/epoch_processing/etc. Handlers can change the format, but there is a general target to test.\r\n<test handler name>/  -- Specialization within category. All suites in here will have the same test case format.\r\n<test suite name>/    -- Suites are split up. Suite size does not change memory bounds, and makes lookups of particular tests fast to find and load.\r\n<test case>/          -- Cases are split up too. This enables diffing of parts of the test case, tracking changes per part, while still using LFS. Also enables different formats for some parts.\r\n<output part>         -- E.g. \"pre.yaml\", \"deposit.yaml\", \"post.yaml\".\r\n                         - Diffing a pre.yaml and post.yaml gives you all ther information for testing, good for readability of the change. Then compare the diff to anything that changes the pre state, e.g. \"deposit.yaml\"\r\n                         - Allows for custom format for some parts of the test. E.g. something encoded in SSZ.\r\n                         - \"pre.ssz\", \"deposit.ssz\", \"post.ssz\" etc. is the next step: place a copy, but in binary format, right next to legacy yaml.\r\n                            Clients can then shift to ssz inputs for efficiency, while we implement a SSZ viewer. \r\n                            And when that alleviates the readability concern, we can drop the yaml files for state encoding.\r\n                            This also means that some clients can drop their YAML -> JSON/other -> SSZ work-arounds that had \r\n                            to be implemented to support the uint64 YAML, hex, etc. that is not idiomatic to their language.\r\n                         - We keep yaml for metadata, and non-SSZ things. (E.g. shuffling and BLS tests)\r\n```\r\n\r\nThe test case formats itself do not change, the properties are just loaded from multiple files, instead of sub-properties of one file.\r\nFor the better, it reduces memory requirements, and makes test case filtering much better. \r\n\r\nI support the LevelDB idea too, but versioning is important, and we do not get that with leveldb.\r\nInstead, I recommend clients to use the gzipped tarball to read tests from in their CI setting, or write their own tooling to push the file structure into their own leveldb.\r\nAlso, please cache your tarball, it helps performance, and saves us all good amounts of bandwidth (may not be prohibitive costs though).\r\n\r\nAnd instead of zipping the `tests/` dir, I think we can zip the individual `<config name>` directories, so people can keep them separate easily if they want to.  \r\n\r\n### Open questions:\r\n- Marking metadata. I like essential metadata to live as close as possible to the test. So the two options for the current data are:\r\n  - Small files / file markers:\r\n    - an empty `bls_required`/`bls_ignored` file (alike to `.gitkeep` markers), a simple file system check works: `if bls_required.exists(): enable_bls() elif bls_ignored.exists(): disable_bls() else: default_bls_preference()`\r\n    - a `post.hash` file, for optimistic equality checking of the resulting post state.  \r\n  - A meta data file, `meta.yaml`, which lists such properties.\r\n  - I considered `bls` as file level, but the extra level for each such property is a bit much, and requires a filesystem check just like the empty file marker. And it does not work for data such as the post state root.\r\n- The tests index file. A yaml file with a tree structure of all tests alleviates the need (and possible errors) in walking the full file tree.\r\n  On the other hand, duplication is error prone too, and a recursive `ls` or `tree` call works just as well to generate your own index.\r\n\r\n### test-viewer\r\n\r\nI have a POC based on the SSZ collapsible tree-view I implemented for https://simpleserialize.com (awesome site by Chainsafe, check it out).\r\nThe basic proposed functionality is:\r\n\r\nBrowse to `somedomain.io/v0.8.1/tests/phase0/operations/deposits/common/success_top_up/` and get 3 tree views next to each other, annotated with SSZ types: pre, post and the deposit.\r\n\r\nHowever, their JS types are not fully usable for 0.8.1 yet, so it cannot load the ssz types that changed yet.\r\nDiffing the `pre.yaml` and `post.yaml` when ingesting `pre.ssz` and `post.ssz` should work well enough for debugging for now though.\r\n\r\nAlso, there is too much tooling to implement, so I will prioritize testing and the testnetwork live verification tool,\r\n over deprecating the yaml. But maybe others like to help with the test viewer? (Chainsafe? @GregTheGreek ?)\r\n\r\n### Review of attention points\r\n\r\n- [x] versioning: LFS, but do not force on clients, provide tar ball\r\n- [x] configuration copy to tests\r\n- [x] config loading: top level change in system, not much switching\r\n- [x] filter efficiency: file tree gives high filter precision, low memory usage\r\n- [x] storage efficiency: traded off, teams are concerned with memory more so. Use compressed tar ball if you like\r\n- [x] phase 1 and beyond: file size is bounded by biggest content type, not multiplied by amount of cases. Files should all be smaller than 5 MB.\r\n- [x] keep categorization: deeper file structure + index file solve this even better\r\n- [x] config separation: configs are top level dir change\r\n- [x] pyspec performance: generation will not be faster (and slower possibly due to SSZ output addition), but memory usage much lower, and no big file writes.\r\n- [x] Keep BLS flexibility: see open question, solution is generally there.\r\n- [x] Consider future forks: included in file structure\r\n- [x] readability: yaml stays for now, is better accessible, and replaced with a SSZ viewer some time in the future.\r\n\r\n### Config\r\n\r\nUnderstand the concern of not changing the config. What I do want to standardize, is how we handle forks in configs.\r\nOverwriting \"constants\" is very impractical, and confusing, and requires configs to live next to each other as full copies during forks.\r\n\r\nInstead, not many constants change anyway, and forks are considered to be backwards compatible in some basic form (we still need to sync old data, with old code or not).\r\nAlso, we would like to add new fork constants in advance, to test functionality in test settings, without configuration overhead.\r\n\r\nI propose to (minimally) prefix constants that changed in a fork, and prepare prefixes for constants when we know they are going to change.\r\n\r\nLong term, we can rotate forks out when we do not need to sync it anymore (deprecating it essentially), and remove the prefixes from constants that are considered stable.\r\n\r\nPrepared change example: `P0_MAX_TRANSFERS = 0` (`P0` = phase 0), then fork to `MAX_TRANSFERS = 16`.\r\n\r\nRotation example: `PROPOSER_REWARD_QUOTIENT = 8`, then fork to `XY_PROPOSER_REWARD_QUOTIENT = 16`. Then deprecate the old constant as `P0_PROPOSER_REWARD_QUOTIENT`, and start calling `XY_PROPOSER_REWARD_QUOTIENT` just `PROPOSER_REWARD_QUOTIENT`.\r\n\r\nPro: single config, easy config management (no forks), and code can do the switching however it likes.\r\nCon: prefixes (although clearer) are less pretty.\r\n\r\nSimple decision, and gets us to transfer testing without complicated configuration or management changes. Sounds good?\r\n\r\nFor forks, the timeline idea still holds: simple key-value mapping to declare the slots for fork names. We can consider other fork activation later, when we have a good example.\r\n\r\n### TLDR\r\n\r\nDeeper test structure for lower constraints and better filtering. Super small config change to enable forks (and transfer tests without hacks).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515015182/reactions",
      "total_count": 6,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515021187",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-515021187",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 515021187,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNTAyMTE4Nw==",
    "user": {
      "login": "mpetrunic",
      "id": 8836210,
      "node_id": "MDQ6VXNlcjg4MzYyMTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8836210?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mpetrunic",
      "html_url": "https://github.com/mpetrunic",
      "followers_url": "https://api.github.com/users/mpetrunic/followers",
      "following_url": "https://api.github.com/users/mpetrunic/following{/other_user}",
      "gists_url": "https://api.github.com/users/mpetrunic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mpetrunic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mpetrunic/subscriptions",
      "organizations_url": "https://api.github.com/users/mpetrunic/orgs",
      "repos_url": "https://api.github.com/users/mpetrunic/repos",
      "events_url": "https://api.github.com/users/mpetrunic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mpetrunic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-25T12:19:55Z",
    "updated_at": "2019-07-25T12:19:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I support the LevelDB idea too, but versioning is important, and we do not get that with leveldb.\r\n\r\nYou could commit leveldb files to git?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515021187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515027070",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-515027070",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 515027070,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNTAyNzA3MA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-25T12:39:55Z",
    "updated_at": "2019-07-25T12:39:55Z",
    "author_association": "MEMBER",
    "body": "> You could commit leveldb files to git?\r\n\r\n@mpetrunic We could, but part of the versioning reasoning is to see which tests are new and/or have been changed. And to roll back a test easily if necessary (as client, or as test maintainer). With raw leveldb chunks you do not get that. As an implementer, you can always write a little script to put the files in leveldb, and use the filepath as key. If that works better for you, please go ahead.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515027070/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515031086",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-515031086",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 515031086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNTAzMTA4Ng==",
    "user": {
      "login": "GregTheGreek",
      "id": 16929357,
      "node_id": "MDQ6VXNlcjE2OTI5MzU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/16929357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GregTheGreek",
      "html_url": "https://github.com/GregTheGreek",
      "followers_url": "https://api.github.com/users/GregTheGreek/followers",
      "following_url": "https://api.github.com/users/GregTheGreek/following{/other_user}",
      "gists_url": "https://api.github.com/users/GregTheGreek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GregTheGreek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GregTheGreek/subscriptions",
      "organizations_url": "https://api.github.com/users/GregTheGreek/orgs",
      "repos_url": "https://api.github.com/users/GregTheGreek/repos",
      "events_url": "https://api.github.com/users/GregTheGreek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GregTheGreek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-25T12:52:49Z",
    "updated_at": "2019-07-25T12:52:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Also, there is too much tooling to implement, so I will prioritize testing and the testnetwork live verification tool,\r\nover deprecating the yaml. But maybe others like to help with the test viewer? (Chainsafe? @GregTheGreek ?)\r\n\r\nLet me know what you need",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515031086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515035516",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-515035516",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 515035516,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxNTAzNTUxNg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-25T13:06:41Z",
    "updated_at": "2019-07-25T13:06:41Z",
    "author_association": "MEMBER",
    "body": "@GregTheGreek Awesome, thanks. Will implement first things first though (the structure change in test generation). But yes, could use some help in:\r\n- a published ssz types package for minimal and mainnet config. BeaconState and operations primarily. Current simpleserialize.com still copies the types over.\r\n- some communication to pull the ssz treeview + lazily evaluated tree parse function I implemented earlier for simpleserialize.com, into its own package. So we can share the code between the two sites (and ideally future improvements).\r\n\r\nIf I get to implement the testing change this week, we could get this viewer going some time next week maybe. Let's discuss in discord chat some time.\r\n\r\nThis is the look of the current POC I implemented yesterday (beacon state type not updated, so using the change thing 3x to get a feel for layout):\r\n![image](https://user-images.githubusercontent.com/19571989/61876442-2e5f7200-aeed-11e9-8a4b-3d0411fc4012.png)\r\nIt loads yaml data from a public (CORS enabled) github media endpoint. But could switch it to fetching ssz files, and parsing them with ssz-js.\r\n\r\nI could put the otherwise static site in a simple firebase hosting wrapper, to deal with routing of dynamic urls. And then we could link to versioned tests by url using the viewing site, instead of the raw ssz on github.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/515035516/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523025723",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1311#issuecomment-523025723",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1311",
    "id": 523025723,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzAyNTcyMw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-20T13:54:01Z",
    "updated_at": "2019-08-20T13:54:01Z",
    "author_association": "MEMBER",
    "body": "Closing 👍\r\n\r\n<img width=\"532\" alt=\"Screenshot 2019-08-20 at 15 53 35\" src=\"https://user-images.githubusercontent.com/731743/63353214-b573fe80-c362-11e9-82f3-4badbd463919.png\">\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523025723/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
