{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2692",
  "id": 1034567160,
  "node_id": "I_kwDOCOoGbc49qj34",
  "number": 2692,
  "title": "Gossipsub parameter tuning",
  "user": {
    "login": "AgeManning",
    "id": 7454587,
    "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AgeManning",
    "html_url": "https://github.com/AgeManning",
    "followers_url": "https://api.github.com/users/AgeManning/followers",
    "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
    "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
    "organizations_url": "https://api.github.com/users/AgeManning/orgs",
    "repos_url": "https://api.github.com/users/AgeManning/repos",
    "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AgeManning/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 17,
  "created_at": "2021-10-25T00:59:24Z",
  "updated_at": "2021-11-09T04:51:40Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "# Overview\r\n\r\nThe gossipsub mesh parameters were originally chosen for message propagation speed and redundancy (a large number of faulty nodes shouldn't impact the message propagation too much). However, now that our networks have advanced, become stable and have a significant number of nodes, it might be time to re-visit the gossipsub parameters. \r\n\r\nWe (Lighthouse) have been looking into bandwidth consumption of our nodes and are in the process of doing some more analysis (which we'll share when we have it) and ways to reduce this without degrading our current networks.\r\n\r\nThe primary source of excessive bandwidth consumption is our gossipsub network which has a large degree of amplification on all our topics. \r\n\r\n## Potentially Low-Hanging Fruit\r\n\r\nI've been monitoring the number of duplicates we have been receiving on various topics as well as the number of IWANT messages we have been sending. Both of these are good measures of redundant bandwidth. The goal, is to minimise these for each topic, without degrading the network. \r\n\r\nA node typically sends IWANT messages when they receive an IHAVE from one of their peers for a message before they receive it from one of their mesh peers. This suggests the mesh is propagating slower or on the order of a node's peer's heartbeat interval.  Messages can be delayed on the mesh for a number of reasons; message validation, network size, mesh connectivity, etc. Each client has their own speeds for validation, but also peer counts. A client that maintains more peer's is more likely to receive IHAVE's from one of their peers before their mesh (as the mesh size is bounded, regardless of peer count). \r\n\r\nOne suggestion to reducing IWANT/IHAVE is to either increase our gossipsub `heartbeat_interval` and/or decrease our `D_lazy` parameter to reduce the amount of gossiping each node does. These changes can however have an impact of message propagation latency, if nodes are currently relying on the gossip IWANT/IHAVE system to get their messages. \r\n\r\n## Message Amplification\r\n\r\nWe have set `D` to be `8` in the specs which naturally gives us relatively high message amplification. On the block topic (the simplest to reason about), we see on average about 8 duplicates (as would naively be expected) and therefore a bandwidth amplification of about 8x. The other topics are less straightforward. \r\n\r\nWe can significantly reduce our node's bandwidth by reducing the mesh sizes. The impact of this at a network-level is non-trivial. As we flood-publish, a client's default peer count plays a large role in how many hops or how fast a message propagates as we publish to every peer we know who is connected on that topic. Therefore, it may be possible to have higher peer counts, and lower mesh sizes whilst maintaining a similar number of hops to reach the entire network.\r\n\r\nIn any case our mesh sizes appear to be larger than needed and we may want to lower them (incrementally on testnets). \r\n\r\n## Proposal\r\n\r\nI think it would be useful to put some lower bounds on the gossipsub mesh topic parameters. For lighthouse, we are considering having some of the parameters CLI tuneable. i.e users with no bandwidth limitation can have a high degree of connectivity (which provides them with lower message latency) and have some users with lower bandwidth but higher message latency.  We were going to leave the default as is, so that most users will have no change to the current gossipsub settings.\r\n\r\nHowever to do this safely, there needs to be some lower bound on the mesh sizes such that if all nodes choose the lowest setting, the network still has sufficient redundancy/amplification and message propagation speed.\r\n\r\nUltimately, I think we should try test some parameters on testnets (slowly) before moving towards mainnet. The parameters can be lowered slowly and iterated on over time. \r\n\r\nI know that a full simulation/analysis of the live network would be ideal before changing/justifying these parameters, however I don't know of anyone that can/has modelled our current eth2 network and can definitively say how much effect adjusting these parameters across all nodes on the network will have. Our testnet's also don't have the same topology as mainnet, so tests there may not reflect on mainnet. \r\n\r\nWith that caveat aside, I'm suggesting we add some lower bounds to the gossipsub values, something like:\r\n\r\n- `D` : 5 (maybe even 4 as a lower bound)\r\n- `D_low`: 3\r\n-  `D_high`: 6\r\n- `D_lazy`: 3 (or maybe 2)\r\n- `heartbeat_interval` : Maybe up to half a slot (clients can choose when they want to send gossip) \r\n\r\nNote that these would be lower bounds and clients can maintain their current values and no work needs to be done. However we discuss and allow for some implementations to reduce these values.\r\n\r\nWe may also want to modify our implementations such that we can specify these on a per-topic basis, if more analysis is done and better values can be found per-topic. \r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/951655343",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-951655343",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 951655343,
    "node_id": "IC_kwDOCOoGbc44uRuv",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-26T07:52:14Z",
    "updated_at": "2021-10-26T07:52:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Two thoughts on `D` settings:\r\n\r\n* too low a range between `D` and `Dhigh` might lead to difficulties joining the mesh because the ratio of \"full\" nodes in the mesh will go up - we will probably want to ensure a healthy range here (_maybe_ something like `Dhigh = max(user_setting, D+Dlow)`\r\n* too low `Dlow` and `D` affects not only latency but also increases the risk of forming disconnected islands\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/951655343/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/952333648",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-952333648",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 952333648,
    "node_id": "IC_kwDOCOoGbc44w3VQ",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-26T21:16:32Z",
    "updated_at": "2021-10-26T21:16:32Z",
    "author_association": "MEMBER",
    "body": "I'm very interested in tuning these params! Also in just getting better visibility to consider deeper beacon chain protocol or gossipsub changes to suit our needs.\r\n\r\n### Bandwidth curiosity\r\n\r\nDo you have high level estimates on the numbers on the bandwidth each topic consumes? Primarily `beacon_block` vs a single `attestation` subnet.\r\n\r\nI'm very curious the ratio to better decide where alternative optimization effort is best spent. E.g. I have a proposal for altering and enforcing attestation subnet subscriptions (to no longer have them scale with # of attached vals) but better data will help know where to push\r\n\r\n### Per-topic parametrization\r\n\r\n> We may also want to modify our implementations such that we can specify these on a per-topic basis, if more analysis is done and better values can be found per-topic.\r\n\r\nParametrizing on a per-topic-type basis also makes sense to me. Our delivery requirements are *not* the same on attestation subnets as they are with beacon blocks. That said, I'd want to see which of our subnets are really the data-hogs before suggesting an upstream gossipsub change to parametrize per topic.\r\n\r\n### Amplification factor looks bad, right?\r\n\r\n> we see on average about 8 duplicates (as would naively be expected) and therefore a bandwidth amplification of about 8x\r\n\r\nDoes this mean that on average, each of my 8 stable peers on a topic are sending me the block? Rather than caches and forwarding providing deduplication? Unless I'm missing something this implies something pretty deeply wrong, right? You'd naively want `< D` amplification because sometimes a peer will send to you and sometimes you'll send to them but most of the time, a peer will not do both for a given message.\r\n\r\n### \r\n\r\n> D_lazy: 3 (or maybe 2)\r\n\r\nDropping `D_lazy` pretty low intuitively makes sense as I suspect that IWANT/IHAVE chatter is largely wasteful on our network (but don't have the data to back it up). \r\n\r\nThat said, it is very important in the event of attacks so getting rid of it altogether would not be wise. See heartbeat discussion below, but keeping on the order of 3/4 and greatly increasing heartbeat interval seems like a good compromise.\r\n\r\n### Heartbeat -- for fast delivery or attack resilience?\r\n\r\n> heartbeat_interval : Maybe up to half a slot (clients can choose when they want to send gossip)\r\n\r\nI would consider altering this in a more mechanized way, rather than suggesting an upper bound and the network being mixed. If IWANT/IHAVE are largely wasted and sent every 0.7s, it'd be good to ascertain this is actually the case.\r\n\r\nNote, we selected 0.7s after this [PL v1.1. report](https://gateway.ipfs.io/ipfs/QmRAFP5DBnvNjdYSbWhEhVRJJDFCLpPyvew5GwCCB4VxM4). Recommendation copied here:\r\n\r\n> the Heartbeat setting of Gossipsub is currently at 1 sec. This is a reasonable setting which allows for responsiveness but avoids frantic changes in the protocol behaviour. Smaller values for the heartbeat will result in higher responsiveness (e.g. gossip is emitted at shorter time intervals), but at the\r\nexpense of higher bandwidth requirements. The ETH2.0 community might want to consider reducing the heartbeat to 600-700 ms, especially with the 3-sec propagation deadline\r\n\r\nThe question seems to be -- is heartbeat gossip to ensure fast delivery or to protect against attacks and edgecases?\r\n\r\nThe 0.7s recommendation was made to ensure fast delivery -- i.e.  *MUST propagate in < 3s*. Whereas while this propagation time is very important in the normal case, the network is resilient in the event of temporary high latencies (chain growth will continue and the core consensus mechanism will under most scenarios continue to finalize). Thus if we instead use the heartbeat gossip to only *help defend against attacks* rather than ensure timely delivery, altering heartbeat to be on the order of a sub-slot (2-4s) could be totally reasonable.\r\n\r\nIntuitively, I'd go for 3s to 4s rather than 6s, giving the the network the chance to mend on the sub-slot sending boundaries.\r\n\r\n### Lower bounds vs changing the spec\r\n\r\nAre you more interested in adding lower bounds to be more conservative about changing network topology? Or do you think there is value in some nodes having larger values than others?\r\n\r\nMy worry with just adding the lower bounds is that we  leave a lot of network-wide savings on the table as most will just use the base defaults.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/952333648/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/952464927",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-952464927",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 952464927,
    "node_id": "IC_kwDOCOoGbc44xXYf",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-27T01:44:30Z",
    "updated_at": "2021-10-27T01:44:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Do you have high level estimates on the numbers on the bandwidth each topic consumes? Primarily beacon_block vs a single attestation subnet.\r\n\r\nI don't have exact numbers, but will get these soon (awaiting a few more metric PR's to get better insights). Based on message count, beacon_block does (as you'd expect) around 8 messages per slot, the aggregate channel is around 2k (with some tuning around 1k). So there is a wide discrepancy is bandwidth. I'll get exact figures so as not to be hand-wavy with the others.\r\n\r\n> Parametrizing on a per-topic-type basis also makes sense to me. Our delivery requirements are not the same on attestation subnets as they are with beacon blocks. That said, I'd want to see which of our subnets are really the data-hogs before suggesting an upstream gossipsub change to parametrize per topic.\r\n\r\nAgreed. Not sure if we'd have to change the gossipsub spec as its a more general change, but either way we can add it our implementation relatively easily (in a backwards compatible way)\r\n\r\n> Does this mean that on average, each of my 8 stable peers on a topic are sending me the block? Rather than caches and forwarding providing deduplication? Unless I'm missing something this implies something pretty deeply wrong, right? You'd naively want < D amplification because sometimes a peer will send to you and sometimes you'll send to them but most of the time, a peer will not do both for a given message.\r\n\r\nAs far as I can tell this is a natural consequence. I've tried to minimize this, but will have to adjust the gossipsub implementation.  It mainly comes from triangle routing (I presume). Consider a mesh of 4. But all 4 are connected to each other. 1 gets a message from outside, and forwards to 2,3,4. 2 forwards to 3,4 also 3 forwards to 2,4 and 4 forwards to 2,3.\r\nIn this example, 3 has received the message 3 times. The duplicate ratio also comes because our mesh is typically > than `8` as our `D_high` is 12 and our mesh on average is > 8 (from what I've seen). \r\nI've modified the implementation to ensure none of our peers ever send us a duplicate (knowingly) and this holds true, so I've deduced the triangle routing scenario as the main culprit for large number of duplicates. \r\nAs Jacek has mentioned, one modification we can make is to keep track of duplicates sent to us from our peers so that we don't propagate to peers that have sent us a duplicate, this could eliminate one of the extra forwards in the example I gave. i.e 4 may not forward to 2,3 if it had registered the duplicate messages from 2,3 earlier. \r\n\r\nIt's not as bad on the aggregate topic channel when there's a lot more messages, but let me come back with some more concrete data. \r\n\r\n> The question seems to be -- is heartbeat gossip to ensure fast delivery or to protect against attacks and edgecases?\r\nThe 0.7s recommendation was made to ensure fast delivery -- i.e. MUST propagate in < 3s. Whereas while this propagation time is very important in the normal case, the network is resilient in the event of temporary high latencies (chain growth will continue and the core consensus mechanism will under most scenarios continue to finalize). Thus if we instead use the heartbeat gossip to only help defend against attacks rather than ensure timely delivery, altering heartbeat to be on the order of a sub-slot (2-4s) could be totally reasonable.\r\n\r\nThe heartbeat does a number of things, mainly mesh maintenance and score. You're probably right that we don't want to make this too large and rather just reduce the amount of gossip via d_lazy. I dont know enough about how it would effect the network dynamics having a larger value, but intuitively, adding/dropping peers from meshes and emitting gossip every 0.7 secs seems a bit fast for some of our topics, especially ones with large numbers of messages when we might want to accept some delay and rely more on our mesh. A small heartbeat also adds bandwidth in control messages as we're constantly GRAFT and PRUNEing peers every 0.7 seconds for all our meshes (topics). \r\n\r\n> Are you more interested in adding lower bounds to be more conservative about changing network topology? Or do you think there is value in some nodes having larger values than others?\r\nMy worry with just adding the lower bounds is that we leave a lot of network-wide savings on the table as most will just use the base defaults.\r\n\r\nMy thinking was to make it configurable for two reasons. \r\n1. So I can test and monitor metrics on a single node, to see how it behaves.  (Irrelevant to the current discussion)\r\n2. Users (if they want) can increase the values (which can only help the network) and will still be spec-compliant.\r\n\r\nSo I guess, maybe the lower bounds are the default, but people can help the network and chew more bandwidth, get better message latency and help the network if they want to and have limited data restrictions. Not opposed to having fixed values either. \r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/952464927/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953268880",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953268880",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953268880,
    "node_id": "IC_kwDOCOoGbc440bqQ",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-27T20:06:17Z",
    "updated_at": "2021-10-27T20:06:17Z",
    "author_association": "MEMBER",
    "body": "> As Jacek has mentioned, one modification we can make is to keep track of duplicates sent to us from our peers so that we don't propagate to peers that have sent us a duplicate\r\n\r\nMeaning, I take information about past messages to not duplicate route for future messages? I'd worry that due to the mesh dynamically changing slot-to-slot that this could create gaps in natural delivery. I'd need to think about it some more.\r\n\r\nIt does seem worth reducing the amplification factor if possible.\r\n\r\nAn alternative might be to gossip headers to peers we expect might do duplicates and the peer only requests the body if it doesn't hear about it from another source. But such mechanisms are a deeper change to what we have today.\r\n\r\n\r\n> You're probably right that we don't want to make this too large and rather just reduce the amount of gossip via d_lazy\r\n\r\nI'm pro doing both! I do think there is a compelling argument to alter this to even 2s or 3s. That is from the perspective of the IWANT/IHAVE gossip -- if we use this gossip as more of a fallback rather than ensuring super fast delivery, 2 or 3s begins to look reasonable. That said as you noted, it also is tied to adding/dropping peers but doing that super fast also seems... a waste.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953268880/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953295020",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953295020",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953295020,
    "node_id": "IC_kwDOCOoGbc440iCs",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-27T20:41:59Z",
    "updated_at": "2021-10-27T20:41:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It does seem worth reducing the amplification factor if possible.\r\n\r\nIt's important to remember that what the amplification factor primarily does is give the message a good spread at the very beginning, when almost no peers have the block/attestation/etc - it comes with a cost as well of course, but it's not \"just\" resilience against partitions that gets affected.\r\n\r\n> might be to gossip headers\r\n\r\nWell, this is by and large what IHAVE is :)\r\n\r\n> subnets\r\n\r\nSubnets are pretty much full these days: there's as many committees as there are subnets, every slot, which means that subscribing to a subnet \"too early\" is really bad, from a bandwidth perspective - what we're looking to optimize right now for few-validators nodes is to shorten the time before aggregation duty that we subscribe to the topic, so as to avoid irrelevant (for that aggreate) attestation traffic. The flip side of being more aggressive here are features like backoff where unsubscribing from a topic prevents you from resubscribing for several slots - this is an issue because the same subnet might be needed fairly soon after an aggregation duty (because randomness).\r\n\r\nNumbers would be extremely valuable at this stage, of relative bandwidth costs of various topics and the metadata around them - it's something that's moving up on our prio list given that altair measurably increases cost (cpu/network) of running a node\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953295020/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953350665",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953350665",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953350665,
    "node_id": "IC_kwDOCOoGbc440voJ",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-27T22:14:50Z",
    "updated_at": "2021-10-27T22:14:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Meaning, I take information about past messages to not duplicate route for future messages? I'd worry that due to the mesh dynamically changing slot-to-slot that this could create gaps in natural delivery. I'd need to think about it some more.\r\n\r\nI think this change is safe and wont effect any natural propagation. Essentially we currently store a list of seen message ids. If someone sends us a message with the same id, we ignore it. The proposed change would be to not only store the message-id from peers, but also the peers that have sent us this exact message. Then when we propagate/publish, we check that a peer hasn't already sent us this exact message. If a peer has sent us this exact message, its a waste for us to send it to them. \r\n\r\nI know we're going down a proper simulation route with formal numbers. I was trialling mesh sizes around 4 or 5 and saw around a 1/6 reduction in bandwidth, to give very rough figures. These was on a node subscribed to all subnets all the time (on prater) however. So there are decent gains to be made. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953350665/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953371174",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953371174",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953371174,
    "node_id": "IC_kwDOCOoGbc4400om",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-27T23:00:57Z",
    "updated_at": "2021-10-27T23:06:22Z",
    "author_association": "MEMBER",
    "body": "> The proposed change would be to not only store the message-id from peers, but also the peers that have sent us this exact message. Then when we propagate/publish, we check that a peer hasn't already sent us this exact message\r\n\r\nwow, I've naively/blindly just assumed this even though I've never seen it written in spec or discussed in implementations.\r\n\r\nI thought you meant to use past messages to imply what to do with future messages (which seems unsafe). What you describe seems safe, natural, and insane (?) not to do.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953371174/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953399772",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953399772",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953399772,
    "node_id": "IC_kwDOCOoGbc4407nc",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-28T00:12:57Z",
    "updated_at": "2021-10-28T00:12:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yeah, I think it hasn't been done because it wasn't clear how much this would save us vs the overhead of storing every peer for every duplicate. \r\n\r\nI think in our case, with all the duplicates we have, there would be a decent amount of bandwidth saving. However we'd have to get all the implementations to implement it for it to take effect at a network level :). I'll add it into rust-gossipsub now. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953399772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953585948",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953585948",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953585948,
    "node_id": "IC_kwDOCOoGbc441pEc",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-28T07:45:25Z",
    "updated_at": "2021-10-28T07:46:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "> wow, I've naively/blindly just assumed this even though I've never seen it written in spec or discussed in implementations.\r\n\r\nThis is only relevant when there's a large enough delay between receiving the message and stamping it \"ok\" for further distribution - for networks that don't validate messages like we do, or where validation is synchronous, it isn't relevant. The cost of it is memory usage - instead of having a single \"seen\" cache, you end up with one per mesh peer.\r\n\r\nI suspect the greatest benefit might be on subnet and aggregate channels where there's are bursts of small data packets with fairly high validation time (vs transmission time).\r\n\r\nWhat's nice about  it is that it works well to \"naturally\" alleviate processing in times of stress - when the client / network is less loaded, (almost) no messages will be dropped by this feature, but under load, it kicks in and filters out _some_ redundancy - the more the load, the more it filters.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953585948/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953641434",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-953641434",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 953641434,
    "node_id": "IC_kwDOCOoGbc4412na",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-28T08:49:05Z",
    "updated_at": "2021-10-28T08:49:05Z",
    "author_association": "MEMBER",
    "body": "> This is only relevant when there's a large enough delay between receiving the message and stamping it \"ok\" for further distribution - for networks that don't validate messages like we do, or where validation is synchronous, it isn't relevant. The cost of it is memory usage - instead of having a single \"seen\" cache, you end up with one per mesh peer.\r\n\r\nWhat if use a counter that bumps every new message received and gives a message an id that grows from one message to another. And a couple of dictionaries that maps 1) counter id on the message id  2) counter id on the peer id. And send messages to peers which counter id is less than a counter id of a message. Though, it would require sending messages in a strict order to be sure that all X messages starting with counter id N-X ending with N have been sent to a peer",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/953641434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/954304629",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-954304629",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 954304629,
    "node_id": "IC_kwDOCOoGbc444Yh1",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-28T23:51:37Z",
    "updated_at": "2021-10-28T23:51:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This is only relevant when there's a large enough delay between receiving the message and stamping it \"ok\" for further distribution - for networks that don't validate messages like we do, or where validation is synchronous, it isn't relevant. The cost of it is memory usage - instead of having a single \"seen\" cache, you end up with one per mesh peer.\r\n\r\nI think this is relevant even without message validation (although message validation probably does make it worse, it just increases message latency in-effect). In my small example of an interconnected mesh of size 4, regardless of message validation, on the second hop, we could always remove sending back a duplicate with this method (provided nodes aren't sending to each other in-flight, its a race-condition on which one we would filter). I think with more complex meshes where messages bounce around in a triangle a bit more we'd get more savings. \r\n\r\n> What if use a counter that bumps every new message received and gives a message an id that grows from one message to another. And a couple of dictionaries that maps 1) counter id on the message id 2) counter id on the peer id. And send messages to peers which counter id is less than a counter id of a message. Though, it would require sending messages in a strict order to be sure that all X messages starting with counter id N-X ending with N have been sent to a peer\r\n\r\nThis is an interesting idea. I guess it would save us some RAM compared to naively storing the peers per message. Also it may be difficult to send in strict order because we do the message validation async and some objects can take longer to validate than others. \r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/954304629/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/954406864",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-954406864",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 954406864,
    "node_id": "IC_kwDOCOoGbc444xfQ",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-29T03:47:53Z",
    "updated_at": "2021-10-29T03:48:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Message Amplification\r\nWe have set D to be 8 in the specs which naturally gives us relatively high message amplification. On the block topic (the simplest to reason about), we see on average about 8 duplicates (as would naively be expected) and therefore a bandwidth amplification of about 8x. The other topics are less straightforward.\r\n\r\n> We can significantly reduce our node's bandwidth by reducing the mesh sizes. The impact of this at a network-level is non-trivial. As we flood-publish, a client's default peer count plays a large role in how many hops or how fast a message propagates as we publish to every peer we know who is connected on that topic. Therefore, it may be possible to have higher peer counts, and lower mesh sizes whilst maintaining a similar number of hops to reach the entire network.\r\n\r\n> In any case our mesh sizes appear to be larger than needed and we may want to lower them (incrementally on testnets).\r\n\r\nOn the topic of message amplification has there been any thought given to tuning the gossipsub `D` parameters to be per topic rather than global ? Some topics naturally have much more duplicates simply because message volumes are much smaller for that topic. Parameters that would work well for beacon blocks might be a negative if applied to `aggregates` or any other noisier channel.\r\n\r\nTuning it per topic, would allow us to tune the parameters to what expected message rates are in a topic, rather than applying smaller mesh sizes across the board. I understand that this will be a non-trivial change implementation wise to all the gossipsub libraries, but since we are looking at ways to reduce message amplification this is one direction to go in. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/954406864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/955496360",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-955496360",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 955496360,
    "node_id": "IC_kwDOCOoGbc4487eo",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-30T17:08:19Z",
    "updated_at": "2021-10-30T17:08:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Some topics naturally have much more duplicates \r\n\r\nHow is message volume related to duplication?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/955496360/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/955745311",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-955745311",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 955745311,
    "node_id": "IC_kwDOCOoGbc4494Qf",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-31T16:28:50Z",
    "updated_at": "2021-10-31T16:28:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "> How is message volume related to duplication?\r\n\r\nDuplication might be the wrong word, but more `IHAVE` messages relaying the same message ids. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/955745311/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/962853523",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-962853523",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 962853523,
    "node_id": "IC_kwDOCOoGbc45Y_qT",
    "user": {
      "login": "jmozah",
      "id": 940575,
      "node_id": "MDQ6VXNlcjk0MDU3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/940575?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmozah",
      "html_url": "https://github.com/jmozah",
      "followers_url": "https://api.github.com/users/jmozah/followers",
      "following_url": "https://api.github.com/users/jmozah/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmozah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmozah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmozah/subscriptions",
      "organizations_url": "https://api.github.com/users/jmozah/orgs",
      "repos_url": "https://api.github.com/users/jmozah/repos",
      "events_url": "https://api.github.com/users/jmozah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmozah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-08T06:38:03Z",
    "updated_at": "2021-11-08T06:47:05Z",
    "author_association": "NONE",
    "body": ">The proposed change would be to not only store the message-id from peers, but also the peers that have sent us this exact message. Then when we propagate/publish, we check that a peer hasn't already sent us this exact message. If a peer has sent us this exact message, its a waste for us to send it to them.\r\n\r\nAnother navie way could be to append the message with the last few overlays prefix's (first 2 bytes maybe) that the message has travelled and ignore retransmitting to similar overlays.  This method can still have duplicates, but tight triangular duplications can be avoided. How much the amplification is reduced is based on how many prefix we choose to send along with the messageID.\r\n\r\nofcourse this has a disadvantage that peers will know to some extent from which direction the message is coming from.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/962853523/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/962879692",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-962879692",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 962879692,
    "node_id": "IC_kwDOCOoGbc45ZGDM",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-08T07:27:46Z",
    "updated_at": "2021-11-08T07:27:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I think this is relevant even without message validation\r\n\r\nHow so? Presumably, without validation you receive a message and rebroadcast it to everyone without delay - ie there's no \"gap\" where nodes can send you messages and thus signal that they have it already - unless one is introduced artificially.\r\n\r\n> overhead of storing\r\n\r\nJust thought a little bit about this, and the overhead should actually be negligible - we only need to store this information for messages that are in-validation - basically, the first time we see the message and send it off to validation, we register it for monitoring - then, when others send it as well, we record that, then when validation is done, we send it to anyone that wasn't in the monitoring record and remove the information completely. Subsequent messages will be discarded by the \"seen\" cache regardless and won't ever enter the validation pipeline so there's no overhead for them.\r\n\r\n> counter that bumps\r\n\r\nThis is an interesting idea, but it also introduces state that must be maintained across across the two clients, which I think adds a complication that we should strive to avoid, exhausting other possibilities first.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/962879692/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/963815366",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2692#issuecomment-963815366",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2692",
    "id": 963815366,
    "node_id": "IC_kwDOCOoGbc45cqfG",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-09T04:51:16Z",
    "updated_at": "2021-11-09T04:51:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "> How so? Presumably, without validation you receive a message and rebroadcast it to everyone without delay - ie there's no \"gap\" where nodes can send you messages and thus signal that they have it already - unless one is introduced artificially.\r\n\r\nYep you're right. Its only in the validation gap this needs to be dealt with. Your suggestion is good. I've modified my implementation as to how we are storing the peers. Shifted it to the mem-cache and its a bit cleaner and should reduce the memory footprint. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/963815366/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
