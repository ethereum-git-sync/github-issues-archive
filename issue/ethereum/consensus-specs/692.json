{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/692",
  "id": 414849408,
  "node_id": "MDU6SXNzdWU0MTQ4NDk0MDg=",
  "number": 692,
  "title": "Phase 0 Wire Protocol",
  "user": {
    "login": "mslipper",
    "id": 67953,
    "node_id": "MDQ6VXNlcjY3OTUz",
    "avatar_url": "https://avatars.githubusercontent.com/u/67953?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mslipper",
    "html_url": "https://github.com/mslipper",
    "followers_url": "https://api.github.com/users/mslipper/followers",
    "following_url": "https://api.github.com/users/mslipper/following{/other_user}",
    "gists_url": "https://api.github.com/users/mslipper/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mslipper/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mslipper/subscriptions",
    "organizations_url": "https://api.github.com/users/mslipper/orgs",
    "repos_url": "https://api.github.com/users/mslipper/repos",
    "events_url": "https://api.github.com/users/mslipper/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mslipper/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 23,
  "created_at": "2019-02-26T22:23:33Z",
  "updated_at": "2020-01-13T09:12:52Z",
  "closed_at": "2019-03-12T20:48:07Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Follow-on to #593.\r\n\r\nThis specification describes Ethereum 2.0's networking wire protocol.\r\n\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL\", NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\r\n\r\n# Use of `libp2p`\r\n\r\nThis protocol uses the `libp2p` networking stack. `libp2p` provides a composable wrapper around common networking primitives, including:\r\n\r\n1. Transport.\r\n2. Encryption.\r\n3. Stream multiplexing.\r\n\r\nClients MUST be compliant with the corresponding `libp2p` specification whenever `libp2p` specific protocols are mentioned. This document will link to those specifications when applicable.\r\n\r\n# Client Identity\r\n\r\n## Identification\r\n\r\nUpon first startup, clients MUST generate an RSA key pair in order to identify the client on the network. The SHA-256 `multihash` of the public key is the clients's Peer ID, which is used to look up the client in `libp2p`'s peer book and allows a client's identity to remain constant across network changes.\r\n\r\n## Addressing\r\n\r\nClients on the Ethereum 2.0 network are identified by`multiaddr`s. `multiaddr`s are self-describing network addresses that include the client's location on the network, the transport protocols it supports, and its peer ID. For example, the human-readable `multiaddr` for a client located at `example.com`, available via TCP on port `8080`, and with peer ID `QmUWmZnpZb6xFryNDeNU7KcJ1Af5oHy7fB9npU67sseEjR` would look like this:\r\n\r\n```\r\n/dns4/example.com/tcp/8080/p2p/QmUWmZnpZb6xFryNDeNU7KcJ1Af5oHy7fB9npU67sseEjR\r\n```\r\n\r\nWe refer to the `/dns4/example.com` part as the 'lookup protocol', the `/tcp/8080` part as the networking protocol, and the `/p2p/<peer ID>` part as the 'identity protocol.' \r\n\r\nClients MAY use either `dns4` or `ip4` lookup protocols. Clients MUST set the identity protocol to `/tcp` followed by a port of their choosing. It is RECOMMENDED to use the default port of `9000`. Clients MUST set the identity protocol to `/p2p/` followed by their peer ID.\r\n\r\n## Relevant `libp2p` Specifications\r\n\r\n- [multiaddr](https://github.com/multiformats/multiaddr)\r\n- [multihash](https://multiformats.io/multihash/)\r\n- [peer-id](https://github.com/libp2p/js-peer-id)\r\n\r\n# Transport\r\n\r\nClients communicate with one another over a TCP stream. Through that TCP stream, clients receive messages either as a result of a 1-1 RPC request/response between peers or via pubsub broadcasts.\r\n\r\n# Weak-Subjectivity Period\r\n\r\nSome of the message types below depend on a calculated value called the 'weak subjectivity period' to be processed correctly. The weak subjectivity period is a function of the size of the validator set at the last finalized epoch. The goal of the weak-subjectivity period is to define the maximum number of validator set changes a client can tolerate before requiring out-of-band information to resync.\r\n\r\nThe definition of this function will be added to the [0-beacon-chain](https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md) specification in the coming days.\r\n\r\n# Messaging\r\n\r\nAll ETH 2.0 messages conform to the following structure:\r\n\r\n```\r\n+--------------------------+\r\n|       protocol path      |\r\n+--------------------------+\r\n|      compression ID      |\r\n+--------------------------+\r\n|                          |\r\n|    compressed body       |\r\n|    (SSZ encoded)         |\r\n|                          |\r\n+--------------------------+\r\n```\r\n\r\nThe _protocol path_ is a human-readable prefix that identifies the message's contents. It is compliant with the `libp2p` `multistream` specification. For example, the protocol path for `libp2p`'s internal `ping` message is `/p2p/ping/1.0.0`. All protocol paths include a version for future upgradeability. In practice, client implementors will not have to manually prepend the protocol path since `libp2p` implements this as part of the `libp2p` library.\r\n\r\nThe _compression ID_ is a single-byte sigil that denotes which compression algorithm is used to compress the message body. Currently, the following compression algorithms are supported:\r\n\r\n1. ID `0x00`: no compression\r\n2. ID `0x01`: Snappy compression\r\n\r\nWe suggest starting with Snappy because of its high throughput (~250MB/s without needing assembler), permissive license, and availability in a variety of different languages.\r\n\r\nFinally, the _compressed body_ is the SSZ-encoded message body after being compressed by the algorithm denoted by the compression ID.\r\n\r\n## Relevant Specifications\r\n\r\n- [multistream](https://github.com/multiformats/multistream)\r\n- [SSZ](https://github.com/ethereum/eth2.0-specs/blob/master/specs/simple-serialize.md)\r\n\r\n# Messages\r\n\r\nThe schema of message bodies is notated like this:\r\n\r\n```\r\n(\r\n    field_name_1: type\r\n    field_name_2: type\r\n)\r\n```\r\n\r\nSSZ serialization is field-order dependent. Therefore, fields MUST be  encoded and decoded according to the order described in this document. The encoded values of each field are concatenated to form the final encoded message body. Embedded structs are serialized as Containers unless otherwise noted.\r\n\r\nAll ETH 2.0 RPC messages prefix their protocol path with `/eth/serenity`.\r\n\r\n## Handshake\r\n\r\n### Hello \r\n\r\n**Protocol Path:** `/eth/serenity/hello/1.0.0`\r\n\r\n**Body**:\r\n\r\n```\r\n(\r\n    network_id: uint8\r\n    latest_finalized_root: bytes32\r\n    latest_finalized_epoch: uint64\r\n    best_root: bytes32\r\n    best_slot: uint64\r\n)\r\n```\r\n\r\nClients exchange `hello` messages upon connection, forming a two-phase handshake. The first message the initiating client sends MUST be the `hello` message. In response, the receiving client MUST respond with its own `hello` message.\r\n\r\nClients SHOULD immediately disconnect from one another following the handshake above under the following conditions:\r\n\r\n1. If `network_id` belongs to a different chain, since the client definitionally cannot sync with this client.\r\n2. If the time between each peer's `latest_finalized_epoch` exceeds the weak-subjectivity period, since syncing with this client would be unsafe.\r\n3. If the `latest_finalized_root` shared by the peer is not in the client's chain at the expected epoch. For example, if Peer 1 in the diagram below has `(root, epoch)` of `(A, 5)` and Peer 2 has `(B, 3)`, Peer 1 would disconnect because it knows that `B` is not the root in their chain at epoch 3:\r\n\r\n```\r\n              Root A\r\n\r\n              +---+\r\n              |xxx|  +----+ Epoch 5\r\n              +-+-+\r\n                ^\r\n                |\r\n              +-+-+\r\n              |   |  +----+ Epoch 4\r\n              +-+-+\r\nRoot B          ^\r\n                |\r\n+---+         +-+-+\r\n|xxx+<---+--->+   |  +----+ Epoch 3\r\n+---+    |    +---+\r\n         |\r\n       +-+-+\r\n       |   |  +-----------+ Epoch 2\r\n       +-+-+\r\n         ^\r\n         |\r\n       +-+-+\r\n       |   |  +-----------+ Epoch 1\r\n       +---+\r\n```\r\n\r\nOnce the handshake completes, the client with the higher `latest_finalized_epoch` or `best_slot` (if the clients have equal `latest_finalized_epoch`s) SHOULD send beacon block roots to its counterparty via `beacon_block_roots`.\r\n\r\n## RPC\r\n\r\nThese protocols represent RPC-like request/response interactions between two clients. Clients send serialized request objects to streams at the protocol paths described below, and wait for a response. If no response is received within a reasonable amount of time, clients MAY disconnect.\r\n\r\n### Beacon Block Roots\r\n\r\n**Protocol Path:** `/eth/serenity/rpc/beacon_block_roots/1.0.0`\r\n\r\n**Body:**\r\n\r\n```\r\n# BlockRootSlot\r\n(\r\n    block_root: HashTreeRoot\r\n    slot: uint64\r\n)\r\n\r\n(\r\n    roots: []BlockRootSlot\r\n)\r\n```\r\n\r\nSend a list of block roots and slots to the peer.\r\n\r\n### Beacon Block Headers\r\n\r\n**Protocol Path:** `/eth/serenity/rpc/beacon_block_headers/1.0.0`\r\n\r\n**Request Body**\r\n\r\n```\r\n(\r\n    start_root: HashTreeRoot\r\n    start_slot: uint64\r\n    max_headers: uint64\r\n    skip_slots: uint64\r\n)\r\n```\r\n\r\n**Response Body:**\r\n\r\n```\r\n# Eth1Data\r\n(\r\n    deposit_root: bytes32\r\n    block_hash: bytes32\r\n)\r\n\r\n# BlockHeader\r\n(\r\n    slot: uint64\r\n    parent_root: bytes32\r\n    state_root: bytes32\r\n    randao_reveal: bytes96\r\n    eth1_data: Eth1Data\r\n    body_root: HashTreeRoot\r\n    signature: bytes96\r\n)\r\n\r\n(\r\n    headers: []BlockHeader\r\n)\r\n```\r\n\r\nRequests beacon block headers from the peer starting from `(start_root, start_slot)`. The response MUST contain fewer than `max_headers` headers. `skip_slots` defines the maximum number of slots to skip between blocks. For example, requesting blocks starting at slots `2` a `skip_slots` value of `2` would return the blocks at `[2, 4, 6, 8, 10]`. In cases where a slot is undefined for a given slot number, the closest previous block MUST be returned returned. For example, if slot `4` were undefined in the previous example, the returned array would contain `[2, 3, 6, 8, 10]`. If slot three were further undefined, the array would contain `[2, 6, 8, 10]` - i.e., duplicate blocks MUST be collapsed.\r\n\r\nThe function of the `skip_slots` parameter helps facilitate light client sync - for example, in [#459](https://github.com/ethereum/eth2.0-specs/issues/459) - and allows clients to balance the peers from whom they request headers. Client could, for instance, request every 10th block from a set of peers where each per has a different starting block in order to populate block data.\r\n\r\n### Beacon Block Bodies\r\n\r\n**Protocol Path:** `/eth/serenity/rpc/beacon_block_bodies/1.0.0`\r\n\r\n**Request Body:**\r\n\r\n```\r\n(\r\n    block_roots: []HashTreeRoot\r\n)\r\n```\r\n\r\nRequests the `block_bodies` associated with the provided `block_roots` from the peer. Responses MUST return `block_roots` in the order provided in the request. If the receiver does not have a particular `block_root`, it must return a zero-value `block_body` (i.e., a zero-filled `bytes32`).\r\n\r\n**Response Body:**\r\n\r\nFor type definitions of the below objects, see the [0-beacon-chain](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#data-structures) specification.\r\n\r\n```\r\n# BlockRoot\r\n(\r\n    proposer_slashings: []ProposerSlashing\r\n    attester_slashings: []AttesterSlashing\r\n    attestations: []Attestation\r\n    deposits: []Deposit\r\n    voluntary_exits: []VoluntaryExit\r\n    transfers: []Transfer\r\n)\r\n\r\n(\r\n    block_roots: BlockRoot[]\r\n)\r\n```\r\n\r\n### Beacon Chain State\r\n\r\n**Note:** This section is preliminary, pending the definition of the data structures to be transferred over the wire during fast sync operations.\r\n\r\n**Protocol Path:** `/eth/serenity/rpc/beacon_chain_state/1.0.0`\r\n\r\n**Request Body:**\r\n\r\n```\r\n(\r\n    hashes: []HashTreeRoot\r\n)\r\n```\r\n\r\nRequests contain the hashes of Merkle tree nodes that when merkelized yield the block's `state_root`.\r\n\r\n**Response Body:** TBD\r\n\r\nThe response will contain the values that, when hashed, yield the hashes inside the request body.\r\n\r\n## Broadcast\r\n\r\nThese protocols represent 'topics' that clients can subscribe to via GossipSub.\r\n\r\n### Beacon Blocks\r\n\r\nThe response bodies of each topic below map to the response bodies of the Beacon RPC methods above. Note that since broadcasts have no concept of a request, any limitations to the RPC response bodies do not apply to broadcast messages.\r\n\r\n**Topics:**\r\n\r\n- `beacon/block_roots`\r\n- `beacon/block_headers`\r\n- `beacon/block_bodies`\r\n\r\n### Voluntary Exits\r\n\r\n**Topic:** `beacon/exits`\r\n\r\n**Body:**\r\n\r\nSee the [0-beacon-chain](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#data-structures) spec for the definition of the `VoluntaryExit` type.\r\n\r\n```\r\n(\r\n    exit: VoluntaryExit\r\n)\r\n```\r\n\r\n### Transfers\r\n\r\n**Topic:** `beacon/transfer`\r\n\r\n**Body:**\r\n\r\nSee the [0-beacon-chain](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#transfer) spec for the definition of the `Transfer` type.\r\n\r\n```\r\n(\r\n    transfer: Transfer\r\n)\r\n```\r\n\r\nClients MUST ignore transfer messages if `transfer.slot < current_slot - GRACE_PERIOD`, where `GRACE_PERIOD` is an integer that represents the number of slots that a remote peer is allowed to drift from `current_slot` in order to take potential network time differences into account.\r\n\r\n### Shard Attestations\r\n\r\n**Topics:** `shard-{number}`, where `number` is an integer in `[0, SHARD_SUBNET_COUNT)`, and `beacon/attestations`.\r\n\r\nThe `Attestation` object below includes fully serialized `AttestationData` in its `data` field. See the [0-beacon-chain](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#data-structures) for the definition of the `Attestation` type.\r\n\r\n**Body:**\r\n\r\n```\r\n(\r\n    attestations: []Attestation\r\n)\r\n```\r\n\r\nOnly aggregate attestations are broadcast to the `beacon/attestations` topic.\r\n\r\nClients SHOULD NOT send attestations for shards that the recipient is not interested in. Clients receiving uninteresting attestations MAY disconnect from senders.\r\n\r\n## Relevant Specifications\r\n\r\n- [gossipsub](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub)\r\n\r\n# Client Synchronization\r\n\r\nWhen a client joins the network, or has otherwise fallen behind the `latest_finalized_root` or `latest_finalized_epoch`, the client MUST perform a sync in order to catch up with the head of the chain. This specification defines two sync methods:\r\n\r\n1. **Standard:** Used when clients already have state at `latest_finalized_root` or `latest_finalized_epoch`. In a standard sync, clients process per-block state transitions until they reach the head of the chain.\r\n2. **Fast:** Used when clients do not have state at `latest_finalized_root` or `latest_finalized_epoch`. In a fast sync, clients use RPC methods to download nodes in the state tree for a given `state_root` via the `/eth/serenity/rpc/beacon_chain_state/1.0.0` endpoint. The basic algorithm is as follows:\r\n    1. Peer 1 and Peer 2 connect. Peer 1 has `(C, 1)` and Peer 2 has `(A, 5)`. Peer 1 validates that this new head is within the weak subjectivity period.\r\n    2. If the head is within the weak subjectivity period, Peer 2 checks the validity of the new chain by verifying that all children point to valid parent roots.\r\n    3. Peer 2 then takes the state root of `(A, 5)` and sends `/eth/serenity/rpc/beacon_chain_state/1.0.0` requests recursively to its peers in order to build its SSZ BeaconState.\r\n\r\nNote that nodes MUST perform a fast sync if they do not have state at their starting finalized root. For example, if Peer 1 in the example above did not have the state at `(C, 1)`, Peer 1 would have to perform a fast sync because it would have no base state to compute transitions from.\r\n\r\n \r\n# Open Questions\r\n\r\n## Encryption\r\n\r\nThis specification does not currently define an encrypted transport mechanism because the set of `libp2p`-native encryption libraries is limited. `libp2p` currently supports an encryption scheme called SecIO, which is a variant of TLSv1.3 that uses a peer's public key for authentication rather than a certificate authority. While SecIO is available for public use, it has not been audited and is going to be deprecated when TLSv1.3 ships.\r\n\r\nAnother potential solution would be to support an encryption scheme such as [Noise](http://www.noiseprotocol.org/noise.html). The Lightning Network team has successfully deployed Noise in production to secure inter-node communications.\r\n\r\n## Granularity of Topics\r\n\r\nThis specification defines granular GossipSub topics - i.e., `beacon/block_headers` vs. simply `beacon`. The goal of using granular topics is to simplify client development by defining a single payload type for each topic. For example, `beacon/block_headers` will only ever contain block headers, so clients know the content type of without needing to read the message body itself. This may have drawbacks. For example, having too many topics may hinder peer discovery speed. If this is the case, this specification will be updated to use less granular topics.\r\n\r\n## Block Structure Changes\r\n\r\nThe structure of blocks may change due to [#649](https://github.com/ethereum/eth2.0-specs/pull/649). Changes that affect this specification will be incorporated here once the PR is merged.",
  "closed_by": {
    "login": "mslipper",
    "id": 67953,
    "node_id": "MDQ6VXNlcjY3OTUz",
    "avatar_url": "https://avatars.githubusercontent.com/u/67953?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mslipper",
    "html_url": "https://github.com/mslipper",
    "followers_url": "https://api.github.com/users/mslipper/followers",
    "following_url": "https://api.github.com/users/mslipper/following{/other_user}",
    "gists_url": "https://api.github.com/users/mslipper/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mslipper/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mslipper/subscriptions",
    "organizations_url": "https://api.github.com/users/mslipper/orgs",
    "repos_url": "https://api.github.com/users/mslipper/repos",
    "events_url": "https://api.github.com/users/mslipper/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mslipper/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692/reactions",
    "total_count": 4,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 4,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467659706",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467659706",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467659706,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzY1OTcwNg==",
    "user": {
      "login": "Mikerah",
      "id": 4249799,
      "node_id": "MDQ6VXNlcjQyNDk3OTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4249799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Mikerah",
      "html_url": "https://github.com/Mikerah",
      "followers_url": "https://api.github.com/users/Mikerah/followers",
      "following_url": "https://api.github.com/users/Mikerah/following{/other_user}",
      "gists_url": "https://api.github.com/users/Mikerah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Mikerah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Mikerah/subscriptions",
      "organizations_url": "https://api.github.com/users/Mikerah/orgs",
      "repos_url": "https://api.github.com/users/Mikerah/repos",
      "events_url": "https://api.github.com/users/Mikerah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Mikerah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-26T23:34:17Z",
    "updated_at": "2019-02-27T02:03:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "Great writeup!\r\n\r\nA few notes:\r\n\r\nThere has been [discussions](https://github.com/ethresearch/p2p/issues/15) on whether to use RLP for discovery and SSZ for messages.\r\n\r\nThere has also been some [discussion](https://github.com/ethresearch/p2p/issues/8) on using QUIC instead of UDP for discovery and TCP for all other peer communication. By using QUIC, we no longer need a 3-way handshake as in TCP and we get built-in encryption. The main issue is that it hasn't been implemented in all programming languages.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467659706/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467684205",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467684205",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467684205,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzY4NDIwNQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T01:20:56Z",
    "updated_at": "2019-02-27T01:21:09Z",
    "author_association": "MEMBER",
    "body": "> If the time between each peer's `latest_finalized_epoch` exceeds the weak-subjectivity period, since syncing with this client would be unsafe.\r\n\r\nWhat do we mean by this? Note that especially in cases where the validator set is very small, it is absolutely possible for the latest finalized block to be more than a weak subjectivity period behind the current block. \r\n\r\n> 3. If the `latest_finalized_root` shared by the peer is not in the client's chain at the expected epoch. For example, if Peer 1 in the diagram below has `(root, epoch)` of `(A, 5)` and Peer 2 has `(B, 3)`, Peer 1 would disconnect because it knows that `B` is not the root in their chain at epoch 3:\r\n\r\nThis feels backward. It's not the peer's latest finalized root that should be checked against the client head, it's the peer's head that should be checked against the client's latest finalized root. As an example of how the current approach is insufficient, consider the case where the client head is H with a latest finalized root R with parent P, and a peer says hello with a chain going through some different child R' of P that doesn't finalize any blocks. The peer's latest finalized root would be some ancestor of P; so this is clearly invalid from the point of view of the client, but it would still be accepted.\r\n\r\n> Only aggregate attestations are broadcast to the `beacon/attestations` topic.\r\n\r\nIs there a need for this particular wire protocol spec to specify where _unaggregated_ attestations get sent?\r\n\r\n> There has been [discussions](https://github.com/ethresearch/p2p/issues/15) on whether to use RLP for discovery and SSZ for messages.\r\n\r\nAs the inventor of RLP, I'm inclined to prefer SSZ (or SOS if we end up replacing SSZ with SOS or something similar) :laughing:\r\n\r\nThe \"simplicity over efficiency\" desideratum would imply that we should ideally only use one algorithm per task (in this case the task being \"serialization\"), even if they have slightly different tradeoffs. I see the overhead of a few extra zero bytes in SSZ being tiny relative to the absolute size of the objects that would be transferred, so the gains wouldn't be large.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467684205/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467706765",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467706765",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467706765,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzcwNjc2NQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T03:12:15Z",
    "updated_at": "2019-02-27T03:12:15Z",
    "author_association": "MEMBER",
    "body": "> What do we mean by this? Note that especially in cases where the validator set is very small, it is absolutely possible for the latest finalized block to be more than a weak subjectivity period behind the current block.\r\n\r\nThe point here is to make clear that you may think you are safe to sync but realize on the wire that you don't have recent enough information to safely sync. I suppose this information can (and maybe should) be known before you even contact peers. An epoch # is an absolute time so you can know the expected head of chain epoch before you sync and know you are in the danger zone without knocking on a peer's door. In this case, maybe this is not a wire protocol note, but a client implementer safety note that goes in another doc.\r\n\r\n> This feels backward\r\n\r\nThe peer with the lower finalized epoch (peer-1) cannot immediately tell just by shaking hands with the peer with the higher finalized epoch (peer-2) if the peer-1's finalized epoch is in peer-2's chain or not. Peer-2 on the other hand can easily check if peer-1's finalized epoch is in their chain. If not, no use in sending blocks to them because to sync peer-2's blocks, peer-1 would have to revert.\r\n\r\nI'm not sure if what we currently have in (3) is backward, but it is does not sufficiently cover all the cases in which two chains might be out of sync wrt finality \r\n\r\n> Is there a need for this particular wire protocol spec to specify where _unaggregated_ attestations get sent?\r\n\r\nNot 100% sure. The expectation is that single signer attestations are sent to the shard subnet. Only rarely would a single signer attestation be broadcast to the beacon net as a \"best effort\" aggregation.\r\n\r\n> The \"simplicity over efficiency\" desideratum would imply that we should ideally only use one algorithm per task\r\n\r\n+1",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467706765/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467726653",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467726653",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467726653,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzcyNjY1Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T05:11:26Z",
    "updated_at": "2019-02-27T05:11:26Z",
    "author_association": "MEMBER",
    "body": "> Not 100% sure. The expectation is that single signer attestations are sent to the shard subnet. Only rarely would a single signer attestation be broadcast to the beacon net as a \"best effort\" aggregation.\r\n\r\nAgree! So do we need a \"shard subnet wire protocol\" section?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467726653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467815609",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467815609",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467815609,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzgxNTYwOQ==",
    "user": {
      "login": "CarlBeek",
      "id": 12530043,
      "node_id": "MDQ6VXNlcjEyNTMwMDQz",
      "avatar_url": "https://avatars.githubusercontent.com/u/12530043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CarlBeek",
      "html_url": "https://github.com/CarlBeek",
      "followers_url": "https://api.github.com/users/CarlBeek/followers",
      "following_url": "https://api.github.com/users/CarlBeek/following{/other_user}",
      "gists_url": "https://api.github.com/users/CarlBeek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CarlBeek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CarlBeek/subscriptions",
      "organizations_url": "https://api.github.com/users/CarlBeek/orgs",
      "repos_url": "https://api.github.com/users/CarlBeek/repos",
      "events_url": "https://api.github.com/users/CarlBeek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CarlBeek/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T10:48:57Z",
    "updated_at": "2019-02-27T10:50:58Z",
    "author_association": "MEMBER",
    "body": "Re-raising this point, but is there any particular reason why `beacon_block_roots` is built in as a part of `hello` instead of being exposed as its own RPC request? It improves the modularity of `hello` and passes the onus of getting up to date to the peer that is behind. Under the above proposal, if a peer is behind and conducts several `hello` exchanges with its peers (perhaps due to being offline temporarily) would receive beacon block roots several times. This obviously represents sevral redundant messages. Furthermore, in the above protocol, the **only** means of obtaining beacon block roots is via new `hello` exchanges.\r\n\r\nAlso, if we are going to make topics plural, please can we make `beacon/transfer` plural too.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467815609/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467847773",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467847773",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467847773,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Nzg0Nzc3Mw==",
    "user": {
      "login": "jannikluhn",
      "id": 29854669,
      "node_id": "MDQ6VXNlcjI5ODU0NjY5",
      "avatar_url": "https://avatars.githubusercontent.com/u/29854669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jannikluhn",
      "html_url": "https://github.com/jannikluhn",
      "followers_url": "https://api.github.com/users/jannikluhn/followers",
      "following_url": "https://api.github.com/users/jannikluhn/following{/other_user}",
      "gists_url": "https://api.github.com/users/jannikluhn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jannikluhn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jannikluhn/subscriptions",
      "organizations_url": "https://api.github.com/users/jannikluhn/orgs",
      "repos_url": "https://api.github.com/users/jannikluhn/repos",
      "events_url": "https://api.github.com/users/jannikluhn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jannikluhn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T12:42:41Z",
    "updated_at": "2019-02-27T12:44:15Z",
    "author_association": "MEMBER",
    "body": "Nice writeup! This is quite a big document, so maybe opening a PR would allow for easier review (not sure what the best place for this would be though). I'll try giving some feedback anyway:\r\n\r\n> SSZ/SOS vs RLP debate\r\n\r\nI'm leaning towards RLP for message encoding. Not because of efficiency, but because with SSZ we at all times need to know the exact message type that we're expecting. RLP is more flexible in that regard which would make it easier to support versioning, multiple possible response message types, and using the same gossip topic for multiple object types. Also, if we go with RLP at the discovery level anyway, then using it at the \"content\" level would be more consistent (but this is a different debate I guess).\r\n\r\n> Message format\r\n\r\nI think whenever we send objects that are defined in the spec, we should put them in the message either as a (list of) SSZ blob(s) (if we go with non-SSZ as message format) or as a container field (for SSZ messages). Right now, it seems like we're redefining some object types (e.g. block header and block body).\r\n\r\n> Handshake\r\n\r\n- network id: It seems like we don't actually use this to distinguish between networks, but rather between chains. Replacing it with something like \"hard fork choices\" would make this more explicit: It would contain slot or epoch and block hash pairs for relevant blocks (genesis and all hard forks, or at least the latest one)\r\n\r\n- Shall we add the latest justified head as well? If I'm not making a mistake, the last finalized epoch will be 1.5 epochs or ~10 minutes old on average, even in optimal conditions, and adding the justified epoch should be quite cheap.\r\n\r\n- Shall we rename `best` to `head` to follow the terminology of the spec and be more neutral?\r\n\r\n> Disconnect\r\n\r\nMaybe we should have an explicit \"Disconnect\" message. This would enable peers to do some clean ups and also stop responding to any potential outstanding requests.\r\n\r\n> Request/Responses\r\n\r\nWe should add a `request_id` to each request/response message. This way handling replies gets much easier and also allows for parallel requests.\r\n\r\n> Beacon Block Roots\r\n\r\nI think the corresponding request is missing, no? We can probably just use the same format as we do for requesting beacon block headers.\r\n\r\n> Beacon Block Headers\r\n\r\nThe request contains both slot and root. Why? The slot seems to be redundant so I think removing it is better for simplicity.\r\n\r\n> Scope\r\n\r\nI think we should try to keep this as simple as possible for now and don't specify any fast or light sync etc.\r\n\r\n> Protocol paths\r\n\r\nI think we should add beacon/shard to the protocol path, i.e.\r\n\r\n`/eth/serenity/rpc/beacon_block_roots/1.0.0` --> `/eth/serenity/beacon/rpc/beacon_block_roots/1.0.0`\r\n\r\n> Agree! So do we need a \"shard subnet wire protocol\" section?\r\n\r\n:+1:",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467847773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467877376",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467877376",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467877376,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Nzg3NzM3Ng==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T14:15:56Z",
    "updated_at": "2019-02-27T14:15:56Z",
    "author_association": "MEMBER",
    "body": "> Agree! So do we need a \"shard subnet wire protocol\" section?\r\n\r\nThe \"Shard Attestations\" section includes both `shard` and `beacon` topics as valid topics to broadcast on. It just makes the note that only aggregated are expected to be passed to the `beacon` topic. Is this what you mean? We can pull these things out so they are more clearly distinct.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467877376/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467879277",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467879277",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467879277,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Nzg3OTI3Nw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T14:21:18Z",
    "updated_at": "2019-02-27T14:21:18Z",
    "author_association": "MEMBER",
    "body": "> Re-raising this point, but is there any particular reason why `beacon_block_roots` is built in as a part of `hello` instead of being exposed as its own RPC request?\r\n\r\nThis is similar to how block hashes are exchanged on the ethereum 1.0 wire protocol. The expectation is that you are only gathering information to \"catch up\" when initially finding peers and that beyond that you generally stay synced by listening to broadcasts on the wire. If you get a recent block and don't have it's parent, you can ask for it's parent via the root embedded in the block and walk the chain back until you find a common ancestor. If fallen way out of sync, you can reconnect to peers to get a list of roots. \r\n\r\nI see the potential utility of what you describe but am not sure needing to request the list after initial `hello` is generally necessary. I'd like to look into how geth handles this and will ask a couple of 1.0 sync masters about it today.\r\n\r\n> Also, if we are going to make topics plural, please can we make `beacon/transfer` plural too.\r\n\r\n👍 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467879277/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467884396",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467884396",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467884396,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Nzg4NDM5Ng==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T14:34:41Z",
    "updated_at": "2019-02-27T14:34:41Z",
    "author_association": "MEMBER",
    "body": "> Nice writeup! This is quite a big document, so maybe opening a PR would allow for easier review (not sure what the best place for this would be though). I'll try giving some feedback anyway:\r\n\r\nWill open up a PR after these initial comments. Thanks!\r\n\r\n> Right now, it seems like we're redefining some object types (e.g. block header and block body).\r\n\r\nThe current format of `BlockHeader` here is just the `BeaconBlock` with the body served as a hash root. I hear you on making the formats just easily reference the SSZ objects for clarity. We have a couple of header/body changes coming in #649 (firm separation between header/body) and then will clean up accordingly.\r\n\r\n>  network id: It seems like we don't actually use this to distinguish between networks, but rather between chains.\r\n\r\nInteresting. In the 1.0 protocol we use it for both distinguishing between entirely different chains (mainnet vs ropsten vs ..) as well as forks within a single chain. and contentious forks _become_ different networks. I see there could be some use in coming up with a succinct format to describe forks independent of base \"network\". Nick Johnson had an [interesting proposal on twitter](https://twitter.com/nicksdjohnson/status/1100528276710125568). Something like this might be worth pursuing.\r\n\r\n>  If I'm not making a mistake, the last finalized epoch will be 1.5 epochs or ~10 minutes old on average, even in optimal conditions, and adding the justified epoch should be quite cheap.\r\n\r\nThe `latest_finalized_epoch`/`root` is to see if the two chains are irrevocably disjoint and to serve somewhat as a \"check-pointing\" mechanism. The lastest justified is not set in stone. What use case do you see here? Also note, that a newly syncing peer would probably just have a latest finalized epoch/root.\r\n\r\n>  Shall we rename `best` to `head` to follow the terminology of the spec and be more neutral?\r\n\r\nagreed\r\n\r\n> Maybe we should have an explicit \"Disconnect\" message. This would enable peers to do some clean ups and also stop responding to any potential outstanding requests.\r\n\r\nSeems reasonable. Could also signal a \"why\" if you had a particular reason\r\n\r\n> I think we should try to keep this as simple as possible for now and don't specify any fast or light sync etc.\r\n\r\nA method to sync state is necessary in the weakly subjective chain. Clients are expected to show up with some recent finalized root and peers are not expected to serve blocks since genesis in perpetuity.  The term is more aptly described here as \"State Sync\" rather than \"fast\" as it's primary use is to provide a recent state to a client. Also note that the state size is bound ~600MB even in the worst case and so should actually be _fast_.\r\n\r\n_gotta run. I'll get to your other few things in a bit, and will make some edits accordingly._",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467884396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467936405",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-467936405",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 467936405,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzkzNjQwNQ==",
    "user": {
      "login": "FrankSzendzielarz",
      "id": 33515470,
      "node_id": "MDQ6VXNlcjMzNTE1NDcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33515470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/FrankSzendzielarz",
      "html_url": "https://github.com/FrankSzendzielarz",
      "followers_url": "https://api.github.com/users/FrankSzendzielarz/followers",
      "following_url": "https://api.github.com/users/FrankSzendzielarz/following{/other_user}",
      "gists_url": "https://api.github.com/users/FrankSzendzielarz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/FrankSzendzielarz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/FrankSzendzielarz/subscriptions",
      "organizations_url": "https://api.github.com/users/FrankSzendzielarz/orgs",
      "repos_url": "https://api.github.com/users/FrankSzendzielarz/repos",
      "events_url": "https://api.github.com/users/FrankSzendzielarz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/FrankSzendzielarz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-27T16:41:05Z",
    "updated_at": "2019-02-27T16:41:05Z",
    "author_association": "MEMBER",
    "body": "After a review (I will study/contemplate this later in more depth) of this lovely piece of work,  I just want to raise a couple of questions, which most likely arise out of my own lack of understanding:\r\n\r\n1) If nodes are *discovered* using [ENRs]( https://github.com/ethereum/devp2p/tree/master/discv5), the information on the node is already available. This means that clients will be identified by ENR, and if libp2p multiaddr is used or not is an implementation detail, not a protocol requirement, (right?)\r\n2) Similarly, compression type could be omitted from the message as the default should be the 'highest' supported by the sending node supported by the recipient.\r\n3) Encoding (SSZ) could similarly be optional/variable. \r\n4) Protocol path could be compressed out as the info is in the ENR. A byte/nibble should be sufficient. Why compress the message body and make the protocol path human readable?\r\n5) Eth-current uses Network ID and Chain ID.\r\n\r\nOn wire encoding is it fair to say that for participation in the existing network, RLP is necessary as a software component for the medium term future regardless?\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/467936405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468274953",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-468274953",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 468274953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODI3NDk1Mw==",
    "user": {
      "login": "jannikluhn",
      "id": 29854669,
      "node_id": "MDQ6VXNlcjI5ODU0NjY5",
      "avatar_url": "https://avatars.githubusercontent.com/u/29854669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jannikluhn",
      "html_url": "https://github.com/jannikluhn",
      "followers_url": "https://api.github.com/users/jannikluhn/followers",
      "following_url": "https://api.github.com/users/jannikluhn/following{/other_user}",
      "gists_url": "https://api.github.com/users/jannikluhn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jannikluhn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jannikluhn/subscriptions",
      "organizations_url": "https://api.github.com/users/jannikluhn/orgs",
      "repos_url": "https://api.github.com/users/jannikluhn/repos",
      "events_url": "https://api.github.com/users/jannikluhn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jannikluhn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T13:37:10Z",
    "updated_at": "2019-02-28T13:37:10Z",
    "author_association": "MEMBER",
    "body": "> The `latest_finalized_epoch`/`root` is to see if the two chains are irrevocably disjoint and to serve somewhat as a \"check-pointing\" mechanism. The lastest justified is not set in stone. What use case do you see here? Also note, that a newly syncing peer would probably just have a latest finalized epoch/root.\r\n\r\nI assumed both finalized epoch and head are just used to select the best peer to connect to and sync from. The justified epoch would just be an additional piece of information to do this a little better. Maybe in practice the head is already enough though, so this might not be necessary.\r\n\r\n>  Interesting. In the 1.0 protocol we use it for both distinguishing between entirely different chains (mainnet vs ropsten vs ..) as well as forks within a single chain. and contentious forks _become_ different networks. I see there could be some use in coming up with a succinct format to describe forks independent of base \"network\". Nick Johnson had an [interesting proposal on twitter](https://twitter.com/nicksdjohnson/status/1100528276710125568). Something like this might be worth pursuing.\r\n\r\nYes, in Eth1.0 there's kind of a one to one relationship between networks and forks. But in Eth2.0, we have at least the beacon network and multiple (shard) subnetworks for the same (beacon) chain, and if we count the various topics as one network each we get even more. So I think we should differentiate the terms a bit more cleanly.\r\n\r\n> Similarly, compression type could be omitted from the message as the default should be the 'highest' supported by the sending node supported by the recipient.\r\n\r\nI think/hope libp2p handles this for us already so nothing we should worry about.\r\n\r\n> Encoding (SSZ) could similarly be optional/variable.\r\n\r\nI strongly think we should agree on some encoding scheme and require it. Otherwise different clients won't be able to talk to each other and the network will cluster by implementation.\r\n\r\n> Protocol path could be compressed out as the info is in the ENR. A byte/nibble should be sufficient. Why compress the message body and make the protocol path human readable?\r\n\r\nI think that's also in libp2p's domain.\r\n\r\ncc @raulk",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468274953/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468281471",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-468281471",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 468281471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODI4MTQ3MQ==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T13:57:11Z",
    "updated_at": "2019-02-28T13:58:20Z",
    "author_association": "MEMBER",
    "body": ">  Upon first startup, clients MUST generate an RSA key pair in order to identify the client on the network. The SHA-256 `multihash` of the public key is the clients's Peer ID...\r\n\r\nThis shouldn't be in this specification because it is handled by lower layers of the stack.\r\nAlso, are we really considering to use RSA?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468281471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469356620",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-469356620",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 469356620,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTM1NjYyMA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T18:12:05Z",
    "updated_at": "2019-03-04T18:12:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "From what I understand, `beacon_block_headers` goes forwards in time, starting at a low slot number and building towards higher slot numbers.\r\n\r\nWhat's often happens in distributed systems is that stuff gets lost along the way, for a variety of reasons. Thus, what would be useful is an ancestor request, such that when you receive a block or attestation whose parent is unknown, you can quickly recover and establish if this is a good block or not.\r\n\r\nWhat you need:\r\n* a finalized block serving as anchor - here you can go back to genesis or whatever block you already know is finalized - `tail` is a useful name, if the other end is called `head`.\r\n* a request to get ancestor blocks - strictly, one at a time is sufficient, but it quickly becomes obvious that it's nice to get a range as well.\r\n\r\nWhen you receive a block, you need to check that you have a path back to a tail block you know about - if you don't, it's either a block that's not part of the chain (spam?), or you're missing links. To find out, you have to try downloading the missing block headers, using slot time to establish a horizon to tell one situation from the other.\r\n\r\nThis kind of request is very flexible, because it allows you to join the network, start listening to broadcast chatter and discover what the most popular heads are (assuming broadcast network is namespaced / separate for every chain - it's fairly low cost to add a network id to every broadcast, which will greatly help debugging, if nothing else)\r\n\r\nThe approach is nice for a few different reasons:\r\n* cheap to implement - all data is already in the blocks, so there's no need for clients to build special indices to support basic functionality\r\n* same flow for sync and repair - whether you lost a block because connectivity was cut or are joining with a fresh state, the same request is used to fill in the gaps\r\n* the method is sufficient for a correctly functioning network - on top, you can add certain well-placed optimizations to speed things up (like the hello message to discover heads)\r\n* you can join the network and start listening to broadcasts - no special requests necessary for sync \r\n\r\nWhat you do as a client is to divide blocks into two: resolved and unresolved. Resolved blocks are those that you have established a path to a finalized state (that you know through other means) to. Unresolved are all the others:\r\n\r\n* blocks from different chains, malicious blocks etc.. will never establish path\r\n* blocks where you're missing links - will establish path\r\n\r\nThe request would look something like:\r\n\r\n```\r\n(\r\n    head_root: HashTreeRoot\r\n    ancestor_slots: uint64\r\n)\r\n```\r\n\r\nBasically, a start-pointer+length kind of request, but going backwards in time (this is already an optimization over getting blocks one at a time then getting their parents recursively, which also works - this is incidentally the same as the `git` dumb remote sync protocol).\r\n\r\nThis request can return block headers or roots as is appropriate (headers seems natural, because you want to use the response to verify that one of the blocks resolves to a known chain state) \r\n\r\nOne problem with the approach is that when you receive an unknown block, you have to use network resources to find out if it's valid or not (the block might be signed by a validator that's not in your validator set, because the latest finalized block you know about does not yet contain it ). This can be mitigated by:\r\n* using heuristics to score blocks and use resources accordingly (is it well-formed? is it signed by a known validator? does slot time make sense? etc)\r\n* make sure that answers are ordered from low slot number to high, so you can quickly discard bad information - potentially with pagination (ie you have to be prepared to handle a partial response)\r\n\r\nThe forward-direction request is slightly problematic in that it also needs to decide if it should branch out on all children or simply follow what the responding client considers to be the canonical chain at the time. Ancestor request does not have this issue.\r\n\r\n>    skip_slots: uint64\r\n\r\nwhat's the use case for skipping slots at uniform intervals?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469356620/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469424217",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-469424217",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 469424217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTQyNDIxNw==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T21:14:24Z",
    "updated_at": "2019-03-04T21:14:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "fwiw we just landed a simple implementation of the application layer requests in this protocol in Nimbus: https://github.com/status-im/nim-beacon-chain/pull/117 (the PR description is a bit off, it refers to an earlier attempt that we subsequently rewrote), and will be playing around with it for the initial sync. \r\n\r\nA detail is that we're running it over devp2p right now for convenience, but should be integrating with a libp2p transport soon:ish.\r\n\r\nOne thing of note is that when you're a proposer, you want to include attestations from as many shards as possible, right? Effectively, this means that that if attestation broadcasts are split up by shards, you end up having to listen to all of them anyway, under the naive attestation broadcast protocol where everyone just broadcasts their self-signed attestation.\r\n\r\n> Only aggregate attestations are broadcast to the beacon/attestations topic.\r\n\r\nWhat's lacking for this is a responsible entity that does the aggregation and broadcasts it here - also, what's aggregate in this context? 2/3 votes? all? and who does the aggregation.. so many questions :) Pegasys' aggregation looks promising, but until we have that, in the implementation we're broadcasting everything everywhere - obviously, this will not do for 4 million validators!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469424217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469898086",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-469898086",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 469898086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTg5ODA4Ng==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-05T23:14:58Z",
    "updated_at": "2019-03-05T23:14:58Z",
    "author_association": "MEMBER",
    "body": "> Effectively, this means that that if attestation broadcasts are split up by shards, you end up having to listen to all of them anyway, under the naive attestation broadcast protocol where everyone just broadcasts their self-signed attestation.\r\n\r\nThe expectation is to have some subset of committee broadcast best-effort aggregates picked up from the shard subnet to the beacon (say last N of committee). These validators are already connected to the subnet for creating the attestation and are incentivized to have their attestations included in the beacon chain so are a natural pick. A proposer of a beacon chain block is not expected to sync to a bunch of different subnets to pick up and aggregate attestations. Adding this to honest validator guide shortly.\r\n\r\n> Pegasys' aggregation looks promising\r\n\r\nAgreed. Glad to have it in our back pocket, but want to get some nodes on testnets before we decide to go with a more sophisticated setup. Note that even with a more structured aggregatation scheme, we need some sort of expected behavior defining what gets passed to the beacon net.\r\n\r\n> what's the use case for skipping slots at uniform intervals?\r\n\r\nTo distribute the load of requests across peers, and to also be able to provide a \"skip\" subset to light clients.\r\n\r\nStill digesting the rest of your post.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469898086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470229888",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-470229888",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 470229888,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDIyOTg4OA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-06T18:53:40Z",
    "updated_at": "2019-03-06T18:53:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "> These validators are already connected to the subnet for creating the attestation and are incentivized to have their attestations included in the beacon chain so are a natural pick.\r\n\r\nbut do they have an interest for others to be rewarded also? minimally no, right? since reward depends on total active validator balance, it's better for me if someone else loses balance? there's the social good argument of course that validators might remember who excluded them and reciprocate etc.. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470229888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470235729",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-470235729",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 470235729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDIzNTcyOQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-06T19:09:11Z",
    "updated_at": "2019-03-06T19:09:11Z",
    "author_association": "MEMBER",
    "body": "> but do they have an interest for others to be rewarded also? minimally no, right? since reward depends on total active validator balance, it's better for me if someone else loses balance? there's the social good argument of course that validators might remember who excluded them and reciprocate etc..\r\n\r\nvalidators lose money if they aren't successfully crosslinking or finalizing. The best thing I can do as an individual is maximize participation of my committee and validators as a whole. If I happen to have some huge majority of validation, my optimal strategy might change to censorship.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470235729/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/471416292",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-471416292",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 471416292,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MTQxNjI5Mg==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-11T06:12:16Z",
    "updated_at": "2019-03-11T06:12:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "How would state sync work in the case of skipped slots ? Lets say a node A joins the network so has no saved state locally and will have to perform a `fast` sync.  Node B has the latest finalized root/epoch , A is at (R<sub>A</sub>,1) and B is at (R<sub>B</sub>,5). \r\n\r\nWhat happens when the slots before finalization were skipped slots in epoch 5 ? Node A downloads the whole state from its peers and will have the same finalized state as Node B. However now Node A has to catch up to the current head of the network and starts requesting for blocks after the latest finalized epoch.\r\n\r\nLets say due to network issues slots are skipped before finalization, every block that Node A import's now will point to a parent that the node cannot validate as the parent is not saved and that block will end up being thrown away despite being a valid block. This would end up with sync permanently stalling as it would never be able to reach the current head ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/471416292/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472097882",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-472097882",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 472097882,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjA5Nzg4Mg==",
    "user": {
      "login": "jannikluhn",
      "id": 29854669,
      "node_id": "MDQ6VXNlcjI5ODU0NjY5",
      "avatar_url": "https://avatars.githubusercontent.com/u/29854669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jannikluhn",
      "html_url": "https://github.com/jannikluhn",
      "followers_url": "https://api.github.com/users/jannikluhn/followers",
      "following_url": "https://api.github.com/users/jannikluhn/following{/other_user}",
      "gists_url": "https://api.github.com/users/jannikluhn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jannikluhn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jannikluhn/subscriptions",
      "organizations_url": "https://api.github.com/users/jannikluhn/orgs",
      "repos_url": "https://api.github.com/users/jannikluhn/repos",
      "events_url": "https://api.github.com/users/jannikluhn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jannikluhn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-12T17:20:22Z",
    "updated_at": "2019-03-12T17:20:22Z",
    "author_association": "MEMBER",
    "body": "@nisdas Skipped slots don't matter, all A need is blocks and they can still get them even if some slots in between are empty. A would just ask for all blocks from their last known slot to the current slot and B would reply with all non-skipped ones. I guess this may become slightly more inefficient if A tries to request from multiple Bs (as they don't know which blocks have been skipped, so the load won't be distributed equally), but that seems not very significant.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472097882/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472174888",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-472174888",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 472174888,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjE3NDg4OA==",
    "user": {
      "login": "mslipper",
      "id": 67953,
      "node_id": "MDQ6VXNlcjY3OTUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/67953?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mslipper",
      "html_url": "https://github.com/mslipper",
      "followers_url": "https://api.github.com/users/mslipper/followers",
      "following_url": "https://api.github.com/users/mslipper/following{/other_user}",
      "gists_url": "https://api.github.com/users/mslipper/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mslipper/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mslipper/subscriptions",
      "organizations_url": "https://api.github.com/users/mslipper/orgs",
      "repos_url": "https://api.github.com/users/mslipper/repos",
      "events_url": "https://api.github.com/users/mslipper/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mslipper/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-12T20:48:07Z",
    "updated_at": "2019-03-12T20:48:07Z",
    "author_association": "MEMBER",
    "body": "I've included updates to this spec here: https://github.com/ethereum/eth2.0-specs/pull/763. Closing this in favor of the PR.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472174888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472346984",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-472346984",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 472346984,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjM0Njk4NA==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-13T09:34:45Z",
    "updated_at": "2019-03-13T09:34:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jannikluhn The issue isnt requesting skipped slots. Its how we perform `fast` sync while requesting for the beacon state initially. This is what I was thinking of \r\n```\r\n Block Proposed +-----------+ Slot 94 ( Current Head)\r\n         ^\r\n         | \r\n         ^\r\n         | \r\n         ^\r\n         | \r\n Block Proposed +-----------+ Slot 66\r\n         ^\r\n         | \r\n   Slot Skipped +-----------+ Slot 65\r\n         ^\r\n         | \r\n   Slot Skipped +-----------+ Slot 64 ( Epoch Transition & State is finalized)\r\n         ^\r\n         | \r\n   Slot Skipped +-----------+ Slot 63\r\n         ^\r\n         | \r\n   Slot Skipped +-----------+ Slot 62\r\n         ^\r\n         | \r\n   Slot Skipped +-----------+ Slot 61\r\n         ^\r\n         |\r\n    Block Proposed +-----------+ Slot 60\r\n  \r\n```\r\nIf a new node joins the network they will start sync by requesting the finalized state at slot 64( epoch 1). Then in order to sync till the current head at slot 94, it will request blocks from (65,94). So when the node receives the response containing the blocks in this range, it will process the block at slot 66 (since 65 was skipped). But when we process this block into state transition function, it will be rejected since we do not have the previous chain head which is actually the block at slot 60. We also will need to save the parent block(slot 60) in state sync in order for sync to work.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472346984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472369311",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-472369311",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 472369311,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjM2OTMxMQ==",
    "user": {
      "login": "jannikluhn",
      "id": 29854669,
      "node_id": "MDQ6VXNlcjI5ODU0NjY5",
      "avatar_url": "https://avatars.githubusercontent.com/u/29854669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jannikluhn",
      "html_url": "https://github.com/jannikluhn",
      "followers_url": "https://api.github.com/users/jannikluhn/followers",
      "following_url": "https://api.github.com/users/jannikluhn/following{/other_user}",
      "gists_url": "https://api.github.com/users/jannikluhn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jannikluhn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jannikluhn/subscriptions",
      "organizations_url": "https://api.github.com/users/jannikluhn/orgs",
      "repos_url": "https://api.github.com/users/jannikluhn/repos",
      "events_url": "https://api.github.com/users/jannikluhn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jannikluhn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-13T10:38:55Z",
    "updated_at": "2019-03-13T10:38:55Z",
    "author_association": "MEMBER",
    "body": "Ah, I think I get what you mean now. The state does contain the latest block header though, so this should deal with it, right?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472369311/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472445424",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/692#issuecomment-472445424",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/692",
    "id": 472445424,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjQ0NTQyNA==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-13T14:29:36Z",
    "updated_at": "2019-03-13T14:29:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ahh , yes that would solve it. This is a bug on our end since we generate the previous block root from our locally saved block instead of using the one kept in state. Thanks !",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472445424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
