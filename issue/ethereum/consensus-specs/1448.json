{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1448",
  "id": 512906301,
  "node_id": "MDU6SXNzdWU1MTI5MDYzMDE=",
  "number": 1448,
  "title": "Attestations and custody bits proposal for phase 1",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-10-27T01:26:27Z",
  "updated_at": "2019-11-03T17:24:09Z",
  "closed_at": "2019-11-03T17:24:09Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Challenges\r\n\r\n* An attestation is signing over a maximum of 256 shard blocks and state roots (maximum 1024 shard blocks and state roots signed over per block in total)\r\n* This is a lot of data, and we want to only store the data we need to store (eg. we don't need to store the shard blocks and state roots signed over by _losing_ attestations)\r\n* We want verifying attestations to be efficient (i) in beacon blocks, (ii) over the wire during the aggregation process.\r\n\r\n### Proposal\r\n\r\nWe define two data structures, `Attestation` and `AttestationShardData`. A beacon block contains one `AttestationShardData` for each shard that it is processing (min 1 max 64). `Attestation` objects only contain a hash of the `AttestationShardData` (the hash is still needed to verify signatures). We verify that the `AttestationShardData` hashes to the hash of the winning attestation, ie. the one that gets >=2/3 and updates that shard (or is empty if there is no winner).\r\n\r\nAn `Attestation` contains a 2D custody bits array, 1 bit per committee member (max 2048) per block processed by that attestation (max 256).\r\n\r\nWhen an attestation is broadcasted over the wire, it _does not_ come with explicit `AttestationShardData`; instead, it is broadcasted in a wrapper that contains a pointer to a single \"head\". This is because `AttestationShardData` can be inferred from the head assuming that a given client has downloaded all of the shard blocks. \r\n\r\nWe define the message hash that a validator is expected to sign over as follows. Let `bits[0]....bits[n-1]` be the validator's custody bits of the `n` blocks. Let `R` be the attestation data root. The validator signs `hash_to_point((R, 0, bits[0])) + ... + hash_to_point((R, n-1, bits[n-1]))`, where `+` is elliptic curve addition over G2.\r\n\r\nNote that verifying this signature \"on the wire\" requires `n` hash to point operations and additions, though the hash-to-point operations need only be computed once for any particular attestation data; only G2 additions are per-attestation work.\r\n\r\nVerifying an aggregate signature in a block can be done as follows. Let `custody_subset(i, b)` be the subset of validators whose i'th custody bit is `b`. We do `e(hash_to_point((R, 0, 0)), group_pubkey(custody_subset(0, 0))) * e(hash_to_point((R, 0, 1)), group_pubkey(custody_subset(0, 1))) * ... * e(hash_to_point((R, n-1, 1)), group_pubkey(custody_subset(n-1, 1)))` to compute the Fp12 element the signature is checked against. This requires `2n` pairings.",
  "closed_by": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547300415",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1448#issuecomment-547300415",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448",
    "id": 547300415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzMwMDQxNQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-10-29T08:00:26Z",
    "updated_at": "2019-10-29T14:51:26Z",
    "author_association": "MEMBER",
    "body": "Clever! This or something similar seems like a reasonable approach.\r\n\r\nThe inclusion of only winning `AttestationShardData` is particularly nice.\r\n\r\nThe 2D custody bit array is max size -- `256 * 2048 = 64 kB`. For the case of unaggregated attestations on the wire this data will be highly compressible (almost all zeros). For the case of aggregates on the shared net, we just need to ensure that not too many can be broadcast (which is done in the simple aggregation strategy.\r\n\r\nThe main potential issue is the size requirement in the blocks which could at worst case be `32kb * 128 = ~4MB` of custody bits in the blocks. This isn't great but is still small wrt to some of the larger operations that can be included (attester slashings).\r\n\r\nThe IndexedAttestation (used by slashings) would need to be redesigned to be a list of indices with an associated max-256-bit bitfield each which ups the max size of `AttesterSlashing`s to `2 * (MAX_COMMITTEE_SIZE * BYTES_PER_VAL_INDEX + MAX_COMMITTEE_SIZE *  MAX_SIZE_OF_CUSTODY_BITFIELD)  = 2* (2048 * 8 + 2048 * 64) = ~300kb` from the previous ~66kb so a moderately substantial increase here.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/547300415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/549159458",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1448#issuecomment-549159458",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1448",
    "id": 549159458,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0OTE1OTQ1OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-03T17:24:09Z",
    "updated_at": "2019-11-03T17:24:09Z",
    "author_association": "MEMBER",
    "body": "> The IndexedAttestation (used by slashings) would need to be redesigned to be a list of indices with an associated max-256-bit bitfield each which ups the max size of AttesterSlashings to 2 * (MAX_COMMITTEE_SIZE * BYTES_PER_VAL_INDEX + MAX_COMMITTEE_SIZE * MAX_SIZE_OF_CUSTODY_BITFIELD) = 2* (2048 * 8 + 2048 * 64) = ~300kb from the previous ~66kb so a moderately substantial increase here.\r\n\r\nYep, this is how I changed indexed attestations to work.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/549159458/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
