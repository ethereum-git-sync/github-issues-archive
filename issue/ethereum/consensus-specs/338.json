{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/338",
  "id": 392578478,
  "node_id": "MDU6SXNzdWUzOTI1Nzg0Nzg=",
  "number": 338,
  "title": "Phase 1: block headers inside or outside of data committed to in the shard data root?",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2018-12-19T12:27:03Z",
  "updated_at": "2019-06-19T00:34:49Z",
  "closed_at": "2019-06-19T00:34:49Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "I see two paths for exactly what data the shard data roots that are attested to in crosslinks commit to. Note that each choice also influences the choice of what clients will need to check to gain assurance of validity and availability.\r\n\r\n### Proofs of custody on data roots only\r\n\r\nSuppose the last crosslink for shard `i` was of a block at slot `N`, and the next crosslink is of a block at slot `N+k`. The crosslink commits to a merkle root of the data roots of each block in the range `[N ... N+k-1]`, where skipped slots are deemed as containing empty data.\r\n\r\nTo verify a chain, a client must:\r\n\r\n* Verify the beacon chain\r\n* Verify the header chains of every shard and check that they match what's in the crosslinks\r\n* If desired, perform data availability checks on the erasure coded data corresponding to the data included in the crosslink\r\n\r\nThe main weakness of the scheme is higher overhead for clients wishing to fully verify: you need to be a light client on every shard, so that's ~400 bytes * 1024 shards / 6 seconds = 67 kB/sec.\r\n\r\n### Proofs of custody on shard chains\r\n\r\nInstead of one 16-kb data root, each shard block has 5 data roots for 15.5 kb of data, leaving the other 512 bytes empty. You can then calculate the \"real data root\" of a block as being the Merkle root of the 512 byte space including the header concatenated with the 15.5 kb of the data (the header itself and the 5 data roots suffice for this).\r\n\r\nThe crosslink commits to a merkle root of _these_ data roots.\r\n\r\nTo fully verify a chain, a client must now only verify the beacon chain, and do data availability checks on the erasure coded data of the crosslink roots if desired. Verifying the validity of the shard chain can now be done entirely with slashing conditions, where you can declare a data root invalid by providing a Merkle branch into a block, verifying the block in-beacon-chain and showing that the block is invalid (or providing two adjacent blocks to show that their hashes mismatch).\r\n\r\nThe main weaknesses of the scheme are:\r\n\r\n* It slightly mixes checking availability and checking state transition validity, as it's checking validity of the headers\r\n* It requires a somewhat more awkward data root construction",
  "closed_by": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/448666543",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/338#issuecomment-448666543",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338",
    "id": 448666543,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0ODY2NjU0Mw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-19T16:54:11Z",
    "updated_at": "2018-12-19T16:54:11Z",
    "author_association": "MEMBER",
    "body": "I'm a bit confused about the construction of the 5 data roots.\r\nGiven 15.5kb of block data, do we create 5 distinct roots but placing the 512 empty bytes at different locations in the data hash tree?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/448666543/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/448697648",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/338#issuecomment-448697648",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338",
    "id": 448697648,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0ODY5NzY0OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-19T18:29:39Z",
    "updated_at": "2018-12-19T18:29:52Z",
    "author_association": "MEMBER",
    "body": "Let `[M0 .... M31]` be the full Merkle tree and `R[i, j]` be the sub-root of `M[i:j]` (eg. `R[0, 32]` is the root of the whole tree). The block header would include `M1`, `R[2, 4]`, `R[4, 8]`, `R[8, 16]`, `R[16, 32]`, and then you would calculate the tree via `R[0, 32] = hash(hash(hash(hash(hash(hash(block_header, M1), R[2, 4]), R[4, 8]), R[8, 16]), R[16, 32])`. So the block header effectively contains the Merkle branch that lets you compute the full data root of the block once you drop in the header.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/448697648/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/449529453",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/338#issuecomment-449529453",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/338",
    "id": 449529453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0OTUyOTQ1Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-22T00:23:05Z",
    "updated_at": "2018-12-22T00:23:05Z",
    "author_association": "MEMBER",
    "body": "Notes from a discussion with @JustinDrake:\r\n\r\n* We could also not store any information about the headers, because it's all either redundant info that could be recalculated or data that could be put into the data root, except for the signatures, which can be BLS aggregated into a single 96-byte sig.\r\n* Alternatively, the header of block N could be put into the body of block N+1\r\n* Instead of doing a single PoC (and erasure code) of unknown length, we can do it on a per-epoch basis, maintaining in the shard blocks an accumulator that tracks all historical super-data-roots for each epoch\r\n* Another approach is to build up two separate super-data-roots during each epoch: one for tx data, and one for headers + intermediate state roots + eventually possibly a STARK or something similar, then you can just combine together the roots at the end. This will lead to erasure coding a root with ~1.9x more data than necessary initially (because the size of the data root is much bigger) but eh whatever; FFT erasure coding is cheap",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/449529453/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
