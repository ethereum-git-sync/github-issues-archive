{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1901",
  "id": 639886777,
  "node_id": "MDU6SXNzdWU2Mzk4ODY3Nzc=",
  "number": 1901,
  "title": "Transition SSZ out of Eth2 specs repo, introduce new SSZ specs repo.",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    },
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/milestones/6",
    "html_url": "https://github.com/ethereum/consensus-specs/milestone/6",
    "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/milestones/6/labels",
    "id": 5797403,
    "node_id": "MDk6TWlsZXN0b25lNTc5NzQwMw==",
    "number": 6,
    "title": "🔵 v1.0.0 candidates",
    "description": "",
    "creator": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 12,
    "closed_issues": 5,
    "state": "closed",
    "created_at": "2020-08-21T16:23:12Z",
    "updated_at": "2021-06-07T15:09:56Z",
    "due_on": null,
    "closed_at": "2021-05-04T14:59:24Z"
  },
  "comments": 9,
  "created_at": "2020-06-16T18:29:36Z",
  "updated_at": "2020-08-21T16:26:52Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "First of all: this does not change any existing SSZ functionality, this is a proposal to extend the information available, and move it out of the Eth2 specs repository.\r\n\r\nThe current SSZ specification in this repository is very dense, prune to bugs because of it, and most of all, incomplete with regards to the more advanced features.\r\n\r\nThere is a lot I want the SSZ spec to describe: principles, ideas, advanced topics, and more description for hardening certain decoding features. However, this seems like too much to fit into the Eth2 specs.\r\n\r\nSo instead, I have this draft up for an SSZ specs repository:\r\n\r\n**https://github.com/protolambda/eth2.0-ssz/** (yes, moving it out of a personal GitHub repo once we have a transition plan).\r\n\r\nI also plan to include ssz-specific testing in this new repository as well, to better cover invalid SSZ data, and help SSZ implementations embed just the tests they need, as opposed to the full Eth2 suite of tests. (fastssz as standalone Go library being a good example)\r\n\r\nAdditionally, I am looking to do versioning differently, where features grow in stages, and feedback on style and wording can be merged into the specs more quickly for unstable stages.\r\n\r\nHopefully this also enables the formal verification team (cc @franck44, @booleanfunction) to express their findings better. I feel like any change in the current SSZ spec here confuses implementers more than it helps them, since the functionality is there, but the way it is written is difficult to follow, and having a debate whether or not something is a bug, or how/when something breaks, shows how limiting the spec format is.\r\n\r\nSo this is an open call for others involved in SSZ to give the draft repo a look, help iterate on it now that it's still an early draft and friction is lower, and to plan on a transition to this separate SSZ repository.\r\n\r\nCC @wemeetagain @zah - since you have both spent a lot of time on more advanced SSZ implementations, you may be interested.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645225305",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645225305",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645225305,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTIyNTMwNQ==",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-17T08:12:40Z",
    "updated_at": "2020-06-17T08:23:42Z",
    "author_association": "MEMBER",
    "body": "My two cents\r\n\r\n#### IMHO what are the insufficient parts of the status-quo SSZ spec:\r\n1. **The historical problem**\r\n    1. [Phase 0] `simple-serialize.md`: there was a [pyspec-only ssz implementation](https://github.com/ethereum/eth2.0-specs/blob/v0.9.0/test_libs/pyspec/eth2spec/utils/ssz/ssz_impl.py) before pyspec moved to use [`remerkleable`](https://github.com/ethereum/eth2.0-specs/pull/1552). Some Python functions that the spec is referencing are from that implementation. `py-ssz` itself has some optimization so that `py-ssz` doesn't 100% follow the spec presentation too.\r\n    2. [Phase 1] `merkle-proofs.md` is untested: It's almost all Python codes to describe how it works. However, the codes haven't been tested in CI. And since we use `remerkleable` for pyspec, we may ignore the inconsistency between `merkle-proofs.md` and implementation.\r\n2. **Specification process and presentation**\r\n    1. @franck44 I fully agreed that formal verification spec is valuable! But also, it's important to have a spec that devs and users can understand quickly. It troubles me by how difficult it is to have an SSZ spec that makes everyone happy, also as its name — it should be simple.\r\n    2. Agreed with making SSZ spec has its own versions. 👍   More importantly, I'd appreciate it to have a stable version of SSZ v1.0 when phase 0 launch that all the future features are compatible with v1.0. That's also why formal verification is important at this point. 🙂\r\n    3. IMO our old friend protobuf (hello Prysm) 's document is pretty clear for the devs and users: https://developers.google.com/protocol-buffers/docs/encoding\r\n\r\n#### Documentation v.s. Formal verification spec\r\nPlease correct me if I'm wrong @franck44 @booleanfunction: Dafny has done the formal verification for `simple-serialize.md` but not the `merkle-proofs.md`?\r\n\r\nAnd @protolambda, I *think* the encoding part of https://github.com/protolambda/eth2.0-ssz is not too different from `simple-serialize.md`?\r\n\r\nAs I can see, the most tricky part now is how to polish and describe multi-proofs algorithm properly. Luckily we still have time to iterate it until phase 1. IMHO it's also an argument of why it's good to rewrite `merkle-proofs.md` to a more understandable way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645225305/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645285172",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645285172",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645285172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTI4NTE3Mg==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-17T10:14:01Z",
    "updated_at": "2020-06-17T10:16:27Z",
    "author_association": "NONE",
    "body": "Thanks for your proposals @protolambda and @hwwhww.\r\n\r\nI think the important thing is to focus on what a specification should look like rather than where it is located.\r\nAccording to other comments in other issues, I am not confident we all agree on what a specification is. I can give an example here of what it is and how it can be used, from a formal methods perspective.\r\n\r\n#### Specs vs implementation, and formal verification\r\nA simple example of a spec is the fibonacci function, say `fib`. The **specification** of **what** fib(n) should be is defined by:\r\n```\r\nfunction fib (n: nat) : nat {\r\n    if n == 0 then 0\r\n    else if n == 1 then 1\r\n    else fib (n - 1) + fib (n - 2)\r\n}\r\n```\r\nThis is the spec.It is a mathematical function, devoid of ambiguities.\r\n\r\nA recursive **implementation** how to compute `fib(n)` follows directly from the definition.\r\nHowever it is inefficient and we may prefer a small memory footprint and a faster computation. For instance:\r\n```\r\nmethod ComputeFib (n: nat) returns (b : nat) {\r\n    var i := 1;\r\n    var a := 0;\r\n    b := 1;\r\n    if (n == 0) { return 0; }\r\n     while (i < n) {\r\n        a, b := b, a + b;\r\n        i := i + 1;\r\n    }\r\n    return b;\r\n}\r\n``` \r\nThis is an **implementation**. It is not clear at all (at first sight) that this method computes `fib(n)`.\r\nThere may be many other implementations, for instance one that caches the first say 50 fib(n) in a pre-computed array:\r\n```\r\nmethod ComputeFib2 (n: nat) returns (b : nat) {\r\n    // an array caching the first 50 fib(n)\r\n    var knownFib = [0, 1, 1, 2, 3, 5 ...   ]\r\n    if (n < 50) { return knownFib[n]; }\r\n    var i := 1;\r\n    var a := 0;\r\n     b := 1;\r\n     while (i < n) {\r\n        a, b := b, a + b;\r\n        i := i + 1;\r\n    }\r\n   return b;\r\n}\r\n```\r\n\r\nNote that the specification does not prescribe how to compute the result, and the developers are free to propose a way to compute the result, as long as they are correct.\r\n\r\nAre the implementations correct?  yes if every time we compute `computeFib(n)` the result is equal to `fib(n)`, otherwise no. This is the **(formal) correctness criteria**. Note that hidden in the criteria is the fact that the algorithms terminate i.e.never end up in an infinite loop.\r\nIf an implementation computes the correct result **all the time** according to a spec, we say that it **satisfies the spec**.\r\n\r\nWhat is formal verification about? **Mathematically proving using mathematical logic and inference rules** that an implementation satisfies a specification. \r\nWhat is automated verification? Use an algorithm and possibly reasoning engines (e.g. SAT-solvers) to check (or assist you to check) that an implementation satisfies a specification.\r\n\r\nTo apply this to the Eth2 \"specs\", we had to somehow work as archeologist to figure out what a logical and functional specification is, in other words, what the intent was; and only then we can prove that an implementation (the Python-like current spec) satisfies a spec.\r\nWe have some good examples how to do that for the SSZ, Merkleisation, and recently for the Beacon Chain (`on_block`).\r\n[Our spec](https://github.com/PegaSysEng/eth2.0-dafny) is formal, we have also provided implementations (that we can execute), and proved that our implementations satisfy their specifications. We can also establish non-trivial properties, .e.g. `deserialise(serialise(x)) == x` for all `x` (no testing but a formal proof and 100% guarantee).\r\n\r\n#### About the readability by developers\r\n\r\nWhen I read that developers don't want to read formal specs, I am a bit surprised. \r\nThe non-formal specs are 1) imprecise, confusing and require a lot of work from the developers and 2) error-prone because different interpretations can arise, so they'll have to fix bugs.\r\n\r\nA good historical example is _undefined behaviours in C_. Every undefined behaviour (e.g. division by zero) can be implemented in the C compiler as you wish. This has been creating problems for years in software written in C. Two compilers can result in different behaviours for the same program.\r\n\r\nAn advantage of a formal and proved specification is that the developers can understand it, it is not ambiguous. It seems to me a much cleaner approach than Python code which I don't think was intended as a specification language (at least we do not use it for that purpose in the formal methods' world).\r\n\r\nThe current Eth2 specs are a good starting point, and it is certainly a good way to start describing all those clever ideas. But at some point, we may use the tool of the trades, languages, tools and techniques to improve the readability of the specs (and disambiguate them).\r\n\r\nWe have shown our specs in Dafny to many colleagues who are not expert in formal specification and verification and they understand them. The ability to annotate the specs with proofs is invaluable and provides a degree of reliability that cannot be obtained by testing.\r\n\r\n#### Moving forward.\r\n\r\nSo rather than writing yet another Python-spec that is ambiguous, not proved, why not fostering a formal version, with clear definitions, correctness proofs?\r\nAnd if this is a possible avenue, we have a candidate [here.](https://github.com/PegaSysEng/eth2.0-dafny)\r\n\r\nIt can easily accomodate future extensions like the merkle-proofs ( @booleanfunction is already investigating a formal treatment of the Merkle-proofs).\r\nIt contains specifications, implementations and proofs, all in the same language, Dafny.\r\nImplementations in other mainstream languages can be obtained by compiling Dafny into C#, Go and soon Java.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645285172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645354568",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645354568",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645354568,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTM1NDU2OA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-17T12:52:14Z",
    "updated_at": "2020-06-17T13:57:03Z",
    "author_association": "MEMBER",
    "body": "Wall of text, sorry for that, I tried to go into detail about my concerns with the various approaches, and why it makes sense to plan a move to the new SSZ draft.\r\n\r\n-----\r\n\r\nSo here are the weaknesses I see of each approach:\r\n\r\n**Current py-spec**\r\n- Python-isms sometimes leak into the spec language, I think for understanding of the spec this is not a big problem. But it does make it harder to port to another language. Pure functions would also help, but see later comments below about that.\r\n- Chance of ambiguity: most of the time there is none, but when python is mangled into regular text (like the merkleize function), edge cases are not tested and problems may arise.\r\n- Lack of explanation and guidance (not the same as simple comments). We tried to balance between python and regular markdown, went deep in the python direction to reduce ambiguity and have something that can both be tested and export tests. However, I recognize that there should be more explanation to help the reader. PR #1824 with comments is open, but I still think we should have more explanation/guidance in the spec eventually. This is easier when the spec-change churn is lower.\r\n- Python was never intended as specification language. It serves us well for various other things, but ultimately not the right language once spec is completely frozen.\r\n\r\n**Dafny**\r\n- Only Dafny programmers can contribute effectively, the Eth2 spec is not just about formalism, but also about a process of having a ton of teams communicate their feedback to a project that pushes  limits in various domains. We need accessibility in the spec while it still changes.\r\n- Although formally correct, it still has some of the drawbacks of the pyspec: Dafny on its own is not any more readable than Python (in my opinion), except that it can be shown to be correct (which is a different thing)\r\n- Correctness is important, but I think it fails to catch little things in-between the process. E.g. by changing a `pack` function to guarantee a single chunk output, the total resulting behavior may be correct, but it has nothing to do with `pack`. A spec should be built from ideas, described, then shown to be formally correct. Not the other way around.\r\n\r\n**More text, like new SSZ spec draft**\r\n- Possibly lots of ambiguity in the smaller details\r\n- Cannot be executed, tested, or proven without a model.\r\n\r\n----\r\n\r\nAnd here are the benefits I see with each approach:\r\n\r\n**Current py-spec**\r\n- Accessible to almost any programmer who is familiar with the domain. The python language subset that is used is kept minimal. No class definitions with methods, no inheritance, etc. Yes the pyspec can improve accessibility in other ways (more explanation), but that is being worked on.\r\n- Unit tests to guarantee some level of correctness, which at the same time can be exported to run in every client\r\n- Usable in lots of different tooling, interact with Eth2 without having to go through complexities of a full Eth2 client.\r\n\r\n**Dafny**\r\n- Formal verification, once the spec is completely defined in Dafny\r\n- No ambiguity whatsoever\r\n- Good candidate for a specification, where \"specification\" means that of the behavior that we try to describe, not the various meta-problems the current \"spec\" is trying to solve (accessibility, implementer feedback loop, client testing).\r\n\r\n**More text, like new SSZ spec draft**\r\n- The explanation and guidance implementers or readers in general need to make sense of the thing, and not just craft implementation that is correct, but does it in a way that makes sense in their context.\r\n- Converging on a shared open resource that does not get out of date as quickly. Existing efforts like [the annotated spec](https://benjaminion.xyz/eth2-annotated-spec/) and the [Phase0-for-humans write-up](https://notes.ethereum.org/@djrtwo/Bkn3zpwxB) are invaluable to onboarding implementers, but tend to get out of date quickly, since they are separate efforts.\r\n\r\n----\r\n\r\nOn pure functions and the spec<>implementation trade-off:\r\n\r\nI agree we could do a better job at separating the validation and mutation parts, possibly write every function as a pure function that returns a new modified copy of the state.\r\n\r\nHowever, as with some other parts currently in the spec, that gets somewhat ignored by client implementers. The way the spec is implemented defines the behavior well, but is not capable to reach mainnet scale state size and transition speed without modifications.\r\n\r\nNot to say we should not have more pure-functions, but what we should do is *listen to client implementers*, and keep the spec aware of the actual implementation. I have raised this issue before, and I'm not completely content with the current compromise, but I see the value of the current \"spec\" (or organization medium at this stage really) quickly diminish if we have to jump through extra hoops to compare and test a client implementation.\r\n\r\nThe spec is not where the network value will be, the clients are. The end-goal is not to show the spec satisfies correctness, the goal is that a client does, and the correct spec is a means to do that. If we only care about the spec, and stop right there, while making it more difficult for a client to verify against and keep in sync with the changes, we have not added any value.\r\n\r\n----\r\n\r\nAll in all I don't think we have to choose between these, we should aim to have these approaches complement each other.\r\n\r\n> The ability to annotate the specs with proofs is invaluable and provides a degree of reliability that cannot be obtained by testing.\r\n\r\nAgree, but annotation is a keyword for me here. If you would add the proofs to the other works, the result should be something that both provides guidance and explanation, can handle remaining churn of a spec, as well as a formal proof of the behavior, to resolve any possible ambiguity.\r\n\r\nAnd given that SSZ functionality has not changed for a long time, the pyspec benefits are getting less, and we can focus on the explanation-with-proof part, with little to no churn of functionality changes in the candidate/finished stages of the spec. Thus the proposal to move to the new SSZ draft, which solves half of the problem, but where Dafny could start to complement the spec to solve the remainder of the problem.\r\n\r\nFor the remainder of the eth2-spec it is currently more complicated, as:\r\n- Clients have grown closer to the python spec\r\n- Testing is in place and important, especially during spec changes.\r\n- We need some parts of the spec to improve still, and phase-1 is being actively developed.\r\nTo turn that all around is more difficult, involves talking with clients, and will be more of a long-term goal for now.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645354568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645659380",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645659380",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645659380,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTY1OTM4MA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-17T22:29:10Z",
    "updated_at": "2020-06-17T22:29:10Z",
    "author_association": "NONE",
    "body": "thanks @protolambda for your time and sharing your thoughts.\r\nI respectfully disagree with most of the conclusions and I think the reasoning you presented has some inconstancies.\r\n\r\nAmong them:\r\n\r\n> Python was never intended as specification language. It serves us well for various other things, but ultimately not the right language once spec is completely frozen.\r\n\r\nI don't understand this argument. If Python is not the right language for this purpose, how can we express the spec in this language first, freeze it, and then move on?\r\nI don't think arguing about each and every single point is a very productive usage of our time.\r\nFor now, I have presented my arguments in details, with the motivations, some scientific and logical argument, and I don't think I have anything to add.\r\n\r\nAll the best on your endeavour with the new SSZ spec. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645659380/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645685973",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645685973",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645685973,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTY4NTk3Mw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-17T23:53:58Z",
    "updated_at": "2020-06-17T23:53:58Z",
    "author_association": "MEMBER",
    "body": "@franck44 :\r\n\r\n> It seems to me a much cleaner approach than Python code which I don't think was intended as a specification language (at least we do not use it for that purpose in the formal methods' world).\r\n\r\nMe in my summary of all the weaknesses/benefits, trying to get the picture:\r\n\r\n> Python was never intended as specification language\r\n\r\n> I don't understand this argument.\r\n\r\nI am trying to see through yours, agree that Python is not optimal, and figure out a way forward. If you are reasoning the opposite, and do not want me to remove any python in favor of more explanation + future formal definitions, then make that clear.\r\n\r\n> how can we express the spec in this language first, freeze it, and then move on?\r\n\r\nWhat I'm trying to say is that ultimately, when there is no functional difference in expressing the idea that has been iterated on endlessly, then adopting something more formal should be smooth. And we can do so before it is 100% frozen. Once things are frozen I'd like it to be better, that does not mean we cannot iterate and work towards it before it fully being frozen with format and everything. If before phase 0 launches (and being 100% frozen) we can have at least a paper or other resource going in-depth through the spec, with proofs for the important parts, then I rather have that than the python for spec purposes.\r\nRight now though, it is not the spec language that is the bottleneck for phase 0 stabilization, but the feedback loop to get through a mix of usability and less theoretical parts of the spec (networking in particular). SSZ on the other hand has not changed much, and I'm making the argument that there is room to transition it away from this specs repository, include the in-depth explanation that is missing, with room for formal definitions to complement it where possible.\r\n\r\n> on your endeavour\r\n\r\nPlease, I am not looking for drama, but a concrete plan to improve on the status quo, and some freedom to try things as part of the transition planning. If you dislike the python for a spec, but also don't see value in being less python-centric, while making room for more formal definitions of the types, then I don't understand.\r\nIf anything, the SSZ part of the spec is the perfect experimentation ground to get the format right, without affecting ongoing spec work. The part of the spec itself is as stable as can be, many different formats may fit (I'm also thinking of using more encoding-specific languages to describe the format), and there has been a draft since forever that can be teared apart and polished before we actually finalize any decision.\r\nNow I wanted to give this a try, and instead we are arguing over the internet. If nobody is interested in a change of format, then I feel like I'm wasting my time here. And I will just go back to non-SSZ issues, and continue with the pyspec format that every once in a while gets a complaint about a python-ism, but at least ships spec improvements while we need them.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645685973/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645921915",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-645921915",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 645921915,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NTkyMTkxNQ==",
    "user": {
      "login": "zah",
      "id": 175462,
      "node_id": "MDQ6VXNlcjE3NTQ2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/175462?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zah",
      "html_url": "https://github.com/zah",
      "followers_url": "https://api.github.com/users/zah/followers",
      "following_url": "https://api.github.com/users/zah/following{/other_user}",
      "gists_url": "https://api.github.com/users/zah/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zah/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zah/subscriptions",
      "organizations_url": "https://api.github.com/users/zah/orgs",
      "repos_url": "https://api.github.com/users/zah/repos",
      "events_url": "https://api.github.com/users/zah/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zah/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-18T10:10:01Z",
    "updated_at": "2020-06-18T12:17:02Z",
    "author_association": "NONE",
    "body": "I would welcome an independently versioned SSZ spec with an isolated test suite. SSZ as a format has many useful properties and finding applications outside of the Ethereum spec is certainly possible.\r\n\r\nI do have one significant concern for SSZ though. It would be quite difficult to coordinate an upgrade of the SSZ spec once Ethereum consensus objects start to appear in third-party databases, so we should do everything in our power to perfect the SSZ spec before the 1.0 release. To this end, I'm creating the following issue where some possible improvements can be discussed:\r\n\r\nhttps://github.com/ethereum/eth2.0-specs/issues/1916\r\n\r\nOtherwise, if I have to contribute to the spec-format discussion, my opinion is that nothing prevents a correct spec to be described in prose, in an accessible language (e.g. Python) and in a formally verifiable language (e.g. Dafny) at the same time. \r\n\r\nIf the the spec is correct and unambiguous, all definitions will agree on every input and output. The new ssz-spec can even host all of these descriptions. @protolambda's argument is that the different descriptions have different strengths and weaknesses at different times in the development process of the spec (ideas start as prose, they may be developed and tested out in Python and later formally verified in Dafny). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/645921915/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/646450430",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-646450430",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 646450430,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NjQ1MDQzMA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-19T05:55:47Z",
    "updated_at": "2020-06-19T07:05:24Z",
    "author_association": "NONE",
    "body": "@protolambda @zah @CarlBeek \r\n\r\n> Otherwise, if I have to contribute to the spec-format discussion, my opinion is that nothing prevents a **correct spec to be described in prose**, in an accessible language (e.g. Python) and in a formally verifiable language (e.g. Dafny) at the same time.\r\n\r\nAmazing. Formal methods' people may run away and trade their ETH for Cardano when they read that :-) I hope jokes are allowed here ...\r\nAnother point is that we may argue based on scientific and informed argument rather than opinions.\r\n\r\nI would encourage you to have a look at [this](https://en.wikipedia.org/wiki/Formal_specification).\r\n\r\nI'll leave you to it (the new SSZ informal spec) but I really think it is not the best usage of our time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/646450430/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/646504081",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-646504081",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 646504081,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NjUwNDA4MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-19T08:11:54Z",
    "updated_at": "2020-06-19T08:11:54Z",
    "author_association": "MEMBER",
    "body": "You are skipping over the second part of the sentence where a language like Dafny is being considered. If we finally get to a point where we have multiple complete descriptions, I would always prefer the most formal one for correctness (especially if it has proven properties).\r\nBut in the process of getting there, and to help readers understand the intention and background while they read the python, or any future Dafny code, I think it's meaningful to have more than one format. Then link them together, and warn the user that prose or python may not be as good as the formal description. Naming a spec prose \"correct\" at any point is dangerous yes, but it's completely valid to aim for (even though by definition it can't be perfect).\r\n\r\nAnd what I want to avoid is a spec process where new features or improvements take a prohibitively high overhead to be developed. And preferably I want to allow as many readers as possible to understand *why* something was written like it is. I don't see a single-format spec achieve that. Maybe a brilliantly clear readable formal specification for a completely stable spec, but we're not there yet.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/646504081/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/647517499",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1901#issuecomment-647517499",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1901",
    "id": 647517499,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NzUxNzQ5OQ==",
    "user": {
      "login": "ericsson49",
      "id": 10426192,
      "node_id": "MDQ6VXNlcjEwNDI2MTky",
      "avatar_url": "https://avatars.githubusercontent.com/u/10426192?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ericsson49",
      "html_url": "https://github.com/ericsson49",
      "followers_url": "https://api.github.com/users/ericsson49/followers",
      "following_url": "https://api.github.com/users/ericsson49/following{/other_user}",
      "gists_url": "https://api.github.com/users/ericsson49/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ericsson49/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ericsson49/subscriptions",
      "organizations_url": "https://api.github.com/users/ericsson49/orgs",
      "repos_url": "https://api.github.com/users/ericsson49/repos",
      "events_url": "https://api.github.com/users/ericsson49/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ericsson49/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-22T13:25:06Z",
    "updated_at": "2020-06-22T13:25:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Otherwise, if I have to contribute to the spec-format discussion, my opinion is that nothing prevents a correct spec to be described in prose, in an accessible language (e.g. Python) and in a formally verifiable language (e.g. Dafny) at the same time.\r\n\r\nI believe (prose + spec in some accessible language + formal spec) approach is inevitable. However, I would add important refinements, which I believe are crucial, in the sense that they shape long term efforts.\r\n\r\n> If the the spec is correct and unambiguous, all definitions will agree on every input and output. \r\n\r\nThere is a fundamental difference between a prose and a formal spec. Somewhat simplifying, one can formally prove that an implementation agrees with the formal spec on every input and output (under certain assumptions).\r\nHowever, the situation with proving that prose agrees with formal spec or spec in an accessible language is much more difficult.\r\nFirst, I can see no way to give formal semantics to pose. So, actually it will be an audit, manual inspection. And human make mistakes.\r\nSecond, one can start adapting prose to make it more formal, but then we lose accessibility to regular programmers.\r\n\r\nSo, while in theory, human audit (manual 'proof checking') of agreement between prose + python spec + formal spec is possible in theory, I believe it is way too expensive.\r\n\r\nModern formal method suggest another approach - minimizing (or optimizing) Trusted Code Base. Basically, some parts have to be trusted and/or inspected manually, but we try to make this as small as reasonable. Else should be checked by computers.\r\n\r\nSo, I would formulate prose + python spec + formal spec approach in a somewhat different way:\r\n1. prose is (very) important as a way to communicate to humans, as it pointed out before\r\n\r\n2. but prose is super informal, so an **implementation** in some accessible language is (very) important too, as a more accurate way to communicate to programmers.\r\nActually, I would say prose + py-spec is the beacon chain spec for implementers (in my humble opinion, based on my experience of working with several beacon chain implementations).\r\n**Reference implementation** is perhaps a better term for the py-spec. I will use it hereinafter.\r\n\r\n3. Eventually, a formal beacon chain spec is expected to appear and I believe that several teams are working in that direction.\r\n\r\nOne can formally prove the formal spec agrees with the reference implementation on every input and output, though there are some important prerequisites for that. First, one need formal semantics for the language that the reference implementation is written in. The problem with Python is that it one of the worst languages in that respect.\r\nThough I don't think the situation is really bad. Basically, EF team writes the py-spec in a statically-typed subset of Python, with minor exceptions. Second, it uses a rather minimal set of Python features (as @protolambda has outlined before).\r\nI personally don't think it is a big problem to formalize the subset actually used by py-spec developers, especially assuming that EF is open to suggestions.\r\nI would rather say that a downside of the approach is that EF team may become more reluctant to port the py-spec to a language that is better suited to beacon chain spec development :). Though, as lots of efforts invested into the py-spec and tools (including tests) I believe it's a quite reasonable way.\r\nThere is a [formal tool](https://www.pm.inf.ethz.ch/research/nagini.html) for a subset of statically-typed Python 3, which is another reason why I believe py-spec can be kept as a reference implementation which can be formally verified against a formal spec, with some reasonable amount of efforts.\r\n\r\nAnother possible way in my opinion would be to translate the existing py-spec into a language more suitable for spec development at some point (I assume development of a reference implemenation, which continues to be the spec for implementers). By more suitable I mean a statically typed language presumably impure functional programming language (Rust, OCaml, Standard ML, F#, Scala, Kotlin, etc). As in my opinion, languages from the category fit best the current state of the spec. For example, manual translation of `phase0/spec.py` to Kotlin took about 7 hours (without further testing, cleanup, etc). I do not want to say this is the only possible way, rather my personal opinion, based on my experience of working with the pyspec and multiple programming languages.\r\nSome of the languages have pretty expressible type systems (e.g. Scala and OCaml allows use [GADT](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type)). So, many bugs can be caught by a compiler.\r\nWhile I believe the spec translated in the language can be pretty readable and quite close to the py-spec (for example, [phase0 in Kotlin](https://github.com/ericsson49/research/blob/master/beacon_kotlin_generated/src/phase0/spec.kt)), I believe it is true that it will be more difficult to contribute to the spec development.\r\n\r\nSo, it's probably not that bad variant, if one keeps prose + py-spec as a main beacon chain 'spec' for implementers. While formal method guys can make implementations along with necessary formalization of requirements, lemmas, invariants, post-condtions, pre-conditions, etc in their favorite language suitable for a formal work.\r\nThere will be an inevitable duplication of efforts, though as one can see, the duplication serves different purposed (e.g. communication to humans vs. 'communication' to computers).\r\nHowever, some efforts required to reduce duplication of efforts between formal method teams are necessary). I will elaborate on this somewhere else, as I have some ideas but they are not yet really mature.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/647517499/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
