{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2902",
  "id": 1246944377,
  "node_id": "I_kwDOCOoGbc5KUtx5",
  "number": 2902,
  "title": "Multiple fork transitions on same slot/epoch discard old `fork_version`s",
  "user": {
    "login": "tersec",
    "id": 11422416,
    "node_id": "MDQ6VXNlcjExNDIyNDE2",
    "avatar_url": "https://avatars.githubusercontent.com/u/11422416?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tersec",
    "html_url": "https://github.com/tersec",
    "followers_url": "https://api.github.com/users/tersec/followers",
    "following_url": "https://api.github.com/users/tersec/following{/other_user}",
    "gists_url": "https://api.github.com/users/tersec/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tersec/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tersec/subscriptions",
    "organizations_url": "https://api.github.com/users/tersec/orgs",
    "repos_url": "https://api.github.com/users/tersec/repos",
    "events_url": "https://api.github.com/users/tersec/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tersec/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2022-05-24T17:59:13Z",
  "updated_at": "2023-12-26T20:09:44Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The result is that certain messages across multiple-fork-transition-per-epoch boundaries might not be verifiable when received.\r\n\r\nhttps://github.com/ethereum/consensus-specs/blob/dev/specs/altair/fork.md#upgrading-the-state states that the fork of the upgraded state is\r\n```python\r\n        fork=Fork(\r\n            previous_version=pre.fork.current_version,\r\n            current_version=ALTAIR_FORK_VERSION,\r\n            epoch=epoch,\r\n        ),\r\n```\r\nhttps://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/fork.md#upgrading-the-state states that for Bellatrix, it's:\r\n```python\r\n        fork=Fork(\r\n            previous_version=pre.fork.current_version,\r\n            current_version=BELLATRIX_FORK_VERSION,\r\n            epoch=epoch,\r\n        ),\r\n```\r\nAnd for https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/fork.md#upgrading-the-state, it's\r\n```python\r\n        fork=Fork(\r\n            previous_version=pre.fork.current_version,\r\n            current_version=CAPELLA_FORK_VERSION,\r\n            epoch=epoch,\r\n        ),\r\n```\r\n\r\nThat is, even if there was no observable beacon chain-time during which an `ALTAIR_FORK_EPOCH == BELLATRIX_FORK_EPOCH` or `BELLATRIX_FORK_EPOCH == CAPELLA_FORK_EPOCH` network existed in that intermediate fork, it will still show up as `state.fork.previous_version` of the fork to which it was upgraded, not necessarily the chronologically previous fork in question (e.g., the fork which might appear in the beacon API fork schedule).\r\n\r\nThis means that signatures of attestations, for example, from a slot or two before an `ALTAIR_FORK_EPOCH == BELLATRIX_FORK_EPOCH` or `BELLATRIX_FORK_EPOCH == CAPELLA_FORK_EPOCH` transition and then included in slots (which is supposed to be valid for up to 32 slots) cannot be verified afterward by a conforming client using https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#get_domain as written:\r\n```python\r\ndef get_domain(state: BeaconState, domain_type: DomainType, epoch: Epoch=None) -> Domain:\r\n    ...\r\n    fork_version = state.fork.previous_version if epoch < state.fork.epoch else state.fork.current_version\r\n    ...\r\n```\r\nbecause `fork_version` cannot access an old enough version in `state` by then.\r\n\r\nWhen fork transitions only occur on successive epochs, the attestations which trigger this are old enough to be invalid (`ATTESTATION_PROPAGATION_SLOT_RANGE == 32`), but in either the `minimal` preset or immediately-after-each-other fork transitions, there can be glitches around these fork boundaries.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1138714977",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2902#issuecomment-1138714977",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902",
    "id": 1138714977,
    "node_id": "IC_kwDOCOoGbc5D32lh",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-26T15:41:15Z",
    "updated_at": "2022-05-26T15:41:15Z",
    "author_association": "MEMBER",
    "body": "this system was written w/ the expectation that forks would be far enough apart to not hit this issue and we only really see this type of thing in artificial settings like testnets etc.\r\n\r\nto fix it, we would need to store the full fork schedule in the beacon state and modify many of the helpers to account for finding the right fork version (or even rewrite the messages to accelerate search)\r\n\r\nI personally don't think it is worth the additional consensus complexity to support this type of thing although if there is some huge thing I'm missing I'm open to discussing further :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1138714977/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1139397584",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2902#issuecomment-1139397584",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2902",
    "id": 1139397584,
    "node_id": "IC_kwDOCOoGbc5D6dPQ",
    "user": {
      "login": "tersec",
      "id": 11422416,
      "node_id": "MDQ6VXNlcjExNDIyNDE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/11422416?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tersec",
      "html_url": "https://github.com/tersec",
      "followers_url": "https://api.github.com/users/tersec/followers",
      "following_url": "https://api.github.com/users/tersec/following{/other_user}",
      "gists_url": "https://api.github.com/users/tersec/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tersec/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tersec/subscriptions",
      "organizations_url": "https://api.github.com/users/tersec/orgs",
      "repos_url": "https://api.github.com/users/tersec/repos",
      "events_url": "https://api.github.com/users/tersec/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tersec/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-27T08:27:56Z",
    "updated_at": "2022-05-27T08:27:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "I agree that this is somewhat theoretical, insofar as real networks can be constructed not to have this problem. I also agree that fixing properly this might not be worth the technical complexity, for the reasons you outline.\r\n\r\nMy concerns are:\r\n- those artificial test cases come up disproportionately often, in, well, testing. People running Kurtosis, Hive and other short-lived local testnets for testing purposes would generally prefer not to waste time on forks they're not testing, so there's a temptation to trigger these edge cases. Either these should be well-defined or prohibited by the spec;\r\n- as written, the spec doesn't mention this, so it relies on a kind of folk knowledge creating potential consensus disagreements (e.g., above, which attestations to count towards a block's validity, per fork choice rules, where some CL clients might decide to strictly use information in `state.fork` and others might rely on their knowledge of the fork schedule as a whole, and the intuitively \"reasonable\" one might not line up with the technically-correct one, an unfortunate situation for a specification); and\r\n- the mismatch between minimal presets' 8 slots per epoch and `ATTESTATION_PROPAGATION_SLOT_RANGE == 32` regardless of preset results in this occurring even without the more obviously artificial cases where fork epochs equal each other, and at least seems to be an example of where there's supposed to be a not-actually-coincidental lineup of numeric constants that allows the protocol to work, but only under mainnet presets, which risks creating false-positives in terms of apparent bugs in the minimal preset that can't occur in mainnet and reduces the utility of the minimal preset.\r\n\r\nI'd prefer to specify something along the lines of, e.g., no two fork epochs can be equal if they're not 0. If people want to run clients or tests that way regardless, but then the outcome is not defined per spec. Already, one can reasonably assert that `CAPELLA_FORK_EPOCH >= BELLATRIX_FORK_EPOCH >= ALTAIR_FORK_EPOCH >= GENESIS_EPOCH`, but if `BELLATRIX_FORK_EPOCH == ALTAIR_FORK_EPOCH > 0` or `CAPELLA_FORK_EPOCH == BELLATRIX_FORK_EPOCH > ALTAIR_FORK_EPOCH > GENESIS_EPOCH` won't actually reliably work, without glitches, then the spec note this.\r\n\r\nThis way, Kurtosis, Hive, and similar systems could elide an arbitrary number of forks initially, because no ambiguity exists, but could not skip multiple forks afterwards.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1139397584/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
