{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1331",
  "id": 476301782,
  "node_id": "MDU6SXNzdWU0NzYzMDE3ODI=",
  "number": 1331,
  "title": "Choose signature aggregation dissemination strategy for mainnet",
  "user": {
    "login": "arnetheduck",
    "id": 1382986,
    "node_id": "MDQ6VXNlcjEzODI5ODY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/arnetheduck",
    "html_url": "https://github.com/arnetheduck",
    "followers_url": "https://api.github.com/users/arnetheduck/followers",
    "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
    "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
    "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
    "repos_url": "https://api.github.com/users/arnetheduck/repos",
    "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
    "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    },
    {
      "id": 1486925112,
      "node_id": "MDU6TGFiZWwxNDg2OTI1MTEy",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:attestation-management",
      "name": "scope:attestation-management",
      "color": "D9CD90",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2019-08-02T18:21:37Z",
  "updated_at": "2019-12-12T15:43:41Z",
  "closed_at": "2019-12-12T15:43:41Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "On mainnet, the expectation is that unaggregated attestations will be disseminated to a shard-specific topic, then aggregated and forwarded to a beacon-chain-wide topic so that block proposers can propose blocks without having to listen to all shard attestation channels.\r\n\r\nIn the networking spec, the aggregation strategy is left open, with a few notable alternatives having been discussed in the past (please add any that I missed):\r\n\r\n1) A random selection of validators are responsible for packaging attestations and forwarding to beacon topic - for example the first N in committee\r\n\r\n2) As 1) but random selection is a probability function instead where validators roll a local die, with increasing probability of doing the work as time passes and nobody has passed attestation - the function could weigh certain validators higher to prevent collisions.\r\n\r\n3) [Handel](https://github.com/ConsenSys/handel)",
  "closed_by": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/518306741",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1331#issuecomment-518306741",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331",
    "id": 518306741,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxODMwNjc0MQ==",
    "user": {
      "login": "ericsson49",
      "id": 10426192,
      "node_id": "MDQ6VXNlcjEwNDI2MTky",
      "avatar_url": "https://avatars.githubusercontent.com/u/10426192?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ericsson49",
      "html_url": "https://github.com/ericsson49",
      "followers_url": "https://api.github.com/users/ericsson49/followers",
      "following_url": "https://api.github.com/users/ericsson49/following{/other_user}",
      "gists_url": "https://api.github.com/users/ericsson49/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ericsson49/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ericsson49/subscriptions",
      "organizations_url": "https://api.github.com/users/ericsson49/orgs",
      "repos_url": "https://api.github.com/users/ericsson49/repos",
      "events_url": "https://api.github.com/users/ericsson49/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ericsson49/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-05T16:35:09Z",
    "updated_at": "2019-08-05T16:35:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "We have been investigating the attestation aggregation and dissemination problem for awhile.\r\nWe've found many issues and I am to write a more elaborate and comprehensive overview sometime. But here I try to outline main issues (not so) breifly.\r\n\r\n### Preliminary scalability considerations\r\n\r\nThere will be many participant nodes, even we consider only a part of the overall network active at a given slot, e.g. attesters, intermediate nodes (aggregators, transient nodes) and proposers (of next blocks). It's expected there will be around 300K attesters initially (10M ether). This means about 300 attesters per shard/committee. Given 16 committees per slot, it's around 5K nodes. In future, amount of validators may grow, so if there are 1M validators, there will be 1K attesters per committee, i.e. around 15-16K nodes with at least one attester (assuming 100K nodes overall, it will be a rare situation to have more than one attester on a node).\r\n\r\nThe same issue with shard subnets, i.e. it's expected that around 300 validators plus 200 standard nodes are listening to a shard. There are several shards in a subnet, so a subnet size is several times more than a committee size. There are up to 16 active subnets in a slot, so it's lots of nodes too.\r\n\r\nGiven all above, one should be very careful when designing an aggregation/dissemination protocol. We'll look at this in more details in the following sections.\r\n\r\n**NB** The estimates of 300 validators per shard and 200 standard nodes per shard are based on [p2p/issues/1](https://github.com/ethresearch/p2p/issues/1) and [p2p/issues/6](https://github.com/ethresearch/p2p/issues/6#issue-383052296).\r\n\r\n### Aggregation and result delivery are separate problems\r\n\r\nThe [network specifications](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/networking/p2p-interface.md#mainnet-3) states:\r\n> Unaggregated attestations are sent to the subnet topic. Aggregated attestations are sent to the beacon_attestation topic.\r\n\r\nThis implies only a subset of aggregators should send their results to proposers (beacon_attestation). Else it's too much traffic and it is probably simpler to send individual attestations directly (unless aggregators size is much smaller than attesters size).\r\nThis means the subset should be chosen somehow (e.g. by rolling a dice).\r\nThe subset size is a scalability vs BFT tradeoff, i.e. too small size means less BF tolerance (easier to block results propagation), while too big size means two many messages.\r\n\r\nThis is regardless of which aggregation protocol is employed. E.g. if Handel is employed to aggregate attestations, then the aggregating nodes still have to decides who sends the results.\r\n\r\n### Partial aggregates may be okay\r\n\r\nSince several aggregators have to send their results to proposers, it may be okay not to wait when aggregates become complete or near complete (include all or almost all individual attestations).\r\nIf several agregators are to send aggregates, then we can weaken the requirement so that union of the aggregates should cover the committee. In other words, a proposer can participate in an aggregation protocol on the final round, performing the final merge.\r\n\r\nGiven network or byzantine failures, this is a highly desirable property, since some attestations may be lost for various reasons. This allows for aggregation protocol to stop before a final solution is obtained (which may be too late). However, it raises additional problems (see below).\r\n\r\n### Coordinated vs random aggregation\r\n\r\nLet's look at the aggregation part in more details. There are three general kinds of protocols to aggregate data in p2p-networks:\r\n* Tree-like protocols. It's very efficient communication-wise, bit not tolerant to failures, specially byzantine ones. \r\n* Gossip-like protocols. Participants send partial aggregates to several (randomly) selected peers, to avoid traffic amplification. After some rounds, most participants should have received most individual items. It may be too long to wait when all nodes receive all items, especially in a byzantine context.\r\n* Hybrid protocols. Try to aggregate data in a coordinated manner (via tree-like structures), but handling network/byzantine failures (falling to some kind of a gossip protocol). Handel is a good example of the approach.\r\n\r\nWhen node/link failures cannot be ignored, we have only two options, either a gossip or a hybrid approach. A gossip approach has a significant drawback: since partial aggregates are sent in a random way, at some point, it will be difficult or impossible to merge two partial aggregations, because the sets of their attesters are overlapping, i.e. there is one or more attesters, whose attestations are included in both partial aggregates. The problem is caused by the [Attestation](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#attestation) class, which uses bitifields to account for attesters.\r\n\r\nA coordinated approach is required to avoid this, so that nodes should communicate in a way that allows for non-overlapping partial aggregates. Organizing nodes in a tree is an ideal choice in a fault-free setup, but in byzantine context, rather a forest of trees should be constructed to mask failures and message omissions.\r\nHandel follows this way. However, it imposes some overhead. E.g. Handel requires pairwise connections between nodes, which is not compatible with p2p-graph approach, without modifications (e.g. messages will pass through transient nodes, which may happen to be byzantine).\r\n\r\n### Medium-sized partial aggregation\r\n\r\nGossip-like protocols are attractive because they require less coordination and well matched to p2p communication graph. Also it's beneficial (and may be even required if slot duration is about to elapse) to stop the aggregation stage before a final result is reached.\r\nSo, if the partial aggregate merge problem is resolved, then gossip protocols is a very attractive solution.\r\nI.e. aggregators send their peers partial aggregates for several rounds, and when a aggregate become big enough (around sqrt(m), where m is the committee size) or before the end of the slot, an aggregator roll a dice and send its partial aggregate to proposers. It also may roll a dice several times.\r\n\r\nActually, the beacon block structure allows storing multiple partial attestations of a committee. The main obstacle is the 128 limit on total amount of Attestations. More importantly, storing too many attestation will bloat a beacon block, which can be a problem to scalability. However, we think that the problem can be resolved with proper block structure and/or smart compression. See [here](https://hackmd.io/ZCOiGwjLRy6il6yuAnF05w) for details.\r\n\r\n### Handel is a partial solution\r\n\r\nHandel is an interesting protocol, however as it follows from the above notes, it's not a complete solution.\r\n\r\nFirst, Handel requires pairwise connections between nodes, which doesn't fit well p2p-graph, i.e. instead of direct connections, messages will pass through transient nodes, which means: a) additional delays, b) opportunities for byzantine attacks. The last is not Handel specific, though.\r\n\r\nSecond, after Handel is complete or partially complete, the results should be sent somehow to proposers in a reliable fashion - the problem common to all attestation aggregation-dissemination strategies (discussed before).\r\n\r\nThird, Handel paper says that Handel is able to aggregate 4K attestations under 1 second in case of UDP setup. However, when using QUIC, Handel developers [report](https://github.com/ConsenSys/handel/issues/126) it's three times slower. In case of p2p-graph, when a pairwise connection between nodes have to be implemented with sending a message via transient nodes, it means an additional latency. So, when implemented in the context of Ethereum 2.0 requirements, it's not clear whether it's performant enough or not.\r\n\r\nOverall, if follow a coordinated route, Handel seems to be a very good starting point, which should be augmented to resolve the above issues.\r\n\r\n### Topic-based Publish-Subscribe pattern seems to be a poor match\r\n\r\nAs quoted before, the network specifications states:\r\n> Unaggregated attestations are sent to the subnet topic. Aggregated attestations are sent to the beacon_attestation topic.\r\n\r\nHowever, fully delivering of individual attestations to subnet topic is very resource consuming. Earlier, we estimated that the are 16 committees of 300-1000 senders and each should send to a subnet topic of a size which is several times more, i.e. around thousands subscribers.\r\n\r\nActually, it's excessive since individual attestations have to be delivered to only some of aggregators. The final aggregation is obtained via several rounds of aggregation protocol. If all individual attestations are propagated to all members of a shard subnet, then there is no need for an aggregation protocol at all, since they can be sent to proposers directly, with less efforts (assuming amount of proposers in beacon_attestation is much less than amount of subscribers to a shard subnet topic).\r\n\r\nAn aggregation protocol also doesn't match topic-based publish subscribe pattern, since aggregators send partial aggregates which are growing with each round, so there are different messages.\r\n\r\nThe final stage, where aggregators send their results to proposers, looks a good match on a high level. However, considering implementation details, the subscribers to beacon_attestation topic are constantly changing. So, this is a serious problem with topic membership management, which discussed in the following section\r\n\r\n### Overlay management and Topic discovery\r\n\r\nNew proposers should subscribe to the topic beforehand to be able to receive results. And later unsubscribe (to keep topic subscribers small). The appropriate information about topic membership changes should be propagated to aggregator nodes, so that they know whom to send their results.\r\n\r\nAs the specification assumes that beacon_attestation are mostly proposers, we assume there won't be many subscribers -- around tens of them. From scalabilty point of view, ideally there should be one subscriber each slot -- the proposer of the next slot. However, it's safer to assume there will be proposers of some slots before and after the current one.\r\n\r\nIf the topic membership is small and changes rapidly, then it will be a problem for gossipsub to maintain the mesh for the topic. Basically, we should assume, a gossipsub router at a node should request beforehand Topic Discovery service for an information of latest topic changes. Moreover, for a validator which is assigned to be an attester for a particular slot, it's most important that the topic membership information includes the entry of the next slot proposer.\r\nWhich means the next slot proposer should beforehand advertise itself with a Topic Discovery as the topic member. Since it's a lengthy process and proposers are assigned in a preceding epoch before, it becomes a serious problem. Basically, the next slot proposer and the current slot attesters have from 64 to 128 slots (6 seconds), i.e. about 3-6 minutes to exchange with the necessary information.\r\n\r\n### Topic Discovery and BFT\r\n\r\nAnother critical problem is byzantine fault tolerance properties of Topic Discovery service. An adversary can advertise wrong records in Topic Discovery service or run Topic Discovery service instance which provides wrong records to honest nodes about who are the members of the beacon_attestation topic. The honest nodes will send their attestations in a wrong direction.\r\nIt's not clear how BF tolerant Topic Dsicovery is, but an excerpt from [here](https://github.com/ethereum/devp2p/blob/master/discv5/discv5-rationale.md#amplifying-network-traffic-by-returning-fake-registrations) suggests it's not\r\n>An attacker might wish to direct discovery traffic to a chosen address by returning records pointing to that address.\r\n>\r\n> TBD: this is not solved.\r\n\r\nBasically, Topic Discovery is based around Kademlia DHT and p2p DHT are known to have problems with BFT. The BFT in the context of p2p and DHT is also discussed [here](https://www.researchgate.net/publication/228842563_Byzantine_Fault_Tolerance_of_Inverse_de_Bruijn_Overlay_Networks_for_Secure_P2P_Routing).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/518306741/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523999517",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1331#issuecomment-523999517",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331",
    "id": 523999517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzk5OTUxNw==",
    "user": {
      "login": "nkeywal",
      "id": 1179343,
      "node_id": "MDQ6VXNlcjExNzkzNDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1179343?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nkeywal",
      "html_url": "https://github.com/nkeywal",
      "followers_url": "https://api.github.com/users/nkeywal/followers",
      "following_url": "https://api.github.com/users/nkeywal/following{/other_user}",
      "gists_url": "https://api.github.com/users/nkeywal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nkeywal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nkeywal/subscriptions",
      "organizations_url": "https://api.github.com/users/nkeywal/orgs",
      "repos_url": "https://api.github.com/users/nkeywal/repos",
      "events_url": "https://api.github.com/users/nkeywal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nkeywal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-22T17:25:17Z",
    "updated_at": "2019-08-22T17:55:35Z",
    "author_association": "NONE",
    "body": "Good stuff :-)\r\n\r\nOn Handel:\r\n> First, Handel requires pairwise connections between nodes\r\nYes. It's a drawback (and a tradeoff). \r\n\r\n> the results should be sent somehow to proposers\r\nSo it could depend, but I would expect the proposers to participate in the aggregation. If not, yes, you need to publish the final aggregation on a p2p network, adding some extra costs & time.\r\n\r\n> However, when using QUIC, Handel developers report it's three times slower.\r\nI asked to @bkolad: the test was done when the 0-RTT handshake was not available (I don't know if it's available now) and we were creating a new session (eg. handshake) for each message. In real life we should be able to cache all the sessions and the cache should be reused between aggregation and the 0-RTT handshake should be there... But it's as well possible to mix protocols (eg. udp/quic/tor-like-hopefully-a-day).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523999517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/565061632",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1331#issuecomment-565061632",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1331",
    "id": 565061632,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NTA2MTYzMg==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-12T15:43:41Z",
    "updated_at": "2019-12-12T15:43:41Z",
    "author_association": "MEMBER",
    "body": "Intention is to use the simple approach currently in the network/validator specs. Will revisit this if run into issues on testnets",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/565061632/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
