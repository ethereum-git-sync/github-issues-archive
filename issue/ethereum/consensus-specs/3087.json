{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3087",
  "id": 1440302777,
  "node_id": "I_kwDOCOoGbc5V2Ua5",
  "number": 3087,
  "title": "EIP-4844: Remove BlobsSidecarsByRange Req-Resp",
  "user": {
    "login": "Inphi",
    "id": 3516807,
    "node_id": "MDQ6VXNlcjM1MTY4MDc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3516807?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Inphi",
    "html_url": "https://github.com/Inphi",
    "followers_url": "https://api.github.com/users/Inphi/followers",
    "following_url": "https://api.github.com/users/Inphi/following{/other_user}",
    "gists_url": "https://api.github.com/users/Inphi/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Inphi/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Inphi/subscriptions",
    "organizations_url": "https://api.github.com/users/Inphi/orgs",
    "repos_url": "https://api.github.com/users/Inphi/repos",
    "events_url": "https://api.github.com/users/Inphi/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Inphi/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4163819084,
      "node_id": "LA_kwDOCOoGbc74LtZM",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/eip-4844",
      "name": "eip-4844",
      "color": "A28C37",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 15,
  "created_at": "2022-11-08T14:23:45Z",
  "updated_at": "2022-12-16T07:34:15Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The original usecase for `BlobsSidecarByRange` RPC was to allow nodes sync blobs that missed the initial broadcast. We no longer need to do this with Coupled Beacon Blocks. Historical sync can continue to sync (eip-4844) blocks as it works today because they now contain blob sidecars.\r\n\r\nThere is one other use for `BlobsSidecarByRange` which is so light clients can retrieve blobs sidecars only that are older than `MIN_EPOCHS_FOR_BLOBS_SIDECARS_REQUESTS`. This usecase is pretty niche though and such clients can always use the blocks RPC, even if that means potentially receiving dup blocks. Hence, I propose that we remove the RPC altogether and keep the spec minimal.\r\n\r\n@terencechain",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307306621",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307306621",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307306621,
    "node_id": "IC_kwDOCOoGbc5N6-p9",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T14:26:55Z",
    "updated_at": "2022-11-08T14:26:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "We still need a way to historical sync or backtrack sync \"missing\" blobs with a weak subjectivity state. Are you implying that we add a `BeaconBlockAndBlobsSidecarByRange` RPC?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307306621/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307379284",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307379284",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307379284,
    "node_id": "IC_kwDOCOoGbc5N7QZU",
    "user": {
      "login": "tbenr",
      "id": 15999009,
      "node_id": "MDQ6VXNlcjE1OTk5MDA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/15999009?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tbenr",
      "html_url": "https://github.com/tbenr",
      "followers_url": "https://api.github.com/users/tbenr/followers",
      "following_url": "https://api.github.com/users/tbenr/following{/other_user}",
      "gists_url": "https://api.github.com/users/tbenr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tbenr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tbenr/subscriptions",
      "organizations_url": "https://api.github.com/users/tbenr/orgs",
      "repos_url": "https://api.github.com/users/tbenr/repos",
      "events_url": "https://api.github.com/users/tbenr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tbenr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T15:14:20Z",
    "updated_at": "2022-11-08T15:14:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "We could make `BeaconBlockAndBlobsSidecarByRange` to return a ZERO BlobsSidecar if range includes slots prior to `MIN_EPOCHS_FOR_BLOBS_SIDECARS_REQUESTS`,  Instead of failing the request and retry with `BeaconBlocksByRange`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307379284/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307384679",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307384679",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307384679,
    "node_id": "IC_kwDOCOoGbc5N7Rtn",
    "user": {
      "login": "Inphi",
      "id": 3516807,
      "node_id": "MDQ6VXNlcjM1MTY4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3516807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Inphi",
      "html_url": "https://github.com/Inphi",
      "followers_url": "https://api.github.com/users/Inphi/followers",
      "following_url": "https://api.github.com/users/Inphi/following{/other_user}",
      "gists_url": "https://api.github.com/users/Inphi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Inphi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Inphi/subscriptions",
      "organizations_url": "https://api.github.com/users/Inphi/orgs",
      "repos_url": "https://api.github.com/users/Inphi/repos",
      "events_url": "https://api.github.com/users/Inphi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Inphi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T15:17:59Z",
    "updated_at": "2022-11-08T15:17:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ah I see. I misread the spec, It was my understanding that the `BeaconBlocksByRange` RPC would return coupled beacon block after the upgrade.\r\nBut also we should still consider removing the RPC and like you say add a new RPC that returns both.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307384679/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307386109",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307386109",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307386109,
    "node_id": "IC_kwDOCOoGbc5N7SD9",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T15:18:56Z",
    "updated_at": "2022-11-08T15:20:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "> We could make `BeaconBlockAndBlobsSidecarByRange` to return a ZERO BlobsSidecar if range includes slots prior to `MIN_EPOCHS_FOR_BLOBS_SIDECARS_REQUESTS`, Instead of failing the request and retry with `BeaconBlocksByRange`.\r\n\r\nWe've separately been coming to a similar conclusion in lighthouse.\r\n\r\nI think we were initially planning to have a separate `BeaconBlockByRange` and `BlobsSidecarByRange` request. But @divagant-martian made the point that if we only ever want a block by itself or a block and block together, we should structure our requests to reflect that, both a `BeaconBlockByRange` and a `BeaconBlockAndBlobsSidecarByRange`. One for use within the range we're required to have blobs and one for use outside of that range.  Making a `BlobsSidecarByRange` doesn't really make any sense if there are no scenarios where we want just a blob. \r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307386109/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307422850",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307422850",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307422850,
    "node_id": "IC_kwDOCOoGbc5N7bCC",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T15:43:35Z",
    "updated_at": "2022-11-08T15:43:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "@realbigsean I agree. I think we should just have `BeaconBlockByRange` and `BeaconBlockAndBlobsSidecarByRange`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307422850/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307436859",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307436859",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307436859,
    "node_id": "IC_kwDOCOoGbc5N7ec7",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T15:53:39Z",
    "updated_at": "2022-11-08T15:53:39Z",
    "author_association": "MEMBER",
    "body": "We definitely need some form of historical sync req-resp method. The `BlobsSidecarByRange` would allow for blobs to be fetched in parallel to the beacon-blocks. Fusing the methods together `BeaconBlockAndBlobsSidecarByRange` would simplify the sync, but limit optimizations.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307436859/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307631204",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1307631204",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1307631204,
    "node_id": "IC_kwDOCOoGbc5N8N5k",
    "user": {
      "login": "tbenr",
      "id": 15999009,
      "node_id": "MDQ6VXNlcjE1OTk5MDA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/15999009?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tbenr",
      "html_url": "https://github.com/tbenr",
      "followers_url": "https://api.github.com/users/tbenr/followers",
      "following_url": "https://api.github.com/users/tbenr/following{/other_user}",
      "gists_url": "https://api.github.com/users/tbenr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tbenr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tbenr/subscriptions",
      "organizations_url": "https://api.github.com/users/tbenr/orgs",
      "repos_url": "https://api.github.com/users/tbenr/repos",
      "events_url": "https://api.github.com/users/tbenr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tbenr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-08T18:08:00Z",
    "updated_at": "2022-11-08T18:08:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "The problem with having only `BeaconBlockAndBlobsSidecarByRange` is the (edge?) case in which the peer have early pruned the Blobs and responds with block and ZERO BlobsSidecar. So you fall in the decoupled case in which you have to fill up the blobs for known blocks. Retrieving them  using `BlobsSidecarByRange` opens to potential block-blobs inconsistency so the best way to do that would be by `BlobsSidecarByRoot` (but we might be outside the \"recent chain\" to which we want to limit the usage of the byRoot option, as mentioned in the today's call).\r\n\r\nA naive option would be to discard the `BeaconBlockAndBlobsSidecarByRange` responses containing ZERO Blobs where you actually expect blobs, and redoing `BeaconBlockAndBlobsSidecarByRange` towards other peers. This is a meaningful waste of bandwidth only when there are many dishonest validators.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1307631204/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1308948604",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1308948604",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1308948604,
    "node_id": "IC_kwDOCOoGbc5OBPh8",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-09T15:37:00Z",
    "updated_at": "2022-11-09T15:37:00Z",
    "author_association": "MEMBER",
    "body": "I think coupling on historic sync adds more technical debt than keeping them together due to having to rework something that is tried and true (block sync) into something that looks very different than what we expect the future to hold\r\n\r\nReasons being:\r\n1. disrupting block (no blobs) sync in a manner that does not look like what we expect the future to hold\r\n2. having to deal with the edge case of alternate pruning depth between Blocks and Blobs as native to block sync\r\n3. likely changing block sync range strategies due to the much larger blobs attached to them (e.g. getting 100 at a time might not be tenable to request to a peer)\r\n\r\nThat said, the protocol technical debt is not huge. I suspect the debt to manifest more in the engineering so will step down if the general engineering consensus is counter to my view.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1308948604/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1310388364",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1310388364",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1310388364,
    "node_id": "IC_kwDOCOoGbc5OGvCM",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-10T14:37:27Z",
    "updated_at": "2022-11-10T14:37:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't think it's possible to leave blob syncing untouched within the blob prune depth because block validation is now dependent on blobs, so we have to fit blobs into the picture somehow. With decoupling, we're introducing scenarios where a blob could show up before or after a blob, so you'd have to cache blocks and blobs and probably figure out a way to re-request either if either doesn't show up. And then you have to figure out how to attribute faults if any.\r\n\r\nMore generally, decoupling introduces asynchrony (which could be good, but is just more complicated to engineer and changes block sync code more) and the possibility of inconsistency. We could address these two things in a decoupled approach by:\r\n\r\n1. always making both requests at once\r\n2. always making both requests to the same peer\r\n3. if one fails, both fail\r\n\r\nBut this starts to look very much like the coupled approach, and this logic would be enabled/disabled at different prune depths, and also may mean we may require different sync strategies at different depths, so has similar drawbacks to coupling.  The main difference would be two parallel streams of data vs one. And this *could* end up being worth it for the sake of more efficient download but we haven't seen download being the bottleneck elsewhere in sync. \r\n\r\nGenerally what I think implementation would look like in Lighthouse - \r\n\r\nCoupling:\r\n- prior to the blob prune depth it remains the same\r\n- after the prune depth, we use a new request that uses the same processing logic, but might use a different batch size  (we make existing processing generic)\r\n\r\nDecoupling:\r\n- prior to the blob prune depth it remains the same\r\n- after, we add a new request and figure out how to merge it with with the existing block sync\r\n  - Either via caching, and figuring out re-processing and fault attribution logic (this would require the most tinkering in existing block sync, perhaps making a new implementation so as to not disturb what we have)\r\n  - or coupling requests tightly, and potentially adjusting batch size \r\n\r\nSo either way, the new logic looks like an appendage that we can later remove, and we will have to keep existing sync - the second to me is a cleaner separation, so unless we find the gain from parallel download to be meaningful for coupling would still be my vote.\r\n\r\nI'm curious what the Prysm implementation looks like currently? Maybe @terencechain or @Inphi know? And also interested to hear what other client teams think about what their implementation might look like",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1310388364/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1310412239",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1310412239",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1310412239,
    "node_id": "IC_kwDOCOoGbc5OG03P",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-10T14:53:10Z",
    "updated_at": "2022-11-10T14:53:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "Also I don't think prune depth edge cases will be a problem, so long as in implementation nodes serve blobs with some margin past the prune depth ( maybe a couple of epochs, maybe a couple of hours). And only request at the prune depth. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1310412239/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1311116535",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1311116535",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1311116535,
    "node_id": "IC_kwDOCOoGbc5OJgz3",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-11T01:26:54Z",
    "updated_at": "2022-11-11T01:26:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "As @realbigsean has said, I think for Lighthouse, the coupling approach would be by far the least engineering effort solution.\r\n\r\nWe could leave our sync strategies almost entirely untouched and generalise our processing of the blocks and blobs.\r\n\r\nIf we uniformly agree of the pruning depth amongst nodes and consider nodes that prune early malicious, our sync code could also find and score these peers appropriately. It would be harder to do in the uncoupled case.\r\n\r\nWe do lose some potential optimisation in parallel downloading  of blobs, but our sync automatically load balances across peers and it is adjustable such that instead of downloading many blocks from one peer, we can download fewer blocks and blobs from each peer, in effect still parallelising the downloading, just in block + blob bundles. As Sean pointed out, currently the bottleneck is not the bandwidth usually, its processing. This may change with blobs, for lower bandwidth peers, but at the moment our network is quite idle in sync waiting for blocks to be processed. \r\n\r\nThis may not be the case for other client teams who may prefer the decoupled case. Just speaking specifically for lighthouse. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1311116535/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1311990284",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1311990284",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1311990284,
    "node_id": "IC_kwDOCOoGbc5OM2IM",
    "user": {
      "login": "tbenr",
      "id": 15999009,
      "node_id": "MDQ6VXNlcjE1OTk5MDA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/15999009?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tbenr",
      "html_url": "https://github.com/tbenr",
      "followers_url": "https://api.github.com/users/tbenr/followers",
      "following_url": "https://api.github.com/users/tbenr/following{/other_user}",
      "gists_url": "https://api.github.com/users/tbenr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tbenr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tbenr/subscriptions",
      "organizations_url": "https://api.github.com/users/tbenr/orgs",
      "repos_url": "https://api.github.com/users/tbenr/repos",
      "events_url": "https://api.github.com/users/tbenr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tbenr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-11T17:48:05Z",
    "updated_at": "2022-11-11T17:48:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "I agree that the simplest approach is to have the coupled version, which would lead to a simpler implementation. We don't need to have any concept of \"optimistic\" head wrt blobs. Any failure has a clear scoring attribution.\r\n\r\nI still think that at the boundary, when we expect to start getting blobs, there is an edge case to handle. I'm thinking about being permissive when requesting blobs for the farmost epoch if we are close to the epoch transition that would allow that epoch to be pruned (this might turn out to not request blobs for that epoch at all, since by the time we reach the tip of the chain those blobs will be probably already prunable).\r\n\r\nIf we decide for the decoupled version, I think the first implementation would try to couple in the syncing process by asking a batch of blocks and blobs in parallel to the same peer, than make some simple consistency checks and then try to import the batch. If fails we consider it invalid downscoring the peer and will try again with another peer. \r\n\r\nA more advanced approach would be to keep block sync as it is, let it import optimistically and then have a separate blobs sidecar fetcher that handle the download an kzg verification independently and mark nodes as valid. Verification failure handling and retries would be tricky here.\r\n\r\nI'm curious to hear from Prysm too. Are they trying to couple early or do they implemented an optimistic approach?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1311990284/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1320310127",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1320310127",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1320310127,
    "node_id": "IC_kwDOCOoGbc5OslVv",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-18T17:20:18Z",
    "updated_at": "2022-11-18T17:20:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "Apology for the delayed response. Prysm will aim to \"couple\" even if the protocol specification has them decoupled. Under decoupling, Prysm will need to figure out how to merge block and blob sync under one process, and this can be done either by advanced caching or greatly coupling the request next to each other. This is not ideal due to potential differences in batch sizes between block and blob requests and peering scoring attributes.\r\n \r\nDecoupling is more complicated to implement within Prysm code base due to asynchrony and inconsistency. It's also unclear how much optimization there is by decoupling them and if we are falling down a premature optimization path ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1320310127/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1320399024",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1320399024",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1320399024,
    "node_id": "IC_kwDOCOoGbc5Os7Cw",
    "user": {
      "login": "dapplion",
      "id": 35266934,
      "node_id": "MDQ6VXNlcjM1MjY2OTM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dapplion",
      "html_url": "https://github.com/dapplion",
      "followers_url": "https://api.github.com/users/dapplion/followers",
      "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
      "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
      "organizations_url": "https://api.github.com/users/dapplion/orgs",
      "repos_url": "https://api.github.com/users/dapplion/repos",
      "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dapplion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-18T18:42:49Z",
    "updated_at": "2022-11-18T18:42:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "In Lodestar implementation sync and block processing is agnostic on dealing with either blocks or block+blobs. So the byRange call is coupled effectively during range sync. I won't mind coupling these methods but don't see the problem with leaving them un-coupled either. Implementations can choose to logically couple them but the reverse is not possible.\r\n- Given that the returned block's slot is known in advance coupling shouldn't experience the issue from https://github.com/ethereum/consensus-specs/issues/3113",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1320399024/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1354331656",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3087#issuecomment-1354331656",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3087",
    "id": 1354331656,
    "node_id": "IC_kwDOCOoGbc5QuXYI",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-16T07:34:15Z",
    "updated_at": "2022-12-16T07:34:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'll leave the same comment as in https://github.com/ethereum/consensus-specs/pull/3139#issuecomment-1354327256 - I believe that while it's simpler to implement coupling right now, this is a case of simplicity becoming simplistic instead - with growing data amounts, we will want to optimize data access and coupling introduces an artificial barrier.\r\n\r\nFor the long term, I believe uncoupled-everything has more merit, even if makes the initial implementation a bit more tricky.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1354331656/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
