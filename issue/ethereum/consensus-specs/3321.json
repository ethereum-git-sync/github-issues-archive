{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3321",
  "id": 1664909784,
  "node_id": "I_kwDOCOoGbc5jPIHY",
  "number": 3321,
  "title": "Sync committee slashing",
  "user": {
    "login": "etan-status",
    "id": 89844309,
    "node_id": "MDQ6VXNlcjg5ODQ0MzA5",
    "avatar_url": "https://avatars.githubusercontent.com/u/89844309?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/etan-status",
    "html_url": "https://github.com/etan-status",
    "followers_url": "https://api.github.com/users/etan-status/followers",
    "following_url": "https://api.github.com/users/etan-status/following{/other_user}",
    "gists_url": "https://api.github.com/users/etan-status/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/etan-status/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/etan-status/subscriptions",
    "organizations_url": "https://api.github.com/users/etan-status/orgs",
    "repos_url": "https://api.github.com/users/etan-status/repos",
    "events_url": "https://api.github.com/users/etan-status/events{/privacy}",
    "received_events_url": "https://api.github.com/users/etan-status/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2023-04-12T16:52:22Z",
  "updated_at": "2023-04-12T23:56:06Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum's light client sync protocol to assume a non-canonical finalized header, and to potentially take over the sync authority for future `SyncCommitteePeriod`. By signing a malicious beacon block root, a malicious (but valid!) `LightClientUpdate` message can be formed and subsequently used to, for example, exploit a trust-minimized bridge contract based on the light client sync protocol.\r\n\r\nWhile honest nodes only propagate canonical `LightClientUpdate` messages, there is currently no disincentive against signing malicious beacon block roots. In fact, because there is no downside, it could even be considered a form of MEV to exploit bridges on top of performing all honest validator duties. See also: https://prestwich.substack.com/p/altair\r\n\r\nNote that even if the entire sync committee could be fully slashed all the way down to 0 ETH, that this would still cap the security level to `SYNC_COMMITTEE_SIZE * MAX_EFFECTIVE_BALANCE` = `512 * 32 ETH` = `16384 ETH` ~= `32 million USD @ 2k USD / ETH`. Bridges that secure more funds than this security level may combine the light client sync protocol with other established methods such as a multisig, or may want to require posting additional collateral to be eligible for updating the bridge. These methods are out of scope for this issue.\r\n\r\n# Goals\r\n\r\n## Slashing definition\r\n\r\nAn additional type of slashing should be introduced to deter against signing non-canonical beacon block roots as a sync committee member. As is the case with `ProposerSlashing` and `AttesterSlashing`, only malicious behaviour should be slashable. This includes simultaneous contradictory participation across multiple chain branches, but a validator that is simply tricked into syncing to an incorrect checkpoint should not be slashable even though it is participating on a non-canonical chain. Note that a slashing must be verifiable even without access to history, e.g., by a checkpoint synced beacon node.\r\n\r\n## Reference implementation\r\n\r\nPython + Pytests + reference implementation for one of the consensus clients.\r\n\r\n## Slashing protection\r\n\r\nThe slashing protection database format should be extended to guarantee that validators can never be slashed regardless of chain syncing activity. For example, if a node operator deletes their chain data and syncs to a different branch, that should never be slashable as long as the slashing protection database is in place. The slashing protection interchange format needs to be updated accordingly.\r\n\r\n## Web3signer / Validator client APIs\r\n\r\nAPIs interacting with remote validators need to be extended to pass along information relevant to slashing protection. For example, a signer may need to know what the finalized checkpoint is at the signed block's post-state, before performing the signature operation.\r\n\r\n## Beacon APIs\r\n\r\nAn API to submit / observe sync committee slashing evidence needs to be added, to be used by slashers for getting evidence included into blocks. Likewise, a libp2p mesh is necessary to allow exchanging slashing evidence.\r\n\r\n## Slasher\r\n\r\nA slasher component should be developed that observes interactions with popular bridges and automatically propagates slashable evidence, and alerts operators about unexpected data.\r\n\r\n# Reporting\r\n\r\nProgress should be reported and discussed in Eth R&D Discord #light-clients.\r\n\r\n# Prior work\r\n\r\nA coarse slashing proposal can be found here: https://github.com/metacraft-labs/DendrETH/tree/main/docs/long-range-syncing#sync_committee_slashing-proposal - note that this is not feasible due to historic access requirements, and due to slashability even for syncing to an incorrect head.\r\n\r\n# Existing ideas (untested draft!)\r\n\r\nNote: This still allows having contradictions between attestations/proposals and sync committee messages. This also, by design, allows a validator to not participate at all in honest sync committee messages but solely participate in dishonest sync committee messages.\r\n\r\n| Name | Value |\r\n| - | - |\r\n| `BLOCK_STATE_ROOT_INDEX` | `get_generalized_index(BeaconBlock, 'state_root')` (= 11) |\r\n| `STATE_BLOCK_ROOTS_INDEX` | `get_generalized_index(BeaconState, 'block_roots')` (= 37) |\r\n| `STATE_HISTORICAL_ROOTS_INDEX` | `get_generalized_index(BeaconState, 'historical_roots')` (= 39) |\r\n| `HISTORICAL_BATCH_BLOCK_ROOTS_INDEX` | `get_generalized_index(HistoricalBatch, 'block_roots')` (= 2) |\r\n| `MAX_SYNC_COMMITTEE_SLASHINGS` | `2**0` (= 1) |\r\n\r\n```python\r\nclass SyncCommitteeSlashingEvidence(Container):\r\n    attested_header: BeaconBlockHeader\r\n    next_sync_committee: SyncCommittee\r\n    next_sync_committee_branch: Vector[Root, floorlog2(NEXT_SYNC_COMMITTEE_INDEX)]\r\n    finalized_header: BeaconBlockHeader\r\n    finality_branch: Vector[Root, floorlog2(FINALIZED_ROOT_INDEX)]\r\n    sync_aggregate: SyncAggregate\r\n    signature_slot: Slot\r\n    sync_committee_pubkeys: Vector[BLSPubkey, SYNC_COMMITTEE_SIZE]\r\n    actual_finalized_block_root: Root\r\n    actual_finalized_branch: List[Root, (\r\n        floorlog2(BLOCK_STATE_ROOT_INDEX)\r\n        + floorlog2(STATE_HISTORICAL_ROOTS_INDEX)\r\n        + 1 + floorlog2(HISTORICAL_ROOTS_LIMIT)\r\n        + floorlog2(HISTORICAL_BATCH_BLOCK_ROOTS_INDEX)\r\n        + 1 + floorlog2(SLOTS_PER_HISTORICAL_ROOT))]\r\n\r\nclass SyncCommitteeSlashing(Container):\r\n    slashable_validators: List[ValidatorIndex, SYNC_COMMITTEE_SIZE]\r\n    evidence_1: SyncCommitteeSlashingEvidence\r\n    evidence_2: SyncCommitteeSlashingEvidence\r\n    recent_finalized_block_root: Root\r\n    recent_finalized_slot: Slot\r\n\r\ndef sync_committee_slashing_evidence_has_sync_committee(evidence: SyncCommitteeSlashingEvidence) -> bool:\r\n    return evidence.next_sync_committee_branch != [Root() for _ in range(floorlog2(NEXT_SYNC_COMMITTEE_INDEX))]\r\n\r\ndef sync_committee_slashing_evidence_has_finality(evidence: SyncCommitteeSlashingEvidence) -> bool:\r\n    return evidence.finality_branch != [Root() for _ in range(floorlog2(FINALIZED_ROOT_INDEX))]\r\n\r\ndef is_valid_sync_committee_slashing_evidence(evidence: SyncCommitteeSlashingEvidence,\r\n                                              recent_finalized_block_root: Root,\r\n                                              recent_finalized_slot: Slot,\r\n                                              genesis_validators_root: Root) -> bool:\r\n    # Verify sync committee has sufficient participants\r\n    sync_aggregate = evidence.sync_aggregate\r\n    if sum(sync_aggregate.sync_committee_bits) < MIN_SYNC_COMMITTEE_PARTICIPANTS:\r\n        return False\r\n\r\n    # Verify that the `finality_branch`, if present, confirms `finalized_header`\r\n    # to match the finalized checkpoint root saved in the state of `attested_header`.\r\n    # Note that the genesis finalized checkpoint root is represented as a zero hash.\r\n    if not sync_committee_slashing_evidence_has_finality(evidence):\r\n        if evidence.actual_finalized_block_root != Root():\r\n            return False\r\n        if evidence.finalized_header != BeaconBlockHeader():\r\n            return False\r\n    else:\r\n        if evidence.finalized_header.slot == GENESIS_SLOT:\r\n            if evidence.actual_finalized_block_root != Root():\r\n                return False\r\n            if evidence.finalized_header != BeaconBlockHeader():\r\n                return False\r\n            finalized_root = Root()\r\n        else:\r\n            finalized_root = hash_tree_root(evidence.finalized_header)\r\n        if not is_valid_merkle_branch(\r\n            leaf=finalized_root,\r\n            branch=evidence.finality_branch,\r\n            depth=floorlog2(FINALIZED_ROOT_INDEX),\r\n            index=get_subtree_index(FINALIZED_ROOT_INDEX),\r\n            root=evidence.attested_header.state_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify that the `next_sync_committee`, if present, actually is the next sync committee saved in the\r\n    # state of the `attested_header`\r\n    if not sync_committee_slashing_evidence_has_sync_committee(evidence):\r\n        if evidence.next_sync_committee != SyncCommittee():\r\n            return False\r\n    else:\r\n        if not is_valid_merkle_branch(\r\n            leaf=hash_tree_root(evidence.next_sync_committee),\r\n            branch=evidence.next_sync_committee_branch,\r\n            depth=floorlog2(NEXT_SYNC_COMMITTEE_INDEX),\r\n            index=get_subtree_index(NEXT_SYNC_COMMITTEE_INDEX),\r\n            root=evidence.attested_header.state_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify that the `actual_finalized_block_root`, if present, is confirmed by `actual_finalized_branch`\r\n    # to be the block root at slot `finalized_header.slot` relative to `recent_finalized_block_root`\r\n    if recent_finalized_block_root == Root():\r\n        if evidence.actual_finalized_block_root != Root():\r\n            return False\r\n    if evidence.actual_finalized_block_root == Root():\r\n        if len(evidence.actual_finalized_branch) != 0:\r\n            return False\r\n    else:\r\n        finalized_slot = evidence.finalized_header.slot\r\n        if recent_finalized_slot < finalized_slot:\r\n            return False\r\n        distance = recent_finalized_slot - finalized_slot\r\n        if distance == 0:\r\n            gindex = GeneralizedIndex(1)\r\n        else:\r\n            gindex = BLOCK_STATE_ROOT_INDEX\r\n            if distance <= SLOTS_PER_HISTORICAL_ROOT:\r\n                gindex = (gindex << floorlog2(STATE_BLOCK_ROOTS_INDEX)) + STATE_BLOCK_ROOTS_INDEX\r\n            else:\r\n                gindex = (gindex << floorlog2(STATE_HISTORICAL_ROOTS_INDEX)) + STATE_HISTORICAL_ROOTS_INDEX\r\n                gindex = (gindex << uint64(1)) + 0  # `mix_in_length`\r\n                historical_batch_index = finalized_slot // SLOTS_PER_HISTORICAL_ROOT\r\n                gindex = (gindex << floorlog2(HISTORICAL_ROOTS_LIMIT)) + historical_batch_index\r\n                gindex = (gindex << floorlog2(HISTORICAL_BATCH_BLOCK_ROOTS_INDEX)) + HISTORICAL_BATCH_BLOCK_ROOTS_INDEX\r\n            gindex = (gindex << uint64(1)) + 0  # `mix_in_length`\r\n            block_root_index = finalized_slot % SLOTS_PER_HISTORICAL_ROOT\r\n            gindex = (gindex << floorlog2(SLOTS_PER_HISTORICAL_ROOT)) + block_root_index\r\n        if len(evidence.actual_finalized_branch) != floorlog2(gindex):\r\n            return False\r\n        if not is_valid_merkle_branch(\r\n            leaf=evidence.actual_finalized_block_root,\r\n            branch=evidence.actual_finalized_branch,\r\n            depth=floorlog2(gindex),\r\n            index=get_subtree_index(gindex),\r\n            root=recent_finalized_block_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify sync committee aggregate signature\r\n    sync_committee_pubkeys = evidence.sync_committee_pubkeys\r\n    participant_pubkeys = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate.sync_committee_bits, sync_committee_pubkeys)\r\n        if bit\r\n    ]\r\n    fork_version = compute_fork_version(compute_epoch_at_slot(evidence.signature_slot))\r\n    domain = compute_domain(DOMAIN_SYNC_COMMITTEE, fork_version, genesis_validators_root)\r\n    signing_root = compute_signing_root(evidence.attested_header, domain)\r\n    return bls.FastAggregateVerify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)\r\n\r\ndef process_sync_committee_slashing(state: BeaconState, sync_committee_slashing: SyncCommitteeSlashing) -> None:\r\n    is_slashable = False\r\n\r\n    # Check that evidence is ordered descending by `attested_header.slot` and is not from the future\r\n    evidence_1 = sync_committee_slashing.evidence_1\r\n    evidence_2 = sync_committee_slashing.evidence_2\r\n    assert state.slot >= evidence_1.signature_slot > evidence_1.attested_header.slot >= evidence_1.finalized_header.slot\r\n    assert state.slot >= evidence_2.signature_slot > evidence_2.attested_header.slot >= evidence_2.finalized_header.slot\r\n    assert evidence_1.attested_header.slot >= evidence_2.attested_header.slot\r\n\r\n    # Only conflicting data among the current and previous sync committee period is slashable;\r\n    # on new periods, the sync committee initially signs blocks in a previous sync committee period.\r\n    # This allows a validator synced to a malicious checkpoint to contribute again in a future period\r\n    evidence_1_attested_period = compute_sync_committee_period_at_slot(evidence_1.attested_header.slot)\r\n    evidence_2_attested_period = compute_sync_committee_period_at_slot(evidence_2.attested_header.slot)\r\n    assert evidence_1_attested_period <= evidence_2_attested_period + 1\r\n\r\n    # It is not allowed to sign conflicting `attested_header` for a given slot\r\n    if evidence_1.attested_header.slot == evidence_2.attested_header.slot:\r\n        if evidence_1.attested_header != evidence_2.attested_header:\r\n            is_slashable = True\r\n\r\n    # It is not allowed to sign conflicting finalized `next_sync_committee`\r\n    evidence_1_finalized_period = compute_sync_committee_period_at_slot(evidence_1.finalized_header.slot)\r\n    evidence_2_finalized_period = compute_sync_committee_period_at_slot(evidence_2.finalized_header.slot)\r\n    if (\r\n        evidence_1_attested_period == evidence_2_attested_period\r\n        and evidence_1_finalized_period == evidence_1_attested_period\r\n        and evidence_2_finalized_period == evidence_2_attested_period\r\n        and sync_committee_slashing_evidence_has_finality(evidence_1)\r\n        and sync_committee_slashing_evidence_has_finality(evidence_2)\r\n        and sync_committee_slashing_evidence_has_sync_committee(evidence_1)\r\n        and sync_committee_slashing_evidence_has_sync_committee(evidence_2)\r\n    ):\r\n        if evidence_1.next_sync_committee != evidence_2.next_sync_committee:\r\n            is_slashable = True\r\n\r\n    # It is not allowed to sign a non-linear finalized history\r\n    recent_finalized_slot = sync_committee_slashing.recent_finalized_slot\r\n    recent_finalized_block_root = sync_committee_slashing.recent_finalized_block_root\r\n    if (\r\n        not sync_committee_slashing_evidence_has_finality(evidence_1)\r\n        or not sync_committee_slashing_evidence_has_finality(evidence_2)\r\n    ):\r\n        assert recent_finalized_block_root == Root()\r\n    if recent_finalized_block_root == Root():\r\n        assert recent_finalized_slot == 0\r\n    else:\r\n        # Merkle proofs may be included to indicate that `finalized_header` does not match\r\n        # the `actual_finalized_block_root` relative to a given `recent_finalized_block_root`.\r\n        # The finalized history is linear. Therefore, a mismatch indicates signing on an unrelated chain.\r\n        # Note that it is not slashable to sign solely an alternate history, as long as it is consistent.\r\n        # This allows a validator synced to a malicious checkpoint to contribute again in a future period\r\n        linear_1 = (evidence_1.actual_finalized_block_root == hash_tree_root(evidence_1.finalized_header))\r\n        linear_2 = (evidence_2.actual_finalized_block_root == hash_tree_root(evidence_2.finalized_header))\r\n        assert not linear_1 or not linear_2\r\n        assert linear_1 or linear_2  # Do not slash on signing solely an alternate history\r\n\r\n        # `actual_finalized_branch` may be rooted in the provided `finalized_header` with highest slot\r\n        rooted_in_evidence_1 = (\r\n            evidence_1.finalized_header.slot >= evidence_2.finalized_header.slot\r\n            and recent_finalized_slot == evidence_1.finalized_header.slot\r\n            and recent_finalized_block_root == evidence_1.actual_finalized_block_root and linear_1\r\n        )\r\n        rooted_in_evidence_2 = (\r\n            evidence_2.finalized_header.slot >= evidence_1.finalized_header.slot\r\n            and recent_finalized_slot == evidence_2.finalized_header.slot\r\n            and recent_finalized_block_root == evidence_2.actual_finalized_block_root and linear_2\r\n        )\r\n\r\n        # Alternatively, if evidence about non-linearity cannot be obtained directly from an attack,\r\n        # it can be proven that one of the `finalized_header` is part of the canonical finalized chain\r\n        # that our beacon node is synced to, while the other `finalized_header` is unrelated.\r\n        rooted_in_canonical = (\r\n            recent_finalized_slot < state.slot <= recent_finalized_slot + SLOTS_PER_HISTORICAL_ROOT\r\n            and recent_finalized_slot <= compute_start_slot_at_epoch(state.finalized_checkpoint.epoch)\r\n            and recent_finalized_block_root == state.state_roots[recent_finalized_slot % SLOTS_PER_HISTORICAL_ROOT]\r\n        )\r\n        assert rooted_in_evidence_1 or rooted_in_evidence_2 or rooted_in_canonical\r\n        is_slashable = True\r\n\r\n    assert is_slashable\r\n\r\n    # Check that slashable validators are sorted, known, and participated in both signatures\r\n    will_slash_any = False\r\n    sync_aggregate_1 = evidence_1.sync_aggregate\r\n    sync_aggregate_2 = evidence_2.sync_aggregate\r\n    sync_committee_pubkeys_1 = evidence_1.sync_committee_pubkeys\r\n    sync_committee_pubkeys_2 = evidence_2.sync_committee_pubkeys\r\n    participant_pubkeys_1 = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate_1.sync_committee_bits, sync_committee_pubkeys_1)\r\n        if bit\r\n    ]\r\n    participant_pubkeys_2 = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate_2.sync_committee_bits, sync_committee_pubkeys_2)\r\n        if bit\r\n    ]\r\n    slashable_validators = sync_committee_slashing.slashable_validators\r\n    num_validators = len(state.validators)\r\n    for i, index in enumerate(slashable_validators):\r\n        assert (\r\n            index < num_validators\r\n            and (i == 0 or index > slashable_validators[i - 1])\r\n        )\r\n        assert state.validators[index].pubkey in participant_pubkeys_1\r\n        assert state.validators[index].pubkey in participant_pubkeys_2\r\n        if is_slashable_validator(state.validators[index], get_current_epoch(state)):\r\n            will_slash_any = True\r\n    assert will_slash_any\r\n\r\n    # Validate evidence, including signatures\r\n    assert is_valid_sync_committee_slashing_evidence(\r\n        evidence_1,\r\n        recent_finalized_block_root,\r\n        recent_finalized_slot,\r\n        state.genesis_validator_root,\r\n    )\r\n    assert is_valid_sync_committee_slashing_evidence(\r\n        evidence_2,\r\n        recent_finalized_block_root,\r\n        recent_finalized_slot,\r\n        state.genesis_validator_root,\r\n    )\r\n\r\n    # Perform slashing\r\n    for index in slashable_validators:\r\n        if is_slashable_validator(state.validators[index], get_current_epoch(state)):\r\n            slash_validator(state, index)\r\n```",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/reactions",
    "total_count": 3,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 3,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506112571",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3321#issuecomment-1506112571",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
    "id": 1506112571,
    "node_id": "IC_kwDOCOoGbc5ZxXQ7",
    "user": {
      "login": "dapplion",
      "id": 35266934,
      "node_id": "MDQ6VXNlcjM1MjY2OTM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dapplion",
      "html_url": "https://github.com/dapplion",
      "followers_url": "https://api.github.com/users/dapplion/followers",
      "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
      "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
      "organizations_url": "https://api.github.com/users/dapplion/orgs",
      "repos_url": "https://api.github.com/users/dapplion/repos",
      "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dapplion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-12T23:56:06Z",
    "updated_at": "2023-04-12T23:56:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "Noting that existing slashing is proportional to the amount of stake performing the attack. Should sync committee slashing be part of that multiplier? Say if 100% of the sync committee participates in the attack, should the penalties by much higher than if only 1 participant does?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506112571/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
