{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3321",
  "id": 1664909784,
  "node_id": "I_kwDOCOoGbc5jPIHY",
  "number": 3321,
  "title": "Sync committee slashing",
  "user": {
    "login": "etan-status",
    "id": 89844309,
    "node_id": "MDQ6VXNlcjg5ODQ0MzA5",
    "avatar_url": "https://avatars.githubusercontent.com/u/89844309?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/etan-status",
    "html_url": "https://github.com/etan-status",
    "followers_url": "https://api.github.com/users/etan-status/followers",
    "following_url": "https://api.github.com/users/etan-status/following{/other_user}",
    "gists_url": "https://api.github.com/users/etan-status/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/etan-status/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/etan-status/subscriptions",
    "organizations_url": "https://api.github.com/users/etan-status/orgs",
    "repos_url": "https://api.github.com/users/etan-status/repos",
    "events_url": "https://api.github.com/users/etan-status/events{/privacy}",
    "received_events_url": "https://api.github.com/users/etan-status/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2023-04-12T16:52:22Z",
  "updated_at": "2023-12-26T19:40:35Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum's light client sync protocol to assume a non-canonical finalized header, and to potentially take over the sync authority for future `SyncCommitteePeriod`. By signing a malicious beacon block root, a malicious (but valid!) `LightClientUpdate` message can be formed and subsequently used to, for example, exploit a trust-minimized bridge contract based on the light client sync protocol.\r\n\r\nWhile honest nodes only propagate canonical `LightClientUpdate` messages, there is currently no disincentive against signing malicious beacon block roots. In fact, because there is no downside, it could even be considered a form of MEV to exploit bridges on top of performing all honest validator duties. See also: https://prestwich.substack.com/p/altair\r\n\r\nNote that even if the entire sync committee could be fully slashed all the way down to 0 ETH, that this would still cap the security level to `SYNC_COMMITTEE_SIZE * MAX_EFFECTIVE_BALANCE` = `512 * 32 ETH` = `16384 ETH` ~= `32 million USD @ 2k USD / ETH`. Bridges that secure more funds than this security level may combine the light client sync protocol with other established methods such as a multisig, or may want to require posting additional collateral to be eligible for updating the bridge. These methods are out of scope for this issue.\r\n\r\n# Goals\r\n\r\n## Slashing definition\r\n\r\nAn additional type of slashing should be introduced to deter against signing non-canonical beacon block roots as a sync committee member. As is the case with `ProposerSlashing` and `AttesterSlashing`, only malicious behaviour should be slashable. This includes simultaneous contradictory participation across multiple chain branches, but a validator that is simply tricked into syncing to an incorrect checkpoint should not be slashable even though it is participating on a non-canonical chain. Note that a slashing must be verifiable even without access to history, e.g., by a checkpoint synced beacon node.\r\n\r\n## Reference implementation\r\n\r\nPython + Pytests + reference implementation for one of the consensus clients.\r\n\r\n## Slashing protection\r\n\r\nThe slashing protection database format should be extended to guarantee that validators can never be slashed regardless of chain syncing activity. For example, if a node operator deletes their chain data and syncs to a different branch, that should never be slashable as long as the slashing protection database is in place. The slashing protection interchange format needs to be updated accordingly.\r\n\r\n## Web3signer / Validator client APIs\r\n\r\nAPIs interacting with remote validators need to be extended to pass along information relevant to slashing protection. For example, a signer may need to know what the finalized checkpoint is at the signed block's post-state, before performing the signature operation.\r\n\r\n## Beacon APIs\r\n\r\nAn API to submit / observe sync committee slashing evidence needs to be added, to be used by slashers for getting evidence included into blocks. Likewise, a libp2p mesh is necessary to allow exchanging slashing evidence.\r\n\r\n## Slasher\r\n\r\nA slasher component should be developed that observes interactions with popular bridges and automatically propagates slashable evidence, and alerts operators about unexpected data.\r\n\r\n# Reporting\r\n\r\nProgress should be reported and discussed in Eth R&D Discord #light-clients.\r\n\r\n# Prior work\r\n\r\nA coarse slashing proposal can be found here: https://github.com/metacraft-labs/DendrETH/tree/main/docs/long-range-syncing#sync_committee_slashing-proposal - note that this is not feasible due to historic access requirements, and due to slashability even for syncing to an incorrect head.\r\n\r\n# Existing ideas (untested draft!)\r\n\r\nNote: This still allows having contradictions between attestations/proposals and sync committee messages. This also, by design, allows a validator to not participate at all in honest sync committee messages but solely participate in dishonest sync committee messages.\r\n\r\n| Name | Value |\r\n| - | - |\r\n| `BLOCK_STATE_ROOT_INDEX` | `get_generalized_index(BeaconBlock, 'state_root')` (= 11) |\r\n| `STATE_BLOCK_ROOTS_INDEX` | `get_generalized_index(BeaconState, 'block_roots')` (= 37) |\r\n| `STATE_HISTORICAL_ROOTS_INDEX` | `get_generalized_index(BeaconState, 'historical_roots')` (= 39) |\r\n| `HISTORICAL_BATCH_BLOCK_ROOTS_INDEX` | `get_generalized_index(HistoricalBatch, 'block_roots')` (= 2) |\r\n| `MAX_SYNC_COMMITTEE_SLASHINGS` | `2**0` (= 1) |\r\n\r\n```python\r\nclass SyncCommitteeSlashingEvidence(Container):\r\n    attested_header: BeaconBlockHeader\r\n    next_sync_committee: SyncCommittee\r\n    next_sync_committee_branch: Vector[Root, floorlog2(NEXT_SYNC_COMMITTEE_INDEX)]\r\n    finalized_header: BeaconBlockHeader\r\n    finality_branch: Vector[Root, floorlog2(FINALIZED_ROOT_INDEX)]\r\n    sync_aggregate: SyncAggregate\r\n    signature_slot: Slot\r\n    sync_committee_pubkeys: Vector[BLSPubkey, SYNC_COMMITTEE_SIZE]\r\n    actual_finalized_block_root: Root\r\n    actual_finalized_branch: List[Root, (\r\n        floorlog2(BLOCK_STATE_ROOT_INDEX)\r\n        + floorlog2(STATE_HISTORICAL_ROOTS_INDEX)\r\n        + 1 + floorlog2(HISTORICAL_ROOTS_LIMIT)\r\n        + floorlog2(HISTORICAL_BATCH_BLOCK_ROOTS_INDEX)\r\n        + 1 + floorlog2(SLOTS_PER_HISTORICAL_ROOT))]\r\n\r\nclass SyncCommitteeSlashing(Container):\r\n    slashable_validators: List[ValidatorIndex, SYNC_COMMITTEE_SIZE]\r\n    evidence_1: SyncCommitteeSlashingEvidence\r\n    evidence_2: SyncCommitteeSlashingEvidence\r\n    recent_finalized_block_root: Root\r\n    recent_finalized_slot: Slot\r\n\r\ndef sync_committee_slashing_evidence_has_sync_committee(evidence: SyncCommitteeSlashingEvidence) -> bool:\r\n    return evidence.next_sync_committee_branch != [Root() for _ in range(floorlog2(NEXT_SYNC_COMMITTEE_INDEX))]\r\n\r\ndef sync_committee_slashing_evidence_has_finality(evidence: SyncCommitteeSlashingEvidence) -> bool:\r\n    return evidence.finality_branch != [Root() for _ in range(floorlog2(FINALIZED_ROOT_INDEX))]\r\n\r\ndef is_valid_sync_committee_slashing_evidence(evidence: SyncCommitteeSlashingEvidence,\r\n                                              recent_finalized_block_root: Root,\r\n                                              recent_finalized_slot: Slot,\r\n                                              genesis_validators_root: Root) -> bool:\r\n    # Verify sync committee has sufficient participants\r\n    sync_aggregate = evidence.sync_aggregate\r\n    if sum(sync_aggregate.sync_committee_bits) < MIN_SYNC_COMMITTEE_PARTICIPANTS:\r\n        return False\r\n\r\n    # Verify that the `finality_branch`, if present, confirms `finalized_header`\r\n    # to match the finalized checkpoint root saved in the state of `attested_header`.\r\n    # Note that the genesis finalized checkpoint root is represented as a zero hash.\r\n    if not sync_committee_slashing_evidence_has_finality(evidence):\r\n        if evidence.actual_finalized_block_root != Root():\r\n            return False\r\n        if evidence.finalized_header != BeaconBlockHeader():\r\n            return False\r\n    else:\r\n        if evidence.finalized_header.slot == GENESIS_SLOT:\r\n            if evidence.actual_finalized_block_root != Root():\r\n                return False\r\n            if evidence.finalized_header != BeaconBlockHeader():\r\n                return False\r\n            finalized_root = Root()\r\n        else:\r\n            finalized_root = hash_tree_root(evidence.finalized_header)\r\n        if not is_valid_merkle_branch(\r\n            leaf=finalized_root,\r\n            branch=evidence.finality_branch,\r\n            depth=floorlog2(FINALIZED_ROOT_INDEX),\r\n            index=get_subtree_index(FINALIZED_ROOT_INDEX),\r\n            root=evidence.attested_header.state_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify that the `next_sync_committee`, if present, actually is the next sync committee saved in the\r\n    # state of the `attested_header`\r\n    if not sync_committee_slashing_evidence_has_sync_committee(evidence):\r\n        if evidence.next_sync_committee != SyncCommittee():\r\n            return False\r\n    else:\r\n        if not is_valid_merkle_branch(\r\n            leaf=hash_tree_root(evidence.next_sync_committee),\r\n            branch=evidence.next_sync_committee_branch,\r\n            depth=floorlog2(NEXT_SYNC_COMMITTEE_INDEX),\r\n            index=get_subtree_index(NEXT_SYNC_COMMITTEE_INDEX),\r\n            root=evidence.attested_header.state_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify that the `actual_finalized_block_root`, if present, is confirmed by `actual_finalized_branch`\r\n    # to be the block root at slot `finalized_header.slot` relative to `recent_finalized_block_root`\r\n    if recent_finalized_block_root == Root():\r\n        if evidence.actual_finalized_block_root != Root():\r\n            return False\r\n    if evidence.actual_finalized_block_root == Root():\r\n        if len(evidence.actual_finalized_branch) != 0:\r\n            return False\r\n    else:\r\n        finalized_slot = evidence.finalized_header.slot\r\n        if recent_finalized_slot < finalized_slot:\r\n            return False\r\n        distance = recent_finalized_slot - finalized_slot\r\n        if distance == 0:\r\n            gindex = GeneralizedIndex(1)\r\n        else:\r\n            gindex = BLOCK_STATE_ROOT_INDEX\r\n            if distance <= SLOTS_PER_HISTORICAL_ROOT:\r\n                gindex = (gindex << floorlog2(STATE_BLOCK_ROOTS_INDEX)) + STATE_BLOCK_ROOTS_INDEX\r\n            else:\r\n                gindex = (gindex << floorlog2(STATE_HISTORICAL_ROOTS_INDEX)) + STATE_HISTORICAL_ROOTS_INDEX\r\n                gindex = (gindex << uint64(1)) + 0  # `mix_in_length`\r\n                historical_batch_index = finalized_slot // SLOTS_PER_HISTORICAL_ROOT\r\n                gindex = (gindex << floorlog2(HISTORICAL_ROOTS_LIMIT)) + historical_batch_index\r\n                gindex = (gindex << floorlog2(HISTORICAL_BATCH_BLOCK_ROOTS_INDEX)) + HISTORICAL_BATCH_BLOCK_ROOTS_INDEX\r\n            gindex = (gindex << uint64(1)) + 0  # `mix_in_length`\r\n            block_root_index = finalized_slot % SLOTS_PER_HISTORICAL_ROOT\r\n            gindex = (gindex << floorlog2(SLOTS_PER_HISTORICAL_ROOT)) + block_root_index\r\n        if len(evidence.actual_finalized_branch) != floorlog2(gindex):\r\n            return False\r\n        if not is_valid_merkle_branch(\r\n            leaf=evidence.actual_finalized_block_root,\r\n            branch=evidence.actual_finalized_branch,\r\n            depth=floorlog2(gindex),\r\n            index=get_subtree_index(gindex),\r\n            root=recent_finalized_block_root,\r\n        ):\r\n            return False\r\n\r\n    # Verify sync committee aggregate signature\r\n    sync_committee_pubkeys = evidence.sync_committee_pubkeys\r\n    participant_pubkeys = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate.sync_committee_bits, sync_committee_pubkeys)\r\n        if bit\r\n    ]\r\n    fork_version = compute_fork_version(compute_epoch_at_slot(evidence.signature_slot))\r\n    domain = compute_domain(DOMAIN_SYNC_COMMITTEE, fork_version, genesis_validators_root)\r\n    signing_root = compute_signing_root(evidence.attested_header, domain)\r\n    return bls.FastAggregateVerify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)\r\n\r\ndef process_sync_committee_slashing(state: BeaconState, sync_committee_slashing: SyncCommitteeSlashing) -> None:\r\n    is_slashable = False\r\n\r\n    # Check that evidence is ordered descending by `attested_header.slot` and is not from the future\r\n    evidence_1 = sync_committee_slashing.evidence_1\r\n    evidence_2 = sync_committee_slashing.evidence_2\r\n    assert state.slot >= evidence_1.signature_slot > evidence_1.attested_header.slot >= evidence_1.finalized_header.slot\r\n    assert state.slot >= evidence_2.signature_slot > evidence_2.attested_header.slot >= evidence_2.finalized_header.slot\r\n    assert evidence_1.attested_header.slot >= evidence_2.attested_header.slot\r\n\r\n    # Only conflicting data among the current and previous sync committee period is slashable;\r\n    # on new periods, the sync committee initially signs blocks in a previous sync committee period.\r\n    # This allows a validator synced to a malicious checkpoint to contribute again in a future period\r\n    evidence_1_attested_period = compute_sync_committee_period_at_slot(evidence_1.attested_header.slot)\r\n    evidence_2_attested_period = compute_sync_committee_period_at_slot(evidence_2.attested_header.slot)\r\n    assert evidence_1_attested_period <= evidence_2_attested_period + 1\r\n\r\n    # It is not allowed to sign conflicting `attested_header` for a given slot\r\n    if evidence_1.attested_header.slot == evidence_2.attested_header.slot:\r\n        if evidence_1.attested_header != evidence_2.attested_header:\r\n            is_slashable = True\r\n\r\n    # It is not allowed to sign conflicting finalized `next_sync_committee`\r\n    evidence_1_finalized_period = compute_sync_committee_period_at_slot(evidence_1.finalized_header.slot)\r\n    evidence_2_finalized_period = compute_sync_committee_period_at_slot(evidence_2.finalized_header.slot)\r\n    if (\r\n        evidence_1_attested_period == evidence_2_attested_period\r\n        and evidence_1_finalized_period == evidence_1_attested_period\r\n        and evidence_2_finalized_period == evidence_2_attested_period\r\n        and sync_committee_slashing_evidence_has_finality(evidence_1)\r\n        and sync_committee_slashing_evidence_has_finality(evidence_2)\r\n        and sync_committee_slashing_evidence_has_sync_committee(evidence_1)\r\n        and sync_committee_slashing_evidence_has_sync_committee(evidence_2)\r\n    ):\r\n        if evidence_1.next_sync_committee != evidence_2.next_sync_committee:\r\n            is_slashable = True\r\n\r\n    # It is not allowed to sign a non-linear finalized history\r\n    recent_finalized_slot = sync_committee_slashing.recent_finalized_slot\r\n    recent_finalized_block_root = sync_committee_slashing.recent_finalized_block_root\r\n    if (\r\n        not sync_committee_slashing_evidence_has_finality(evidence_1)\r\n        or not sync_committee_slashing_evidence_has_finality(evidence_2)\r\n    ):\r\n        assert recent_finalized_block_root == Root()\r\n    if recent_finalized_block_root == Root():\r\n        assert recent_finalized_slot == 0\r\n    else:\r\n        # Merkle proofs may be included to indicate that `finalized_header` does not match\r\n        # the `actual_finalized_block_root` relative to a given `recent_finalized_block_root`.\r\n        # The finalized history is linear. Therefore, a mismatch indicates signing on an unrelated chain.\r\n        # Note that it is not slashable to sign solely an alternate history, as long as it is consistent.\r\n        # This allows a validator synced to a malicious checkpoint to contribute again in a future period\r\n        linear_1 = (evidence_1.actual_finalized_block_root == hash_tree_root(evidence_1.finalized_header))\r\n        linear_2 = (evidence_2.actual_finalized_block_root == hash_tree_root(evidence_2.finalized_header))\r\n        assert not linear_1 or not linear_2\r\n        assert linear_1 or linear_2  # Do not slash on signing solely an alternate history\r\n\r\n        # `actual_finalized_branch` may be rooted in the provided `finalized_header` with highest slot\r\n        rooted_in_evidence_1 = (\r\n            evidence_1.finalized_header.slot >= evidence_2.finalized_header.slot\r\n            and recent_finalized_slot == evidence_1.finalized_header.slot\r\n            and recent_finalized_block_root == evidence_1.actual_finalized_block_root and linear_1\r\n        )\r\n        rooted_in_evidence_2 = (\r\n            evidence_2.finalized_header.slot >= evidence_1.finalized_header.slot\r\n            and recent_finalized_slot == evidence_2.finalized_header.slot\r\n            and recent_finalized_block_root == evidence_2.actual_finalized_block_root and linear_2\r\n        )\r\n\r\n        # Alternatively, if evidence about non-linearity cannot be obtained directly from an attack,\r\n        # it can be proven that one of the `finalized_header` is part of the canonical finalized chain\r\n        # that our beacon node is synced to, while the other `finalized_header` is unrelated.\r\n        rooted_in_canonical = (\r\n            recent_finalized_slot < state.slot <= recent_finalized_slot + SLOTS_PER_HISTORICAL_ROOT\r\n            and recent_finalized_slot <= compute_start_slot_at_epoch(state.finalized_checkpoint.epoch)\r\n            and recent_finalized_block_root == state.state_roots[recent_finalized_slot % SLOTS_PER_HISTORICAL_ROOT]\r\n        )\r\n        assert rooted_in_evidence_1 or rooted_in_evidence_2 or rooted_in_canonical\r\n        is_slashable = True\r\n\r\n    assert is_slashable\r\n\r\n    # Check that slashable validators are sorted, known, and participated in both signatures\r\n    will_slash_any = False\r\n    sync_aggregate_1 = evidence_1.sync_aggregate\r\n    sync_aggregate_2 = evidence_2.sync_aggregate\r\n    sync_committee_pubkeys_1 = evidence_1.sync_committee_pubkeys\r\n    sync_committee_pubkeys_2 = evidence_2.sync_committee_pubkeys\r\n    participant_pubkeys_1 = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate_1.sync_committee_bits, sync_committee_pubkeys_1)\r\n        if bit\r\n    ]\r\n    participant_pubkeys_2 = [\r\n        pubkey for (bit, pubkey) in zip(sync_aggregate_2.sync_committee_bits, sync_committee_pubkeys_2)\r\n        if bit\r\n    ]\r\n    slashable_validators = sync_committee_slashing.slashable_validators\r\n    num_validators = len(state.validators)\r\n    for i, index in enumerate(slashable_validators):\r\n        assert (\r\n            index < num_validators\r\n            and (i == 0 or index > slashable_validators[i - 1])\r\n        )\r\n        assert state.validators[index].pubkey in participant_pubkeys_1\r\n        assert state.validators[index].pubkey in participant_pubkeys_2\r\n        if is_slashable_validator(state.validators[index], get_current_epoch(state)):\r\n            will_slash_any = True\r\n    assert will_slash_any\r\n\r\n    # Validate evidence, including signatures\r\n    assert is_valid_sync_committee_slashing_evidence(\r\n        evidence_1,\r\n        recent_finalized_block_root,\r\n        recent_finalized_slot,\r\n        state.genesis_validator_root,\r\n    )\r\n    assert is_valid_sync_committee_slashing_evidence(\r\n        evidence_2,\r\n        recent_finalized_block_root,\r\n        recent_finalized_slot,\r\n        state.genesis_validator_root,\r\n    )\r\n\r\n    # Perform slashing\r\n    for index in slashable_validators:\r\n        if is_slashable_validator(state.validators[index], get_current_epoch(state)):\r\n            slash_validator(state, index)\r\n```",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/reactions",
    "total_count": 4,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 4,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506112571",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3321#issuecomment-1506112571",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
    "id": 1506112571,
    "node_id": "IC_kwDOCOoGbc5ZxXQ7",
    "user": {
      "login": "dapplion",
      "id": 35266934,
      "node_id": "MDQ6VXNlcjM1MjY2OTM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dapplion",
      "html_url": "https://github.com/dapplion",
      "followers_url": "https://api.github.com/users/dapplion/followers",
      "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
      "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
      "organizations_url": "https://api.github.com/users/dapplion/orgs",
      "repos_url": "https://api.github.com/users/dapplion/repos",
      "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dapplion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-12T23:56:06Z",
    "updated_at": "2023-04-12T23:56:06Z",
    "author_association": "COLLABORATOR",
    "body": "Noting that existing slashing is proportional to the amount of stake performing the attack. Should sync committee slashing be part of that multiplier? Say if 100% of the sync committee participates in the attack, should the penalties by much higher than if only 1 participant does?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506112571/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506185248",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3321#issuecomment-1506185248",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
    "id": 1506185248,
    "node_id": "IC_kwDOCOoGbc5ZxpAg",
    "user": {
      "login": "etan-status",
      "id": 89844309,
      "node_id": "MDQ6VXNlcjg5ODQ0MzA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/89844309?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/etan-status",
      "html_url": "https://github.com/etan-status",
      "followers_url": "https://api.github.com/users/etan-status/followers",
      "following_url": "https://api.github.com/users/etan-status/following{/other_user}",
      "gists_url": "https://api.github.com/users/etan-status/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/etan-status/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/etan-status/subscriptions",
      "organizations_url": "https://api.github.com/users/etan-status/orgs",
      "repos_url": "https://api.github.com/users/etan-status/repos",
      "events_url": "https://api.github.com/users/etan-status/events{/privacy}",
      "received_events_url": "https://api.github.com/users/etan-status/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-13T01:30:00Z",
    "updated_at": "2023-04-13T01:30:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "It can be a bit tricky to count, as the sync committees may be different across the various branches (canonical vs attacker), e.g., due to non-finality for prolonged time, or due to attacker mixing malicious pubkeys with real pubkeys to try and appear more legitimate. We also want to slash, when we detect a pubkey being used to exploit two bridges on other branches, even when they are not signing the canonical chain.\r\n\r\nFurthermore, slashing evidence may not provide us with all of the participating pubkeys, it may be just a subset of keys, further complicating a correct multiplier.\r\n\r\nFinally, slashing evidence could be submitted after the exploit already happened. e.g., manual analysis, then discover that this was a sync committee based attack 1-2 days later, compute the evidence, submit it, and hope that the attackers couldn't exit faster than that.\r\n\r\nOverall, it makes sense though, to scale the penalty accordingly.\r\n\r\nHaving said that, at this time I also wouldn't rule out more sophisticated reward/penalty schemes specifically aimed at sync committee members.\r\n\r\nFor example, one could require that if you attested in the last hour before knowing that you will be part of next_sync_committee, that you are required to also participate on the canonical chain in that next_sync_committee. If you then only participate in a non-canonical chain (after participating on the canonical chain a day ago), that may also be a slashing condition.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506185248/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506710208",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3321#issuecomment-1506710208",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3321",
    "id": 1506710208,
    "node_id": "IC_kwDOCOoGbc5ZzpLA",
    "user": {
      "login": "etan-status",
      "id": 89844309,
      "node_id": "MDQ6VXNlcjg5ODQ0MzA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/89844309?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/etan-status",
      "html_url": "https://github.com/etan-status",
      "followers_url": "https://api.github.com/users/etan-status/followers",
      "following_url": "https://api.github.com/users/etan-status/following{/other_user}",
      "gists_url": "https://api.github.com/users/etan-status/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/etan-status/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/etan-status/subscriptions",
      "organizations_url": "https://api.github.com/users/etan-status/orgs",
      "repos_url": "https://api.github.com/users/etan-status/repos",
      "events_url": "https://api.github.com/users/etan-status/events{/privacy}",
      "received_events_url": "https://api.github.com/users/etan-status/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-13T10:14:05Z",
    "updated_at": "2023-04-13T10:14:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "Also, another thing to keep in mind re slashing amounts, is, that, slashings won't affect `current/next_sync_committee` but can only be accommodated for the future. Sync committees are locked in place a day before they become active.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1506710208/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
