{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/497",
  "id": 402952269,
  "node_id": "MDU6SXNzdWU0MDI5NTIyNjk=",
  "number": 497,
  "title": "When to run fork choice rule?",
  "user": {
    "login": "terencechain",
    "id": 21316537,
    "node_id": "MDQ6VXNlcjIxMzE2NTM3",
    "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/terencechain",
    "html_url": "https://github.com/terencechain",
    "followers_url": "https://api.github.com/users/terencechain/followers",
    "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
    "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
    "organizations_url": "https://api.github.com/users/terencechain/orgs",
    "repos_url": "https://api.github.com/users/terencechain/repos",
    "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
    "received_events_url": "https://api.github.com/users/terencechain/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1063043872,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODcy",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:question",
      "name": "general:question",
      "color": "FAD689",
      "default": false,
      "description": "Further information is requested"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2019-01-25T00:16:55Z",
  "updated_at": "2019-02-13T01:01:20Z",
  "closed_at": "2019-02-13T01:01:20Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Can we have a discussion on when exactly to run the fork choice rule?\r\n\r\nWe see two possibilities as the following:\r\n1. We use a slot ticker that \"ticks\" every `SLOT_DURATION` seconds, triggering an `UpdateHead` function in our code along with processing received blocks, running a state transition, etc.\r\n\r\n2. We do not use a slot ticker but instead just have a function that listens for incoming processed blocks from proposers\r\n\r\nFor 2, will `UpdateHead` be called when we receive this block as well?\r\nHow does time a play a role here if everything is abstracted away into slot counters? Does it only play a role in certain timestamp verification details such as isValidSlot(block types.Block) bool?\r\nOur client currently favors option 2, in which we do not use an internal clock ticker to run critical beacon node functionality",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457424301",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-457424301",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 457424301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzQyNDMwMQ==",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-25T01:38:49Z",
    "updated_at": "2019-01-25T01:38:49Z",
    "author_association": "MEMBER",
    "body": "the fork choice can be written as a pure function of a particular beacon block tree, a focus within that tree (the latest justified head) and a set of (latest) attestations.\r\n\r\ngiven we have discrete inputs to a pure function, we only have to run the fork choice when one of our discrete inputs changes. so setting aside questions of performance, we would run the fork choice when we receive\r\n\r\n1. a new, valid block\r\n2. a new, valid attestation\r\n3. confirmation that the justified head changed\r\n\r\nthe ideal node will be calculating fork choice when any of the above changes (i.e. infinite performance); given that we can't build ideal nodes we will have to make some sacrifices in our clients. so we want to run the fork choice as often as possible while still allowing for the other duties of a beacon node (and keep in mind the target hardware is commodity stuff). \r\n\r\nand at this point, the answer is to just do the ideal thing and measure how well it works; i think there has been some benchmarking work in the EF beacon chain repo but i'm not sure to what extent. in the meantime, we can make some guesses. the lowest frequency change will be (3) as the justified head will only update at most every epoch. we should be receiving blocks and attestations on the order of every slot but i would guess this is where we run into trouble recalculating the fork choice that frequently. it is worth thinking about how long the ideal node could delay recalculating the fork choice and still be able to make the blocks/attestations they would otherwise -- which seems like on average would be the `MIN_ATTESTATION_INCLUSION_DELAY`, accounting for the instances when you need to propose a block and would have to move sooner.\r\n\r\nas an aside, you could imagine some exotic incremental computation that does incorporate a new fork choice upon every new piece of data but i can't say much more about this.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457424301/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457647950",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-457647950",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 457647950,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzY0Nzk1MA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-25T17:20:47Z",
    "updated_at": "2019-01-25T17:20:47Z",
    "author_association": "MEMBER",
    "body": "I think the sane approach here is going to be to run the fork choice at both:\r\n\r\n1) After processing a new incoming block\r\n2) at the start of each slot.\r\n\r\nFor (2), I mean at the start of each slot from a machine's time perspective, not from a block processing perspective. Between the starts of slots, a node will receive attestations both on the wire and within blocks. To keep the fork choice function from being overworked and at the same time to make sure local information is up to date enough for validators and other applications, the start of the slot is the natural target here.\r\n\r\n+1 on @ralexstokes explanation. A couple of followup notes\r\n* Even without more benchmarks, we can firmly say that updating at each new attestation will be a major DOS vector and should be avoided\r\n* Justified head only changes upon receiving a new block (and processing the state transition function) so this is generally encapsulated within (1). [yes, you can opportunistically process through empty slots and see a new justified/finalized block without a new incoming block, but I would avoid this optimizations for the time being]",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457647950/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457648180",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-457648180",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 457648180,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzY0ODE4MA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-25T17:21:31Z",
    "updated_at": "2019-01-25T17:21:31Z",
    "author_association": "MEMBER",
    "body": "I am in favor of adding explicit guidance on this in the spec, btw",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457648180/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457914406",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-457914406",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 457914406,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzkxNDQwNg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-27T12:39:55Z",
    "updated_at": "2019-01-27T12:39:55Z",
    "author_association": "MEMBER",
    "body": "> After processing a new incoming block\r\n\r\nThis is potentially risky, because a single malicious proposer could create a very large number of blocks. I would say either (i) only do it once per slot change, or (ii) do it once per slot change and once upon the first time you receive a block at any given slot.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457914406/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457927460",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-457927460",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 457927460,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzkyNzQ2MA==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-27T15:30:18Z",
    "updated_at": "2019-01-27T15:30:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "The single malicious proposer would be slashed by create a very large number of blocks right? I assume a well designed beacon node would just drop rest of the incoming blocks from the malicious proposer ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/457927460/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463009934",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/497#issuecomment-463009934",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/497",
    "id": 463009934,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MzAwOTkzNA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-13T01:01:20Z",
    "updated_at": "2019-02-13T01:01:20Z",
    "author_association": "MEMBER",
    "body": "I'd say the question was well answered by Alex, Danny, Vitalik. Closing for now :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463009934/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
