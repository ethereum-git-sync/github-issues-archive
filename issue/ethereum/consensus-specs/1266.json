{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1266",
  "id": 463482796,
  "node_id": "MDU6SXNzdWU0NjM0ODI3OTY=",
  "number": 1266,
  "title": "Remove bitlist length bit from SSZ",
  "user": {
    "login": "prestonvanloon",
    "id": 7246818,
    "node_id": "MDQ6VXNlcjcyNDY4MTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/prestonvanloon",
    "html_url": "https://github.com/prestonvanloon",
    "followers_url": "https://api.github.com/users/prestonvanloon/followers",
    "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
    "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
    "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
    "repos_url": "https://api.github.com/users/prestonvanloon/repos",
    "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 17,
  "created_at": "2019-07-02T23:51:56Z",
  "updated_at": "2019-07-04T20:04:54Z",
  "closed_at": "2019-07-04T20:04:54Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "There was a change recently that changed the bitfield types to Bitlist[N] in #1224. Part of this change was to also change SSZ to include special handling for the underlying data type, a byte array. \r\n\r\nI've talked with a few folks about the rationale for the changes in #1224. From what I understand, these changes were included for readability in the Python specification/implementation. However, this added a change that isn't strictly related to readability: Bitlist bit length in SSZ encoding.\r\n\r\n> `Bitlist[N]`\r\n> Note that from the offset coding, the length (in bytes) of the bitlist is known. An additional leading 1 bit is added so that the length in bits will also be known.\r\n> ```python \r\n> as_integer = (1 << len(value)) + sum([value[i] << i for i in range(len(value))])\r\n> return as_integer.to_bytes((as_integer.bit_length() + 7) // 8, \"little\")\r\n> ```\r\n[specs/simple-serialize.md](https://github.com/ethereum/eth2.0-specs/blob/master/specs/simple-serialize.md)\r\n\r\nPrior to the add bitlist length in SSZ, we checked the number of bytes in the bitfield byte array to ensure it was the expected length. Maybe an issue here is that you can only check for fields in multiples of 8 bits (1 byte). So if we had a bitfield that represented indices in a committee where the committee length was 10 then we would check the bitfield had 2 bytes, but there were 6 bits unused. An additional layer of verification could be to set the 6 most significant bits to 0 in the second byte or simple disregard their values entirely. In either case, we had a solution without Bitlist length in SSZ. The length enforcement should be handled in the application layer rather than the serialization layer. \r\n\r\nWith these changes, we now have this added consequence of a non-primitive type handling in SSZ. Up until this PR, you could use SSZ and other encoders interchangeably with adding special rules. You could encode any data structure with a bitfield to JSON or others where the underlying bytes array would naturally be appropriately represented in the same way. We have to treat some byte arrays different than other byte arrays and this adds unnecessary complexity. The key takeaway here is that we could previously fully populate an SSZ yaml file to a data structure using the existing serialization tooling for yaml and/or json. i.e. byte arrays were simply byte arrays, not byte arrays with some extra metadata.\r\n\r\nIf its helpful, I had started collecting notes on this change and trying to piece together the puzzle of #1224. [Link](https://hackmd.io/B1zuJEt3RR-uOEYXFpwHKQ)\r\n\r\nThere's a good bit about this in @rauljordan's article in the section called \"Why Not More Basic Types!?\" [link](https://rauljordan.com/2019/07/02/go-lessons-from-writing-a-serialization-library-for-ethereum.html)\r\n\r\nTL;DR - Bitfield length information in SSZ is unnecessary complexity and we should remove it. Let's keep simple serialize simple. ",
  "closed_by": {
    "login": "prestonvanloon",
    "id": 7246818,
    "node_id": "MDQ6VXNlcjcyNDY4MTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/prestonvanloon",
    "html_url": "https://github.com/prestonvanloon",
    "followers_url": "https://api.github.com/users/prestonvanloon/followers",
    "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
    "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
    "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
    "repos_url": "https://api.github.com/users/prestonvanloon/repos",
    "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266/reactions",
    "total_count": 7,
    "+1": 4,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 1,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/507925848",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-507925848",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 507925848,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNzkyNTg0OA==",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T03:44:07Z",
    "updated_at": "2019-07-03T03:44:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "+1 on this. Although it adds further readability on perhaps the Python implementation, it pushes further complexity on languages, such as Go, which already have a harder time implementing SSZ due to a lack of generics. Having bitlists and bitvectors as primitives as @prestonvanloon mentioned also make implementation assumptions within SSZ that limit us from using the tooling we use in Prysm with other encoders. We kindly ask researchers to reconsider this change and possibly revert in favor of keeping SSZ simple.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/507925848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508049432",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508049432",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508049432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODA0OTQzMg==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T11:11:37Z",
    "updated_at": "2019-07-03T11:11:37Z",
    "author_association": "MEMBER",
    "body": "Since I was the driver behind this change I am very happy to answer any questions about it. The way I understand it, the main criticism is this:\r\n\r\n> The length enforcement should be handled in the application layer rather than the serialization layer.\r\n\r\nIt was the main intention of this PR to have the length check in the SSZ layer. The reason is that we came across a number of these bitfields in different places, and it seemed that it would be much more natural to have this length check at a lower layer. We think it does increase readability of the spec.\r\n\r\n> You could encode any data structure with a bitfield to JSON or others where the underlying bytes array would naturally be appropriately represented in the same way. We have to treat some byte arrays different than other byte arrays and this adds unnecessary complexity.\r\n\r\nI don't understand this part, could you clarify? My recommendation is that you just don't treat bitfields as bytes, but as a separate object, that is just a list of booleans with a special way of serializing it. That should be possible in any implementation, even if you serialize to yaml or JSON?\r\n\r\nHere are some answers to your question in the Hackmd:\r\n\r\n> This appears to have moved from the phase 0 spec into the custody game spec for phase 1. It also appears to have been renamed to get_bit.\r\n\r\nThis is just temporary because there will be larger changes to the phase 1, and we will make it completely use the SSZ bitfields. There will be no more need for get_bit, it will all be handled by SSZ.\r\n\r\n> What isn’t clear is how does ssz know what the committee size is? Removing this validation loosens overall validation on justification and finalization during epoch processing. I recommend client implementors keep this validation and we restore it in the specification.\r\n\r\nSSZ does not know the committee size, but it now knows the bitfield size. There was a bug where this size was not checked, which has now been fixed by Justin in #1264 .\r\n\r\n> Bitlists with padding bit seems like a change we don’t need given the added cost and no clear benefit.\r\n\r\nThe benefit is that we have a well defined length of every bitfield object.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508049432/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508093907",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508093907",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508093907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODA5MzkwNw==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T13:30:39Z",
    "updated_at": "2019-07-03T13:35:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I don't understand this part, could you clarify? My recommendation is that you just don't treat bitfields as bytes, but as a separate object, that is just a list of booleans with a special way of serializing it. That should be possible in any implementation, even if you serialize to yaml or JSON?\r\n\r\nI'll try to come up with a contrived example. \r\n\r\nImagine that we have a bitlist of length 8 where the data is `0b00111111`. \r\nAlso imagine we have a data structure that exists of primitive types.\r\n```go\r\ntype Data struct {\r\n   Num uint64      `json:\"num\"`\r\n   Bitfield []byte `json:\"bitifeld\"`\r\n   Name string     `json:\"name\"`\r\n}\r\n```\r\n\r\nNow if we look at the JSON representation of this object:\r\n```javascript\r\n{\r\n   \"num\": 5,\r\n   \"bitfield\": \"8w==\", // Or 0xF3 if you prefer\r\n    \"string\": \"hello\"\r\n}\r\n```\r\nThis JSON can populate the go struct without any special handling or processing. It just works. \r\n\r\nBefore #1226, the SSZ representation of the bitfield would be 0xF3 as well. These data representations are interchangeable between the two. \r\n\r\nNow, you have this padding bit metadata. So the bitlist would be serialized to 0x3F01 in SSZ. If we were to put this same data in JSON and use that data to populate our primitive `[]byte` field, we would have data that looks like\r\n\r\n```go\r\n[]byte{0b00111111, 0b00000001} \r\n```\r\n\r\nSo now we have to do a second round a processing this data.\r\n\r\n1. Populate the structure with the data from JSON\r\n1. Then go back and clean up any bitfields, removing the length bit. \r\n\r\nLikewise with marshaling to JSON and remain compatible with SSZ primitives \r\n1. Edit any bitfields to add the padding bit \r\n1. Marshal to JSON\r\n\r\n\r\nAn alternative is to change our struct to\r\n```go\r\ntype Data struct {\r\n   Num uint64      `json:\"num\"`\r\n   Bitfield struct{\r\n      Data []byte `json:\"data\"`\r\n      Length uint64 `json:\"length\"`\r\n   } `json:\"bitifeld\"`\r\n   Name string     `json:\"name\"`\r\n}\r\n```\r\n\r\nBut now our JSON object from earlier doesn't map so we have to change that representation to the following:\r\n```javascript\r\n{\r\n   \"num\": 5,\r\n   \"bitfield\": {\r\n       \"data\": \"8w==\", // Or 0xF3 if you prefer\r\n        \"length\": 8,\r\n     },\r\n    \"string\": \"hello\"\r\n}\r\n```\r\n\r\n> SSZ does not know the committee size, but it now knows the bitfield size. \r\n\r\nSSZ doesn't need to know either of these things. The bitlist is an unbounded/dynamic array of bytes in ssz. I offered a solution in the original issue description for handling expected bitlist lengths that were not a multiple of 8. \r\n\r\n> The benefit is that we have a well defined length of every bitfield object.\r\n\r\nWe already knew what to expect for bits length in processing.\r\n\r\nI strong urge you to reconsider this change. It may improve readability in python but comes with a non-trivial increase in complexity. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508093907/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508099470",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508099470",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508099470,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODA5OTQ3MA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T13:45:08Z",
    "updated_at": "2019-07-03T13:45:08Z",
    "author_association": "MEMBER",
    "body": "What if you just have your bitfield `Bitfield []byte` already be in the serialized SSZ format? Then all the information would be contained in this data structure.\r\n\r\n> SSZ doesn't need to know either of these things.\r\n\r\nThe argument here is that SSZ is a strictly better typing library if it handles lengths of lists safely, i.e. it is aware of the exact length of a list and can catch an out of bounds access. This change makes bitlists behave in exactly the same way any other kind of lists behave. It pushes a very slight bit of complexity into the SSZ layer, and removes a larger amount of complexity from the application layer.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508099470/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508100573",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508100573",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508100573,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODEwMDU3Mw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T13:47:54Z",
    "updated_at": "2019-07-03T13:48:09Z",
    "author_association": "MEMBER",
    "body": "While I do think it is natural to enforce bitlist lengths in consensus via Merkleisation length mix-ins, there is wiggle room to experiment with alternative serialisations if the currently suggested serialisation is too painful to deal with. Indeed, the consensus part of phase 0 (deposit contract, state transition function, fork choice rule) is agnostic to serialisation. In other words, serialisation is an implementation detail not part of the remit of the spec freeze.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508100573/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508127231",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508127231",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508127231,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODEyNzIzMQ==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T14:51:57Z",
    "updated_at": "2019-07-03T14:51:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Indeed, the consensus part of phase 0 (deposit contract, state transition function, fork choice rule) is agnostic to serialisation\r\n\r\nI would think alternative serializations would have an impact to changing state transition function. Ex: if we don't enforce length check in the SSZ layer, state transition will now need to check block body's operation lengths, validator length for shuffling...etc\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508127231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508160153",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508160153",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508160153,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODE2MDE1Mw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T16:15:41Z",
    "updated_at": "2019-07-03T16:15:41Z",
    "author_association": "MEMBER",
    "body": "Go is somewhat painfull here due to the lack of static-type parametrization, but you can work around it reasonably well. I.e. you keep the leading bit in memory for bitlists to derive the length from. And for bitvectors you declare it as byte array (fixed size) and put a Count method on it to tell the bit length. Your SSZ lib can instantiate a default value, and derive the length from there, since there are no type/class/static-methods in Go to work with. Or you make Count run on a pointer receiver, and you can use a typed nil to call the bit-count function on.\r\n\r\nHere's a POC: https://play.golang.org/p/fiCVRA5_1jS\r\n\r\nThis should enable you to read it from hex/yaml, like any other `[]byte` and `[N]byte`. The functions attached to the type will handle the logic, no constructor or encode-decode overrides necessary. Go sure is different than Python, JS, etc.\r\n\r\nBitvectors cost you a few lines to define a different length, but there's simply no generics/parametrization/inheritance to do it with. And it's not a struct, so no embedding either. But this works well enough, although Go certainly is not \"pretty\" here.\r\n\r\nCarelessly being able to convert from `Bitvector[:]` to `[]byte` to `Bitlist` is the benefit however, and SSZ serialization/deserialization is basically free (copy over bytes in one go, check length, and done).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508160153/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508167895",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508167895",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508167895,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODE2Nzg5NQ==",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T16:38:15Z",
    "updated_at": "2019-07-03T16:38:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @dankrad \r\n\r\n> What if you just have your bitfield Bitfield []byte already be in the serialized SSZ format? Then all the information would be contained in this data structure.\r\n\r\nThis is highly non-standard and enforces one more cognitive leap for someone attempting to read our serialization code + use our libraries. It adds more \"gotchas\" that shouldn't exist in the first place. I can't think of an encoding library that would do this. We certainly would _never_ expect the canonical Go JSON encoder to enforce that a list of something never exceeds 10 elements, and for good reason.\r\n\r\n@protolambda \r\n> Bitvectors cost you a few lines to define a different length, but there's simply no generics/parametrization/inheritance to do it with. And it's not a struct, so no embedding either. But this works well enough, although Go certainly is not \"pretty\" here.\r\n\r\nWhy do we need to work around that? Why not just handle it at the application layer in the first place? Aside from being quite messy and difficult to grok, using something akin to that Go playground would add large complexity to our SSZ and lack of readability. That also makes assumptions about the structure of our SSZ library. It is unreasonable to need to do that sort of logic for something that could have been avoided in the first place.\r\n\r\nOur point is less about the difficulty of doing it in Go and more that this adds significant constraints to our tooling and forces SSZ to make assumptions that other serialization libraries would never enforce given they are supposed to be agnostic to use cases. \r\n\r\nWhen approaching SSZ, we sought out to build it following the mindset and API's of other popular, agnostic serialization libraries that focus simplicity and do not take on application layer or use-case complexity. This change means **we have to use SSZ for everything**, and **encourages lock-in**, as it is what does length enforcement instead of it living in the application layer.\r\n\r\nOn behalf of our entire team and keeping in mind the goals of SSZ as a generic, agnostic, and _simple_ serialization library, we kindly ask to please reconsider this change, as v0.7.1 SSZ maintained a higher level of simplicity and a more robust, agnostic specification with respect to these primitives than what we see in v0.8's design decisions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508167895/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508198811",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508198811",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508198811,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODE5ODgxMQ==",
    "user": {
      "login": "wemeetagain",
      "id": 1348242,
      "node_id": "MDQ6VXNlcjEzNDgyNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1348242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wemeetagain",
      "html_url": "https://github.com/wemeetagain",
      "followers_url": "https://api.github.com/users/wemeetagain/followers",
      "following_url": "https://api.github.com/users/wemeetagain/following{/other_user}",
      "gists_url": "https://api.github.com/users/wemeetagain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wemeetagain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wemeetagain/subscriptions",
      "organizations_url": "https://api.github.com/users/wemeetagain/orgs",
      "repos_url": "https://api.github.com/users/wemeetagain/repos",
      "events_url": "https://api.github.com/users/wemeetagain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wemeetagain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-03T18:06:17Z",
    "updated_at": "2019-07-03T18:06:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "> My recommendation is that you just don't treat bitfields as bytes, but as a separate object, that is just a list of booleans with a special way of serializing it.\r\n\r\nI think part of the friction is around the fact that practically speaking, any performant implementation is going to want to represent a bitlist as bytes, like a bitfield. But by imbuing a bitlist with its length information, we can no longer just use the bytes primitive as is. This is the first type that is not a primitive in any language to be added to ssz. The non-standard convention of the padding bit / length information practically requires an additional type to be supported.\r\n\r\nIts this disconnect between this pseudo-bitfield and the widely-known pattern of bitfield usage that is a little troubling. The switch to thinking about bitfields as \"lists of bits\" creates different machinery and potentially different semantics than a normal bitfield.\r\n\r\nDoes the bitlist need to grow/shrink? Does bit access beyond the bitlength but within the bytelength throw an error? What operations does it support? These are new questions that need to be addressed by a 'bitlist' implementor. The lack of specification and unknown future usage of bitlists makes it difficult to build out what amounts to a custom data type library.\r\n\r\nI'm curious if there are known tangible benefits from tracking the bitlist length? I understand the typing is more robust, but why do we need/want it within ssz? What will we need to be doing with bitlists that we can't be doing with bitfields/bytes in our application?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508198811/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508331558",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508331558",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508331558,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODMzMTU1OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T04:16:05Z",
    "updated_at": "2019-07-04T04:16:05Z",
    "author_association": "MEMBER",
    "body": "This is tricky because SSZ implicitly assumes that there are two levels of \"staticness of length\" of a type: (i) known at \"compile time\", (ii) not known until you receive the object. Case (i) corresponds to `Vector[foo, n]`, case (ii) corresponds to `List[foo,n]`. But attestations are a strange third type, where the length is NOT known at compile time, but it's also known before we get the list, because it's proportional to the length of the committee size. So a variable length type is necessary, but we don't technically _have to_ specify the exact length. So this specific kind of dynamicness that we see with attestations is worst-case for SSZ.\r\n\r\nI could foresee usecases in the future where the fully dynamic bitlist is valuable; representing Merkle paths in SSZ objects is one big example.\r\n\r\nI'm personally okay with going back to bitfields being an application-layer concept if desired; it's a small change either way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508331558/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508490096",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508490096",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508490096,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODQ5MDA5Ng==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T13:52:01Z",
    "updated_at": "2019-07-04T15:49:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "Pros:\r\n- ~None?~\r\n- Spec simplicity (depending on your perspective) \r\n- Ability to populate a clear bitlist abstraction from the encoding data.\r\n\r\nCons: \r\n- When len(bitfield) % 8 == 0, the encoding size increases by 1 byte\r\n- The expected length can be inferred at runtime for verification already \r\n- Including the bitlist length in ssz encoding requires workarounds\r\n- Most implementations would verify the expected length in runtime processing at the application layer in addition to decoding any ssz container\r\n- Increased complexity of ssz libraries\r\n\r\n~I think its a clear win to revert this, especially if its a small change.~ Let me know what you think. \r\n\r\nEdit: Updated with a nice pro after chatting with @dankrad on the phone. It's not such a clear win now :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508490096/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508492294",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508492294",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508492294,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODQ5MjI5NA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T13:58:41Z",
    "updated_at": "2019-07-04T14:18:58Z",
    "author_association": "MEMBER",
    "body": "> if we don't enforce length check in the SSZ layer, state transition will now need to check block body's operation lengths, validator length for shuffling...etc\r\n\r\nRight, you can do that if you want :) The spec freeze does not prevent implementers from not enforcing the length check in their (de)serialisation layer, and instead pushing the check at a higher layer to keep the abstract state transition equivalent and maintain compatibility with the frozen spec. It's an implementation detail.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508492294/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508502334",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508502334",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508502334,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODUwMjMzNA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T14:30:26Z",
    "updated_at": "2019-07-04T15:48:54Z",
    "author_association": "MEMBER",
    "body": "> Pros:\r\n> \r\n>     * None?\r\n> \r\n>     * Spec simplicity (depending on your perspective)\r\n * Consistency with other kinds of lists (all of them have a clearly defined length, bitlist is the exception here -- why should a programmer have to think different about bitlists compared to other kinds of lists?)\r\n * Better readability of the spec (and also any other program that makes use of SSZ+bitlists in the future)\r\n * Type safety (In this particular case, the length is known from another place, but in general, it is preferrable that all types come with the same kind of guarantees)\r\n * assert len(bitlist) == expected_length is easier to read and reason about than verify_bitlist(...)\r\n\r\n> Cons:\r\n> \r\n>     * When len(bitfield) % 8 == 0, the encoding size increases by 1 byte\r\nThis difference is extremely small (one bit on average!)\r\n\r\n>     * The expected length can be inferred at runtime for verification already\r\nThat's not a con, that's a neutral one. It only applies in this case.\r\n\r\n>     * Including the bitlist length in ssz encoding requires workarounds\r\n>     * Most implementations would verify the expected length in runtime processing at the application layer in addition to decoding any ssz container\r\n>     * Increased complexity of ssz libraries\r\n\r\nI think the increase in complexity here is a bit overblown :)\r\n\r\n> I think its a clear win to revert this, especially if its a small change. Let me know what you think.\r\n\r\nWell, I think your list of pros and cons is a bit biased. I think we're all willing to engage in the discussion here, but please let's keep it at the technical layer.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508502334/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508519254",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508519254",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508519254,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODUxOTI1NA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T15:28:02Z",
    "updated_at": "2019-07-04T15:28:02Z",
    "author_association": "MEMBER",
    "body": "@prestonvanloon Would you be happier if every `Bitlist[N]` was replaced by `Container{bits: Bitvector[N], length: uint256}`, with the length check done in the state transition function? :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508519254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508524453",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508524453",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508524453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODUyNDQ1Mw==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T15:47:52Z",
    "updated_at": "2019-07-04T15:47:52Z",
    "author_association": "MEMBER",
    "body": "I just had a quick chat with @prestonvanloon about this. Currently, the solutions available to us seem:\r\n\r\n1. Go with @protolambda's POC, which basically always uses the serialized version in memory. Then Bitlists can still be represented by bytes without a problem with naturally using yaml/json libraries.\r\n\r\n- In this case, the SSZ libraries should still present the appropriate methods for getting/setting bits and for getting the length, with the corresponding safety in terms of length checking.\r\n- We might want to consider to change Merkleizationif we go this way, because currently, the length checking bit is not added for Merkleization [Disadvantage: a bitlist of max length 2^n could have a bitlength of 2^n+1, needing 2^(n+1) bits at the bottom of the Merkle tree effectively...]\r\n\r\n2. @JustinDrake's suggestion; another possibility would be to use this as the representation of the Bitlist inside SSZ, thus getting rid of the leading bit\r\n\r\n3. Removing Bitlists entirely and going back to the status before the change, with separate Bitlist checks inside the spec",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508524453/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508528312",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508528312",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508528312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODUyODMxMg==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T16:03:53Z",
    "updated_at": "2019-07-04T16:03:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the recap @dankrad. The offline discussion was much needed. \r\n\r\nThe primary motivation for using a bitlist abstraction is that the bit getters/setters are much more intuitive than bitwise operations. Different languages may represent and maintain the underlying data in different ways, i.e. python might be a list of booleans while others might use some container with bytes / length or use the ssz encoded format with the length bit present. \r\n\r\nThe trade off is clear: you cannot simply construct this bitlist abstraction _without_ the length information. \r\n\r\nWith that said, our original position was option 3 as we did not fully understand the trade offs. Now, we are leaning more towards option 1 where we can keep the length information in the optimized form as suggested by @dankrad with an abstraction pattern suggested by @protolambda or a backing container in our implementation as @JustinDrake suggested. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508528312/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 2,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508567531",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1266#issuecomment-508567531",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1266",
    "id": 508567531,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwODU2NzUzMQ==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-07-04T20:04:54Z",
    "updated_at": "2019-07-04T20:04:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'll go ahead and close this. \r\n\r\nHappy to reopen if anyone has any further ideas or comments. Thanks all!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/508567531/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
