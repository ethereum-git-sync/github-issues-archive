{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1340",
  "id": 477537512,
  "node_id": "MDU6SXNzdWU0Nzc1Mzc1MTI=",
  "number": 1340,
  "title": "Simplifying empty epoch transitions",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1437528763,
      "node_id": "MDU6TGFiZWwxNDM3NTI4NzYz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/post-freeze%20(substantive)",
      "name": "post-freeze (substantive)",
      "color": "991a40",
      "default": false,
      "description": "Substantive consensus change non-critical for long-lived cross-client testnets"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2019-08-06T18:46:09Z",
  "updated_at": "2021-07-05T15:07:17Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "See also: https://github.com/ethereum/eth2.0-specs/issues/1339\r\n\r\nSuppose that you receive a block that specifies a parent 100 epochs in the past, and want to verify it. Currently, this requires processing through 6400 slot transitions (fortunately trivial) but also 100 epoch transitions, each of which take O(N) effort because they involve per-validator work, particularly updating everyone's balances. Hence, the cost of doing this verification may be prohibitive. The largest part of the epoch transition work, computing the compact committees root, is [now being removed](https://github.com/ethereum/eth2.0-specs/pull/1329), but can we simplify things further?\r\n\r\nFirst, let's enumerate all of the O(N) computations that are happening in an empty epoch transition (defined here for simplicity as an epoch transition in a situation where both the current and previous epochs had no blocks). Here is the `process_epoch` function: https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#epoch-processing\r\n\r\n```python\r\ndef process_epoch(state: BeaconState) -> None:\r\n    process_justification_and_finalization(state)\r\n    process_crosslinks(state)\r\n    process_rewards_and_penalties(state)\r\n    process_registry_updates(state)\r\n    process_slashings(state)\r\n    process_final_updates(state)\r\n```\r\n\r\nThis is essentially the only complex thing happening in 6400 slots worth of transitions; slot transitions are just a small number of hash tree updates each. So let's go through these functions one by one.\r\n\r\n#### `process_justification_and_finalization`\r\n\r\nThe only non-O(1) work in this function is computing `matching_target_attestations = get_matching_target_attestations(state, previous_epoch)` and computing its total balance. However, in the no-block case we can simply hard-code this to `[]` (and the total balance to 0), and so it is trivial.\r\n\r\n#### `process_crosslinks`\r\n\r\nHere is the entire function:\r\n\r\n```python\r\ndef process_crosslinks(state: BeaconState) -> None:\r\n    state.previous_crosslinks = [c for c in state.current_crosslinks]\r\n    for epoch in (get_previous_epoch(state), get_current_epoch(state)):\r\n        for offset in range(get_committee_count(state, epoch)):\r\n            shard = Shard((get_start_shard(state, epoch) + offset) % SHARD_COUNT)\r\n            crosslink_committee = set(get_crosslink_committee(state, epoch, shard))\r\n            winning_crosslink, attesting_indices = get_winning_crosslink_and_attesting_indices(state, epoch, shard)\r\n            if 3 * get_total_balance(state, attesting_indices) >= 2 * get_total_balance(state, crosslink_committee):\r\n                state.current_crosslinks[shard] = winning_crosslink\r\n```\r\n\r\nAs written, this requires computing every crosslink committee using `get_crosslink_committee`. However, the only state transition is `state.current_crosslinks[shard] = winning_crosslink`, which we know will never happen in an empty epoch, so we can just add special case code to bypass this function entirely in that case.\r\n\r\n#### `process_registry_updates`\r\n\r\nThis function processes the activation queue, which has a throughput of `|V| / 65536` (ie. max 64) validators per epoch. So it's more significant than the truly O(1) functions, but still minor. It also processes the conditions for activation eligibility, hitting max balance, which cannot happen unless other objects such as deposits and transfers are being included in any case, and the condition for exit eligibility, falling below half balance, which will also happen rarely.\r\n\r\n#### `process_slashings`\r\n\r\n`get_total_active_balance` is O(N), though fortunately it only needs to be run if any post-slashed validators actually are getting processed for post-slashing penalties. This can only happen once per slashed validator, so should happen rarely.\r\n\r\n#### `process_final_updates`\r\n\r\nAside from code that is going away soon (computing active index and compact committee roots), and O(1) code, the main thing happening here is updates to effective balance. The hysteresis adjustment mechanism ensures that a validator balance change of at most 0.5 ETH is required to trigger an effective balance update. This is likely to be the bulk of the processing other than the `process_rewards_and_penalties` function below. Fortunately, the proposal given below will also remove the need to run this code.\r\n\r\n### `process_rewards_and_penalties`\r\n\r\nThis involves computing (i) `get_attestation_deltas` and (ii) `get_crosslink_deltas` and using the returned rewards and penalties to adjust every validator's balances. This is the bulk of the computational complexity for processing an epoch transition.\r\n\r\nThere are four rewards/penalties that could be applied to a validator in `get_attestation_deltas`; three are covered by this code:\r\n\r\n```python\r\n    for attestations in (matching_source_attestations, matching_target_attestations, matching_head_attestations):\r\n        unslashed_attesting_indices = get_unslashed_attesting_indices(state, attestations)\r\n        attesting_balance = get_total_balance(state, unslashed_attesting_indices)\r\n        for index in eligible_validator_indices:\r\n            if index in unslashed_attesting_indices:\r\n                rewards[index] += get_base_reward(state, index) * attesting_balance // total_balance\r\n            else:\r\n                penalties[index] += get_base_reward(state, index)\r\n```\r\n\r\nIn an empty epoch, `unslashed_attesting_indices == []`, so all `eligible_validator_indices` are penalized, where `eligible_validator_indices` is defined as:\r\n\r\n```python\r\n[\r\n        ValidatorIndex(index) for index, v in enumerate(state.validators)\r\n        if is_active_validator(v, previous_epoch) or (v.slashed and previous_epoch + 1 < v.withdrawable_epoch)\r\n    ]\r\n```\r\n\r\nThe fourth kind of reward, \"Proposer and inclusion delay micro-rewards\", can be skipped as `get_unslashed_attesting_indices(state, matching_source_attestations) = []`. The fourth kind of penalty, the inactivity leak, applies to all `eligible_validator_indices` not in `matching_target_attesting_indices` (also an empty list), so it applies to all `eligible_validator_indices`.\r\n\r\nIn `get_crosslink_deltas`, once again no index is attesting so no one is rewarded, but every index in every committee is penalized. Though this is not immediately obvious from looking, every active validator is in exactly one crosslink committee, so every validator in `get_active_validator_indices(state, epoch)` gets penalized the same amount (NOTE: there is a slight difference between here and the above penalties, in that slashed validators are eligible for rewards in `get_attestation_deltas` but not here.\r\n\r\n### Proposed protocol changes\r\n\r\nFrom the above, we can see that in an empty epoch, computing any committee is never actually necessary (except for the very limited case of computing one or a few shuffled indices to determine the proposer); rather, all that we need to do is penalize every validator, and in fact penalize each validator the same portion of their balance.\r\n\r\nWe can make this considerably easier as follows. First, we can remove the penalties from `get_attestation_deltas` and `get_crosslink_deltas`; instead, we can consider adding a third `get_penalties` function to compute a single penalty that would apply to all active validators (to cancel out the penalties for those validators that participated in each reward-receiving reaction, the rewards for those actions would be increased).\r\n\r\nBut instead, we can take a more radical path. We add to the state a variable `penalty_denominator`, which starts off at some constant `PENALTY_BASE` (eg. 2**20). Instead of applying a penalty of `balance * num / den`, we set `penalty_denominator += penalty_denominator * num / den`. We also abstract `eligible_indices` into a function:\r\n\r\n```python\r\ndef get_eligible_validator_indices(state: BeaconState, epoch: Epoch) -> Sequence[ValidatorIndex]:\r\n    return [\r\n            ValidatorIndex(index) for index, v in enumerate(state.validators)\r\n            if is_active_validator(v, epoch) or (v.slashed and epoch + 1 < v.withdrawable_epoch)\r\n    ]\r\n```\r\n\r\nThen, we add a function to the start of `process_block`, which says:\r\n\r\n```python\r\ndef reset_penalty_denominator(state: BeaconState):\r\n    if state.penalty_denominator > PENALTY_BASE:\r\n        for index in get_eligible_validator_indices(state, get_previous_epoch(state)):\r\n            new_balance = state.balances[index] * PENALTY_BASE // state.penalty_denominator\r\n            decrease_balance(validator, state.balances[index] - new_balance)\r\n        state.penalty_denominator = PENALTY_BASE\r\n```\r\n\r\nWe also need code in `process_epoch` to process penalties for validators when they exit the eligible set:\r\n\r\n```python\r\neligible_now = get_eligible_validator_indices(state, get_previous_epoch(state))\r\neligible_before = get_eligible_validator_indices(state, max(get_previous_epoch(state), 1) - 1)\r\nfor index in range(len(state.validators)):\r\n    if index in eligible_before and index not in eligible_now:\r\n        new_balance = state.balances[index] * PENALTY_BASE // state.penalty_denominator\r\n        decrease_balance(validator, state.balances[index] - new_balance)\r\n```\r\n\r\nThis last piece of code is O(N) as written, but with data structures can be made to be <= O(log(N)), eg. via a priority queue, triggering only when a validator moves from eligible to ineligible status. `reset_penalty_denominator` is O(N), but would only run once when a block appears, so would not need to be run per epoch. This way we can massively decrease the cost of processing an epoch transition in the case where an epoch is empty.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340/reactions",
    "total_count": 3,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 3,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/519056756",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1340#issuecomment-519056756",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340",
    "id": 519056756,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTA1Njc1Ng==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-07T11:29:04Z",
    "updated_at": "2019-08-07T11:29:04Z",
    "author_association": "MEMBER",
    "body": "> `get_total_active_balance` is O(N)\r\n\r\nCan we keep track of (i.e. cache) total balance (incrementally modifying it if the effective balance of a validator changes), making `get_total_active_balance` O(1)?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/519056756/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/519156312",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1340#issuecomment-519156312",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1340",
    "id": 519156312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTE1NjMxMg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-07T15:48:16Z",
    "updated_at": "2019-08-07T15:48:16Z",
    "author_association": "MEMBER",
    "body": "Yep! That's definitely another important optimization. In fact, during an empty epoch, the only time total active balance should change is when a validator enters or exits the validator set.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/519156312/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
