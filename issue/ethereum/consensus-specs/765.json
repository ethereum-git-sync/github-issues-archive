{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/765",
  "id": 420340950,
  "node_id": "MDU6SXNzdWU0MjAzNDA5NTA=",
  "number": 765,
  "title": "Light client protocol standardization",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2019-03-13T06:42:15Z",
  "updated_at": "2019-03-13T07:56:16Z",
  "closed_at": "2019-03-13T07:56:16Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Generalized Merkle tree index\r\n\r\nIn a binary Merkle tree, we define a \"generalized index\" of a node as `2**depth + index`. Visually, this looks as follows:\r\n\r\n```\r\n    1\r\n 2     3\r\n4 5   6 7\r\n   ...\r\n```\r\n\r\nNote that the generalized index has the convenient property that the two children of node `k` are `2k` and `2k+1`, and also that it equals the position of a node in the linear representation of the Merkle tree that's computed by this function:\r\n\r\n```python\r\ndef merkle_tree(leaves):\r\n    o = [0] * len(leaves) + leaves\r\n    for i in range(len(leaves)-1, 0, -1):\r\n        o[i] = hash(o[i*2] + o[i*2+1])\r\n    return o\r\n```\r\n\r\nWe will define Merkle proofs in terms of generalized indices.\r\n\r\n### SSZ object to index\r\n\r\nWe can describe the hash tree of any SSZ object, rooted in `hash_tree_root(object)`, as a binary Merkle tree whose depth may vary. For example, an object `{x: bytes32, y: List[uint64]}` would look as follows:\r\n\r\n```\r\n     root\r\n    /    \\\r\n   x    y_root\r\n        /    \\\r\ny_data_root  len(y)\r\n    / \\\r\n   /\\ /\\\r\n  .......\r\n```\r\n\r\nWe can now define a concept of a \"path\", a way of describing a function that takes as input an SSZ object and outputs some specific (possibly deeply nested) member. For example, `foo -> foo.x` is a path, as are `foo -> len(foo.y)` and `foo -> foo[5]`. We'll describe paths as lists: in these three cases they are `[\"x\"]`, `[\"y\", \"len\"]` and `[\"y\", 5]` respectively. We can now define a function `get_generalized_indices(object: Any, path: List[str OR int], root=1: int) -> int` that converts an object and a path to a set of generalized indices (note that for constant-sized objects, there is only one generalized index and it only depends on the path, but for dynamically sized objects the indices may depend on the object itself too). For dynamically-sized objects, the set of indices will have more than one member because of the need to access an array's length to determine the correct generalized index for some array access.\r\n\r\n```python\r\ndef get_generalized_indices(obj: Any, path: List[str or int], root=1) -> List[int]:\r\n    if len(path) == 0:\r\n        return [root]\r\n    elif isinstance(obj, StaticList):\r\n        items_per_chunk = (32 // len(serialize(x))) if isinstance(x, int) else 1\r\n        new_root = root * next_power_of_2(len(obj) // items_per_chunk) + path[0] // items_per_chunk\r\n        return get_generalized_indices(obj[path[0]], path[1:], new_root)\r\n    elif isinstance(obj, DynamicList) and path[0] == \"len\":\r\n        return [root * 2 + 1]\r\n    elif isinstance(obj, DynamicList) and isinstance(path[0], int):\r\n        assert path[0] < len(obj)\r\n        items_per_chunk = (32 // len(serialize(x))) if isinstance(x, int) else 1\r\n        new_root = root * 2 * next_power_of_2(len(obj) // items_per_chunk) + path[0] // items_per_chunk\r\n        return [root *2 + 1] + get_generalized_indices(obj[path[0]], path[1:], new_root)\r\n    elif hasattr(obj, \"fields\"):\r\n        index = list(fields.keys()).index(path[0])\r\n        new_root = root * next_power_of_2(len(fields)) + index\r\n        return get_generalized_indices(getattr(obj, path[0]), path[1:], new_root)\r\n    else:\r\n        raise Exception(\"Unknown type / path\")\r\n```\r\n\r\n### Merkle multiproofs\r\n\r\nWe define a Merkle multiproof as a minimal subset of nodes in a Merkle tree needed to fully authenticate that a set of nodes actually are part of a Merkle tree with some specified root, at a particular set of generalized indices. For example, here is the Merkle multiproof for positions 0, 1, 6 in an 8-node Merkle tree (ie. generalized indices 8, 9, 14):\r\n\r\n```\r\n       .\r\n   .       .\r\n .   *   *   .\r\nx x . . . . x *\r\n```\r\n\r\n. are unused nodes, * are used nodes, x are the values we are trying to prove. Notice how despite being a multiproof for 3 values, it requires only 3 auxiliary nodes, only one node more than would be required to prove a single value. Normally the efficiency gains are not quite that extreme, but the savings relative to individual Merkle proofs are still significant. As a rule of thumb, a multiproof for k nodes at the same level of an n-node tree has size `k * (n/k + log(n/k))`.\r\n\r\nHere is code for creating and verifying a multiproof. First a helper:\r\n\r\n```python\r\ndef log2(x):\r\n    return 0 if x == 1 else 1 + log2(x//2)\r\n```\r\n\r\nFirst, a method for computing the generalized indices of the auxiliary tree nodes that a proof of a given set of generalized indices will require:\r\n\r\n```python\r\ndef get_proof_indices(tree_indices: List[int]) -> List[int]:\r\n    # Get all indices touched by the proof\r\n    maximal_indices = set({})\r\n    for i in tree_indices:\r\n        x = i\r\n        while x > 1:\r\n            maximal_indices.add(x ^ 1)\r\n            x //= 2\r\n    maximal_indices = tree_indices + sorted(list(maximal_indices))[::-1]\r\n    # Get indices that cannot be recalculated from earlier indices\r\n    redundant_indices = set({})\r\n    proof = []\r\n    for index in maximal_indices:\r\n        if index not in redundant_indices:\r\n            proof.append(index)\r\n            while index > 1:\r\n                redundant_indices.add(index)\r\n                if (index ^ 1) not in redundant_indices:\r\n                    break\r\n                index //= 2\r\n    return [i for i in proof if i not in tree_indices]\r\n````\r\n\r\nGenerating a proof is simply a matter of taking the node of the SSZ hash tree with the union of the given generalized indices for each index given by `get_proof_indices`, and outputting the list of nodes in the same order.\r\n\r\n```python\r\ndef verify_multi_proof(root, indices, leaves, proof):\r\n    tree = {}\r\n    for index, leaf in zip(indices, leaves):\r\n        tree[index] = leaf\r\n    for index, proofitem in zip(get_proof_indices(indices), proof):\r\n        tree[index] = proofitem\r\n    indexqueue = sorted(tree.keys())[:-1]\r\n    i = 0\r\n    while i < len(indexqueue):\r\n        index = indexqueue[i]\r\n        if index >= 2 and index^1 in tree:\r\n            tree[index//2] = hash(tree[index - index%2] + tree[index - index%2 + 1])\r\n            indexqueue.append(index//2)\r\n        i += 1\r\n    return (indices == []) or (1 in tree and tree[1] == root)\r\n```\r\n\r\n#### Proofs for execution\r\n\r\nWe define `MerklePartial(f, arg1, arg2...)` as being a list of Merkle multiproofs of the sets of nodes in the hash trees of the SSZ objects that are needed to authenticate the values needed to compute some function `f(arg1, arg2...)`. An individual Merkle multiproof is given as a dynamic sized list of `bytes32` values, a `MerklePartial` is a fixed-size list of objects `{proof: [\"bytes32\"], value: \"bytes32\"}`, one for each `arg` to `f` (if some `arg` is a base type, then the multiproof is empty). \r\n\r\nIdeally, any function which accepts an SSZ object should also be able to accept a `MerklePartial` object as a substitute.",
  "closed_by": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/765/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[

]
