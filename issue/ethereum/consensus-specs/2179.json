{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2179",
  "id": 783170661,
  "node_id": "MDU6SXNzdWU3ODMxNzA2NjE=",
  "number": 2179,
  "title": "merkle-proofs.md presentation",
  "user": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    },
    {
      "id": 1295439957,
      "node_id": "MDU6TGFiZWwxMjk1NDM5OTU3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:CI/tests/pyspec",
      "name": "scope:CI/tests/pyspec",
      "color": "BDC0BA",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2021-01-11T08:27:49Z",
  "updated_at": "2021-01-13T08:58:34Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Issue\r\n\r\n#### History and status-quo\r\n1. [Before] Pyspec used to implement the SSZ class library in a simple `.py` file. \r\n2. [Currently] Pyspec uses Proto's SSZ library [`remerkleable`](https://github.com/protolambda/remerkleable) for having the much more efficient `hash_tree_root`.\r\n    - Also, use some class methods and syntax sugar of `remekleable` in the test suites.\r\n3. We tried to avoid using Python dark magic in the specs, so [merkle-proofs.md](https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/merkle-proofs.md) implements the algorithm with simple tools and may be less efficient. \r\n4. #1901 proposes that making SSZ related specs to a standalone repo.\r\n\r\n#### Follow-up of https://github.com/ethereum/eth2.0-specs/pull/2147#discussion_r554659746 comment:\r\n> @vbuterin: Do we want generalized index logic to be \"human readable\"? If so, calling into a library that does weird class magic may not be the best choice and perhaps we could instead try to make it executable by pointing to https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/merkle-proofs.md#ssz-object-to-index ?\r\n\r\n### Discussion\r\n\r\nSince the light client patch (HF1) requires the generalized index scheme, we may want to include the Merkle proof algorithm as part of the specs now. Thus, I agreed that it makes sense to revisit it, make it executable (it should be able to be applied with `remerkleable` classes smoothly), and add tests to sync with client teams more effectively in the next few months.\r\n\r\nThere may have some trade-offs, e.g., we may make duplicate specs and delay #1901.\r\n\r\n/cc @protolambda, you may have the most comprehensive view of this topic. 🙏\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/757901471",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-757901471",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 757901471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1NzkwMTQ3MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-11T11:49:59Z",
    "updated_at": "2021-01-11T11:49:59Z",
    "author_association": "MEMBER",
    "body": "Currently, remerkleable paths are already very \"human readable\" (imo): e.g. `vote_path = Path(BeaconState) / 'eth1_data_votes' / 42 / 'block_hash'` is as readable as it gets. And it's not magic, it's inspired by https://docs.python.org/3/library/pathlib.html, and is as close to a URI path as we can get, while also keeping it typed.\r\n\r\nI'm convinced it's good to defer conversion of paths to generalized indices till the last moment possible. It's a lot easier to mess up combinations with integers than combining type-checked path components.\r\n\r\nA function like `def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -> GeneralizedIndex:`\r\ncould instead be: `def get_generalized_index(path: Path) -> GeneralizedIndex:`, and simply iterate through segments as `(typ, id)` tuples, doing otherwise the same logic as it does now.\r\n\r\n----\r\n\r\nThen for merkle proofs, we have two options:\r\n1. Work with `Bytes32`\r\n2. Work with `Node`, which has a root, and a left and right node.\r\n\r\nCurrently we've been doing the 1st, which is minimal and works well with full trees (since you can do that `i <- i*2, i*2+1` reduction thing in a flat array. And it's simple with single proofs too.\r\n\r\nHowever, with multi-proofs it's not nearly as attractive, since then you get into **`Dict[GeneralizedIndex, Bytes32]`** territory: storing paths for every single node in the proof. If we are dealing with multi-proofs, I prefer the structure of having left and right nodes.\r\n\r\nOne other thing to consider here are client implementations: will they build hashmaps with big-ints as keys to build a multi-merkle proof? In some languages this seems painful to even implement (since big ints are not valid primitives for keys), and probably is quite slow compared to the existing \"flat array\" approach for full proofs.\r\n\r\nAnd in other contexts that also want to optimize for proofs, e.g. a smart contract, they also will not use call-data with hashmaps in them. Proofs have structure, it doesn't make sense to wrap a binary tree into a hashtree.\r\n\r\nNow I'm not trying to optimize as much here, but I do think we should present it in a way that translates well to something that doesn't have to be completely re-approached for efficiency reasons. We'll end up with clients doing something completely different than the spec, making them difficult to audit. This happened before, e.g. with HF1 we are only now getting around to enshrining something alike to the participation tracking optimization, and that feature actually seems really good.\r\n\r\nSo I propose we keep basic abstractions around (a \"path\", a \"path iterator\", a \"node\"), letting clients can optimize it all they like in the implementations of these, but design towards them *using a very similar abstraction*.\r\n\r\n---\r\n\r\nLet's talk to end-users who will have to produce and consume these proofs. Then I'll change remerkleable to fit whatever direction works best.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/757901471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759287758",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-759287758",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 759287758,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTI4Nzc1OA==",
    "user": {
      "login": "mpetrunic",
      "id": 8836210,
      "node_id": "MDQ6VXNlcjg4MzYyMTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8836210?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mpetrunic",
      "html_url": "https://github.com/mpetrunic",
      "followers_url": "https://api.github.com/users/mpetrunic/followers",
      "following_url": "https://api.github.com/users/mpetrunic/following{/other_user}",
      "gists_url": "https://api.github.com/users/mpetrunic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mpetrunic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mpetrunic/subscriptions",
      "organizations_url": "https://api.github.com/users/mpetrunic/orgs",
      "repos_url": "https://api.github.com/users/mpetrunic/repos",
      "events_url": "https://api.github.com/users/mpetrunic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mpetrunic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-13T08:24:13Z",
    "updated_at": "2021-01-13T08:24:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "> A function like def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -> GeneralizedIndex:\r\ncould instead be: def get_generalized_index(path: Path) -> GeneralizedIndex:, and simply iterate through segments as (typ, id) tuples, doing otherwise the same logic as it does now.\r\n\r\nIn js using path would basically mean using and parsing string so in my initial implementation it's a lot easier and efficient to use api like `get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]])`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759287758/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759305714",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-759305714",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 759305714,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTMwNTcxNA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-13T08:58:34Z",
    "updated_at": "2021-01-13T08:58:34Z",
    "author_association": "MEMBER",
    "body": "@mpetrunic Sure, there are lots of ways to represent `Path`:\r\n- an `anchor_type, Sequence[Union[int, SSZVariableName]])` tuple (like now, but abstracted away)\r\n- an `anchor_type, GeneralizedIndex` tuple (what I think a Go/Rust implementation would naturally shift towards)\r\n- a literal URI string (not fast, but readable)\r\n- some kind of a pointer structure\r\n- something precomputed\r\n\r\nI think that if you convert the path to generalized index too early, you get bad (IMHO) things like `Dict[generalized_index, Value]`. I prefer making `Path` an interface, and allowing clients to do their own thing over the same spec abstraction. Having more context than an integer is nice to avoid the `Dict` etc. later on, and \"free\" if you defer converting a path to a generalized index.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759305714/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
