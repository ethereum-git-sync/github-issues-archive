{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2179",
  "id": 783170661,
  "node_id": "MDU6SXNzdWU3ODMxNzA2NjE=",
  "number": 2179,
  "title": "merkle-proofs.md presentation",
  "user": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    },
    {
      "id": 1295439957,
      "node_id": "MDU6TGFiZWwxMjk1NDM5OTU3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:CI/tests/pyspec",
      "name": "scope:CI/tests/pyspec",
      "color": "BDC0BA",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2021-01-11T08:27:49Z",
  "updated_at": "2023-01-23T15:58:51Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Issue\r\n\r\n#### History and status-quo\r\n1. [Before] Pyspec used to implement the SSZ class library in a simple `.py` file. \r\n2. [Currently] Pyspec uses Proto's SSZ library [`remerkleable`](https://github.com/protolambda/remerkleable) for having the much more efficient `hash_tree_root`.\r\n    - Also, use some class methods and syntax sugar of `remekleable` in the test suites.\r\n3. We tried to avoid using Python dark magic in the specs, so [merkle-proofs.md](https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/merkle-proofs.md) implements the algorithm with simple tools and may be less efficient. \r\n4. #1901 proposes that making SSZ related specs to a standalone repo.\r\n\r\n#### Follow-up of https://github.com/ethereum/eth2.0-specs/pull/2147#discussion_r554659746 comment:\r\n> @vbuterin: Do we want generalized index logic to be \"human readable\"? If so, calling into a library that does weird class magic may not be the best choice and perhaps we could instead try to make it executable by pointing to https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/merkle-proofs.md#ssz-object-to-index ?\r\n\r\n### Discussion\r\n\r\nSince the light client patch (HF1) requires the generalized index scheme, we may want to include the Merkle proof algorithm as part of the specs now. Thus, I agreed that it makes sense to revisit it, make it executable (it should be able to be applied with `remerkleable` classes smoothly), and add tests to sync with client teams more effectively in the next few months.\r\n\r\nThere may have some trade-offs, e.g., we may make duplicate specs and delay #1901.\r\n\r\n/cc @protolambda, you may have the most comprehensive view of this topic. ðŸ™\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/757901471",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-757901471",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 757901471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1NzkwMTQ3MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-11T11:49:59Z",
    "updated_at": "2021-01-11T11:49:59Z",
    "author_association": "MEMBER",
    "body": "Currently, remerkleable paths are already very \"human readable\" (imo): e.g. `vote_path = Path(BeaconState) / 'eth1_data_votes' / 42 / 'block_hash'` is as readable as it gets. And it's not magic, it's inspired by https://docs.python.org/3/library/pathlib.html, and is as close to a URI path as we can get, while also keeping it typed.\r\n\r\nI'm convinced it's good to defer conversion of paths to generalized indices till the last moment possible. It's a lot easier to mess up combinations with integers than combining type-checked path components.\r\n\r\nA function like `def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -> GeneralizedIndex:`\r\ncould instead be: `def get_generalized_index(path: Path) -> GeneralizedIndex:`, and simply iterate through segments as `(typ, id)` tuples, doing otherwise the same logic as it does now.\r\n\r\n----\r\n\r\nThen for merkle proofs, we have two options:\r\n1. Work with `Bytes32`\r\n2. Work with `Node`, which has a root, and a left and right node.\r\n\r\nCurrently we've been doing the 1st, which is minimal and works well with full trees (since you can do that `i <- i*2, i*2+1` reduction thing in a flat array. And it's simple with single proofs too.\r\n\r\nHowever, with multi-proofs it's not nearly as attractive, since then you get into **`Dict[GeneralizedIndex, Bytes32]`** territory: storing paths for every single node in the proof. If we are dealing with multi-proofs, I prefer the structure of having left and right nodes.\r\n\r\nOne other thing to consider here are client implementations: will they build hashmaps with big-ints as keys to build a multi-merkle proof? In some languages this seems painful to even implement (since big ints are not valid primitives for keys), and probably is quite slow compared to the existing \"flat array\" approach for full proofs.\r\n\r\nAnd in other contexts that also want to optimize for proofs, e.g. a smart contract, they also will not use call-data with hashmaps in them. Proofs have structure, it doesn't make sense to wrap a binary tree into a hashtree.\r\n\r\nNow I'm not trying to optimize as much here, but I do think we should present it in a way that translates well to something that doesn't have to be completely re-approached for efficiency reasons. We'll end up with clients doing something completely different than the spec, making them difficult to audit. This happened before, e.g. with HF1 we are only now getting around to enshrining something alike to the participation tracking optimization, and that feature actually seems really good.\r\n\r\nSo I propose we keep basic abstractions around (a \"path\", a \"path iterator\", a \"node\"), letting clients can optimize it all they like in the implementations of these, but design towards them *using a very similar abstraction*.\r\n\r\n---\r\n\r\nLet's talk to end-users who will have to produce and consume these proofs. Then I'll change remerkleable to fit whatever direction works best.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/757901471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759287758",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-759287758",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 759287758,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTI4Nzc1OA==",
    "user": {
      "login": "mpetrunic",
      "id": 8836210,
      "node_id": "MDQ6VXNlcjg4MzYyMTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8836210?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mpetrunic",
      "html_url": "https://github.com/mpetrunic",
      "followers_url": "https://api.github.com/users/mpetrunic/followers",
      "following_url": "https://api.github.com/users/mpetrunic/following{/other_user}",
      "gists_url": "https://api.github.com/users/mpetrunic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mpetrunic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mpetrunic/subscriptions",
      "organizations_url": "https://api.github.com/users/mpetrunic/orgs",
      "repos_url": "https://api.github.com/users/mpetrunic/repos",
      "events_url": "https://api.github.com/users/mpetrunic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mpetrunic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-13T08:24:13Z",
    "updated_at": "2021-01-13T08:24:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "> A function like def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -> GeneralizedIndex:\r\ncould instead be: def get_generalized_index(path: Path) -> GeneralizedIndex:, and simply iterate through segments as (typ, id) tuples, doing otherwise the same logic as it does now.\r\n\r\nIn js using path would basically mean using and parsing string so in my initial implementation it's a lot easier and efficient to use api like `get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]])`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759287758/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759305714",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-759305714",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 759305714,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTMwNTcxNA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-13T08:58:34Z",
    "updated_at": "2021-01-13T08:58:34Z",
    "author_association": "MEMBER",
    "body": "@mpetrunic Sure, there are lots of ways to represent `Path`:\r\n- an `anchor_type, Sequence[Union[int, SSZVariableName]])` tuple (like now, but abstracted away)\r\n- an `anchor_type, GeneralizedIndex` tuple (what I think a Go/Rust implementation would naturally shift towards)\r\n- a literal URI string (not fast, but readable)\r\n- some kind of a pointer structure\r\n- something precomputed\r\n\r\nI think that if you convert the path to generalized index too early, you get bad (IMHO) things like `Dict[generalized_index, Value]`. I prefer making `Path` an interface, and allowing clients to do their own thing over the same spec abstraction. Having more context than an integer is nice to avoid the `Dict` etc. later on, and \"free\" if you defer converting a path to a generalized index.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759305714/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399394344",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-1399394344",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 1399394344,
    "node_id": "IC_kwDOCOoGbc5TaRAo",
    "user": {
      "login": "samlaf",
      "id": 9342524,
      "node_id": "MDQ6VXNlcjkzNDI1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9342524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/samlaf",
      "html_url": "https://github.com/samlaf",
      "followers_url": "https://api.github.com/users/samlaf/followers",
      "following_url": "https://api.github.com/users/samlaf/following{/other_user}",
      "gists_url": "https://api.github.com/users/samlaf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/samlaf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/samlaf/subscriptions",
      "organizations_url": "https://api.github.com/users/samlaf/orgs",
      "repos_url": "https://api.github.com/users/samlaf/repos",
      "events_url": "https://api.github.com/users/samlaf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/samlaf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-22T03:19:27Z",
    "updated_at": "2023-01-22T03:27:12Z",
    "author_association": "NONE",
    "body": "Is merkle-proofs.md supposed to be runnable code?\r\nI've been trying to play with it to learn about generalized indices, hash_tree_root, and proofs, but most of the functions in there don't seem to be part of the eth2spec library (only a few functions in `eth2spec.utils.merkle_minimal` and some specialized function like `compute_merkle_proof_for_state` are accessible).\r\n\r\nAnd trying to run the code as standalone completely fails. For example, what is `SSZType`? Doesn't appear anywhere else in eth2spec. I tried replacing it with remerkleable's `View`, and `BasicValue` -> `BasicView`, but then I stumbled upon `BaseList` which was also nowhere to be found. [`SSZVariableName was actually surprisingly defined`](https://github.com/ethereum/consensus-specs/blob/521de12d9bac0b6c3df8ebdc849c64b22eb2e5d2/setup.py#L508), which makes me think that the others were just forgotten?\r\n\r\nI basically need to prove a validator's withdrawal_credentials against the beacon state root. What would you recommend for this? Could be in any language. I even browsed through the prysm codebase, zrnt, etc. and couldn't find anything \"out of the box\".",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399394344/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399458213",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-1399458213",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 1399458213,
    "node_id": "IC_kwDOCOoGbc5Tagml",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-22T11:21:57Z",
    "updated_at": "2023-01-22T11:21:57Z",
    "author_association": "MEMBER",
    "body": "Hi @samlaf,\r\n\r\n> Is merkle-proofs.md supposed to be runnable code?\r\n\r\nNo, it's not. We use [remerkleable](https://github.com/protolambda/remerkleable)'s APIs in the executable pyspec.\r\n\r\n> I basically need to prove a validator's withdrawal_credentials against the beacon state root. What would you recommend for this?\r\n\r\nYou can use remerakble's API directly, or, use pyspec (`eth2spec`) light client specs's `compute_merkle_proof_for_state(state, index)` to generate the proof and use `is_valid_merkle_branch(leaf: Bytes32, branch: Sequence[Bytes32], depth: uint64, index: uint64, root: Root)` to verify it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399458213/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399477411",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-1399477411",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 1399477411,
    "node_id": "IC_kwDOCOoGbc5TalSj",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-22T12:55:47Z",
    "updated_at": "2023-01-22T12:56:27Z",
    "author_association": "MEMBER",
    "body": "Stuck at a starbucks for 4 hours (don't ask) so thought I'd help here. Here's how you use the `eth2spec` and build a proof for any part of a beacon-state & verify the proof using `remerkleable` :)\r\n\r\n```bash\r\npython3 -m venv venv\r\n. venv/bin/activate\r\n\r\npip install \"git+https://github.com/ethereum/consensus-specs@dev\"\r\n```\r\n\r\n```python\r\nimport eth2spec.phase0.mainnet as spec   # change this to eth2spec.capella.mainnet if you are loading a Capella state!\r\nfrom remerkleable.core import Path\r\nfrom remerkleable.tree import merkle_hash\r\nimport os\r\n\r\n# We're going to load the genesis state (phase0.BeaconState type)\r\nfile = \"state.ssz\"\r\nstate_size = os.stat(file).st_size\r\nprint(f\"loading BeaconState of {state_size} bytes!\")\r\n\r\nwith open(\"state.ssz\", \"rb\") as f:\r\n    state = spec.BeaconState.deserialize(f, state_size)\r\n\r\nprint(\"loaded state!\")\r\n\r\nprint(\"validator:\")\r\nprint(state.validators[123])\r\n\r\n# We can navigate to any part of the state, and create a generalized index for it,\r\n# to do merkle navigation with on the raw binary tree that backs the state.\r\nmerkle_path = Path(spec.BeaconState) / 'validators' / 123 / 'withdrawal_credentials'\r\ntarget_gindex = merkle_path.gindex()\r\nprint(\"target gindex (in binary):\", bin(target_gindex))\r\n\r\nmerkle_tree = state.get_backing()\r\n\r\nprint(\"root:\", merkle_tree.merkle_root().hex())\r\n\r\nnode = merkle_tree\r\n# 1 less because bitlength returns 1 more than we need to shift, and 1 less because we don't care about the root\r\ncheck_bit = 1 << (target_gindex.bit_length()-2)\r\nprint(\"check bit:\", bin(check_bit))\r\nwitness = []\r\nwhile check_bit > 0:\r\n    if check_bit & target_gindex != 0:  # follow bit path of target gindex, and get sibling nodes as witness\r\n        witness.append(node.get_left().merkle_root())\r\n        node = node.get_right()\r\n    else:\r\n        witness.append(node.get_right().merkle_root())\r\n        node = node.get_left()\r\n    check_bit >>= 1\r\n\r\nprint(\"value:\", node.merkle_root().hex())\r\nprint(\"witness:\")\r\nfor i, sib in enumerate(reversed(witness)):\r\n    print(f\"{i:3}: {sib.hex()}\")\r\n\r\n# now let's see if we can verify the proof\r\nx = node.merkle_root()\r\nfor i, sib in enumerate(reversed(witness)):\r\n    if (1 << i) & target_gindex != 0:\r\n        x = merkle_hash(sib, x)\r\n    else:\r\n        x = merkle_hash(x, sib)\r\nprint(\"reconstructed state root from proof and value, to verify against real state:\", x.hex())\r\n\r\n```\r\n\r\nOutput (when loading the mainnet genesis state as `state.ssz`):\r\n```\r\nloading BeaconState of 5404504 bytes!\r\nloaded state!\r\nvalidator:\r\nValidator(Container)\r\n    pubkey: BLSPubkey = 0xa9df2cfd79a8b569e7abc286047ade81dbc2e5b89bfd8c00b0913ba3c539b80ff469e77465c6d1815b29e151ab8efd38\r\n    withdrawal_credentials: SpecialByteVectorView = 0x0051416641fd04d2322efa2c23351158f752255ec6354ece0978b2246283d5cb\r\n    effective_balance: Gwei = 32000000000\r\n    slashed: boolean = 0\r\n    activation_eligibility_epoch: Epoch = 0\r\n    activation_epoch: Epoch = 0\r\n    exit_epoch: Epoch = 18446744073709551615\r\n    withdrawable_epoch: Epoch = 18446744073709551615\r\ntarget gindex (in binary): 0b10101100000000000000000000000000000000001111011001\r\nroot: 7e76880eb67bbdc86250aa578958e9d0675e64e714337855204fb5abaaf82c2b\r\ncheck bit: 0b1000000000000000000000000000000000000000000000000\r\nvalue: 0051416641fd04d2322efa2c23351158f752255ec6354ece0978b2246283d5cb\r\nwitness:\r\n  0: cf69f7df20491fd5ed90381550b0db1209b2b0ba13cdf8e0adf2ff4d2e344089\r\n  1: 19327cb9763c96e00332bde93bdbb1032c4b796dda73e515c8c5f7ede9a419be\r\n  2: bcd42b1f092780448fb0131cd25a24c9d25e4b3b610774ae9aa8d3e437e811fe\r\n  3: f5565f5517b58155cd05d08bed3209f8dba7106059355a770e97f14f46584333\r\n  4: c0c0d17f54cabc30af8ea3259434b21e1186526b4f6eddad24f070299684e07a\r\n  5: 86212bd527bc083f485312a391cb05f030e8dcec1644de496e0d77a57f2dc623\r\n  6: ff272b8aa036383fea68becb7f1272f015de8b6db50326ec8f553db4f3051192\r\n  7: 202d3dfe42be124dd44901342aca0cd4f4c8f82e96e4d208c01f5acf75768faf\r\n  8: 056a473b9ca341b58d69c978ab6928029e2be6dacb04a02fa7780b66dcda2539\r\n  9: d49d356c85a1265a5241e46d9cae7e34293806257107088edc460bcf1691352d\r\n 10: 3cb0c5972e7b766d5eb77b9821d67d98b2a5caf3b7fe7b948db7abc53bcbaa1d\r\n 11: 559f5b3ce5b3476e70ed9ac21a1852a7e6530e798e864b627c3c2c2e3a04ff26\r\n 12: 6bb474e1f0a0596da8e167b2f338327f192b173b291113dd5899909540a4ad83\r\n 13: cb4ff5c9878ec98e8a20deee7bab5d7560a6b6ee912098a76769856a8c8610a8\r\n 14: 9dee21a095961822e6bef7398b23f42eec8fb809cfafeb8f299ccd24ac6f1163\r\n 15: 666e12657b0982c6765e82810fe1ad99f958ce00931e79f6d1a9ff4f9b2fcc2b\r\n 16: c05b3d9fe4e0eb1048e553981d198478cf736d735fa861e566cd60052bc9d48a\r\n 17: fe5a17d87a7a13729f8ed3c89288dd413d4c5f4c10871d32c8a1055ad9942374\r\n 18: d49a7502ffcfb0340b1d7885688500ca308161a7f96b62df9d083b71fcc8f2bb\r\n 19: 8fe6b1689256c0d385f42f5bbe2027a22c1996e110ba97c171d3e5948de92beb\r\n 20: 8d0d63c39ebade8509e0ae3c9c3876fb5fa112be18f905ecacfecb92057603ab\r\n 21: 95eec8b2e541cad4e91de38385f2e046619f54496c2382cb6cacd5b98c26f5a4\r\n 22: f893e908917775b62bff23294dbbe3a1cd8e6cc1c35b4801887b646a6f81f17f\r\n 23: cddba7b592e3133393c16194fac7431abf2f5485ed711db282183c819e08ebaa\r\n 24: 8a8d7fe3af8caa085a7639a832001457dfb9128a8061142ad0335629ff23ff9c\r\n 25: feb3c337d7a51a6fbf00b9e34c52e1c9195c969bd4e7a0bfd51d5c5bed9c1167\r\n 26: e71f0aa83cc32edfbefa9f4d3e0174ca85182eec9f3a09f6a6c0df6377a510d7\r\n 27: 31206fa80a50bb6abe29085058f16212212a60eec8f049fecb92d8c8e0a84bc0\r\n 28: 21352bfecbeddde993839f614c3dac0a3ee37543f9b412b16199dc158e23b544\r\n 29: 619e312724bb6d7c3153ed9de791d764a366b389af13c58bf8a8d90481a46765\r\n 30: 7cdd2986268250628d0c10e385c58c6191e6fbe05191bcc04f133f2cea72c1c4\r\n 31: 848930bd7ba8cac54661072113fb278869e07bb8587f91392933374d017bcbe1\r\n 32: 8869ff2c22b28cc10510d9853292803328be4fb0e80495e8bb8d271f5b889636\r\n 33: b5fe28e79f1b850f8658246ce9b6a1e7b49fc06db7143e8fe0b4f2b0c5523a5c\r\n 34: 985e929f70af28d0bdd1a90a808f977f597c7c778c489e98d3bd8910d31ac0f7\r\n 35: c6f67e02e6e4e1bdefb994c6098953f34636ba2b6ca20a4721d2b26a886722ff\r\n 36: 1c9a7e5ff1cf48b4ad1582d3f4e4a1004f3b20d8c5a2b71387a4254ad933ebc5\r\n 37: 2f075ae229646b6f6aed19a5e372cf295081401eb893ff599b3f9acc0c0d3e7d\r\n 38: 328921deb59612076801e8cd61592107b5c67c79b846595cc6320c395b46362c\r\n 39: bfb909fdb236ad2411b4e4883810a074b840464689986c3f8a8091827e17c327\r\n 40: 55d8fb3687ba3ba49f342c77f5a1f89bec83d811446e1a467139213d640b6a74\r\n 41: f7210d4f8e7e1039790e7bf4efa207555a10a6db1dd4b95da313aaa88b88fe76\r\n 42: ad21b516cbc645ffe34ab5de1c8aef8cd4e7f8d2b51e8e1456adc7563cda206f\r\n 43: 4752000000000000000000000000000000000000000000000000000000000000\r\n 44: 5152000000000000000000000000000000000000000000000000000000000000\r\n 45: 1966996e4b51621e27791d188fe8fba1c5f1749c3305266552bad95b62c0a54a\r\n 46: 162fe1b56a232dabeb5095d95c562db36f5e0775f0d816f3b1f5aefbb99ee378\r\n 47: ca3b6f66b9395967ace5870cb7c7a3dbea6b2d3678acbba82804154c98cd319c\r\n 48: 83aa709f61935832d58c344c31b321c3fc8d347cc2e5d800fb18a18285654146\r\nreconstructed state root from proof and value, to verify against real state: 7e76880eb67bbdc86250aa578958e9d0675e64e714337855204fb5abaaf82c2b\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1399477411/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1400585610",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2179#issuecomment-1400585610",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2179",
    "id": 1400585610,
    "node_id": "IC_kwDOCOoGbc5Tez2K",
    "user": {
      "login": "samlaf",
      "id": 9342524,
      "node_id": "MDQ6VXNlcjkzNDI1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9342524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/samlaf",
      "html_url": "https://github.com/samlaf",
      "followers_url": "https://api.github.com/users/samlaf/followers",
      "following_url": "https://api.github.com/users/samlaf/following{/other_user}",
      "gists_url": "https://api.github.com/users/samlaf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/samlaf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/samlaf/subscriptions",
      "organizations_url": "https://api.github.com/users/samlaf/orgs",
      "repos_url": "https://api.github.com/users/samlaf/repos",
      "events_url": "https://api.github.com/users/samlaf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/samlaf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-23T15:58:50Z",
    "updated_at": "2023-01-23T15:58:50Z",
    "author_association": "NONE",
    "body": "A big thank you to both of you @protolambda and @hwwhww !",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1400585610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
