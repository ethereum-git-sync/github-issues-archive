{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1537",
  "id": 539462566,
  "node_id": "MDU6SXNzdWU1Mzk0NjI1NjY=",
  "number": 1537,
  "title": "Concerns about eth1 voting in the context of caching",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-12-18T05:37:43Z",
  "updated_at": "2020-01-06T13:21:24Z",
  "closed_at": "2020-01-06T13:21:24Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "I think the current eth1 voting mechanism has some undesirable properties when we consider that staking eth2 clients should cache eth1 blocks. They should cache because:\r\n\r\n1. Requiring a call to some external server during block production is risky. If the eth1 node is unavailable at that time, we miss a beacon slot.\r\n2. The amount of data required to make the vote is >1,000 blocks. Doing this remote call during block production will add significant (likely infeasible) lag to block production.\r\n\r\nFirst I will state two undesirable properties of the current system in the context of caching and then suggest a simpler system.\r\n\r\n### Undesirable property 1: Clients must cache the eth1 chain all the way up to the head\r\n\r\nConsider the first block proposer in the eth1 voting period (`slot % SLOTS_PER_ETH1_VOTING_PERIOD == 0`). In order to calculate `get_eth1_data(distance)` it needs to know the block number of the eth1 block at the start of the voting period (now). That block is the head of the eth1 chain.\r\n\r\nThis is the primary problem I have and it has two effects:\r\n- The eth2 client caches must be concerned with eth1 re-orgs, whilst the core eth2 protocol is not.\r\n- There are points in time (the start of the voting period) where an eth2 node's ability to vote is reduced by not having a cache that is _immediately_ up to date.\r\n\r\n### Undesirable property 2: You need to cache all the way back to the current eth1_data\r\n\r\nIn order to cast a vote (i.e., not trigger an exception in the spec), a node must have in their cache all descendants of the block represented by `state.eth1_data` (at the start of the current voting period). So, the cache grows linearly with the time since a successful eth1 voting period.\r\n\r\nAdditionally, if a node wants their cache to be safe in the case of an _eth2_ re-org, they should cache all the way back to the eth1_data in the last finalized block. Therefore, the cache also grows linearly with the time since finalization.\r\n\r\n## My proposal:\r\n\r\nBelow is some **rough** Python code that I think is minimal and viable. I'm not convinced this should be the final solution, but it's a starting point at least.\r\n\r\nIt has the following properties that the present solution does not:\r\n\r\n- Clients can go for `ETH1_FOLLOW_DISTANCE * SECONDS_PER_SLOT` without contacting an eth1 node and still vote perfectly.\r\n- The size of this cache is limited to the amount of eth1 blocks in `ETH1_FOLLOW_DISTANCE * SECONDS_PER_SLOT`.\r\n- It is reasonable to assume that a re-org will never affect this cache.\r\n\r\n```python\r\ndef voting_period_start(state: BeaconState):\r\n    eth1_voting_period_start_slot = state.slot % SLOTS_PER_ETH1_VOTING_PERIOD\r\n    state.genesis_time + eth1_voting_period_start_slot * SECONDS_PER_SLOT\r\n\r\ndef is_candidate_block(block: Eth1Block, period_start: uint64) -> Bool:\r\n    block.timestamp <= period_start - SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE and \\\r\n    block.timestamp >= period_start - SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE * 2\r\n\r\ndef get_eth1_vote(state: BeaconState) -> Eth1Data:\r\n    period_start = voting_period_start(state)\r\n    # `eth1_chain` abstractly represents all blocks in the eth1 chain.\r\n    votes_to_consider = [get_eth1_data(block) for block in eth1_chain if\r\n                         is_candidate_block(block, period_start)]\r\n\r\n    valid_votes = [vote for vote in state.eth1_data_votes if vote in votes_to_consider]\r\n\r\n    return max(\r\n        valid_votes,\r\n        key=lambda v: (valid_votes.count(v), -valid_votes.index(v)),  # Tiebreak by smallest distance\r\n        default=get_eth1_data(ETH1_FOLLOW_DISTANCE),\r\n    )\r\n\r\n```\r\n\r\nBasically, solution makes the following changes:\r\n\r\n1. We select the range of viable votes using _only_ timestamp, instead of the timestamp/block number hybrid we have now. This frees us from undesirable property 1.\r\n1. Don't try and vote on blocks prior to the current voting period (i.e., ditch `all_eth1_data`). This frees us from undesirable property 2.\r\n\r\nWRT (2), it's not clear to me why we bother with `all_eth1_data`. I have some ideas, but I'd be keen to hear the original motivations.",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/567252999",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1537#issuecomment-567252999",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
    "id": 567252999,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NzI1Mjk5OQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-18T23:08:02Z",
    "updated_at": "2019-12-18T23:24:37Z",
    "author_association": "MEMBER",
    "body": "### why `all_eth1_data`\r\nThe original intent of `new_eth1_data` vs `all_eth1_data` is to attempt to only cast repeat votes for new eth1 data if at the \"start\" of the period, and then in the tail of the period, favor just coming to consensus on anything valid.\r\n\r\nThis is to fight against the case in which an attacker has control of some proposers early in a voting period and just selects say the next block past the last eth1data. This attack is relatively easy to conduct, costs nothing, and would majorly stall the induction of new validators into the beacon chain.\r\n\r\n### Proposer honestly assumption as justification of new design\r\n\r\nWhat we lose by only considering \"new\" when casting repeat votes instead of opening up to \"all\" in the tail seems marginal, at best. Even in the case in which an attacker has all of the proposers during the first `sqrt(SLOTS_PER_ETH1_VOTING_PERIOD)` (32) slots, it is very likely that at least one honest proposer shows up before substantially further into the voting period. After which, honest votes would coalesce upon their vote. In fact, we actually already make the assumption that we have at least 1 honest proposer per 32 slots as a liveness assumption for getting attestations on chain to facilitate FFG finality. If this assumption consistently fails, we (1) are unlikely to be able to control the eth1 voting mechanism from the attacker and (2) might have bigger fish to fry.\r\n\r\n### Will the change affect the finality gadget?\r\n\r\nOne thing to consider is how this operates when `SLOTS_PER_ETH1_VOTING_PERIOD` and `ETH1_FOLLOW_DISTANCE` are reduced when introducing the finality gadget.\r\n\r\nWhen `SLOTS_PER_ETH1_VOTING_PERIOD` is reduced, we rely more and more on our honesty assumption because our random sampling of proposers decreases. This seems unaffected by the proposal.\r\n\r\nWhen `ETH1_FOLLOW_DISTANCE` is reduced into the range of potential forking (say 25-50 eth1 blocks), to ensure that proposers can coalesce on one vote even if the chain has a high degree of forking, we might need to have validators consider the recent eth1 block _tree_ instead of just the PoW canonical chain. This requirement is debatable, but I don't think this proposal affects that potential requirement. It might require building a local cache (both with block depth or timestamp) so we should at least keep cache requirements in mind when researching and spec'ing finality gadget.\r\n\r\n### I'm in favor\r\n\r\nI'm in favor.\r\n\r\nThis seems like something that we can release in a spec ASAP because it won't actually interfere interoperability in clients in 99%+ of the cases. With different clients running the existing algorithm and this new algorithm, validators might end up with disagreements on early votes, but would start to agree during the `period_tail`.\r\n\r\nLet's gauge the temperature on the call tomorrow\r\n\r\n--------\r\n\r\n_edit_: where are your `return` statements?! Do you even python?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/567252999/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/567275269",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1537#issuecomment-567275269",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
    "id": 567275269,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NzI3NTI2OQ==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-19T00:34:12Z",
    "updated_at": "2019-12-19T00:34:34Z",
    "author_association": "MEMBER",
    "body": "> This is to fight against the case in which an attacker has control of some proposers early in a voting period and just selects say the next block past the last eth1data.\r\n\r\nI'm not following how `all_eth1_data` prevents this. As I understand it, the presence of `all_eth1_data` would make it _more_ likely that honest clients end up voting on older (lower block #) eth1 blocks. This is because `all_eth1_data` must contain blocks that are either (a) in `new_eth1_data` or (b) older than all blocks in `eth1_data`.\r\n\r\n> Let's gauge the temperature on the call tomorrow\r\n\r\nSGTM\r\n\r\n> edit: where are your return statements?! Do you even python?\r\n\r\n~~Return~~ statements are _so_ passé.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/567275269/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/568540111",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1537#issuecomment-568540111",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
    "id": 568540111,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2ODU0MDExMQ==",
    "user": {
      "login": "prestonvanloon",
      "id": 7246818,
      "node_id": "MDQ6VXNlcjcyNDY4MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7246818?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prestonvanloon",
      "html_url": "https://github.com/prestonvanloon",
      "followers_url": "https://api.github.com/users/prestonvanloon/followers",
      "following_url": "https://api.github.com/users/prestonvanloon/following{/other_user}",
      "gists_url": "https://api.github.com/users/prestonvanloon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prestonvanloon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prestonvanloon/subscriptions",
      "organizations_url": "https://api.github.com/users/prestonvanloon/orgs",
      "repos_url": "https://api.github.com/users/prestonvanloon/repos",
      "events_url": "https://api.github.com/users/prestonvanloon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prestonvanloon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-23T17:56:18Z",
    "updated_at": "2019-12-23T17:56:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "I like it. This is close to what we do in Prysm, except for the tie breaking for vote decisions. We don't consider anyone elses vote at the moment when determining our eth1data vote. \r\n\r\nI am a bit concerned about caching and eth1 reorgs. If everyone caches the same way and no one invalidates their cache on eth1 re-org, that coud be a problem. Could you elaborate on the assumption that eth1 re-orgs cannot affect this cache method?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/568540111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/570426315",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1537#issuecomment-570426315",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
    "id": 570426315,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3MDQyNjMxNQ==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-03T01:17:43Z",
    "updated_at": "2020-01-03T01:17:43Z",
    "author_association": "MEMBER",
    "body": "> I like it.\r\n\r\nGlad to hear that!\r\n\r\n> Could you elaborate on the assumption that eth1 re-orgs cannot affect this cache method?\r\n\r\nThe present voting mechanism (when considered alongside the validator on-boarding logic) makes an assumption that eth1 will never re-org a block that is more than 128 blocks deep. This is fine, but my gripe is that eth1 voting is structured in such a way that a client is most likely going to need to keep a cache that occasionally includes all blocks up to the current eth1 head.\r\n\r\nThe mechanism I have proposed addresses my gripe by making a slightly different assumption; instead of saying _\"eth1 will never re-org a block that is more than 128 blocks deep\"_, it says _\"eth1 will never re-org a block that is more than 128 times the expected block time (15s) deep\"_. In other words, we judge a blocks depth in the eth1 chain by `eth1_block.timestamp` instead of `eth1_block.number`.\r\n\r\nThe important part about my mechanism is that it only requires the client to cache blocks that are at least `SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE` seconds prior to the current eth1 head. So, if we can make the assumption that eth1 will never re-org a block with a timestamp more than 32 minutes old (15 secs * 128) then we can also assume that our caches will never experience a re-org.\r\n\r\n_Note: the assumption is not necessarily \"eth1 will never re-org a block 32 minutes deep\", it's more along the lines of \"if eth1 re-orgs past 32 min then we need an extra-protocol solution to patch eth2\"._",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/570426315/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/571135761",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1537#issuecomment-571135761",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1537",
    "id": 571135761,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3MTEzNTc2MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-06T13:21:24Z",
    "updated_at": "2020-01-06T13:21:24Z",
    "author_association": "MEMBER",
    "body": "Closed via #1553 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/571135761/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
