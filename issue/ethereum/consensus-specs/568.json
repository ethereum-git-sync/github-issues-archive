{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/568",
  "id": 406126304,
  "node_id": "MDU6SXNzdWU0MDYxMjYzMDQ=",
  "number": 568,
  "title": "Proof of custody game design",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2019-02-03T20:19:10Z",
  "updated_at": "2019-03-28T22:57:32Z",
  "closed_at": "2019-03-28T22:57:32Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "The basic proof of custody mechanism works as follows:\r\n\r\n* For every (eg. 2 week) period `p`, each validator calculates `rk[p] = BLS_sign(key=validator_privkey, msg=p)` as their round key.\r\n* For every crosslink they participate in during that period, if that crosslink has data with chunks `D[0] ... D[size(D)-1]`, for each `D[i]` they compute `C[i] = mix(rk[p], D[i])` where `mix` is some function where for any `rk`, `mix(rk, x)` depends on `x`. They compute `R = custody_root(D)` as Merkle root of the `C[i]` values and sign `R mod 2` along with the crosslink (this is their \"custody bit\")\r\n* During period `p + 1`, the validator must reveal `prevseed=rk[p]`, and the chain can verify that it is a correct value via `BLS_verify(key=validator.pubkey, msg=p, sig=prevseed)`\r\n\r\nThere are three types of byzantine behavior that we want to penalize:\r\n\r\n1. Revealing `rk[p]` too early\r\n2. Signing with some random custody bit because D is unavailable\r\n3. Signing with the incorrect custody bit because even if D is available, the validator wishes to be malicious\r\n\r\nFor (1) we can have a special-purpose slashing condition; the only requirement is that _anyone_ must be able to trigger the condition and gain from doing so, so there should be a commit-reveal game to allow participants to trigger it without the block proposers being able to frontrun them.\r\n\r\n(2) and (3) are similar cases, except (3) is more tractable. In case (3), once `rk[p]` is revealed, any third party can recompute `custody_root(D)`, check if the bit matches, and if the bit does not match start a challenge game, which they know ahead of time they will be able to win. First, they challenge to ask for the complete custody root, which must match the bit that has already been provided. At this point, the responder is free to respond with an arbitrary value of `R` that matches the same bit; for any `D`, it is almost always possible to find some data `D'` which differs from `D` in only one block where `custody_root(D') mod 2` is either 0 or 1. At this point, the responder has (and the challenger knows that the responder has) committed to some value which is _not_ equal to `custody_root(D)`.\r\n\r\nThe next step is for the challenger to ask for the two children of `R'` (we'll call them `C0` and `C1`). When the responder responds, the challenger can check which of the two don't match the corresponding values in the real custody Merkle tree for `D`. The challenger then asks for the two children of either `C0` or `C1`. This repeats `log(size(D))` times until eventually the responder must respond with some `C[i]` as well as a Merkle branch for the corresponding `D[i]`. The chain will check and find that the provided `C[i]` does _not_ match `mix(rk[p], D[i])`, and the responder can be penalized and the challenger can win. At this point, if the responder responds correctly, the challenger can be penalized.\r\n\r\nNote that this whole process is only possible if all of `D` is available, so challengers can know whether or not they can successfully challenge. If `D` is not available, then we also need a challenge game which allows participants to ask for specific branches of `D` and demand an answer. Because data availability suffers from [fisherman's dilemma problems](https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding), it's likely participants will not bother challenging unless challenging is free; hence, the proposed solution is to only allow block proposers to challenge, and give them a free allotment of challenges in each block, expecting them to fill the allotment.\r\n\r\nNow, we have four types of challenges:\r\n\r\n1. Input: attestation `A`, validator index `v`, data index `i`. Output: a Merkle branch of `D[i]` with the root matching `A.data_commitment`.\r\n2. Input: attestation `A`, validator index `v`. Output: a root `R` matching `get_custody_bit(A, v)`\r\n3. Input: attestation `A`, validator index `v`, index `i`, depth `d`, branch `B`, where `B` has as root the `R` value previously submitted by validator `v`. Output: the two children whose parent is the leaf in `B`.\r\n4. Input: attestation `A`, validator index `v`, index `i`. Output: a Merkle branch of `D[i]` and `C[i]` with the roots matching `A.data_commitment` and the `R` value previously submitted by validator `v`.\r\n\r\nNote that we can increase efficiency by merging (1), (2) and (4). We do this as follows:\r\n\r\n* Input: attestation `A`, validator index `v`, data index `i`. Output: a Merkle branch of `D[i]` and `C[i]` with the roots matching, for the first branch, `A.data_commitment`, and for the second branch, the same `R` value as was submitted during any previous time the same validator answered a challenge for the same attestation.\r\n\r\nWe can also decrease the round count of the game, by asking for 2^k descendants some height k below the provided node (eg. 16 descendants 4 levels down). In this way, in the worst case (eg. a 2**24-sized data tree), the game would take only six rounds, instead of ~24.\r\n\r\n#### How to implement the multi-round game\r\n\r\nThe main saving grace of all of the above is that the only game where honest challengers are not guaranteed to win (the branch challenge) only requires one round of challenging (all challenges can be done in parallel). Going beyond that, any honest challenger should be assured of victory, and hence willing to put down a deposit.\r\n\r\nFor each \"exited\" validator, we will maintain a counter, `challenge_round`, which starts at zero, and a bool `was_challenged_this_round`. When the validator reaches the end of their withdrawal queue, the following happens:\r\n\r\n* If there were no challenges during this `challenge_round` of the validator (ie. `was_challenged_this_round = False`), or if `challenge_round = 6`, the validator withdraws successfully\r\n* If there were challenges (any valid challenge sets `was_challenged_this_round` to `True`), the validator can skip back to the end of the exit queue as soon as they respond to all extant challenges, with `challenge_round += 1` and `was_challenged_this_round` reset to `False`.\r\n* Challenging during round 0 is restricted to proposers. Challenging during round i+1 is restricted to anyone who challenged during round i.\r\n\r\nNow, for economics (this is the part I am still less confident about). If a validator successfully answers all challenges, then every validator that challenged can be penalized some amount. If a responder does not answer challenges and the time hits some timeout period, then all validators that challenge get a reward out of the responder's deposit (these rewards could be evenly split, or only given to the first challenger of each challenge round, or split among the challengers of each round in a decreasing schedule, eg. the kth challenger of each round gets a reward of `(6/pi**2) / k**2` (the `6/pi**2` constant set so that rewards add up to a maximum of 1 per period).",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460104978",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/568#issuecomment-460104978",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568",
    "id": 460104978,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MDEwNDk3OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-04T00:50:16Z",
    "updated_at": "2019-02-04T00:50:16Z",
    "author_association": "MEMBER",
    "body": "**Multi-round game, version 2**\r\n\r\nWe store in the state two lists, `pending_data_challenges` and `pending_challenge_games`.\r\n\r\nThere is no longer a 18-hour minimum validator withdrawal time. Instead, the withdrawal queue always picks the 4 validators each epoch that exited the earliest for which all pending data challenges have been answered (data challenges can be made only for validators < 1 week after exiting). However, these validators are not immediately withdrawn; instead, they are assigned a \"waiting for challenge games\" status. If a validator has been waiting for challenge games for more than 18 hours and no challenge games have been started, the validator can exit.\r\n\r\nAny validator can start a challenge game against any other validator by putting down 1 ETH as a deposit. The challenge game consists of the following process:\r\n\r\n* Challenge game started\r\n* Respondent must respond within 90 days by providing the full custody root; this must be consistent with all other custody roots provided\r\n* Challenger has 14 days to ask for 16 degree-4 grandchildren of the root (otherwise the 1 ETH is forfeited)\r\n* Respondent has 90 days to answer with the grandchildren\r\n* Challenger has 14 days to ask for 16 degree-5 grandchildren of any one of the provided values\r\n* Repeat until the respondent provides part of the bottom layer of the tree. Then the challenger can ask for a specific branch of the data within those provided values, and then the chain can verify whether or not `mix(rk[p], D[i])` matches the provided `C[i]`\r\n\r\nIf the respondent can correctly respond to a game, the respondent gains 0.5 ETH and the challenger loses 1 ETH; if the respondent fails to respond, the respondent loses (1 + calculated anti-correlation penalty) ETH and the challenger recovers their deposit plus half of the penalty. If there are N > 1 games in progress, then all rewards and penalties are multipled by 1/N.\r\n\r\nHence, with the exception of the first round, challenging and responding is broken up into discrete games with a challenger and respondent.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460104978/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460311793",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/568#issuecomment-460311793",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568",
    "id": 460311793,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MDMxMTc5Mw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-04T16:22:49Z",
    "updated_at": "2019-02-04T16:45:55Z",
    "author_association": "MEMBER",
    "body": "Here's a potential strategy to retain the elegance and simplicity of custody bits, and at the same time make them MPC-friendly.\r\n\r\n1. For the purposes of custody bits only, use an MPC- and SNARK-friendly hash function such as MiMC.\r\n    * We get SNARK-friendliness \"for free\" from the Ethereum 2.0 design goal of MPC-friendliness.\r\n    * It's OK to use an experimental hash function such as MiMC. If it breaks the damage is contained to custody.\r\n    * There are now *two* avenues to MPC-friendliness for staking pools. The first is to have an n-of-m MPC. The second is where a dedicated pool member computes the custody bit and provides a SNARK proof to the other pool members.\r\n2. We introduce a non-interactive slashing condition whereby a whistleblower can present a SNARK proof that a specific custody bit is wrong.\r\n    * By using [Sonic](https://eprint.iacr.org/2019/099) we don't have to worry about the trusted setup.\r\n3. (Optional) To handle data availability and retrievability, we introduce a one-round slashing condition whereby a challenger may request a specific data chunk from a validator. The challenged validator must respond with the data chunk plus a SNARK of a custody bit salted with a recent random number.\r\n     * The SNARK of a recent custody bit handles cases where the data is unavailable.\r\n     * The communicated data chunk handles data retrievability.\r\n     * I marked this slashing condition as \"optional\" because I don't expect data to ever be unavailable if the first slashing condition is enforced. My recommendation would be to *not* implement this challenge game, at least not for phase 1.\r\n\r\nNotice that SNARK proofs are not required in the optimistic case, and when they are required the relevant party has a lot of time (hours, days or however long we want) to build the SNARK.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460311793/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460430097",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/568#issuecomment-460430097",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/568",
    "id": 460430097,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MDQzMDA5Nw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-04T21:59:30Z",
    "updated_at": "2019-02-04T21:59:30Z",
    "author_association": "MEMBER",
    "body": "MIMC is MPC-friendler than other hash functions, but not super MPC-friendly; it still requires something like 100 rounds of communication. The strategies that require fewer rounds get their mixing properties by mixing different fields, which is unfortunately not a very SNARK-friendly thing to do....\r\n\r\nI'm also wary of this particular use case because the SNARK scheme failing would lead not to degradation of security of an isolated component of the system, but to innocent validators getting slashed, possibly undetectably. From my last day of thinking about it I don't think the game complexity difference between a SNARK and a Truebit-style game is that large (certainly much smaller than the internals and circuit construction of the SNARK). In either case, we need a multi-round exit game: the first round for challenging missing bits of `D`, and the second round for using the revealed information about `D` to launch a challenge.\r\n\r\nIn the second case, if we adopt the interactive game approach, once the challenge game starts it's a self-contained gadget, and from the point of view of the rest of the system we'll know at some point that it resolves. We can get rid of complexity involving list handling and 1/N rewards above by allowing only one challenge game per attestation per respondent, whoever starts one first. The possibility that a bad validator will challenge themselves and claim their own money can be handled as above by making the reward only half the penalty.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/460430097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
