{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1523",
  "id": 537894702,
  "node_id": "MDU6SXNzdWU1Mzc4OTQ3MDI=",
  "number": 1523,
  "title": "Shuffling lookahead is affected by fork choice",
  "user": {
    "login": "mkalinin",
    "id": 1892772,
    "node_id": "MDQ6VXNlcjE4OTI3NzI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mkalinin",
    "html_url": "https://github.com/mkalinin",
    "followers_url": "https://api.github.com/users/mkalinin/followers",
    "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
    "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
    "organizations_url": "https://api.github.com/users/mkalinin/orgs",
    "repos_url": "https://api.github.com/users/mkalinin/repos",
    "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mkalinin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    },
    {
      "id": 1725628406,
      "node_id": "MDU6TGFiZWwxNzI1NjI4NDA2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase0",
      "name": "phase0",
      "color": "c2e0c6",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/milestones/6",
    "html_url": "https://github.com/ethereum/consensus-specs/milestone/6",
    "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/milestones/6/labels",
    "id": 5797403,
    "node_id": "MDk6TWlsZXN0b25lNTc5NzQwMw==",
    "number": 6,
    "title": "ðŸ”µ v1.0.0 candidates",
    "description": "",
    "creator": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 12,
    "closed_issues": 5,
    "state": "closed",
    "created_at": "2020-08-21T16:23:12Z",
    "updated_at": "2021-06-07T15:09:56Z",
    "due_on": null,
    "closed_at": "2021-05-04T14:59:24Z"
  },
  "comments": 6,
  "created_at": "2019-12-14T10:08:16Z",
  "updated_at": "2021-07-05T15:05:54Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Issue\r\n[Lookahead](https://github.com/ethereum/eth2.0-specs/blob/v0.9.3/specs/validator/0_beacon-chain-validator.md#lookahead) section of Honest Validator spec states:\r\n> `get_committee_assignment` should be called at the start of each epoch to get the assignment for the next epoch (`current_epoch + 1`). A validator should plan for future assignments by noting at which future slot they will have to attest and joining the committee index attestation subnet related to their committee assignment.\r\n\r\nAssume we have two competing forks at the boundary between`N - 1` and `N` epochs. For instance, fork `B` misses last block of `N - 1` while `A`, in opposite, considers that block. Note: these two views of `N - 1` epoch results in two different randao mixes affecting `N + 1` shuffling. In the result node _may_ join wrong aggregation subnet depending on whether it's been following canonical chain _before_ the lookahead or not.\r\n\r\n## Possible solutions\r\n- **Look back to the fork choice.** Once lookahead process done node have to look at the changes of canonical chain that could affect shuffling and re-join subnet in the case when it happens. This approach gives a probability lookahead process which is as strong as far the tip of the chain states from an epoch boundary.\r\n- **Use finalized randao mix.** Use randao mix of finalized epoch `N - 1` to compute shuffling starting from epoch `N + 1` which would give predictable lookahead within one epoch.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/566268575",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1523#issuecomment-566268575",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
    "id": 566268575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NjI2ODU3NQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-16T22:13:29Z",
    "updated_at": "2019-12-16T22:13:29Z",
    "author_association": "MEMBER",
    "body": "Thanks for bringing this up, I just stumbled on similar concerns with aggregation modeling.\r\n\r\n> Look back to the fork choice.\r\n\r\nIf a possible case of future committee changes can be anticipated and prepared for as back-up subnet connection, that would be great. But I imagine it's difficult. I like the idea of modeling it as possibilities: determine for each future subnet (within the look ahead) the chance you need to join, and join everything over some threshold chance.\r\n\r\n> Use finalized randao mix\r\n\r\nWe need committees in the same subnet to have any kind of reasonable aggregation, so the shuffling would need to match the finalized epoch. However, if not finalized, we cannot fallback on the same finalized shuffling, it needs to keep reshuffling. So is there any difference with status quo? Am I missing something here?\r\n\r\nI do think the case of the re-org is small enough that it's not a continuous problem, and when it does occur, joining another subnet is not the biggest problem of the chain, and also mostly temporary. And chances of things flipping back and forth are fork-choice research area, which should be much better with the recent v0.9 changes.\r\n\r\nI think we can revisit this issue when we have a simulation/testnet to test the reorg effect?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/566268575/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/566468300",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1523#issuecomment-566468300",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
    "id": 566468300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NjQ2ODMwMA==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-12-17T09:54:43Z",
    "updated_at": "2019-12-17T09:54:43Z",
    "author_association": "MEMBER",
    "body": "> it needs to keep reshuffling\r\n\r\nRight. And if `randao_mix` is finalized it will still keep reshuffling bc `get_seed` uses `epoch` along with the mix.\r\n\r\n> So is there any difference with status quo? Am I missing something here?\r\n\r\nCurrently shuffling can be computed no more than two epochs ahead. With finalized `randao_mix` it would be possible to compute shuffling _more_ than two epochs ahead in case when finality is being delayed. If finality occurs every epoch finalized `randao_mix` gives the same _no more than_ two epochs lookahead.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/566468300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617023414",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1523#issuecomment-617023414",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
    "id": 617023414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzAyMzQxNA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T08:06:40Z",
    "updated_at": "2020-04-21T08:06:40Z",
    "author_association": "MEMBER",
    "body": "@protolambda @mkalinin What is the outcome of this discussion? Do we want to make any changes in phase 0?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617023414/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617165802",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1523#issuecomment-617165802",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
    "id": 617165802,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzE2NTgwMg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T13:04:03Z",
    "updated_at": "2020-04-21T13:04:03Z",
    "author_association": "MEMBER",
    "body": "This is a weird case where forks are longer than an epoch, and committees split. The question (at least my understanding) is now; how should the validators of forked committees organize into shared subnets, while operating on different forks of the chain, so that if they change their forkchoice view, they don't have to switch subnet suddenly?\r\n\r\nStill, the assignment is random, so I don't expect balancing issues. And since the attestation data is different, similar to the regular smaller fork case, aggregates on the subnet are just limited. It seems to be a network organization issue. And if you ended up on the wrong subnet due to a longer fork, but want to switch to the correct net, you end up short on time, missing an attestation.\r\n\r\nSo I think there are four options:\r\n1. Proposed solution 1: Adapt network strategy to forkchoice and try to work around the issue.\r\n2. Proposed solution 2: finalized data decides on shuffling, organize committees with bigger look ahead, changing beacon spec. However, this needs more thought into subsequent epochs without finalization. Does it keep using that data for the shuffling? Is there a nonce mixed in to finalized data? We don't want to be stuck on the same committee forever. I may be misunderstanding this still.\r\n3. Wait and see how testnets do, and adjust based on results. It's not critical, but can be useful still to improve attestation performance. If on the wrong subnet, a validator could miss a vote, but that's not extraordinary. And the validator just completely changed its view anyway, is it worth it to vote immediately?\r\n4. New solution, change network spec in other ways. Maybe allow re-organized validators to submit their attestations in a way we can verify that they switched to another committee on quick notice. Not sure what other solutions we have.\r\n\r\n\r\nI think 3 is fine so far, but we can do better. Maybe start with exploring the network spec focused options, to not change the state transition spec?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617165802/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617767106",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1523#issuecomment-617767106",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1523",
    "id": 617767106,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzc2NzEwNg==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-22T13:05:42Z",
    "updated_at": "2020-04-22T13:05:42Z",
    "author_association": "MEMBER",
    "body": "@protolambda thanks a lot for your answer!\r\n\r\nIt started from the following spec statement:\r\n> at the start of each epoch to get the assignment for the next epoch `(current_epoch + 1)`\r\n\r\nWhich naturally means that validator should look for assignment and start joining the subnet right after processing the last slot that affects the assignment. If we had 2 epochs lookahead then it would be a deal with forks longer than an epoch which sounds like pretty much rare situation. However, with this statement in the spec and an epoch lookahead validators have to cope with forks longer than a slot which is the usual case.\r\n\r\n> However, this needs more thought into subsequent epochs without finalization. Does it keep using that data for the shuffling? Is there a nonce mixed in to finalized data? We don't want to be stuck on the same committee forever. I may be misunderstanding this still.\r\n\r\n`get_seed` mixes in the epoch number. So, we won't stay with the same committee any longer, it will be re-shuffled each epoch. If we go this way we will still have random committees with sampled _deterministically_ between finalized checkpoints. The determinism is the major difference from the status quo. The other difference is that we will have at least 2 epochs lookahead. \r\n\r\nThe impact of that change is definitely a subject to review. I was a little bit thinking about potential outcome of this change for adversary. If adversary would be able to violate liveness it would make sense for him to compute the seeds beforehand for each finalized checkpoint and break in when it observes an efficient way to exploit particular seed. But, according to my mental model, if randomness of our randao mixes is strong we're not deviating from security properties of the beacon chain. For instance, the level of security of our minimal committee size would be preserved. Though, there could be other ways of exploiting finalized seeds or I might just make wrong reasoning about this one.\r\n\r\nA couple of other options:\r\n- Fix spec in a way that validator _should_ start looking into assignments progressing near to the middle of the epoch rather than from its beginning\r\n- Increase lookahead to two epochs\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617767106/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
