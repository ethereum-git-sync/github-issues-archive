{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3577",
  "id": 2078680743,
  "node_id": "I_kwDOCOoGbc575ian",
  "number": 3577,
  "title": "Do not lock on execution when importing blocks",
  "user": {
    "login": "potuz",
    "id": 16044918,
    "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/potuz",
    "html_url": "https://github.com/potuz",
    "followers_url": "https://api.github.com/users/potuz/followers",
    "following_url": "https://api.github.com/users/potuz/following{/other_user}",
    "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
    "organizations_url": "https://api.github.com/users/potuz/orgs",
    "repos_url": "https://api.github.com/users/potuz/repos",
    "events_url": "https://api.github.com/users/potuz/events{/privacy}",
    "received_events_url": "https://api.github.com/users/potuz/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2024-01-12T11:53:37Z",
  "updated_at": "2024-01-12T19:27:12Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "When currently syncing blocks, the CL notifies the EL about a new payload, after checking the validity it puts the block in forkchoice and after that it notifies the EL again of a new head. This workflow made a lot of sense at the time of the merge, where increased forking and possible attacks from miners could lead to a situation where an optimistically syncing node would deadlock. \r\n\r\nIn the current merged network the above workflow is unnecessarily inefficient, locking both the CL and the EL in what should be independent checks. This proposal is about discussing mechanisms that will allow the CL and EL to perform these checks independently. One possible path would be the following path for block validation\r\n\r\n1. Validate the gossip rules for block propagation\r\n2. Notify the engine of the new payload (do not lock on this notification)\r\n3. Perform BLOCKHASH verification of the block within the CL. \r\n4. Insert the block directly into forkchoice and evaluate new head (allow forkchoice to keep track of which blocks have been fully validated vs those that were just notified, this can simply repurpose the current \"optimistic\" status of nodes).\r\n5. Notify the EL in case of a new head (again not locking). \r\n\r\nThe EL can immediately reply that a block is invalid if its parent is known to be invalid. The CL can retroactively change head to a valid one if either the call in 2 or 5 eventually return with invalid. \r\n\r\nObviously we need to change the way that duties are performed: proposals are on top of fully validated blocks, attestations the same. So perhaps the simplest form is to have `get_head` return the last fully validated block in the branch of the current head (or compute head filtering out all nodes not fully validated, the former seems simpler). \r\n\r\ncc @mkalinin @gakonst @fradamt ",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1889815163",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3577#issuecomment-1889815163",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577",
    "id": 1889815163,
    "node_id": "IC_kwDOCOoGbc5wpEp7",
    "user": {
      "login": "adiasg",
      "id": 25324105,
      "node_id": "MDQ6VXNlcjI1MzI0MTA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/25324105?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adiasg",
      "html_url": "https://github.com/adiasg",
      "followers_url": "https://api.github.com/users/adiasg/followers",
      "following_url": "https://api.github.com/users/adiasg/following{/other_user}",
      "gists_url": "https://api.github.com/users/adiasg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adiasg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adiasg/subscriptions",
      "organizations_url": "https://api.github.com/users/adiasg/orgs",
      "repos_url": "https://api.github.com/users/adiasg/repos",
      "events_url": "https://api.github.com/users/adiasg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adiasg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-12T19:09:54Z",
    "updated_at": "2024-01-12T19:09:54Z",
    "author_association": "MEMBER",
    "body": "At first glance, it seems this proposal does not change the behavior of how the CL optimistically tracks blocks. That is, even with this change a CL with a functioning EL attached would return the same head block as today.\r\n\r\nCan you explain the difference?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1889815163/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1889836103",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3577#issuecomment-1889836103",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3577",
    "id": 1889836103,
    "node_id": "IC_kwDOCOoGbc5wpJxH",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-12T19:27:11Z",
    "updated_at": "2024-01-12T19:27:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the question, I'll add more context on the kinds of changes this would entail. There are some design decisions still to be made, and I am not strongly advocating for some of those decisions that I'll include below. \r\n\r\nCurrently the CL would not even considered for forkchoice a block unless the EL has returned from `notify_NewPayload` with either `VALID`, `ACCEPTED` or `SYNCING`. If the EL returns any of these values, then the CL imports the block for forkchoice and that block is treated, for the purposes of computing the current head, as any other block. That is, at any given time, the head returned from forkchoice could be a block that was imported optimistically (`ACCEPTED` or `SYNCING` replies above). In the even that a call to `get_head` returns an optimistic block, the node is said to be in optimistic mode and it cannot serve duties, that is, such a beacon will not provide a block to propose nor an attestation to sign. \r\n\r\nOn the other hand, if the EL does not return anything (for example if the EL is taking a long time to execute the block) or even errors out on an internal bug, the beacon does not import the block, and the current forkchoice is not changed. This node does not become optimistic, a call to `get_head` will return the previous head without changes and the beacon will happily provide blocks to propose on top of that previous head, or attestations to it. \r\n\r\nThis issue (or the accompanying PR if I get some traction) proposes to change the behavior so that even in the event that the EL is taking longer and does not reply, the block can be imported. It can be imported \"optimistically\" or can be imported with some extra annotation to show that the block was not validated by the EL. But the block will still count for forkchoice and therefore it will affect the result of `get_head` even in the second case. \r\n\r\nThe reason for this change is multi-purpose:\r\n\r\n- Faster CL validation of the block: Since currently we need to wait for the full execution of the block and forkchoice cannot change until at least we have heard back from `notify_NewPayload`, clients stay locked one way or another for a long period in which they can't reliably touch forkchoice. This is on the one hand an implementation detail (functional style programming allows you to have different copies of forkchoice with a large shared subtree or, what prysm currently does, you need to lock forkchoice until the block processing has happened). \r\n- Simplicity of code for the CL:  in part due to the interplay between the CL and the EL, block validation itself becomes complicated because of all the possible combinations of returns from the EL. With the above change, the CL will simply validate the CL status for the block and include it in forkchoice. Then later\r\n    - If the EL returns that the block is invalid, the CL will remove those paths from forkchoice (code already present to deal with invalid blocks¨)\r\n    - If the node is requested for duties, then the node can check if it's head has been fully validated or not (code already present to check optimistic status). \r\n   \r\n There is a liveness component to consider here: if we still do not allow a beacon node to propose blocks when its head is not fully verified, then we would be in a situation where some blocks could be proposed in the previous behavior and some wouldn't with the proposed behavior (that is the EL is taking a long time to validate the currently syncing block, and the node is requested to propose a block). \r\n\r\nTherefore I would tentatively favour that validators that are syncing this way do perform duties on top of their last fully validated block, perhaps with some reasonable conditions like being that this block is a descendant of the current finalized or justified checkpoint. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1889836103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
