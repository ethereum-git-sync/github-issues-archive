{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2270",
  "id": 839282596,
  "node_id": "MDU6SXNzdWU4MzkyODI1OTY=",
  "number": 2270,
  "title": "SSZ Union improvement proposal",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    },
    {
      "id": 2812431987,
      "node_id": "MDU6TGFiZWwyODEyNDMxOTg3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/Bellatrix",
      "name": "Bellatrix",
      "color": "1D36aa",
      "default": false,
      "description": "CL+EL Merge"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2021-03-24T02:29:08Z",
  "updated_at": "2021-05-28T18:20:52Z",
  "closed_at": "2021-05-28T18:20:52Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "The current [Union type](https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#composite-types) is not used in Phase0, and largely not yet implemented in client implementations (exception: lighthouse). In more dynamic contexts, it's could be very useful however. \r\n\r\nThe direct motivation for this is the [Merge block format](https://github.com/ethereum/eth2.0-specs/pull/2257), in which we may see different transaction types that need to be encoded. To avoid overhead of lots of unused zero fields (SSZ does not truncate zeroes like RLP does), you would need different transaction type definitions. And how do you mix these different transactions in the same list, with a Union type.\r\n\r\nOne problem is that it takes 4 bytes per `Union` selector index (the switch between the type options), and we only really see a few type options in the common use case. This is a simple proposal to parametrize (at the type level, compile-time) the selector byte length. E.g. `Union[4, [uint256, Bitvector, uint8]]` would be **backwards compatible** with the already specified `Union[uint256, Bitvector, uint8]`. This would allow us to specify something like `Union[TRANSACTION_SELECTOR_LENGTH, [LegacyTransaction, BetterTransaction, SuperTransaction, AbstractedTransaction]]` (and yes, the selected index is part of the merkleization, no confusion between types in the merkle proof)\r\n\r\nFor the merge specifically, an alternative is to use opaque transactions (`List[byte, max_size], a.k.a. Bytes[max_size]` to encode an RLP transaction, instead of structured data). The pro is that the beacon-spec does not have to care about transaction types, the con is that we miss out on SSZ merkleization of transactions into the block-root, one of the very primary places that merkle-proofs would actually be very useful (you can construct a merkle proof about any transaction detail).\r\n\r\nAs a proof of concept, I implemented this new `Union` behavior in `remerkleable`, the SSZ library used in the python specification. See [here](https://github.com/protolambda/remerkleable/pull/9). (*Note for code reader: it represents the data as binary tree, and overlays it with views, it's focused on merkle proofs and data sharing more so than structural efficiency*).\r\n\r\n",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806053639",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-806053639",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 806053639,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNjA1MzYzOQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-24T18:20:14Z",
    "updated_at": "2021-03-24T18:20:14Z",
    "author_association": "MEMBER",
    "body": "This makes sense to me. Opaque bytes or empty fields seem inferior to using a Union type and reducing the byte footprint is simple enough.\r\n\r\nAny reason the type def has selector length prior to union types?\r\n`Union[selector_length, [types...]]` rather than `Union[[types...], selector_length]`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806053639/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806059074",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-806059074",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 806059074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNjA1OTA3NA==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-24T18:28:32Z",
    "updated_at": "2021-03-24T18:28:32Z",
    "author_association": "MEMBER",
    "body": "Learning from the mistakes of the Contract ABI, I would suggest to consider some forward compatibility.\r\n\r\nI am not sure if this is the case yet, but if the first byte is used as length/kind, a potential option is to block out the highest bit as an indicator for \"future/extended version\". That is only to allow unions where the highest bit not-set currently for the first byte (`b[0] & 0x80 == 0`).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806059074/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806146571",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-806146571",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 806146571,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNjE0NjU3MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-24T19:59:13Z",
    "updated_at": "2021-03-24T19:59:13Z",
    "author_association": "MEMBER",
    "body": "@djrtwo I think I prefer `Union[selector_length, [types...]]` because of the symmetry of the typing with `key, value` (`selcted_index, selected_value`) and because the `[types...]` parameter is constrained by the first parameter (can't have more than 256 types with `selector_length == 1`). And with long lists of types it doesn't end up at the very end:\r\n```\r\nclass Block(Container):\r\n  transactions: Union[TRANSACTION_SELECTOR_SIZE, [\r\n    BasicTransaction,\r\n    SpecialTransaction,\r\n    FoobarTransaction,\r\n    AnotherTransaction\r\n  ]]\r\n```\r\nFor more similarity with `List` and `Vector` we could instead define it as `N` reserved options, and derive the selector byte length to cover the reserved count.\r\nAnother change we could make is to parametrize it with a map, like: `Union[selector_size, {0: BasicTransaction, 0x42: SpecialTransaction}]` if we want to use specific selector bytes.\r\n\r\n\r\n@axic Good point, indicating something is reserved for extension purposes can be part of the `Union` spec. It's not a bitfield though, so reserving just the `0xff` selector, or some small range, could be sufficient.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/806146571/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807311131",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-807311131",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 807311131,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNzMxMTEzMQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-25T19:13:55Z",
    "updated_at": "2021-03-25T19:13:55Z",
    "author_association": "MEMBER",
    "body": "I dislike having to specify the selector size, it makes it a lot less elegant.\r\n\r\nGiven that it hasn't been used yet in any formal specification, can we simply reduce it to one byte now and assume that nobody will ever actually want a 4 byte selector in practice? I personally deem it very unlikely that anyone will run into it.\r\n\r\nIf we want to be super safe, we could simply compromise on two bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807311131/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807481337",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-807481337",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 807481337,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNzQ4MTMzNw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-25T21:02:19Z",
    "updated_at": "2021-03-25T21:02:19Z",
    "author_association": "MEMBER",
    "body": "@dankrad Good point, we can just do single-byte `Union`, nobody uses the current 4 byte version (or even implemented it). There's one exception I know of: Lighthouse uses it in their storage format, but that's outside of consensus. So let's simplify to a 1 byte selector, if we can confirm with Lighthouse? @paulhauner ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807481337/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807657304",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-807657304",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 807657304,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNzY1NzMwNA==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-25T22:48:20Z",
    "updated_at": "2021-03-25T22:48:20Z",
    "author_association": "MEMBER",
    "body": "I'm fine with dropping the selector to one byte. I would prefer one-byte instead of a variable-length selector. Although variable-length is more powerful, I think single-byte adheres better to the first S (simple) of SSZ. A union with more than 256 variants would be pretty gross and I don't think we should add complexity to the simple case (a few variants) to cover this.\r\n\r\nOn the lighthouse end, we only use Union for the `Option` Rust type (which is either `None` or `Some(value)`). If we wanted to avoid a DB migration (at the expense of some technical debt) we could introduce a `LegacySszOption` type which serializes in the old way. That's fairly painless for us.\r\n\r\nLooping in @michaelsproul as well :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807657304/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807666988",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-807666988",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 807666988,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNzY2Njk4OA==",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-25T22:54:15Z",
    "updated_at": "2021-03-25T22:54:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "Cries in Golang 😢. No preference from our end as we will not be able to use this regardless",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807666988/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807778907",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-807778907",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 807778907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgwNzc3ODkwNw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-03-26T00:06:47Z",
    "updated_at": "2021-03-26T00:06:47Z",
    "author_association": "MEMBER",
    "body": "@rauljordan protobuf and generated Go code support something like it (can't do `Union[A, A, B]` though, because multiple same types): https://developers.google.com/protocol-buffers/docs/reference/go-generated#oneof\r\nAlternatively, you can emulate it with a struct of pointer fields, and just check only a single field is set. No interfaces or weak typing that way. And manageable if there's only a limited amount of fields anyway.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/807778907/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/847668846",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2270#issuecomment-847668846",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2270",
    "id": 847668846,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0NzY2ODg0Ng==",
    "user": {
      "login": "Nashatyrev",
      "id": 8173857,
      "node_id": "MDQ6VXNlcjgxNzM4NTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8173857?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Nashatyrev",
      "html_url": "https://github.com/Nashatyrev",
      "followers_url": "https://api.github.com/users/Nashatyrev/followers",
      "following_url": "https://api.github.com/users/Nashatyrev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Nashatyrev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Nashatyrev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Nashatyrev/subscriptions",
      "organizations_url": "https://api.github.com/users/Nashatyrev/orgs",
      "repos_url": "https://api.github.com/users/Nashatyrev/repos",
      "events_url": "https://api.github.com/users/Nashatyrev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Nashatyrev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-25T08:31:49Z",
    "updated_at": "2021-05-25T08:34:16Z",
    "author_association": "MEMBER",
    "body": "I would vote for 1 byte selector + @axic suggestion to reserve the highest bit for potential backward compatible extension (to protobuf `varint` for example).\r\nI.e. `Union` selector then would be 1 byte with the max value of `127`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/847668846/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
