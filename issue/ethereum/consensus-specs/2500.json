{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2500",
  "id": 933210932,
  "node_id": "MDU6SXNzdWU5MzMyMTA5MzI=",
  "number": 2500,
  "title": "Potential array-out-of-bound runtime error in get_attesting_indices",
  "user": {
    "login": "booleanfunction",
    "id": 43776922,
    "node_id": "MDQ6VXNlcjQzNzc2OTIy",
    "avatar_url": "https://avatars.githubusercontent.com/u/43776922?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/booleanfunction",
    "html_url": "https://github.com/booleanfunction",
    "followers_url": "https://api.github.com/users/booleanfunction/followers",
    "following_url": "https://api.github.com/users/booleanfunction/following{/other_user}",
    "gists_url": "https://api.github.com/users/booleanfunction/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/booleanfunction/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/booleanfunction/subscriptions",
    "organizations_url": "https://api.github.com/users/booleanfunction/orgs",
    "repos_url": "https://api.github.com/users/booleanfunction/repos",
    "events_url": "https://api.github.com/users/booleanfunction/events{/privacy}",
    "received_events_url": "https://api.github.com/users/booleanfunction/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2734068619,
      "node_id": "MDU6TGFiZWwyNzM0MDY4NjE5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:security",
      "name": "scope:security",
      "color": "9C18CB",
      "default": false,
      "description": "General protocol security-related items"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2021-06-30T00:50:04Z",
  "updated_at": "2023-12-26T20:32:34Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## What the problem is and where it is located\r\n\r\nThe following relates to [eth2.0-specs/specs/phase0/beacon-chain.md](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md).\r\n\r\nIt appears that the `committee` created in `get_attesting_indices` can exceed length of `MAX_VALIDATORS_PER_COMMITTEE` and hence this will cause an array-out-of-bound runtime error when accessing `bits` to return the set of attesting indices. The problem occurs when the number of active validators exceeds `2**22 = 4,194,304`.\r\n\r\n<img width=\"1168\" alt=\"code1\" src=\"https://user-images.githubusercontent.com/43776922/123884772-5c7a4600-d98f-11eb-8d38-4f89443174d9.png\">\r\n\r\nI would note that strictly speaking, the SSZ definition of a `bitlist` means that `|bits| <= MAX_VALIDATORS_PER_COMMITTEE` and so a more accurate requirement for `get_attesting_indices` is that:\r\n\r\n`|committee| <= |bits| <= MAX_VALIDATORS_PER_COMMITTEE` (i.e.2048)\r\n\r\nhowever, the purpose of this analysis is to understand when \r\n`|committee| > MAX_VALIDATORS_PER_COMMITTEE`.\r\n\r\n## How was the problem discovered\r\n\r\nThe problem was discovered while using Dafny to formally verify the Beacon Chain Phase 0 spec ([eth2.0-dafny](https://github.com/ConsenSys/eth2.0-dafny)).\r\n\r\nAs I think the issue can be difficult to detect, particularly with the use of floor division and the dependency of parameter calculations between functions, I thought it would be useful to step through the calculations involved, which I do below. \r\n\r\n## Results of the analysis\r\n\r\nThe key results are that:\r\n\r\n- when 32 <= **number of active validators** <= 4,194,304, the length of `committee` will range between 1 and `MAX_VALIDATORS_PER_COMMITTEE` (inclusive) for all `data.slot` and `data.index` combinations\r\n- when 4,194,304 < **number of active validators** < 4,196,352, `committee` will have length greater than `MAX_VALIDATORS_PER_COMMITTEE` for at least one `data.slot` and `data.index` combination\r\n- when 4,196,352 <= **number of active validators**, `committee` will have length greater than `MAX_VALIDATORS_PER_COMMITTEE` for all `data.slot` and `data.index` combinations\r\n\r\nAnd for completeness, please note that:\r\n\r\n- when **number of active validators** < 32, `committee` will have length 0 for some `data.slot` and `data.index` combinations\r\n\r\n## Possible solution\r\n\r\nIf in `get_attesting_indices`we assume that `|bits| = MAX_VALIDATORS_PER_COMMITTEE` then a basic solution is to modify  `compute_committee` such that:\r\n\r\n`end = min(start + MAX_VALIDATORS_PER_COMMITTEE, (len(indices) * (index+1)) // count)`.\r\n\r\n\r\n## Detailed analysis\r\n\r\n#### Context\r\n`get_attesting_indices` is used as part of the rewards and penalties, justification and finalisation, as well as process_attestion.\r\n\r\nFor context I thought it was useful to show the function call paths.\r\n\r\n<img width=\"1254\" alt=\"functions\" src=\"https://user-images.githubusercontent.com/43776922/123884812-7451ca00-d98f-11eb-8228-9e4e1626bf28.png\">\r\n\r\n#### Tracing the problem\r\n\r\nTo determine how the length of `committee` is calculated we must look at `get_beacon_committee`.\r\n\r\n<img width=\"1151\" alt=\"code2\" src=\"https://user-images.githubusercontent.com/43776922/123884896-a8c58600-d98f-11eb-8cfc-c81399334654.png\">\r\n\r\nThe output of `get_beacon_committee` is then determined by the call to `compute_committee`.\r\n\r\n<img width=\"1158\" alt=\"code3\" src=\"https://user-images.githubusercontent.com/43776922/123884916-b2e78480-d98f-11eb-86b1-7a76dfebc7df.png\">\r\n\r\nIf we start with the return statement in `compute_committee`, the returned sequence will have a length determined by `range(start, end)`. Specifically, `range(start, end)` will yield a sequence of length `end-start` and hence:\r\n\r\n```\r\n|compute_committee(indices, seed, index, count)| \r\n= end-start\r\n= (len(indices) * (index+1)) // count - (len(indices) * index) // count\r\n```\r\n\r\nWhen `compute_committee` is called from `get_beacon_committee` we see that:\r\n\r\n- `indices = get_active_validator_indices` \r\n- `seed = get_seed` \r\n- `index = (slot % SLOTS_PER_EPOCH) * committees_per_slot + index`\r\n- `count = committees_per_slot * SLOTS_PER_EPOCH`\r\n\r\n(Note that the `index` parameter in `get_beacon_committee` is different to the `index` parameter in `compute_committee`).\r\n\r\nMaking these substitutions, at the `get_beacon_committee` level we determine `end` and `start` as follows:\r\n\r\n- `end = (len(get_active_validator_indices) * (((slot % SLOTS_PER_EPOCH) * committees_per_slot + index)+1)) // (committees_per_slot * SLOTS_PER_EPOCH) `\r\n- `start = (len(get_active_validator_indices) * ((slot % SLOTS_PER_EPOCH) * committees_per_slot + index)) // (committees_per_slot * SLOTS_PER_EPOCH) `\r\n\r\nThis is also a good time to mention that `committees_per_slot` is determined by a call to `get_committees_per_slot` and is calculated as follows:\r\n\r\n`committees_per_slot = max(1, min(MAX_COMMITTEES_PER_SLOT, len(get_active_validator_indices) // SLOTS_PER_EPOCH // TARGET_COMMITTEE_SIZE))`\r\n\r\n`committees_per_slot` is therefore a function of the number of active validators  and 0 < `committees_per_slot` <= 64.\r\n\r\nWe could now substitute the formula for `committees_per_slot` into `end` and `start` but for the purpose of this analysis we can conclude that `end - start` is a function of:\r\n\r\n- `len(get_active_validator_indices)`,\r\n- `slot % SLOTS_PER_EPOCH`, and\r\n- `index` (i.e. the committee `index` parameter of `get_beacon_committee`).\r\n\r\nIt is also useful to note the following bounds on these values:\r\n\r\n- 0 <= `slot % SLOTS_PER_EPOCH` < 32\r\n- 0 <= `index` < `committees_per_slot`\r\n\r\nPutting all of this together, when `get_beacon_committee(state, data.slot, data.index)` is called from `get_attesting_indices` for a state of a particular number of active validators, it can be done so for multiple (`data.slot`,`data.index`) combinations according to the above (`slot % SLOTS_PER_EPOCH`,`index`) bounds. \r\n\r\nFurther in relation to the `index` bounds, as `committees_per_slot` depends on the number of activate validators, the range of `index` also depends on the number of active validators. Once the number of active validators is sufficiently large, there will be a maximum of `32 * 64 = 2048` of these (`slot % SLOTS_PER_EPOCH`,`index`) combinations to consider for a state with a particular number of active validators.\r\n\r\nTo determine for which (`len(get_active_validator_indices)`, `slot % SLOTS_PER_EPOCH`,`index`) combinations we find that `end - start > MAX_VALIDATORS_PER_COMMITTEE` we need to analyse the above formulas for `end` and `start`. Of course, the use of floor division (i.e. `//`) makes this more difficult than regular division and hence here I will just show the overall results but I will include several specific examples where a bound breach occurs (i.e. where `end - start > MAX_VALIDATORS_PER_COMMITTEE`).\r\n\r\nI thought some visualisations might assist.\r\n\r\nLet's firstly consider how many `committees_per_slot` there will be for 0 < `len(get_active_validator_indices)` < 4,250,000.\r\n\r\n![analysis1](https://user-images.githubusercontent.com/43776922/123885054-f7732000-d98f-11eb-9e69-e793e0828650.png)\r\n\r\nWe see that once there are `2**18=262,144` or more active validators, `committees_per_slot` will reach its upper bound of 64.\r\n\r\nThe value of `committees_per_slot` consequently determines the number of (`slot % SLOTS_PER_EPOCH`,`index`) combinations to consider for a state with a particular number of active validators. \r\n\r\nIn the next graph we plot the number of (`slot % SLOTS_PER_EPOCH`,`index`) combinations, as well as how many of these input combinations will produce `end - start > MAX_VALIDATORS_PER_COMMITTEE` and hence ultimately how many `|committee| > MAX_VALIDATORS_PER_COMMITTEE` breaches occur at a given number of active validators.\r\n\r\n![analysis2](https://user-images.githubusercontent.com/43776922/123885075-ffcb5b00-d98f-11eb-94aa-7aa345285982.png)\r\n\r\nWe observe that the number of (`slot % SLOTS_PER_EPOCH`,`index`) combinations reaches its maximum of `32 * 64 = 2048` at `2**18=262144` active validators (i.e. as is expected given the Figure 1 in which `committees_per_slot` reaches its maximum at that number of active validators).\r\n\r\nWe can also observe that the number of these combinations where `|committee| = end - start > MAX_VALIDATORS_PER_COMMITTEE` is zero until the number of active validators exceeds `2**22 = 4,194,304`.\r\n\r\nIf we focus on this particular area of the graph, we see:\r\n\r\n![analysis3](https://user-images.githubusercontent.com/43776922/123885100-0b1e8680-d990-11eb-8aa4-587543ff85fa.png)\r\n\r\nHence, once the number of active validators exceeds `2**22 = 4,194,304` we can observe that there are (`slot % SLOTS_PER_EPOCH`,`index`) combinations such that `|committee| > MAX_VALIDATORS_PER_COMMITTEE`. Further, once the number of active validators reaches `2**22 + 2**11 = 4,196,352` we can observe that all (`slot % SLOTS_PER_EPOCH`,`index`) combinations will result in `|committee| > MAX_VALIDATORS_PER_COMMITTEE`.\r\n\r\n#### Examples\r\n\r\nWe can now look at a couple of examples to see which (`slot % SLOTS_PER_EPOCH`,`index`) combinations cause the problem for a set number of active validators.\r\n\r\nFor example, when the number of active validators is `4,194,305` we can see that (`slot % SLOTS_PER_EPOCH=31`,`index=63`) will be the only committee such that `|committee| > MAX_VALIDATORS_PER_COMMITTEE`. i.e. as indicated by the red block.\r\n\r\n![eg1](https://user-images.githubusercontent.com/43776922/123885117-140f5800-d990-11eb-9949-ddd8628e55ea.png)\r\n\r\nWhere as when the number of active validators is for example `4,194,355`, we can see that numerous (`slot % SLOTS_PER_EPOCH`,`index`) combinations result in `|committee| > MAX_VALIDATORS_PER_COMMITTEE`. i.e. as indicated by the red blocks.\r\n\r\n![eg2](https://user-images.githubusercontent.com/43776922/123885130-1d002980-d990-11eb-8ccf-7c3a52fbd543.png)\r\n\r\nI was able to prove the generalised results using formal verification in Dafny ([eth2.0-dafny](https://github.com/ConsenSys/eth2.0-dafny)) but to create the visualisations shown here I simply created a Jupyter notebook so as to explore the equations numerically.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500/reactions",
    "total_count": 3,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/874891098",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2500#issuecomment-874891098",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2500",
    "id": 874891098,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg3NDg5MTA5OA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-07-06T16:07:23Z",
    "updated_at": "2021-07-06T16:07:23Z",
    "author_association": "MEMBER",
    "body": "This is a known bound chosen and based on the instantiation of the beacon chain on mainnet Ethereum, assuming a maximum suppy of ~130M ETH and thus a maximum number of active validators.\r\n\r\nThis is noted briefly in the [annotated spec under `MAX_VALIDATORS_PER_COMMITTEE`](https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md#configuration).\r\n\r\nTwo quick comments:\r\n1. if there is a simple way to protect against this edge case, we can soft for it it without any issue. That said, any even moderate complexity on this edge is likely not worth it today given the bounds of mainnet ETH\r\n2. The most dangerous thing is likely if these values get naively parroted to another network instantiation that has different minimum ETH requirements or a different ETH supply. OR if ethereum beacon chain mainnet was later upgraded to do a validator split to require much less ETH per validator which could unexpectedly hit this threshold. *At the very least* this should be well documented somewhere.\r\n\r\n*[side note: there are *many* configuration relationships and details that are not well documented and would be weird foot-guns if trying to change configs for other networks. there is likely a whole project here on documenting these relationships]*",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/874891098/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
