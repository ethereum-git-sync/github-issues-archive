{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1008",
  "id": 438046881,
  "node_id": "MDU6SXNzdWU0MzgwNDY4ODE=",
  "number": 1008,
  "title": "Generalized Merkle Tree Index: use 0-based indexing",
  "user": {
    "login": "mratsim",
    "id": 22738317,
    "node_id": "MDQ6VXNlcjIyNzM4MzE3",
    "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mratsim",
    "html_url": "https://github.com/mratsim",
    "followers_url": "https://api.github.com/users/mratsim/followers",
    "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
    "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
    "organizations_url": "https://api.github.com/users/mratsim/orgs",
    "repos_url": "https://api.github.com/users/mratsim/repos",
    "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mratsim/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2019-04-28T11:37:07Z",
  "updated_at": "2019-08-20T14:44:07Z",
  "closed_at": "2019-08-20T14:44:06Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The current specs for generalized merkle tree uses 1-based indexing (https://github.com/ethereum/eth2.0-specs/blob/2787fea5feb8d5977ebee7c578c5d835cff6dc21/specs/light_client/merkle_proofs.md#generalized-merkle-tree-index)\r\n\r\nThe differences between 0 and 1 based indexing are the following:\r\n\r\n|             | root at 0 | root at 1 |\r\n|-------------|-----------|-----------|\r\n| Left child  | i*2 + 1  | i*2      |\r\n| Right child | i*2 + 2  | i*2 + 1  |\r\n| Parent      | (i-1)/2  | i/2      |\r\n\r\n## Convention\r\n\r\nUsing 0-based indexing would be using the common convention of most programming languages (save Fortran, Matlab and Julia).\r\n\r\n## Errors\r\n\r\nIt is well known that mixing 0-based and 1-based indexing tends to create off-by-one errors, we already had several such spec bugs in the past. And using 1-based indexing is introducing new risks.\r\n\r\n## Memory saving\r\n\r\nI expect clients to allocate binary trees with power-of-2 sizes for efficiency reasons.\r\nIf we have N nodes in the merkle tree where N is a power of 2 we will waste N-1 node space.\r\n\r\nConcrete example: 1 byte can store 256 values in the range [0, 255]\r\nAssuming we have values in range [1, 256] instead like the current proposition we would need 2 bytes of storage and will waste the [257-511] range which represent 255 values.\r\n\r\n### Alignment issues\r\n\r\nAssuming we store merkle proofs in arrays of uint32 at a low-level, they would need to be aligned to 32-bit boundaries on many architecture that would benefit the most from light clients (ARM, MIPS, ...).\r\n\r\nFurthermore Merkle proofs would probably be excellent candidates to be accelerated by SIMD/vector hardware which requires also requires alignment.\r\n\r\nThis off-by-one will cause unaligned loads/store that implementers will have to work around, probably via padding further increasing memory waste or via temporaries.\r\n\r\n## Potential counter-argument: extra computation\r\n\r\nSome might be worried that 0-based is slower than 1-based indexing\r\nwhere we can just use `2*i` and `2*i+1` to find children instead of `2*i+1` and `2*i+2`\r\nand `i/2` to find parents instead of `(i-1)/2`.\r\n  1. It doesn't make a difference because at a low-level, CPUs support Scale*Index+Offset\r\n     addressing mode if scale is a power of 2. Execution time is the same. (This is called SIB addressing in x86 and scaled register in ARM).\r\n  2. The performance is dominated by fetching data from memory. During\r\n     the previous memory fetch, the CPU can precompute the next location to fetch.\r\n     as there is no data dependencies.",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008/reactions",
    "total_count": 5,
    "+1": 5,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/487445311",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1008#issuecomment-487445311",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008",
    "id": 487445311,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzQ0NTMxMQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-29T03:51:50Z",
    "updated_at": "2019-04-29T03:51:50Z",
    "author_association": "MEMBER",
    "body": "The memory saving is really negligible, and I think it actually _improves_ alignment; \" If we have N nodes in the merkle tree where N is a power of 2 we will waste N-1 node space.\" is incorrect because most of the Merkle trees we use have 2^N leaves, and so 2^(N+1) - 1 total nodes, so adding an empty value in the zero position just gets us to 2^(N+1)\r\n\r\nAlso, and much more importantly, **generalized indices are not meant to correspond to memory positions and are you are not meant to think of it as an array**; for most complex SSZ objects, that would lead to a lot of empty space in your serialization because of regions that are unused.\r\n\r\nThe purpose of a generalized index is to serialize a binary path, and you can think of the algorithm as follows: the highest 1-bit is a flag saying \"the bits before this were just zeroes but the bits after this are where the actual path starts\", followed by the bits of the path from top to bottom. Viewed this way, offsetting everything down by 1 would break this abstraction.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/487445311/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/487508872",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1008#issuecomment-487508872",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008",
    "id": 487508872,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzUwODg3Mg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-29T09:08:56Z",
    "updated_at": "2019-04-29T09:08:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Also, and much more importantly, generalized indices are not meant to correspond to memory positions and are you are not meant to think of it as an array; for most complex SSZ objects, that would lead to a lot of empty space in your serialization because of regions that are unused.\r\n\r\nThe issue with that is that we will need a translation layer between generalized indices and the actual implementation which is 0-based raising the risk of off-by-one errors.\r\n\r\nAssuming we implement as sparse Merkle trees, the space difference disappears for both 0-based and 1-based but the risk of errors stays.\r\n\r\nRegarding the bit abstraction part, this is indeed the same coding as used in [Fenwick Trees/Binary Indexed Trees](https://en.wikipedia.org/wiki/Fenwick_tree#Description)\r\n\r\n> A Fenwick tree is most easily understood by considering a one-based array. Each element whose index i is a power of 2 contains the sum of the first i elements. Elements whose indices are the sum of two (distinct) powers of 2 contain the sum of the elements since the preceding power of 2. In general, each element contains the sum of the values since its parent in the tree, and that parent is found by clearing the least-significant bit in the index.\r\n>\r\n> To find the sum up to any given index, consider the binary expansion of the index, and add elements which correspond to each 1 bit in the binary form.\r\n> \r\n> For example, say one wishes to find the sum of the first eleven values. Eleven is 10112 in binary. This contains three 1 bits, so three elements must be added: 10002, 10102, and 10112. These contain the sums of values 1–8, 9–10, and 11, respectively.\r\n> \r\n> To modify the eleventh value, the elements which must be modified are 10112, 11002, 100002, and all higher powers of 2 up to the size of the array. These contain the sums of values 11, 9–12, and 1–16, respectively. The maximum number of elements which may need to be updated is limited by the number of bits in the size of the array.\r\n\r\nHowever in practice going through the branches would just use recursive \"if\" test, the binary coding would only be used for visual inspection and we can just `not` the binary representation to switch around the bits.\r\n\r\nComparatively, off-by-one errors are much harder to notice, debug and track down and I'd rather pay the small cost of breaking this abstraction to avoid off-by-ones.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/487508872/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489315467",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1008#issuecomment-489315467",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008",
    "id": 489315467,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTMxNTQ2Nw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-04T10:37:13Z",
    "updated_at": "2019-05-04T10:37:39Z",
    "author_association": "MEMBER",
    "body": "Generalized indices are intended for all kinds of SSZ objects, the great majority of which will be highly unbalanced (eg. think of the `BeaconState`), meaning that the mapping of tree leaves to generalized indices is going to have a lot of \"holes\" in it. So using the generalized index as a memory location is going to be a terrible idea, as you would have a really inefficient memory setup (for the `ShardState` it's looking like generalized indices might exceed `2**300`)\r\n\r\nSo for example, in the data structure below (eg. the SSZ structure  `{x: bytes32, y: {z: bytes32, w: bytes32}}`):\r\n\r\n```\r\n    R\r\n  A   B\r\n     C D\r\n```\r\n\r\nThe indices would be: R=1, A=2, B=3, C=6, D=7. _Nothing_ would correspond to 4 or 5.\r\n\r\nThe reason I don't use the sequential addressing as in the image of the chart in that wiki article is that it's a desideratum for a description of a given Merkle path to not depend on anything outside that path. You especially don't want a description of the path to depend on the size of a variable length list somewhere else in the data structure.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/489315467/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523047695",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1008#issuecomment-523047695",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1008",
    "id": 523047695,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzA0NzY5NQ==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-20T14:44:06Z",
    "updated_at": "2019-08-20T14:44:06Z",
    "author_association": "MEMBER",
    "body": "This was discussed on today's call (cc @protolambda and @djrtwo)—sticking with 1-based indexing for generalised indices lead to cleaner implementations.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/523047695/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
