{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3527",
  "id": 1954816059,
  "node_id": "I_kwDOCOoGbc50hCA7",
  "number": 3527,
  "title": "Consider Blob Sidecar slashing conditions",
  "user": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2023-10-20T18:18:37Z",
  "updated_at": "2023-10-27T00:14:32Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "4844 is being shipped in Deneb *without* slashing conditions on the p2p BlobSidecar message.\r\n\r\npeer-scoring cannot be performed in many cases (might/usually receive sidecar before block from that peer), but by and large, the effect of sending conflicting and invalid sidecars is that the proposer increases their risk of being orphaned. This, in most cases, is a distinct disincentive to spam the network. The primary reason one might leverage additional/invalid messages here is to either create and exploit temporary view splits OR to compound such messages with additional bugs to wreak havic (e.g. if there is a caching issue that creates and irreparable chain split).\r\n\r\nGiven these messages are not a part of the consensus and due to the impact of adding slashing conditions, it was decided to *not* incorporate any such slashable offenses in Deneb, but the conversation around if these should be added later continues to bubble up.\r\n\r\nThere are two types of potential offenses/slashings:\r\n1. Creating duplicate side-cars for a given slot/index. This is the most obvious anti-spam prevention and would lead to easy rules to follow and easy conditions to validate on-chain\r\n2. Creating invalid side-cars -- e.g. sidecars for indices beyond the amount of blobs in the block. This is a *much* more complex type of condition to encode in your anti-slashing DBs as well as to verify on chain.\r\n\r\nThe complexity and risks around (2) seem not a worthwhile path to go down.\r\n\r\nI am personally open to the discussion of (1), but by default, I am resistant to getting into VC anti-slashing DBs and coding this into the core consensus just due to the complexity, and as @dankrad noted, the additional risks it adds to running a validator and thus continue to disincentivize less professional players from validating.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773260653",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1773260653",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1773260653,
    "node_id": "IC_kwDOCOoGbc5psc9t",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-20T19:04:52Z",
    "updated_at": "2023-10-20T19:04:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "I am in Dankrad's camp in that adding slashing conditions is typically a heavy burden and should not be done lightly.\r\n\r\nOne thing I'd like to explicitly mention in this topic is that this issue forces clients to actively remove equivocating (or invalid) blobs quickly from their caches or temporary storage. Otherwise it may become exploitable as a  way of getting free DA. I suspect all clients anyway will implement this pattern (prysm currently does not). But if this becomes a hassle I'd be more open to consider at least 2 a slashable offense",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773260653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773456029",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1773456029",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1773456029,
    "node_id": "IC_kwDOCOoGbc5ptMqd",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-20T22:10:45Z",
    "updated_at": "2023-10-20T22:10:45Z",
    "author_association": "MEMBER",
    "body": "> One thing I'd like to explicitly mention in this topic is that this issue forces clients to actively remove equivocating (or invalid) blobs quickly from their caches or temporary storage. Otherwise it may become exploitable as a way of getting free DA.\r\n\r\nYou do not get free DA form this. In order to get data availability you need to prove in consensus that all nodes had to get the data to accept the block. In this case, the conflicting blob had no influence on the block getting accepted, so there is no free DA.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773456029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775291602",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775291602",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775291602,
    "node_id": "IC_kwDOCOoGbc5p0MzS",
    "user": {
      "login": "ppopth",
      "id": 631508,
      "node_id": "MDQ6VXNlcjYzMTUwOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/631508?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ppopth",
      "html_url": "https://github.com/ppopth",
      "followers_url": "https://api.github.com/users/ppopth/followers",
      "following_url": "https://api.github.com/users/ppopth/following{/other_user}",
      "gists_url": "https://api.github.com/users/ppopth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ppopth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ppopth/subscriptions",
      "organizations_url": "https://api.github.com/users/ppopth/orgs",
      "repos_url": "https://api.github.com/users/ppopth/repos",
      "events_url": "https://api.github.com/users/ppopth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ppopth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T14:09:38Z",
    "updated_at": "2023-10-23T14:11:57Z",
    "author_association": "MEMBER",
    "body": "> Creating duplicate side-cars for a given slot/index. This is the most obvious anti-spam prevention and would lead to easy rules to follow and easy conditions to validate on-chain\r\n\r\nThis sounds impossible to me.\r\n\r\nFrom what I see in the fields of `BlobSidecar`, you cannot create two valid side-cars for a given slot/index, because every field in the side-car is already bound by the block (for example, the blob field is bound by the kzg commitment inserted in the block).\r\n\r\nThe only case that you can create two different valid side-cars is that the proposer proposes two blocks, in which case, the proposer will be slashed anyway.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775291602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775296434",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775296434",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775296434,
    "node_id": "IC_kwDOCOoGbc5p0N-y",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T14:12:03Z",
    "updated_at": "2023-10-23T14:12:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This sounds impossible to me.\r\n\r\nThe point is that the blob is validated independent of the block: from the point of view of gossip validation the blobs are perfectly valid, and only when you get the block you realize that they are invalid. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775296434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775424390",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775424390",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775424390,
    "node_id": "IC_kwDOCOoGbc5p0tOG",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T15:10:05Z",
    "updated_at": "2023-10-23T15:11:04Z",
    "author_association": "MEMBER",
    "body": "> This sounds impossible to me.\r\n\r\nsorry if my phrasing it unclear. I was saying \"A slashing condition for the following: creating duplicate side-cars (thus one has to be invalid wrt a single block)\"\r\n\r\nSo the point is *as a slashing condition* you just need two *different* side-cars for the same slot/index signed by the same proposer. It doesn't matter which is invalid wrt a given chain",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775424390/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1777332137",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1777332137",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1777332137,
    "node_id": "IC_kwDOCOoGbc5p7--p",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-24T14:25:35Z",
    "updated_at": "2023-10-24T14:25:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "My initial thought is it's not worth adding a slashing condition. It might be better to outline RPC caching logic in the spec, since it *has* to be different from our gossip caching which currently (and I think correctly) ignores duplicates completely. The fact that gossip vs RPC caching have to be different tripped us up previously in lighthouse. Something like this:\r\n\r\n1. If you've seen the block\r\n    - serve only blobs with matching kzg commitments in blob by roots responses\r\n2. If you haven't seen the block\r\n    - serve the first valid blobs you see in blobs by root\r\n    - when the block arrives, evict any blobs without match kzg commitments, start requesting blobs by root, retrying until you get the blobs you know to be correct. Cache and serve these correct blobs\r\n\r\nMessing up this caching can split consensus (if it keeps you from importing a block) but IMO it's still simpler to get right than adding new slashing conditions. And like @ppopth is alluding to, the \"right\" blob is determinable so it's fundamentally different from duplicate blocks.\r\n\r\nI will say though, this logic assumes a block that's accepted as canonical had its blobs propagated on gossip widely enough that they can be found in req/resp relatively quickly.  But proposer boost actually weakens this, you just need to propagate the valid blobs to the next proposer plus a much smaller portion of the network. So in the worst case the majority nodes will need the blobs in req/resp and won't have it. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1777332137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1778555864",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1778555864",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1778555864,
    "node_id": "IC_kwDOCOoGbc5qApvY",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-25T05:47:39Z",
    "updated_at": "2023-10-25T05:47:39Z",
    "author_association": "MEMBER",
    "body": "> So in the worst case the majority nodes will need the blobs in req/resp and won't have it.\r\n\r\nWon’t nodes request block and correct blobs upon receiving attestation voting for the block or a child block built atop of it? So the inconsistency will likely be resolved in a sub slot amount of time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1778555864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1781904073",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1781904073",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1781904073,
    "node_id": "IC_kwDOCOoGbc5qNbLJ",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-26T21:14:41Z",
    "updated_at": "2023-10-26T21:14:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Won’t nodes request block and correct blobs upon receiving attestation voting for the block or a child block built atop of it? So the inconsistency will likely be resolved in a sub slot amount of time.\r\n\r\nYes, nodes would request from attesters as they see them. This just usually ends up in a missed attestation for the node, and if only a minority of nodes have the correct blobs, they're responsible for an outsized amount of uploading happening at once",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1781904073/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782102253",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1782102253",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1782102253,
    "node_id": "IC_kwDOCOoGbc5qOLjt",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-27T00:14:32Z",
    "updated_at": "2023-10-27T00:14:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "> they're responsible for an outsized amount of uploading happening at once\r\n\r\nI think this is a real problem. We lose an invariant that we have today. Currently a valid block that is received by any validator is properly synced and committed to DB. With the current gossip conditions we lose this property: a perfectly valid block (albeit from a malicious or buggy proposer) may be rejected by honest validators. The problem here is that if the next proposer actually received the right blobs and did sync the block on time, every validator that had rejected this block will trigger an RPC request. \r\n\r\n- This is an entirely new P2P phenomenon to which we have no data as far as I know gathered. And it is fairly complicated to gather such data in a devnet environment. \r\n- This makes the situation for the next proposer quite precarious as well, his block, no matter how timely, will take much longer to be synced by the part of the network that did receive the bad blobs first. This makes it likely to lose proposer boost and therefore be subject a depth 3 reorg if the next proposer is malicious. \r\n\r\nThe fact that a proposer can cause these splits without penalization (and slashing doesn't seem to completely solve this issue) makes me think that binding blobs to blocks should be taken seriously. There were mostly some concerns about bandwidth that led to unbundle them, however I think these are serious forkchoice issues that we can immediately solve by tying them, at the same time, code complexity on clients (something we hadn't really gauged when we decided to unbundle them) is now clear that becomes simpler with many less edge cases and caches to keep track of equivocating or spurious blobs. It does look like a large refactor, but mostly for a much simpler, less bug prone codebase. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782102253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
