{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3527",
  "id": 1954816059,
  "node_id": "I_kwDOCOoGbc50hCA7",
  "number": 3527,
  "title": "Consider Blob Sidecar slashing conditions",
  "user": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 11,
  "created_at": "2023-10-20T18:18:37Z",
  "updated_at": "2023-12-26T19:36:19Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "4844 is being shipped in Deneb *without* slashing conditions on the p2p BlobSidecar message.\r\n\r\npeer-scoring cannot be performed in many cases (might/usually receive sidecar before block from that peer), but by and large, the effect of sending conflicting and invalid sidecars is that the proposer increases their risk of being orphaned. This, in most cases, is a distinct disincentive to spam the network. The primary reason one might leverage additional/invalid messages here is to either create and exploit temporary view splits OR to compound such messages with additional bugs to wreak havic (e.g. if there is a caching issue that creates and irreparable chain split).\r\n\r\nGiven these messages are not a part of the consensus and due to the impact of adding slashing conditions, it was decided to *not* incorporate any such slashable offenses in Deneb, but the conversation around if these should be added later continues to bubble up.\r\n\r\nThere are two types of potential offenses/slashings:\r\n1. Creating duplicate side-cars for a given slot/index. This is the most obvious anti-spam prevention and would lead to easy rules to follow and easy conditions to validate on-chain\r\n2. Creating invalid side-cars -- e.g. sidecars for indices beyond the amount of blobs in the block. This is a *much* more complex type of condition to encode in your anti-slashing DBs as well as to verify on chain.\r\n\r\nThe complexity and risks around (2) seem not a worthwhile path to go down.\r\n\r\nI am personally open to the discussion of (1), but by default, I am resistant to getting into VC anti-slashing DBs and coding this into the core consensus just due to the complexity, and as @dankrad noted, the additional risks it adds to running a validator and thus continue to disincentivize less professional players from validating.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773260653",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1773260653",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1773260653,
    "node_id": "IC_kwDOCOoGbc5psc9t",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-20T19:04:52Z",
    "updated_at": "2023-10-20T19:04:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "I am in Dankrad's camp in that adding slashing conditions is typically a heavy burden and should not be done lightly.\r\n\r\nOne thing I'd like to explicitly mention in this topic is that this issue forces clients to actively remove equivocating (or invalid) blobs quickly from their caches or temporary storage. Otherwise it may become exploitable as a  way of getting free DA. I suspect all clients anyway will implement this pattern (prysm currently does not). But if this becomes a hassle I'd be more open to consider at least 2 a slashable offense",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773260653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773456029",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1773456029",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1773456029,
    "node_id": "IC_kwDOCOoGbc5ptMqd",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-20T22:10:45Z",
    "updated_at": "2023-10-20T22:10:45Z",
    "author_association": "MEMBER",
    "body": "> One thing I'd like to explicitly mention in this topic is that this issue forces clients to actively remove equivocating (or invalid) blobs quickly from their caches or temporary storage. Otherwise it may become exploitable as a way of getting free DA.\r\n\r\nYou do not get free DA form this. In order to get data availability you need to prove in consensus that all nodes had to get the data to accept the block. In this case, the conflicting blob had no influence on the block getting accepted, so there is no free DA.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1773456029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775291602",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775291602",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775291602,
    "node_id": "IC_kwDOCOoGbc5p0MzS",
    "user": {
      "login": "ppopth",
      "id": 631508,
      "node_id": "MDQ6VXNlcjYzMTUwOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/631508?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ppopth",
      "html_url": "https://github.com/ppopth",
      "followers_url": "https://api.github.com/users/ppopth/followers",
      "following_url": "https://api.github.com/users/ppopth/following{/other_user}",
      "gists_url": "https://api.github.com/users/ppopth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ppopth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ppopth/subscriptions",
      "organizations_url": "https://api.github.com/users/ppopth/orgs",
      "repos_url": "https://api.github.com/users/ppopth/repos",
      "events_url": "https://api.github.com/users/ppopth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ppopth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T14:09:38Z",
    "updated_at": "2023-10-23T14:11:57Z",
    "author_association": "MEMBER",
    "body": "> Creating duplicate side-cars for a given slot/index. This is the most obvious anti-spam prevention and would lead to easy rules to follow and easy conditions to validate on-chain\r\n\r\nThis sounds impossible to me.\r\n\r\nFrom what I see in the fields of `BlobSidecar`, you cannot create two valid side-cars for a given slot/index, because every field in the side-car is already bound by the block (for example, the blob field is bound by the kzg commitment inserted in the block).\r\n\r\nThe only case that you can create two different valid side-cars is that the proposer proposes two blocks, in which case, the proposer will be slashed anyway.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775291602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775296434",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775296434",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775296434,
    "node_id": "IC_kwDOCOoGbc5p0N-y",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T14:12:03Z",
    "updated_at": "2023-10-23T14:12:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This sounds impossible to me.\r\n\r\nThe point is that the blob is validated independent of the block: from the point of view of gossip validation the blobs are perfectly valid, and only when you get the block you realize that they are invalid. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775296434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775424390",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1775424390",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1775424390,
    "node_id": "IC_kwDOCOoGbc5p0tOG",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-23T15:10:05Z",
    "updated_at": "2023-10-23T15:11:04Z",
    "author_association": "MEMBER",
    "body": "> This sounds impossible to me.\r\n\r\nsorry if my phrasing it unclear. I was saying \"A slashing condition for the following: creating duplicate side-cars (thus one has to be invalid wrt a single block)\"\r\n\r\nSo the point is *as a slashing condition* you just need two *different* side-cars for the same slot/index signed by the same proposer. It doesn't matter which is invalid wrt a given chain",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1775424390/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1777332137",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1777332137",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1777332137,
    "node_id": "IC_kwDOCOoGbc5p7--p",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-24T14:25:35Z",
    "updated_at": "2023-10-24T14:25:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "My initial thought is it's not worth adding a slashing condition. It might be better to outline RPC caching logic in the spec, since it *has* to be different from our gossip caching which currently (and I think correctly) ignores duplicates completely. The fact that gossip vs RPC caching have to be different tripped us up previously in lighthouse. Something like this:\r\n\r\n1. If you've seen the block\r\n    - serve only blobs with matching kzg commitments in blob by roots responses\r\n2. If you haven't seen the block\r\n    - serve the first valid blobs you see in blobs by root\r\n    - when the block arrives, evict any blobs without match kzg commitments, start requesting blobs by root, retrying until you get the blobs you know to be correct. Cache and serve these correct blobs\r\n\r\nMessing up this caching can split consensus (if it keeps you from importing a block) but IMO it's still simpler to get right than adding new slashing conditions. And like @ppopth is alluding to, the \"right\" blob is determinable so it's fundamentally different from duplicate blocks.\r\n\r\nI will say though, this logic assumes a block that's accepted as canonical had its blobs propagated on gossip widely enough that they can be found in req/resp relatively quickly.  But proposer boost actually weakens this, you just need to propagate the valid blobs to the next proposer plus a much smaller portion of the network. So in the worst case the majority nodes will need the blobs in req/resp and won't have it. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1777332137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1778555864",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1778555864",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1778555864,
    "node_id": "IC_kwDOCOoGbc5qApvY",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-25T05:47:39Z",
    "updated_at": "2023-10-25T05:47:39Z",
    "author_association": "MEMBER",
    "body": "> So in the worst case the majority nodes will need the blobs in req/resp and won't have it.\r\n\r\nWon’t nodes request block and correct blobs upon receiving attestation voting for the block or a child block built atop of it? So the inconsistency will likely be resolved in a sub slot amount of time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1778555864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1781904073",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1781904073",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1781904073,
    "node_id": "IC_kwDOCOoGbc5qNbLJ",
    "user": {
      "login": "realbigsean",
      "id": 5160426,
      "node_id": "MDQ6VXNlcjUxNjA0MjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5160426?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realbigsean",
      "html_url": "https://github.com/realbigsean",
      "followers_url": "https://api.github.com/users/realbigsean/followers",
      "following_url": "https://api.github.com/users/realbigsean/following{/other_user}",
      "gists_url": "https://api.github.com/users/realbigsean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realbigsean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realbigsean/subscriptions",
      "organizations_url": "https://api.github.com/users/realbigsean/orgs",
      "repos_url": "https://api.github.com/users/realbigsean/repos",
      "events_url": "https://api.github.com/users/realbigsean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realbigsean/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-26T21:14:41Z",
    "updated_at": "2023-10-26T21:14:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Won’t nodes request block and correct blobs upon receiving attestation voting for the block or a child block built atop of it? So the inconsistency will likely be resolved in a sub slot amount of time.\r\n\r\nYes, nodes would request from attesters as they see them. This just usually ends up in a missed attestation for the node, and if only a minority of nodes have the correct blobs, they're responsible for an outsized amount of uploading happening at once",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1781904073/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782102253",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1782102253",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1782102253,
    "node_id": "IC_kwDOCOoGbc5qOLjt",
    "user": {
      "login": "potuz",
      "id": 16044918,
      "node_id": "MDQ6VXNlcjE2MDQ0OTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16044918?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/potuz",
      "html_url": "https://github.com/potuz",
      "followers_url": "https://api.github.com/users/potuz/followers",
      "following_url": "https://api.github.com/users/potuz/following{/other_user}",
      "gists_url": "https://api.github.com/users/potuz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/potuz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/potuz/subscriptions",
      "organizations_url": "https://api.github.com/users/potuz/orgs",
      "repos_url": "https://api.github.com/users/potuz/repos",
      "events_url": "https://api.github.com/users/potuz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/potuz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-27T00:14:32Z",
    "updated_at": "2023-10-27T00:14:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "> they're responsible for an outsized amount of uploading happening at once\r\n\r\nI think this is a real problem. We lose an invariant that we have today. Currently a valid block that is received by any validator is properly synced and committed to DB. With the current gossip conditions we lose this property: a perfectly valid block (albeit from a malicious or buggy proposer) may be rejected by honest validators. The problem here is that if the next proposer actually received the right blobs and did sync the block on time, every validator that had rejected this block will trigger an RPC request. \r\n\r\n- This is an entirely new P2P phenomenon to which we have no data as far as I know gathered. And it is fairly complicated to gather such data in a devnet environment. \r\n- This makes the situation for the next proposer quite precarious as well, his block, no matter how timely, will take much longer to be synced by the part of the network that did receive the bad blobs first. This makes it likely to lose proposer boost and therefore be subject a depth 3 reorg if the next proposer is malicious. \r\n\r\nThe fact that a proposer can cause these splits without penalization (and slashing doesn't seem to completely solve this issue) makes me think that binding blobs to blocks should be taken seriously. There were mostly some concerns about bandwidth that led to unbundle them, however I think these are serious forkchoice issues that we can immediately solve by tying them, at the same time, code complexity on clients (something we hadn't really gauged when we decided to unbundle them) is now clear that becomes simpler with many less edge cases and caches to keep track of equivocating or spurious blobs. It does look like a large refactor, but mostly for a much simpler, less bug prone codebase. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782102253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782412290",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1782412290",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1782412290,
    "node_id": "IC_kwDOCOoGbc5qPXQC",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-27T07:10:53Z",
    "updated_at": "2023-10-27T07:18:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "> The fact that a proposer can cause these splits \r\n\r\nOriginal discussion about the possibility to split the network: https://github.com/ethereum/consensus-specs/pull/3244#discussion_r1109156321\r\n\r\nA core point to remember here is that we're talking about colluding dishonest successive proposers, ie those that have private connections between each other - otherwise, with a correctly implemented cache, the correct blobs will eventually reach all participants on gossipsub.\r\n\r\n> they're responsible for an outsized amount of uploading happening at once\r\n\r\nnot quite - you cannot forward an attestation for a block that you haven't fully observed and validated, so either you don't forward the attestation or you forward it to 8 peers at most (on average) - this means that the rpc access pattern will _broadly_ follow attestation propagation patterns. If clients \"hold\" the attestation in a quarantine/short queue and only rebroadcast it once they've observed the valid blobs, we get an even network usage balance which in general uses less bandwidth for spreading the correct blobs than than gossipsub in general (because no duplicates will be sent). Of course, this requires said quarantine to be implemented in clients, which today is not required (it's recommended though to deal with block vs attestation race conditions).\r\n\r\n> cache\r\n\r\ncaches are indeed the most tricky part here - in particular, we don't specify well in the spec what to do with `IGNORE` stuff once we determine its status (VALID or REJECT) - the correct thing to do at that point (for any message, not just blobs) is to clear IGNORE from the libp2p cache and rebroadcast it (to peers that haven't observed the correct version yet), but this needs to be written down and ideally tested.\r\n\r\nTaking a step back, IGNORE is used for any condition whose adherence to the protocol cannot be determined at that time - for example an attestation whose block we haven't seen, a block whose parent we haven't seen or indeed a blob whose block we haven't seen. \r\n\r\nAll these situations _eventually_ resolve themselves and an efficient client must keep track of that resolution in order not to spam the network but also in order for the network to efficiently reach a steady valid state - for example, if you haven't observed a block and later observe it and determine it's invalid, you need to store this \"invalid\" state in a semi-permanent store (ie at least in memory until shutdown with some high upper bound on number of messages you keep track of) because the libp2p message cache is not sufficient to protect against _the same_ message spreading again on the network, specially during non-finality (or indeed from the client shooting itself in the bandwidth foot and re-requesting it as it chases some weird block history).\r\n\r\nThus, the important point to remember here is that the majority of clients operating on the network already need to be correct and .. \"minimally efficient\" - ie that they are bug-free in critical places and have well-implemented caches - but this is not a new assumption - an inefficient implementation of the spec (hello, quadratic scans of the validator set in the state transition), if it were in majority, can still take down the network and render it unstable, slashing conditions or no (similar to how slow a slow EL block can throw off the network as clients take time to validate / execute them).\r\n\r\nMy original proposal for splitting blobs included the following condition: \r\n\r\n> -- If full verification of the blob fails at a later processing stage, clients MUST clear the blob from this \"seen\" cache so as to allow a the valid blob to propagate. The next block producer MAY orphan the block if they have observed multiple blobs signed by the proposer for the same \"seen\" tuple.\r\n\r\nIt was deemed unnecessary to specify because of the second half being difficult to analyze, but the first half still remains necessary for efficient blob propagation (ie it's part of the \"minimally efficient\" implicit stuff that unfortunately is not specified but still needs to happen). \r\n\r\nI'm happy to readd it (ie `If full verification of the blob fails at a later processing stage, clients MUST clear the blob from this \"seen\" cache so as to allow a the valid blob to propagate.`) as a spec condition if it helps implementers.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782412290/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782451991",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3527#issuecomment-1782451991",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3527",
    "id": 1782451991,
    "node_id": "IC_kwDOCOoGbc5qPg8X",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-10-27T07:42:55Z",
    "updated_at": "2023-10-27T07:42:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "Relevant for this discussion also: https://github.com/ethereum/consensus-specs/pull/3257",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1782451991/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
