{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1128",
  "id": 448838500,
  "node_id": "MDU6SXNzdWU0NDg4Mzg1MDA=",
  "number": 1128,
  "title": "Where SSZ and merkle partials meet.",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2019-05-27T12:41:55Z",
  "updated_at": "2019-06-21T00:17:44Z",
  "closed_at": "2019-06-21T00:17:44Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "So, I have been thinking about implementing SSZ in Go. And given that we already have a bunch (old ZRNT, Firefly, Prysm) with old features, I started thinking of new designs.\r\n\r\n## Opportunities to combine\r\n\r\nCurrently, generalized indices and (multi-)proofs are only thought of as future light-client facilitating tech. But what if a SSZ implementation actually worked well with it?\r\n\r\nThere are a few opportunities in each of the areas, outlined below.\r\n\r\n### Hash-tree-root caching\r\nIt's essentially the same as proofing. When you (multi-)proof, you hit roots of the branch, and stop hashing actual data underneath. The only difference between a (normal) proof is that a proof is unstructured (a multiproof is not). And you check the root, whereas with a cache you are getting a trusted root. It would be nice if you can detach the cache completely, and hit/update it by generalized index. And when you want to verify a part of your state, you run hash-tree-root with the proof data as cache, then verify the root.\r\n\r\n### Serialization\r\nWhen you serialize data, you may only be interested in a specific part to serve to a light-client, based on general indices. So you may as well skip data that's not requested. This touches on the Null/Option discussion in SSZ. Alternative to extending SSZ with options/nulls, we could define a way to read SSZ like normal, but *filtered*. I.e. one or more generalized indices describe the part of the SSZ value actually encoded. The filtering idea is described in more detail below. (there's multiple variants too)\r\n\r\n### Deserialization\r\nWriting a decoder for ZRNT is another goal of mine. However, if you're a light-client, and just need to know about a change in a subsection of a *much* bigger object, without knowing the location, it would be nice to update it easily.\r\nThe idea is that one can do the reverse of filtered serialization: only decode into the generalized indices approved by a filter. This symmetric (with encoder) ignorance of arbitrary ssz data effectively is a more powerful form of Null/Options. (too much?)\r\n\r\n## Filters\r\n\r\nAnother interesting thing with generalized indices + partials that I didn't find anywhere yet: we *can sort them, and binary-search through them to efficiently hit a yes/no for location based queries*. This would be the basis to compile a list of generalized indices (merkle partial) into generalized-filter.\r\n\r\nNow, this filter can be applied to implement the different opportunities above:\r\n```python\r\ndef hash_tree_root(value, typ, filter, index):\r\n    h, ok = filter(index)\r\n    if ok:\r\n      if typ == ...:\r\n        return hash(value)\r\n      if issubclass(typ, Container):\r\n        # merkleize also hits the filter. Values are supplied in lambdas to lazily evaluate/skip.\r\n        # when recursively calling into deeper merkle levels, pass the (adjusted) index we're at. And the count (depth can be inferred from it) when type information doesn't suffice (e.g. list) / is not provided.\r\n        return merkleize((lambda: hash_tree_root(field, field_typ, filter, index.deeper(field_index, typ.field_count)) for (field, field_typ, field_index) in typ.get_fields(), filter, index, typ.field_count)\r\n      elif ...\r\n      ...\r\n    else:\r\n      return h\r\n\r\ndef serialize(value, typ, filter, index):\r\n    if filter(index):\r\n      if typ == ...:\r\n        return value.to_bytes()\r\n      # Same idea with recursive propagation of filter + adjusted index here.\r\n      elif ...\r\n      ...\r\n    else:\r\n      # two options:\r\n      # 1. encode as if a zero value (decoding just works)\r\n      # 2. don't encode (decoder needs to have same filter applied)\r\n\r\ndef deserialize(data, typ, filter, index):\r\n    if filter(index):\r\n      if typ == ...:\r\n        return bytes_to_foobar(data)\r\n      # Same idea with recursive propagation of filter + adjusted index here.\r\n      elif ...\r\n      ...\r\n    else:\r\n      # two options:\r\n      # 1. decode as if any value, just skip over it (standard encoding just works)\r\n      # 2. don't skip over byte data, expect next data to be next filter hit (encoder needs to have same filter applied)\r\n```\r\nNote: this is just pseudocode, I would advise real implementations to read from a stream-like input, and to decode into values, instead of returning them (facilitating updates of previous values).\r\n\r\nAlthough the zeroed-out data variant would be compatible over the current approach, it is a lot of redundant information, and we may not want to leak information of the size of the object in some ignored struct field.\r\n\r\nAnother open design issue is how to introduce and remove cache entries. When in the scope of a small object, you may not know the generalized index. (there are workarounds however)\r\n\r\n",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504243482",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1128#issuecomment-504243482",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1128",
    "id": 504243482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNDI0MzQ4Mg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-21T00:17:44Z",
    "updated_at": "2019-06-21T00:17:44Z",
    "author_association": "MEMBER",
    "body": "I think with #1180 and #1184 we are close enough with a full partials implementation to close this. Re-open if anyone wants to share new ideas.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504243482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
