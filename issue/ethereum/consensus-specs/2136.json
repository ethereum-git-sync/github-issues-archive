{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2136",
  "id": 747876636,
  "node_id": "MDU6SXNzdWU3NDc4NzY2MzY=",
  "number": 2136,
  "title": "Avoid creating \"computation\" overflows when not necessary",
  "user": {
    "login": "franck44",
    "id": 14901362,
    "node_id": "MDQ6VXNlcjE0OTAxMzYy",
    "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/franck44",
    "html_url": "https://github.com/franck44",
    "followers_url": "https://api.github.com/users/franck44/followers",
    "following_url": "https://api.github.com/users/franck44/following{/other_user}",
    "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
    "organizations_url": "https://api.github.com/users/franck44/orgs",
    "repos_url": "https://api.github.com/users/franck44/repos",
    "events_url": "https://api.github.com/users/franck44/events{/privacy}",
    "received_events_url": "https://api.github.com/users/franck44/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2020-11-21T00:19:13Z",
  "updated_at": "2023-12-27T00:17:17Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "# Avoid creating \"computation\" overflows when not necessary\r\n\r\n## Overview of the Issue\r\n\r\nIn some part of the code of the Eth2.0 specs, some computations are performed on bounded integers (e.g. `uint64`) and may result in underflows/overflows.\r\nFor instance if `a` is  `uint64`, computing `3 * a` may result in an overflow as there result may not fit in the 64 bits.\r\n\r\nOverflows can contribute to reject blocks:\r\n\r\n> State transitions that cause a uint64 overflow or underflow are also considered invalid.  [[beacon chain transition function]](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md#beacon-chain-state-transition-function).\r\n\r\nAs a result a block can be rejected even if it is actually well-formed and not responsible for the overflows.\r\n(A related question is whether the previous statement applies only to `uint64` or any underflow/overflow.)\r\n\r\n## Avoiding spurious under/overflows\r\n \r\nHowever, it is possible to rewrite some parts of the specs in a way that avoids **creating spurious overflows**.\r\nSpurious overflows can appear because a computation of a property of a given value is implemented using **unsafe operations**,\r\nbut the property could be checked **without these unsafe operations**.\r\n\r\nExample: assume `a` and `b` are `uint64`.\r\nThe following code may result in an overflow when `a >= MAX_UNIT64 - 1`:\r\n```\r\nif (b >= 2) \r\n  if (a + 2 <= b)  // possible overflow for a + 2 that may not be a `uint64`\r\n  ....\r\n```\r\nThis code snippet can be rewritten in a safer equivalent version:\r\n```\r\nif (b >= 2) \r\n  if (a <= b - 2)  // b - 2 >= 0 and does not underflow not overflow.\r\n  ....\r\n```\r\n\r\n## Occurrences of this issue in part of the Eth2.0 specs\r\nThe [code](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md#justification-and-finalization) for `process_justification_and_finalization` may be made safer avoiding spurious overflows.\r\n\r\nThe following piece of code may be rewritten in a safer non-overflow-prone version:\r\n ```\r\n# Process finalizations\r\n if get_current_epoch(state) <= GENESIS_EPOCH + 1:\r\n        return\r\n\r\n// after this location, get_current_epoch(state) > GENESIS_EPOCH + 1 >= 2 and we can use this fact to\r\n// evaluate the following conditions without any overflows. \r\nbits = state.justification_bits\r\n# The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source\r\nif all(bits[1:4]) and old_previous_justified_checkpoint.epoch + 3 == current_epoch:\r\n      state.finalized_checkpoint = old_previous_justified_checkpoint\r\n# The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source\r\nif all(bits[1:3]) and old_previous_justified_checkpoint.epoch + 2 == current_epoch:\r\n        state.finalized_checkpoint = old_previous_justified_checkpoint\r\n# The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source\r\nif all(bits[0:3]) and old_current_justified_checkpoint.epoch + 2 == current_epoch:\r\n        state.finalized_checkpoint = old_current_justified_checkpoint\r\n# The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source\r\nif all(bits[0:2]) and old_current_justified_checkpoint.epoch + 1 == current_epoch:\r\n        state.finalized_checkpoint = old_current_justified_checkpoint\r\n```\r\n\r\nThe last three `ifs` statement can be rewritten as `old_previous_justified_checkpoint.epoch  == current_epoch - k, k = 1,2` (using a subtraction rather an addition to avoid any overflow.)\r\nThe first one `old_previous_justified_checkpoint.epoch + 3 == current_epoch` falls into two case:\r\n- `current_epoch == 2` and that case, this condition cannot be true as `old_previous_justified_checkpoint.epoch` is a `uint64` and thus non-negative\r\n- `current_epoch > 2` and in this case we can replace the test using a minus operator. Overall this can be rewritten as:\r\n\r\nAs a result it is equivalent to:\r\n\r\n```\r\n if all(bits[1:4]) and current_epoch >= 3 && old_previous_justified_checkpoint.epoch == current_epoch - 3:\r\n        state.finalized_checkpoint = old_previous_justified_checkpoint\r\n```\r\n\r\nAnother occurrence of possible overflows is in the computation of `supermajority` in the same function:\r\n```\r\nif get_attesting_balance(state, matching_target_attestations) * 3 >= get_total_active_balance(state) * 2:\r\n...\r\n```\r\n\r\nThe values `get_attesting_balance(state, matching_target_attestations)` and `get_total_active_balance(state)` are `uint64` and multiplying them may generate an overflow exception.\r\nThis issue can be mitigated by converting the value of `uint128` and perform the comparison with this type.\r\n\r\n## Formal verification that previous proposed patches are correct\r\n\r\nThe formal proof that the previous changes mitigate the overflow issues described above can be found in the [Dafny verified version of process_justification_and_finalization](https://github.com/ConsenSys/eth2.0-dafny/blob/81e73457bde0fef2e99cbd813ea5734a2f7f9d8d/src/dafny/beacon/StateTransition.dfy#L323).\r\n\r\n## How the problem was discovered\r\nThis issue was discovered as part of the formal verification of the [Eth2.0 specification in Dafny project](https://github.com/ConsenSys/eth2.0-dafny).\r\n\r\n\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/731874053",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2136#issuecomment-731874053",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136",
    "id": 731874053,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMTg3NDA1Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-23T00:27:30Z",
    "updated_at": "2020-11-23T00:28:23Z",
    "author_association": "MEMBER",
    "body": "One challenge is that the spec is not solely optimizing for mathematical cleanness; it's optimizing for human readability too (and perhaps even more importantly!). \"`if (a <= b - 2)  // b - 2 >= 0`\" is the exact opposite of that goal!\r\n\r\nOne idea that could achieve formal and human friendliness at the same time is having explicit arithmetically safe operations implemented as functions, eg. in a separate context I advocated for `a_times_b_div_c(a, b, c)` as that's a common case that currently requires ugly hacks to avoid overflows.\r\n\r\nThat said, in many of the cases above, we don't actually need to worry because many of those variables have bounds far below `2**64` that we can rely on, eg. we can safely assume slot and epoch numbers will be under `2**40`, we can safely assume that any balance total will be under `~2**58`, etc. Perhaps we should formalize these tighter bounds in cases where we know them? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/731874053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/731978112",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2136#issuecomment-731978112",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136",
    "id": 731978112,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMTk3ODExMg==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-23T07:25:59Z",
    "updated_at": "2020-11-23T07:25:59Z",
    "author_association": "NONE",
    "body": "I am unsure about readability issues. That for mathematical integers, the truth value of `a + 2 <= b` is the same as `a <= b - 2` seems reasonable and equally readable. \r\nHowever, in a programming context with fixed-sized bit vectors to represent integers, like `uint64`, this may be different. What is known is a fact about `b`, `b >= 2`, and using that fact we can guarantee a safe subtraction operation  `b - 2` in the domain `uint64` (`a + 2` cannot be guaranteed to be safe unless we have a pre-condition `a <= MAX_UINT64 - 2`).\r\n\r\nIf the specs were using mathematical integers that would be OK to use `a + 2`. However, because they prescribe a type, e.g. `uint64` we may think that this is important to account for bounds and make sure the code is safe (wrt under/overflows).\r\n\r\n> One idea that could achieve formal and human friendliness at the same time is having explicit arithmetically safe operations implemented as functions, eg. in a separate context I advocated for a_times_b_div_c(a, b, c) as that's a common case that currently requires ugly hacks to avoid overflows.\r\n\r\nI am unsure it solves the problem. And readability-wise `a_times_b_div_c(a, b, c)` does not really tell whether it is `(a * b) / c` or `a * ( b / c )`. This strategy would also require an adhoc solution for each arithmetic formula.\r\nProblems related to overflow/division by zero are hard to circumvent.\r\nA common solution is to add preconditions to functions which clearly describe the set of input values they accept to operate properly. And to guarantee the absence of problems, we then have to prove the every call to a function guarantees its preconditions.\r\nProving the absence of under/overflows usually requires semantic-level analysis (e.g. abstract interpretation or other static analysis) rather than new/alternative syntax.\r\n\r\n> That said, in many of the cases above, we don't actually need to worry because many of those variables have bounds far below 2**64 that we can rely on, eg. we can safely assume slot and epoch numbers will be under 2**40, we can safely assume that any balance total will be under ~2**58, etc. Perhaps we should formalize these tighter bounds in cases where we know them?\r\n\r\nYes I believe it but that may be true under optimistic circumstances, where no one is malicious.\r\nThe problem may not solely be to formalise the bounds in the theoretical foundations, but to prove that in the implementations \r\nthe program variables also satisfy their type bounds.\r\nIt may be doable to prove that in **a given context** all the operations are safe. But that is usually hard as it is an inter-procedural verification objective which requires to take into considerations the interactions between different functions (and the flow of values between them).\r\nAnother point is that we may not be able to prevent attackers to write code that calls some functions with unforeseen input (for instance if one can tamper with the memory and alter some stored values and choose to set them the `MAX_UINT64 - 1` although in theory this value is not supposed to be used).\r\nFinally the current specs rely on correct handling of exceptions (which may not be as simple as it sounds) so we may try to avoid/minimise their possible occurrences.\r\n\r\nThe changes proposed above aim to rule out any possibility of overflow under **any context** (the facts that the program typechecks and `b -2` is evaluated only when `b >= 2` are enough to prove it). They are simple to implement, can be formally proved as local properties  of [process_justif_and_final](https://github.com/ConsenSys/eth2.0-dafny/blob/81e73457bde0fef2e99cbd813ea5734a2f7f9d8d/src/dafny/beacon/StateTransition.dfy#L323)  and the result is much safer and simpler code (arguably more readable as no under/overflow can occur in this code snippet, so there is no need to handle any 'overflow' exception).\r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/731978112/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/732960364",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2136#issuecomment-732960364",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136",
    "id": 732960364,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMjk2MDM2NA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-24T13:03:39Z",
    "updated_at": "2020-11-24T13:03:39Z",
    "author_association": "MEMBER",
    "body": "It's an interesting idea to attach range assumptions to each variable that have to be checked, and then clients can hopefully drop most of these checks by proving from other assumptions that they can never be violated. This might make it much easier to make safe statements?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/732960364/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/733259823",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2136#issuecomment-733259823",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2136",
    "id": 733259823,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMzI1OTgyMw==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-24T22:05:11Z",
    "updated_at": "2020-11-24T22:05:11Z",
    "author_association": "NONE",
    "body": "> It's an interesting idea to attach range assumptions to each variable that have to be checked, and then clients can hopefully drop most of these checks by proving from other assumptions that they can never be violated. \r\n\r\nIt is not a new idea, this is common in formal verification. Note that we do not add range assumptions to input variables, but rather use their types to derive and attach (provably correct) range constraints to other variables.\r\nAnd indeed, once you have proved that range constraints cannot be violated you don't need runtime checks.\r\n\r\n> This might make it much easier to make safe statements?\r\n\r\nYes, for the example of the [safe process_justif_and_final](https://github.com/ConsenSys/eth2.0-dafny/blob/81e73457bde0fef2e99cbd813ea5734a2f7f9d8d/src/dafny/beacon/StateTransition.dfy#L323) we are able to prove (it is actually a mechanised proof) a strong guarantee: no overflow can happen during the computation of the result (we actually prove more safety properties, including that all the sizes of the `justification_bits` are the same).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/733259823/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
