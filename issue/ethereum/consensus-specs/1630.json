{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1630",
  "id": 571003824,
  "node_id": "MDU6SXNzdWU1NzEwMDM4MjQ=",
  "number": 1630,
  "title": "SSZ encoding/decoding for bit lists, bit vectors, recursive types.",
  "user": {
    "login": "franck44",
    "id": 14901362,
    "node_id": "MDQ6VXNlcjE0OTAxMzYy",
    "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/franck44",
    "html_url": "https://github.com/franck44",
    "followers_url": "https://api.github.com/users/franck44/followers",
    "following_url": "https://api.github.com/users/franck44/following{/other_user}",
    "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
    "organizations_url": "https://api.github.com/users/franck44/orgs",
    "repos_url": "https://api.github.com/users/franck44/repos",
    "events_url": "https://api.github.com/users/franck44/events{/privacy}",
    "received_events_url": "https://api.github.com/users/franck44/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 12,
  "created_at": "2020-02-26T01:48:27Z",
  "updated_at": "2020-03-30T11:16:29Z",
  "closed_at": "2020-03-30T11:16:29Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "I have tried to understand how bit vectors and bit lists (and other vectors and lists) are serialised but I am afraid I am missing a few steps. \r\nForgive me if these are silly questions and feel free to ignore and close if not relevant.\r\n\r\nFirst, I had a look at \"the implementations\" py-ssz and cava and found a few differences compared to the simple-serialize-md guidelines:\r\n\r\n1. for bit vectors, the py-ssz tests seem to consider bitvectors of size which are multiple of 8, which makes the deserialisation easier. The cava implementation does not seem to deal with bit vectors (and not any vectors).\r\n**How is the actual length of a bit vector encoded so that we can deserialise correctly?**\r\nFor instance, bit vector(true, true) is encoded into 0x03 in py-ssz and we probably want to decode it as (true, true) but the length is missing in the encoding.\r\n\r\n2. **what is the status of lists?** According to issue #1160, there was a discussion about removing lists from the SSZ legal types.\r\n\r\n3. lists should have homogeneous types.  It does not seem to rule out lists of containers, and containers can have fields that are containers.  simple-serialise.md refers to a recursive encoding but I could not find any example in py-ssz nor cava.\r\n\r\n4. fourth, Cava provides encoding for String but it does not seem to a type defined in simple-serialise.md. **Is String a legal (basic) SSZ type?**\r\n \r\n5. it is unclear to me why we need is_fixed_size (or not) and also get_size is not defined for variable sized types. When serialising, every list or vector has a given size. **What is the purpose of is_fixed_size?**\r\n\r\nWhere can we get more details about the efficient algorithms to encode these datatypes as sequences of bytes?\r\n\r\nThanks\r\nFranck",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591536226",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-591536226",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 591536226,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTUzNjIyNg==",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-26T17:07:18Z",
    "updated_at": "2020-02-26T17:07:18Z",
    "author_association": "MEMBER",
    "body": "> How is the actual length of a bit vector encoded so that we can deserialise correctly?\r\n\r\nThe length of the given ssz object is known from the type definition. Refer to definitions in the phase 0 spec for examples of ssz objects. If you expect a bit vector, you also know its length so that you can determine which bits are {un,}set in the encoded data.\r\n\r\n> what is the status of lists?\r\n\r\nwe still have lists, the linked issue was resolved by adding a notion of \"max length\" which helps w/ stable merkelization.\r\n\r\n> lists should have homogeneous types.\r\n\r\nthey do; in general you have a `List[T]` where `T` is your \"homogenous\" type. `T` can be a container w/ different types of fields but at the level of the `List` type constructor, you have fields of all one type (namely `T`).\r\n\r\n> simple-serialise.md refers to a recursive encoding but I could not find any example in py-ssz nor cava.\r\nare you looking for something like this? https://github.com/ethereum/py-ssz/blob/master/ssz/tools/dump.py\r\n\r\n>  Is String a legal (basic) SSZ type?\r\n\r\nno `String` type in the spec; I'm not familiar enough with `cava` to speak to what they are doing...\r\n\r\n> What is the purpose of is_fixed_size?\r\n\r\nThese functions are part of the offset encoding where we first encode fixed parts, then the offsets of the variable parts in the remainder of the encoding and then the actual data of the variable parts themselves. this allows for efficient retrieval of various parts of the encoding w/o having to decode the entire blob of ssz data.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591536226/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591733234",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-591733234",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 591733234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTczMzIzNA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T01:39:03Z",
    "updated_at": "2020-02-27T01:39:03Z",
    "author_association": "NONE",
    "body": "Thanks a lot @ralexstokes for the detailed explanation.\r\n\r\nI have just checked in more details some of \"the implementations\".\r\nPy-ssz seems to follow the spec top encode bitList, but I am a bit concerned that Cava/Tuweni does not. They seem to encode a bitList as the length of the list as an Int32, followed by one Byte per Boolean value in the list.\r\n\r\nIsn't the purpose of the SSZ spec to make sure clients can talk to each other?\r\n[irrespective of whether they are written in python or java).\r\n\r\nRegarding the fixed_size part, do I understand correctly:\r\n1. the fixed parts and the variable size parts are encoded separately?\r\n2. where is the actual algorithm in the spec that provides a clear description and examples of how that works? \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591733234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591745655",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-591745655",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 591745655,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTc0NTY1NQ==",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T02:25:34Z",
    "updated_at": "2020-02-27T02:25:34Z",
    "author_association": "MEMBER",
    "body": "> the fixed parts and the variable size parts are encoded separately?\r\n\r\na given ssz object is encoded as a single binary blob, the important bit is just their relative ordering so that it can be efficient to find variable size (sub)elements of some object\r\n\r\n> where is the actual algorithm in the spec that provides a clear description and examples of how that works?\r\n \r\nthe serialization is here: https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#vectors-containers-lists-unions\r\n\r\nre: cava -- i'd open an issue w/ that repo if something seems off. that discussion does not belong in this repo which should contain client-agnostic concerns.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591745655/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591760238",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-591760238",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 591760238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MTc2MDIzOA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-27T03:24:31Z",
    "updated_at": "2020-02-27T04:42:12Z",
    "author_association": "NONE",
    "body": "thanks @ralexstokes.\r\n\r\n> a given ssz object is encoded as a single binary blob, the important bit is just their relative ordering so that it can be efficient to find variable size (sub)elements of some object\r\n> \r\n> > where is the actual algorithm in the spec that provides a clear description and examples of how that works?\r\n> \r\n> the serialization is here: https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#vectors-containers-lists-unions\r\n\r\nyes I had a look at that, but I must admit it is not crystal clear.\r\nFirst it seems to generate a list of (list of bytes) rather than a list of bytes.\r\nSecond, is it not clear to me how it deals with recursive objects.\r\nIt seems to deal with sequences of objects which is a different thing.\r\nAs a matter of fact, I am unable to \"interpolate\" from that description how to encode a recursive type.\r\n\r\nIt is also unclear to me what the deserialiser is supposed to do. \r\nDoes it take as input a `seq<bytes>` AND a target type to deserialise into or just just a `seq<bytes>`?\r\n\r\n> re: cava -- i'd open an issue w/ that repo if something seems off. that discussion does not belong in this repo which should contain client-agnostic concerns.\r\n\r\nsure. But the simple-serialise.md references \"the implementations\" (including Cava) to find efficient algorithms that can serialise. And as not much information is available in the simple-serialise.md file, \"the implemenations\" are the next port of call to help.\r\nI have reported the issue to the Tuweni repo (Cava now seems to be included in Tuweni).\r\n\r\nThe specs may benefit from clearer definitions for the recursive types to make sure that every client implements the proper spec. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/591760238/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/592305008",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-592305008",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 592305008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MjMwNTAwOA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-28T04:15:40Z",
    "updated_at": "2020-02-28T04:15:40Z",
    "author_association": "NONE",
    "body": "@ralexstokes @MrChico \r\nFound a bit more information on SSZ at \r\nhttps://github.com/protolambda/eth2-docs/blob/master/eth2-ssz.png\r\n\r\nIt is still a bit dry. I am trying to write a formal specification (by formal I mean formal methods) of the specs and I'd like to capture the actual specification properly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/592305008/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602303132",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-602303132",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 602303132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMjMwMzEzMg==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-23T00:10:18Z",
    "updated_at": "2020-03-23T00:10:40Z",
    "author_association": "NONE",
    "body": "@ralexstokes @protolambda \r\nI am trying to understand how to encode say List[T] but I must admit all the information I have managed to access did not help me to understand how it works (and this includes the implementations like py-ssz).\r\n\r\nFirst, is there a proper definition (e.g. an algebraic datatype) of what a fixed-size type is?\r\nIs it a type built from basic types and nesting vectors/containers with only fixed-size type?\r\n\r\nSecond, is there any example how the encoding works for say List[uint8]?\r\nI have used [protolambda diagrams](https://github.com/protolambda/eth2-docs#ssz-encoding) as a starting point, but I am unable to understand how it works.\r\n\r\nHow is a List[uint8] encoded? For instance List[8, 111]?\r\nHow is a list of list encoded? For instance List[List[1],List[0,45.  It seems from the py-ssz implementations that the hash/merkelisation of the elements in the top-level list are used.\r\nSome real simple examples would help to understand how the SSZ machinery works.\r\n\r\nAgain I have tried to follow some links to get a better understanding but to avail.\r\nFor instance the  [go-ssz references](https://prysmaticlabs.gitbook.io/prysm/how-prysm-works/ethereum-2.0-serialization-simple-serialize-ssz) seem to provide encodings for \"slice, array, struct and pointer data types.\" These datatypes are not in the SSZ legal types.\r\n\r\nAny help would be music appreciated.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602303132/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602312507",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-602312507",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 602312507,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMjMxMjUwNw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-23T01:09:44Z",
    "updated_at": "2020-03-23T01:09:44Z",
    "author_association": "MEMBER",
    "body": "@franck44, hey, just got a notification, sorry I missed this issue earlier.\r\n\r\nFor some more reference on SSZ, check my repo (draft, but mostly complete): https://github.com/protolambda/eth2.0-ssz/\r\n\r\nRegarding encoding of lists: SSZ is a combination of 2 things to derive lengths: type information and scope in bytes. With scope I mean total byte count that is deserialized, or produced by serializing. And you can recurse deeper; the difference between offsets (or last offset and end of parent scope) is a scope.\r\n\r\nAlso, `List[8, 111]` is confusing: we use `List[E, N]` as notation for a list of `E` element type, and limit `N`.\r\n\r\nNow, to encode a byte list:  `[8, 11]` -> `080b`\r\nOr a list of uint16: `08000b00` (zero bytes last since it is little endian)\r\n\r\nNow a bigger list: `[8, 11, 3]` -> `080b03`\r\nThere are no delimiters, just 1 total scope of 3 bytes. Or 6 for `E = uint16`, etc.\r\nThen simply divide byte length by element type length, and you get the element count. This works for every fixed-size element type list.\r\n\r\nFor dynamic elements, such as a list of lists, offsets are used: `[[1, 2, 3], [4, 5]]`\r\n- `List[List[uint8, M], N]` as type: `0000 0008  0000 000b  0102 0304  05`\r\n  - `0000 0008`: first offset, 4 bytes, a uint32, pointing to the first element (`[1, 2, 3]`). Note that the offset includes the byte count used for offsets themselves.\r\n    - from the first offset, the length of the list is derived: offsets themselves are fixed length. So `element_count = first_offset // 4`\r\n  - `0000 000b`: second offset, 4 bytes, a uint32, pointing to the second element (`[4, 5]`)\r\n  - `0102 0304  05`: the contents\r\n- `010203` is sliced by the two offsets\r\n- `0405` is sliced by second offset + end of scope.\r\n- Note that the inner lists don't have offsets: their element type is fixed size (`uint8`), so the scope is sufficient information to determine the length, and elements are just located at `element_size * i`\r\n\r\nHope that explains the type info + offsets. Generally we do not nest small dynamic items much, so the offsets are fine and speed up lookups by a lot. Other than offsets (and selects for Union type), SSZ is completely free of runtime information, and everything can be derived from the types.\r\n\r\nIf you need more practical examples, there are some human readable test vectors here: https://github.com/protolambda/remerkleable/blob/master/remerkleable/test_impl.py\r\nAnd then a whole much bigger generated set in the Eth2 tests vectors repo.\r\n\r\nFor more low level code, you can also look at my ZSSZ library: github.com/protolambda/zssz\r\nOr if you prefer safety and more type elegance, the nim and rust (of respectively lighthouse and nimbus) are good resources.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602312507/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602313077",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-602313077",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 602313077,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMjMxMzA3Nw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-23T01:13:00Z",
    "updated_at": "2020-03-23T01:13:56Z",
    "author_association": "MEMBER",
    "body": "Also, regarding Cava, I think it is outdated. We did not have offsets until some time in April 2019 or so.\r\nHere's a more complete table with SSZ implementations: https://github.com/protolambda/eth2.0-ssz/#implementations\r\nAnd missing there is https://github.com/protolambda/remerkleable\r\nAnd note that the JS and Java (of Artemis, or now \"Teku\") have been changing a lot recently to move to an approach similar to remerkleable.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602313077/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602357892",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-602357892",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 602357892,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMjM1Nzg5Mg==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-23T03:02:10Z",
    "updated_at": "2020-03-23T03:02:10Z",
    "author_association": "NONE",
    "body": "@protolambda Thanks a lot for your quick reply. Very much appreciated.\r\n\r\nJust to provide you with some context, we are trying to write a formal specification of SSZ/Merkleisation,  some implementation of it and prove that it is correct (wrt spec).\r\nAt the moment, we have the basic types and bitlist specified and proved, and also have discovered a few bugs in the spec and the implementations.\r\nI'll try to extend our current spec to Lists using your explanations.\r\n\r\nThe main problem we are facing is navigating the information ... there is a lot out there and sometimes not consistent (for instance the specs refers to the implementations for \"efficient algorithms\" but the implementations do not seem to agree on how to serialise/deserialise).\r\nAnd most of the implementations are incomplete (they partially implement the spec).\r\n \r\nTo write a formal spec, we really need precise description of what a function should do (e.g. deserialise) rather than how it does it.\r\nI have been trying to find out what deserialise should take as input but it is still unclear to me.\r\nIs is a sequence of Bytes *AND* a target type (to deserialise into) or just a sequence of bytes (and the target type has to be inferred?).\r\nThere are quite a lot of very basic similar questions that do not seem to have obvious answers in the specs (I am not an Eth2 expert, so I may be incorrect). \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602357892/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602366151",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-602366151",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 602366151,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMjM2NjE1MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-23T03:30:35Z",
    "updated_at": "2020-03-23T03:30:35Z",
    "author_association": "MEMBER",
    "body": "> but the implementations do not seem to agree on how to serialise/deserialise\r\n\r\nThey definitely should, but on the surface of serialize/deserialize/hash-tree-root outputs. Internally they can organize however suites them best. There's no such thing as a \"canonical representation\" of data in memory. Only a local understanding of the type structure that it expresses. The type is the API and usage contract, not implementation. (the spec sets a bad example here, implementation is assumed to be done by clients their way, meeting the same outputs)\r\n\r\nA client can choose how to deserialize, e.g. directly into a binary tree structure (see remerkleable) or into native data-types of the given language (e.g. Prysm has methods to deserialize into Go structs that also conform to protobuf). And the implementations are out of sync for different use-cases and niches, e.g. fast read/writes of small objects (e.g. ZSSZ and lighthouse SSZ are very fast here), or re-use of earlier computed merkle work when the state only changes slightly (e.g. remerkleable).\r\n\r\nMost implementations (except the archived/outdated ones) specify what is necessary to stay in consensus with the eth2 beacon chain spec. `Union` for example is not implemented anywhere yet, since it's merely there, unused.\r\n\r\nThe current spec should be deterministic and unambiguous, although understandably hard to read and understand the finer details from. If you are looking for more description, the diagrams on that eth2-docs repo, and the eth2.0-ssz draft repo I linked should help.\r\n\r\n> I have been trying to find out what deserialise should take as input\r\n\r\n- The SSZ type is assumed, i.e. it's compile-time, something the reader of the data provides, not the data.\r\n- The byte-length (also described as scope) of the bytes to deserialize.\r\n- The actual bytes themselves.\r\n\r\nRegard usage of these primitives:\r\n\r\n- If you know the byte length, you can even stream-decode the bytes into the in-memory structure. E.g. in the RPC the length of the SSZ bytes is encoded separately.\r\n- And encoding can be streamed too, since the length can be derived first, and very efficiently so from all the compile-time information (we have lots of fixed-length types, and the dynamic ones are not deep, so they are easily computed by multiplying run-time length with compile-time fixed element size). And as soon as that total byte length number is available, the data can be traversed in one go to write to some output. (See ZSSZ for an example)\r\n- Unlike JSON, SSZ is very static and can be optimized for during compile-time, and expected input sizes etc. can be computed in advance with exact bounds (dynamic length objects have limits). This is great for optimizing functions, and baking in protections against invalid inputs before actually reading any of the data.\r\n\r\n> do not seem to have obvious answers in the specs \r\n\r\nUnfortunately the specs are more focused on being non-ambiguous yet practical, than explanatory. If you want to read background on choices in the eth2-specs in general I recommend https://notes.ethereum.org/@djrtwo/Bkn3zpwxB and https://benjaminion.xyz/eth2-annotated-spec/\r\n\r\nAlso, if you have any link of your work-in-progress (if open source?) please share :)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/602366151/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/605098374",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-605098374",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 605098374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwNTA5ODM3NA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-27T16:34:50Z",
    "updated_at": "2020-03-27T16:34:50Z",
    "author_association": "MEMBER",
    "body": "@franck44 any questions left? Can I close this issue?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/605098374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/605738040",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1630#issuecomment-605738040",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1630",
    "id": 605738040,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwNTczODA0MA==",
    "user": {
      "login": "franck44",
      "id": 14901362,
      "node_id": "MDQ6VXNlcjE0OTAxMzYy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14901362?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/franck44",
      "html_url": "https://github.com/franck44",
      "followers_url": "https://api.github.com/users/franck44/followers",
      "following_url": "https://api.github.com/users/franck44/following{/other_user}",
      "gists_url": "https://api.github.com/users/franck44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/franck44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/franck44/subscriptions",
      "organizations_url": "https://api.github.com/users/franck44/orgs",
      "repos_url": "https://api.github.com/users/franck44/repos",
      "events_url": "https://api.github.com/users/franck44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/franck44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-30T01:34:59Z",
    "updated_at": "2020-03-30T01:34:59Z",
    "author_association": "NONE",
    "body": "@protolambda \r\nyes thanks again, you may close this one.\r\nI'll try to use the info to work out how to specify and implement serialise/deserialise lists of fixed size and variable size.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/605738040/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
