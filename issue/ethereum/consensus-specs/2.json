{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2",
  "id": 362831452,
  "node_id": "MDU6SXNzdWUzNjI4MzE0NTI=",
  "number": 2,
  "title": "TODO: SimpleSerialize (SSZ) spec",
  "user": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 14,
  "created_at": "2018-09-22T06:33:19Z",
  "updated_at": "2018-11-05T13:35:38Z",
  "closed_at": "2018-11-05T13:35:38Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Open an issue for following up our discussion on gitter.\r\n\r\n## Specification requirements\r\n- Design rationale\r\n    - Directly mapping to the specified type and speeding block processing up. (by Vitalik from https://www.youtube.com/watch?reload=9&v=cp0LxJiyV3I)\r\n- Encoding\r\n- Decoding\r\n- Types\r\n   - Integers\r\n       - [not in the current implemenation] Specify the signed and unsigned integers support.\r\n       - [not in the current implemenation] Static types?\r\n\r\nAnything else? :)\r\n\r\n## Reference\r\n- [Python implementation - Vitalik's latest implementation in beacon_chain repo](https://github.com/ethereum/beacon_chain/tree/master/ssz)\r\n- [Rust implemenation - Lighthouse SSZ](https://github.com/sigp/lighthouse/tree/master/ssz)\r\n- [Lighthouse Serialization Sandbox Output](https://notes.ethereum.org/s/BkM5bqsIQ)\r\n- [Ethereum Yellow Paper - Appendix B: Recursive Length Prefix (RLP)](https://ethereum.github.io/yellowpaper/paper.pdf)\r\n- [The EVM Jello Paper - Recursive Length Prefix (RLP)](https://jellopaper.org/data/#recursive-length-prefix-rlp)\r\n- https://github.com/ethereum/beacon_chain/issues/94: simple_serialise - not possible to parse the structure without type information \r\n- https://github.com/ethereum/beacon_chain/issues/112: ssz intX type is actually uint\r\n\r\ncc @vbuterin @djrtwo @arnetheduck @mratsim @paulhauner @NatoliChris @poseyy\r\n",
  "closed_by": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423721189",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-423721189",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 423721189,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzcyMTE4OQ==",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-22T06:35:27Z",
    "updated_at": "2018-09-22T06:35:27Z",
    "author_association": "MEMBER",
    "body": "Repost [the gitter discussion about integer types](https://gitter.im/ethereum/sharding?at=5ba408a4b4990c30eee53db3):\r\n\r\n- @djrtwo: What is the argument for not supporting any int size that satifies `size % 8 == 0`?\r\n- @mratsim: for compiled language default int types are all that can be represented as `2^p`. int128 and int256 works but int40 or int24 don’t. That’s not super blocking as we can always represent them as an array of bytes or packed uint8 + uint16. i.e. in memory it’s just easier to use uint32 constrained to a certain range for uint24 for example. For serialization we would use an array of bytes.\r\n- @djrtwo: in memory, absolutely these things should be in 16/32/64 chunks. for the serialization, I see the value in tightly packing\r\n- @arnetheduck: when processing, it sometimes makes sense to use the smaller types in memory as well - compilers are actually pretty smart nowadays and in some static languages you can get away with 24-bit integers and the like. of course there are other considerations as well, alignment for the type, struct packing etc etc - all architecture-dependent\r\n- @hwwhww: Maybe use the integer type expression in solidity https://solidity.readthedocs.io/en/latest/types.html#integers\r\nIntegers `int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. But *don’t use* this: `uint` and `int` are aliases for `uint256` and `int256`, respectively. <— that’s too confusing in our use cases.\r\n- @arnetheduck: yeah - having 8-bit increments can be useful sometimes - the corresponding feature in C/C++ are bit fields - https://en.cppreference.com/w/cpp/language/bit_field - optimizers that are smart can do interesting things with them because they know upper and lower bounds more precisely - also, if there are large amounts of data, more fits in cache and less needs to be moved around, in general. the downside tends to be in unaligned access - most platforms have the property that aligned reads are faster - on some, it's even an error to read unaligned data, and you might have to resort to reading a 24-bit value byte by byte\r\nllvm likewise uses arbitrary-precision integers (http://llvm.org/docs/LangRef.html#integer-type) while wasm limits itself to i32 and i64",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423721189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423721417",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-423721417",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 423721417,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzcyMTQxNw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-22T06:40:11Z",
    "updated_at": "2018-09-22T06:40:52Z",
    "author_association": "MEMBER",
    "body": "Good call @hwwhww!\r\n\r\nHere's our README: https://github.com/sigp/lighthouse/tree/master/ssz\r\n\r\nEDIT: Oh, I see it's already in your list :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423721417/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423860904",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-423860904",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 423860904,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzg2MDkwNA==",
    "user": {
      "login": "p-mc2",
      "id": 33185528,
      "node_id": "MDQ6VXNlcjMzMTg1NTI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33185528?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/p-mc2",
      "html_url": "https://github.com/p-mc2",
      "followers_url": "https://api.github.com/users/p-mc2/followers",
      "following_url": "https://api.github.com/users/p-mc2/following{/other_user}",
      "gists_url": "https://api.github.com/users/p-mc2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/p-mc2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/p-mc2/subscriptions",
      "organizations_url": "https://api.github.com/users/p-mc2/orgs",
      "repos_url": "https://api.github.com/users/p-mc2/repos",
      "events_url": "https://api.github.com/users/p-mc2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/p-mc2/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T00:55:48Z",
    "updated_at": "2018-09-24T00:55:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is great, I love having so much information all in one place. A few quick comments: \r\n\r\nSome of the above on uint vs int and explicit types is covered [here](https://github.com/ethereum/beacon_chain/pull/120) and will hopefully clear up this small(?) issue. \r\n\r\nI'm writing a blog post on the basics of ssz and the rationale/motivation for introducing a new serialization format, I think the biggest issue with something like this is getting people to understand the rationale for a new format/understanding why it's necessary. Cheers. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423860904/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423866058",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-423866058",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 423866058,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzg2NjA1OA==",
    "user": {
      "login": "p-mc2",
      "id": 33185528,
      "node_id": "MDQ6VXNlcjMzMTg1NTI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33185528?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/p-mc2",
      "html_url": "https://github.com/p-mc2",
      "followers_url": "https://api.github.com/users/p-mc2/followers",
      "following_url": "https://api.github.com/users/p-mc2/following{/other_user}",
      "gists_url": "https://api.github.com/users/p-mc2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/p-mc2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/p-mc2/subscriptions",
      "organizations_url": "https://api.github.com/users/p-mc2/orgs",
      "repos_url": "https://api.github.com/users/p-mc2/repos",
      "events_url": "https://api.github.com/users/p-mc2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/p-mc2/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T02:19:04Z",
    "updated_at": "2018-09-24T02:19:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "One thing I did want to question: in RLP the main motivations were simplicity and guaranteed absolute byte-perfect consistency. Obviously simplicity is carried over, it *seems* like guaranteed absolute byte-perfect consistency is also a part of simple serialize. Can someone confirm this is the case? \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/423866058/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/424614873",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-424614873",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 424614873,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDYxNDg3Mw==",
    "user": {
      "login": "ChihChengLiang",
      "id": 3391420,
      "node_id": "MDQ6VXNlcjMzOTE0MjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3391420?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ChihChengLiang",
      "html_url": "https://github.com/ChihChengLiang",
      "followers_url": "https://api.github.com/users/ChihChengLiang/followers",
      "following_url": "https://api.github.com/users/ChihChengLiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/ChihChengLiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ChihChengLiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ChihChengLiang/subscriptions",
      "organizations_url": "https://api.github.com/users/ChihChengLiang/orgs",
      "repos_url": "https://api.github.com/users/ChihChengLiang/repos",
      "events_url": "https://api.github.com/users/ChihChengLiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ChihChengLiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-26T07:31:09Z",
    "updated_at": "2018-09-26T07:31:09Z",
    "author_association": "MEMBER",
    "body": "I have some archaeological discovery that might shed some light on this issue.\r\n\r\n> One of our core principles in Ethereum is simplicity; the protocol should be as simple as possible, and the protocol should not contain any black boxes. Every single feature of every single sub-protocol should be precisely 100% documented on the whitepaper or wiki, and implemented using that as a specification (ie. test-driven development).\r\n\r\nButerin, V. 2014 [RLP v.s. external technologies](https://blog.ethereum.org/2014/02/09/why-not-just-use-x-an-instructive-example-from-bitcoin/)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/424614873/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/424632325",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-424632325",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 424632325,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDYzMjMyNQ==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-26T08:34:14Z",
    "updated_at": "2018-09-26T08:34:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Here is Nim [implementation](https://github.com/status-im/nim-beacon-chain/blob/ca4082b316689c8702dc8ba665611de31e3a92cf/beacon_chain/ssz.nim), [simple tests](https://github.com/status-im/nim-beacon-chain/blob/master/tests/test_ssz.nim) and the discussion for a [common test format](https://github.com/ethereum/beacon_chain/issues/115).\r\n\r\nOne thing that I'm not too sure of regarding current SSZ are serializing container types. For example:\r\n\r\n```Python\r\n# CrystallizedState\r\nfields = {\r\n    # List of validators\r\n    'validators': [ValidatorRecord],\r\n    # Last CrystallizedState recalculation\r\n    'last_state_recalc': 'int64',\r\n    # What active validators are part of the attester set\r\n    # at what slot, and in what shard. Starts at slot\r\n    # last_state_recalc - CYCLE_LENGTH\r\n    'shard_and_committee_for_slots': [[ShardAndCommittee]],\r\n    # The last justified slot\r\n    'last_justified_slot': 'int64',\r\n    # Number of consecutive justified slots ending at this one\r\n    'justified_streak': 'int64',\r\n    # The last finalized slot\r\n    'last_finalized_slot': 'int64',\r\n    # The current dynasty\r\n    'current_dynasty': 'int64',\r\n    # Records about the most recent crosslink `for each shard\r\n    'crosslink_records': [CrosslinkRecord],\r\n    # Used to select the committees for each shard\r\n    'dynasty_seed': 'hash32',\r\n    # Start of the current dynasty\r\n    'dynasty_start': 'int64'\r\n}\r\n\r\n# ValidatorRecord\r\nfields = {\r\n    # The validator's public key\r\n    'pubkey': 'int256',\r\n    # What shard the validator's balance will be sent to \r\n    # after withdrawal\r\n    'withdrawal_shard': 'int16',\r\n    # And what address\r\n    'withdrawal_address': 'address',\r\n    # The validator's current RANDAO beacon commitment\r\n    'randao_commitment': 'hash32',\r\n    # Current balance\r\n    'balance': 'int128',\r\n    # Dynasty where the validator  is inducted\r\n    'start_dynasty': 'int64',\r\n    # Dynasty where the validator leaves\r\n    'end_dynasty': 'int64'\r\n}\r\n\r\n# ShardsAndCommittee\r\nfields = {\r\n    # The shard ID\r\n    'shard_id': 'int16',\r\n    # Validator indices\r\n    'committee': ['int24']\r\n}\r\n\r\n# CrosslinkRecord\r\nfields = {\r\n    # What dynasty the crosslink was submitted in\r\n    'dynasty': 'int64',\r\n    # What slot\r\n    'slot': 'int64',\r\n    # The block hash\r\n    'hash': 'hash32'\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/424632325/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/425626242",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-425626242",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 425626242,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTYyNjI0Mg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-29T08:10:31Z",
    "updated_at": "2018-10-02T12:34:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "Some thoughts in the past 2 days:\r\n\r\n## Type prefixes\r\n\r\nReplying to @AlexeyAkhunov https://github.com/ethereum/beacon_chain/issues/94 and https://github.com/ethereum/eth2.0-pm/issues/8\r\n\r\nAs mentioned by @raulk in https://github.com/ethereum/eth2.0-pm/issues/8 call, Protocol Labs (libp2p) will probably develop [specialized Wireshard dissectors](https://media.consensys.net/releasing-wireshark-dissectors-for-ethereum-ðξvp2p-protocols-215c9656dd9c) for Eth2.0 which should help traffic analysis a lot.\r\n\r\nHowever, I do think type prefixes would be useful at the top level for `BeaconBlock`, `ActiveState`, `CrystallizedState` i.e. treat them as tagged unions/sum types, but probably unneeded for nested types like `ShardAndCommittee`, `CrosslinkRecord`, `ValidatorRecord`, `AttestationRecord` (unless you serialize and send them as standalone?)\r\n\r\nFor instance let's look at ActiveState and CrystallizedState\r\n```python\r\n# ActiveState\r\nfields = {\r\n    # Attestations that have not yet been processed\r\n    'pending_attestations': [AttestationRecord],\r\n    # Most recent 2 * CYCLE_LENGTH block hashes, older to newer\r\n    'recent_block_hashes': ['hash32']\r\n}\r\n```\r\n```python\r\n# CrystallizedState\r\nfields = {\r\n    # List of validators\r\n    'validators': [ValidatorRecord],\r\n    # Last CrystallizedState recalculation\r\n    'last_state_recalc': 'int64',\r\n    # What active validators are part of the attester set\r\n    # at what slot, and in what shard. Starts at slot\r\n    # last_state_recalc - CYCLE_LENGTH\r\n    'shard_and_committee_for_slots': [[ShardAndCommittee]],\r\n    # The last justified slot\r\n    'last_justified_slot': 'int64',\r\n    # Number of consecutive justified slots ending at this one\r\n    'justified_streak': 'int64',\r\n    # The last finalized slot\r\n    'last_finalized_slot': 'int64',\r\n    # The current dynasty\r\n    'current_dynasty': 'int64',\r\n    # Records about the most recent crosslink `for each shard\r\n    'crosslink_records': [CrosslinkRecord],\r\n    # Used to select the committees for each shard\r\n    'dynasty_seed': 'hash32',\r\n    # Start of the current dynasty\r\n    'dynasty_start': 'int64'\r\n}\r\n```\r\n\r\nTo be able to deserialize and distinguish between those efficiently you would need to send or agree on the types beforehand.\r\n\r\nAlso having type prefixes for top-level types would allow to concat multiple messages in a single one. I don't think we should use type prefixes for 'hash32' or 'address' unless they are serialized stand-alone that would add a lot of bytes especially for types that can appear in a list.\r\n\r\n## On schema version\r\nFrom https://github.com/ethereum/beacon_chain/issues/94 as well\r\n\r\nI think we should have 2 bytes at the start to encode SSZ major.minor version\r\n\r\n## On length prefix vs length suffix\r\n\r\nhttps://github.com/ethereum/beacon_chain/issues/94 and https://github.com/ethereum/eth2.0-pm/issues/8\r\n\r\n- The argument for moving at the end is because otherwise you would have to iterate on the data structure once to get the length then once again to get feed the data. ==> All languages even Haskell have a vector implementation that tracks length so you wouldn't need the first iteration to get length.\r\n\r\n- Furthermore putting length at the end means you need specific token to indicate end of data like ‘\\0’ in cstring. This is causing a lot of issues in C code also this prevents reading by chunk into a buffer, you would have to read token by token (or read by chunk and backtrack).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/425626242/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/425632816",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-425632816",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 425632816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTYzMjgxNg==",
    "user": {
      "login": "raulk",
      "id": 1101242,
      "node_id": "MDQ6VXNlcjExMDEyNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1101242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raulk",
      "html_url": "https://github.com/raulk",
      "followers_url": "https://api.github.com/users/raulk/followers",
      "following_url": "https://api.github.com/users/raulk/following{/other_user}",
      "gists_url": "https://api.github.com/users/raulk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raulk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raulk/subscriptions",
      "organizations_url": "https://api.github.com/users/raulk/orgs",
      "repos_url": "https://api.github.com/users/raulk/repos",
      "events_url": "https://api.github.com/users/raulk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raulk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-29T09:58:12Z",
    "updated_at": "2018-09-29T10:41:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "> As mentioned by @raulk in ethereum/eth2.0-pm#8 call, Protocol Labs (libp2p) will probably develop specialized Wireshard dissectors for Eth2.0 which should help traffic analysis a lot.\r\n\r\nA community member has made progress with developing [Wireshark dissectors for some basic libp2p protocols](https://github.com/mkg20001/libp2p-dissector), like SecIO (security), Multistream (protocol selection), Yamux (multiplexing), etc. However, the challenge is accessing the session secrets to further decrypt the payload. We've briefly discussed that in this issue: https://github.com/libp2p/specs/issues/46. \r\n\r\nWireshark uses an \"onion\" approach to dissect frames. It calls dissectors iteratively to decapsulate the different layers in the message. At one point the dissection is going to encounter an application specific protocol in the payload (eth2.0 protocol), and to decrypt it, a Wireshark dissector should be registered for it. It's best if those dissectors are developed and maintained by the Ethereum 2.0 community, as they are application-specific and they'll need to evolve in lockstep with the protocol.\r\n\r\nEDIT: the existing dissectors are likely outdated and not exhaustively tested.\r\n\r\nEDIT 2: Contributions super welcome. Let’s _buidl_ this tooling together.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/425632816/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 2,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427366550",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-427366550",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 427366550,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzM2NjU1MA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-05T13:30:21Z",
    "updated_at": "2018-10-05T13:30:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mratsim \r\n> All languages even Haskell have a vector implementation that tracks length so you wouldn't need the first iteration to get length.\r\n\r\nthe argument is that you don't keep all data in memory at all - ie not even in a vector. Consider a linked list - there are two common implementations - one that has `O(n)` size and one with `O(1)` - the latter stores size in a central location but this breaks several nice properties of the linked lists.. likewise, if you have the data in a database, you may want to stream it instead of putting it in a vector first - this will make the max-memory requirement of your application go down. Both these things can be solved with a two-pass approach which is sometimes appropriate\r\n\r\n> Furthermore putting length at the end means you need specific token to indicate end of data like ‘\\0’ in cstring. This is causing a lot of issues in C code also this prevents reading by chunk into a buffer, you would have to read token by token (or read by chunk and backtrack).\r\n\r\nThis depends - if you know the size of the full buffer (as is common when working with a datagram-style protocol, or if like above, you're storing the total size somewhere), you can work backwards from there to figure out the positions of the fields (just like when it's at the front, and you're implicitly assuming the buffer starts at \"0\").",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427366550/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427407466",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-427407466",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 427407466,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzQwNzQ2Ng==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-05T15:36:06Z",
    "updated_at": "2018-10-05T15:36:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "Based on my understanding, one of the priorities of the format was efficient in-memory access (along with a willingness to pay a price in terms of space efficiency)\r\n\r\nI just went through the exercise of hardening our implementation against overruns and misaligned pointers (https://github.com/status-im/nim-beacon-chain/pull/7 - hopefully caught all of them :smile:) - the following things are noteworthy, when writing cross-platform code:\r\n\r\n* every field (of size >1) much be alignment-checked, including list items - this causes some performance degradation and prevents us from using `mmap` and the like to directly map the data, when loading from a trusted source\r\n* while it's possible to carefully nurse specific structs to minimize misalignment issues by manually ordering fields in a particular way, it remains impossible to do so generally:\r\n  * anything following a variable-length field can be misaligned\r\n  * anything that has a mix of type lengths will need to manually add padding/dummy fields\r\n\r\nA possible solution to this issue is to introduce a rule to the serializer that ensures that padding is mandatory and deterministic:\r\n* 0-pad any data up to the size-aligned boundary of the next field (4 or 8 bytes for variable-length fields - the size must be aligned, but also the items themselves)\r\n* introduce field-reorder or possibly a check, such fields in the serialized format remain ordered by size, descending - this minimizes the amount of padding necessary, but also makes it harder to do upgrades / add fields\r\n\r\nFor a good example of a well-aligned format, check out https://google.github.io/flatbuffers/flatbuffers_internals.html\r\n\r\nIt is worth to note that modern X86 processors have mostly solved unaligned access and the performance penalty is small - nonetheless, for several cases of optimized access, even X86 requires aligned data as the optimization level of the compiler gets cranked up - sse4.2 for example, as seen here: http://pzemtsov.github.io/2016/11/06/bug-story-alignment-on-x86.html",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/427407466/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/431011402",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-431011402",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 431011402,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTAxMTQwMg==",
    "user": {
      "login": "recmo",
      "id": 4532328,
      "node_id": "MDQ6VXNlcjQ1MzIzMjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4532328?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/recmo",
      "html_url": "https://github.com/recmo",
      "followers_url": "https://api.github.com/users/recmo/followers",
      "following_url": "https://api.github.com/users/recmo/following{/other_user}",
      "gists_url": "https://api.github.com/users/recmo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/recmo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/recmo/subscriptions",
      "organizations_url": "https://api.github.com/users/recmo/orgs",
      "repos_url": "https://api.github.com/users/recmo/repos",
      "events_url": "https://api.github.com/users/recmo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/recmo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T13:37:26Z",
    "updated_at": "2018-10-18T13:41:48Z",
    "author_association": "NONE",
    "body": "I was reading through the [current spec](https://github.com/ethereum/eth2.0-specs/blob/cf28f1a784f6a9a8c8e411e34dbf8bb613023093/specs/simple-serialize.md). Couple of thoughts:\r\n\r\n* The terminology `hash96`/`97` for BLS aggregate public keys is confusing. It is not a hash function in the normal cryptographical sense. (Though admittedly it shares some properties). Why not `bytes96` instead?\r\n* In fact, why not have `bytes`*N* for fixed size byte strings much like the fixed size integers?\r\n* List/Vector explanation assumes elements have a fixed length (`len(list) * sizeof(element)`), but the rest of the spec and reference implementation support variable sized elements. It is thus not clear whether variable sized list items are supported. This potentially makes a O(n) vs O(1) difference for random indexing performance, so clarity would be appreciated.\r\n* I'm not entirely clear on the intended scope of the spec: network format, on disk storage, in memory representation (i.e. mmap-able), ABI format, VM input format, etc. All would imply different trade offs in design.\r\n* Unlike RLP, this format is not self-describing. A schema needs to be provided to disambiguate the serialized data. Where in RLP the valid bytestrings are in one-to-one correspondence with semantic inputs, here they are not: a valid SSZ bytestring can have multiple interpretations depending on which schema is used. This means that a hash of SSZ data is *not* unique. This is can be solved perfectly by hashing in a serialization of the schema like in EIP-712. Alternatively, given the scope, it might be sufficient to manually disambiguate where necessary.\r\n* As far as I can see there is only one unique encoding for every input, so no issues there. Just don't forget the assert in the bool decoding :)\r\n* Fun facts: For every bytestring there exists a schema that will produce a valid decoding (proof: `['uint8'] * len(s)`. For a given schema there always exists an invalid bytestring (proof: take a valid bytestring and append a byte).\r\n\r\n@arnetheduck Here's another nice example of a well-designed serialization format meant for fast mmaping: https://capnproto.org/index.html I do think that takes alignment into consideration will necessarily not be 'simple'.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/431011402/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/431013956",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-431013956",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 431013956,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTAxMzk1Ng==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T13:44:38Z",
    "updated_at": "2018-10-18T13:44:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Recmo \r\nit does deal with alignment: https://capnproto.org/encoding.html\r\nalso, flatbuffers has lots of valuable discussion on the topic: https://google.github.io/flatbuffers/flatbuffers_internals.html",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/431013956/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/433809072",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-433809072",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 433809072,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzgwOTA3Mg==",
    "user": {
      "login": "recmo",
      "id": 4532328,
      "node_id": "MDQ6VXNlcjQ1MzIzMjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4532328?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/recmo",
      "html_url": "https://github.com/recmo",
      "followers_url": "https://api.github.com/users/recmo/followers",
      "following_url": "https://api.github.com/users/recmo/following{/other_user}",
      "gists_url": "https://api.github.com/users/recmo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/recmo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/recmo/subscriptions",
      "organizations_url": "https://api.github.com/users/recmo/orgs",
      "repos_url": "https://api.github.com/users/recmo/repos",
      "events_url": "https://api.github.com/users/recmo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/recmo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-29T07:12:57Z",
    "updated_at": "2018-10-29T07:24:14Z",
    "author_association": "NONE",
    "body": "@arnetheduck I know it handles alignment, that's why i brought it up. :)\r\n\r\nThe point I failed to make was that handling alignment and creating a \"Simple\" format are somewhat conflicting goals.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/433809072/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/435875320",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2#issuecomment-435875320",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2",
    "id": 435875320,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTg3NTMyMA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T13:35:38Z",
    "updated_at": "2018-11-05T13:35:38Z",
    "author_association": "MEMBER",
    "body": "Let's take discussion of alignment and it's relevance to another issue if necessary ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/435875320/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
