{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2137",
  "id": 747960247,
  "node_id": "MDU6SXNzdWU3NDc5NjAyNDc=",
  "number": 2137,
  "title": "Cap validator count at 1m with sortition",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063043868,
      "node_id": "MDU6TGFiZWwxMDYzMDQzODY4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:enhancement",
      "name": "general:enhancement",
      "color": "086788",
      "default": false,
      "description": "New feature or request"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2020-11-21T06:36:07Z",
  "updated_at": "2021-07-05T15:01:04Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "One of the weaknesses of the current spec is the very high variance in client load: clients need to be designed to potentially handle an extremely high load supporting 4 million validators, but real-life load is likely to be much lower (expected to be 100x lower close to launch). This means that validator operators must either get a powerful computer \"just in case\" or run the risk of being unable to keep up if far more validators join then expected.\r\n\r\nThis post is one possible solution to this conundrum, by capping the number of validators to 1 million (actually `2**20`) in a randomized and fair (and hence unexploitable) way.\r\n\r\n### Outline\r\n\r\nAdd a \"dormant\" state (in addition to \"awaiting activation\" / \"activated\" / \"exited\" / \"withdrawn\"); this would be done either by adding a `sleep_epoch` and `wake_epoch` or by adding a `dormant:bool` and `dormancy_transition_epoch` (we need to store it as epochs to preserve the invariant that all state changes are predictable by 4 epochs). Dormant validators can skip the queue to exit.\r\n\r\nIf the total number of active validators at the current time exceeds `2**20`, then add the following rules:\r\n\r\n1. Validators that are activated via the activation queue are instead moved into the dormant state.\r\n2. Let N be the number of validators that normally would be activated via the activation queue mechanism assuming `2**20` active validators (currently that's 16). At the end of each epoch, N randomly selected dormant validators are activated, and N randomly selected active validators are made dormant.\r\n\r\nThe random selection is important, because it ensures that (i) an attacker cannot join with new validators and replace existing participants without being equally diluted themselves, and (ii) there is no benefit from exiting-then-reentering.\r\n\r\n### Economic effects\r\n\r\nIn the case where there are more than `2**20` validators, this proposal would have two sets of consequences to validators. First, per-validator rewards would drop by 1% per 1% gain in staking participation (instead of the status quo: 0.5% drop per 1% gain in participation). Second, validators' costs would go down, because validators would be offline some of the time, and validators would have more freedom to remove some of their funds reliably, reducing implied capital costs.\r\n\r\nNote that there transition between the under-the-cap regime and the at-the-cap regime is gradual, because if the number of total participating validators is only slightly above `2**20` then any validator that is forced into dormancy can expect to be woken back up very quickly.\r\n\r\n### Possible extensions\r\n\r\n* Use `2**19` (524288 validators, ~16.7m ETH) as the cap instead of `2**20`.\r\n* We can make the rotation happen faster by rotating a fixed percentage of validators (eg. 1/64) every time the chain finalizes. This allows us to rotate validators quickly without violating BFT set intersection invariants that would cause a reduction in safety.\r\n\r\n### Simulation code\r\n\r\nHere is some quick simulation code that shows what happens if there are 100 active validators and 50 new ones join, assuming a cap of 100. The distribution quickly stabilizes into the optimal (67 old, 33 new).\r\n\r\n```python\r\nimport random\r\n\r\nactive = list(range(100))\r\ndormant = []\r\nfor i in range(200):\r\n    if i < 50:\r\n        dormant.append(100+ i)\r\n    dormant.append(active.pop(random.randrange(len(active))))\r\n    active.append(dormant.pop(random.randrange(len(dormant))))\r\n    print(\"Active: {} original {} new\".format(\r\n        len([x for x in active if x < 100]),\r\n        len([x for x in active if x >= 100])\r\n    ))\r\n```",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/740630263",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2137#issuecomment-740630263",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2137",
    "id": 740630263,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0MDYzMDI2Mw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-12-08T13:49:51Z",
    "updated_at": "2020-12-08T13:49:51Z",
    "author_association": "MEMBER",
    "body": "Generally agreed. I think this is sensible to get into the proposed \"first\" fork that might include adjusting punitiveness, light client support, etc.\r\n\r\nThere are a few places of concern wrt load as the validator set size grows. One is _memory_ (which this proposal does not solve), but the other is attestation load manifesting as high bandwidth and verification on the wire. Additionally, high attestation load might translate into more issues packing non-optimal aggregates into blocks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/740630263/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
