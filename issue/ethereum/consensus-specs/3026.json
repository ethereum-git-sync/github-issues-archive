{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/3026",
  "id": 1397017023,
  "node_id": "I_kwDOCOoGbc5TRMm_",
  "number": 3026,
  "title": "EIP4844: Suggestion to remove ssz from the Fiat-Shamir function ",
  "user": {
    "login": "kevaundray",
    "id": 37423678,
    "node_id": "MDQ6VXNlcjM3NDIzNjc4",
    "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kevaundray",
    "html_url": "https://github.com/kevaundray",
    "followers_url": "https://api.github.com/users/kevaundray/followers",
    "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
    "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
    "organizations_url": "https://api.github.com/users/kevaundray/orgs",
    "repos_url": "https://api.github.com/users/kevaundray/repos",
    "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kevaundray/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4163819084,
      "node_id": "LA_kwDOCOoGbc74LtZM",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/Deneb",
      "name": "Deneb",
      "color": "A28C37",
      "default": false,
      "description": "was called: eip-4844"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2022-10-05T00:42:47Z",
  "updated_at": "2022-11-03T15:04:42Z",
  "closed_at": "2022-11-03T15:04:41Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The method to create Fiat-Shamir challenges looks like:\r\n\r\n```python\r\ndef hash_to_bls_field(x: Container) -> BLSFieldElement:\r\n    \"\"\"\r\n    Compute 32-byte hash of serialized container and convert it to BLS field.\r\n    The output is not uniform over the BLS field.\r\n    \"\"\"\r\n    return bytes_to_bls_field(hash(ssz_serialize(x)))\r\n ```\r\n \r\nFor security, the Fiat-Shamir protocol requires a bijection from an object to bytes. This is the case if the serialise methods on an ssz struct is setup correctly since [ssz was intended to be bijective](https://ethereum.stackexchange.com/a/82056).\r\n\r\nThis however indirectly ties the security of the commitment scheme to the ssz serialisation strategy, ie its not possible to test the Fiat-Shamir component entirely in the cryptography library without first assuming that the serialisation strategy that caller is using is bijective (The cryptography would only receive bytes). This seems to be an abstraction leak.\r\n \r\nTo keep the cryptography completely modularised, one could implement this function as:\r\n \r\n ```python\r\n def hash_to_bls_field(polys: List[Tuple[Polynomial | Blob]], comms: List[KZGCommitment]) -> BLSFieldElement:\r\n    \"\"\"\r\n    Compute 32-byte hash of serialised polynomials and commitments concatenated\r\n    This hash is then converted to a BLS field.\r\n    The output is not uniform over the BLS field.\r\n    \"\"\"\r\n    \r\n    bytes = []\r\n    \r\n    # Append each polynomial\r\n    for poly in polys:\r\n        for serialised_evaluation in poly:\r\n            bytes.extend(serialised_evaluation)\r\n    \r\n    # Append serialised g1 points\r\n    for serialised_comm in comms:\r\n        bytes.extend(serialised_comm)\r\n        \r\n    return bytes_to_bls_field(hash(bytes))\r\n  ```\r\n  \r\nThe cryptography already knows how to de/serialise field and group elements, so the `hash_to_bls_field`  can live in the cryptography code and tested in isolation.\r\n\r\n\r\n**Changes implied**\r\n\r\nInstead of:\r\n\r\n```python\r\nhash_to_bls_field(BlobsAndCommitments(blobs=blobs, kzg_commitments=kzg_commitments))\r\nhash_to_bls_field(PolynomialAndCommitment(polynomial=aggregated_poly,kzg_commitment=aggregated_poly_commitment)\r\n```\r\n\r\nIt would be called as:\r\n\r\n```python\r\nhash_to_bls_field(blobs, kzg_commitments)\r\nhash_to_bls_field([aggregated_poly],[aggregated_poly_commitment])\r\n```\r\n\r\n\r\n@hwwhww and @asn-d6 The ssz addition seems to have been introduced by you folks, If this change seems reasonable, I can push a PR. Eager to hear your thoughts.",
  "closed_by": {
    "login": "kevaundray",
    "id": 37423678,
    "node_id": "MDQ6VXNlcjM3NDIzNjc4",
    "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kevaundray",
    "html_url": "https://github.com/kevaundray",
    "followers_url": "https://api.github.com/users/kevaundray/followers",
    "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
    "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
    "organizations_url": "https://api.github.com/users/kevaundray/orgs",
    "repos_url": "https://api.github.com/users/kevaundray/repos",
    "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kevaundray/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268261439",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268261439",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268261439,
    "node_id": "IC_kwDOCOoGbc5LmCI_",
    "user": {
      "login": "asn-d6",
      "id": 3611450,
      "node_id": "MDQ6VXNlcjM2MTE0NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3611450?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asn-d6",
      "html_url": "https://github.com/asn-d6",
      "followers_url": "https://api.github.com/users/asn-d6/followers",
      "following_url": "https://api.github.com/users/asn-d6/following{/other_user}",
      "gists_url": "https://api.github.com/users/asn-d6/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asn-d6/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asn-d6/subscriptions",
      "organizations_url": "https://api.github.com/users/asn-d6/orgs",
      "repos_url": "https://api.github.com/users/asn-d6/repos",
      "events_url": "https://api.github.com/users/asn-d6/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asn-d6/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T10:42:38Z",
    "updated_at": "2022-10-05T10:43:08Z",
    "author_association": "MEMBER",
    "body": "Hello,\r\n\r\nYou are effectively saying that you don't trust that `ssz_serialize()` is a bijective function. And that instead we should handle the Fiat-Shamir in the crypto library where we have more control.\r\n\r\nI think that's a reasonable defense in-depth argument given what's at stake. I also think your pseudocode for `hash_to_bls_field()` looks reasonable, but it will probably require modifications to run.\r\n\r\nI guess the counter argument for this is that the crypto library does not know that Fiat-Shamir is used above it. It only exposes a `bytes_to_bls_field()` func, and it's the responsibility of the caller to use that correctly for her agenda. In this case the caller's choice of using `ssz_serialize()` might be a reasonable decision. Why does the crypto library need to test the Fiat-Shamir functionality, since it doesn't expose such a function?\r\n\r\nAll in all, I think a patch for this would be a reasonable improvement.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268261439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268279234",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268279234",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268279234,
    "node_id": "IC_kwDOCOoGbc5LmGfC",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T11:01:01Z",
    "updated_at": "2022-10-05T11:01:01Z",
    "author_association": "MEMBER",
    "body": "Why does it need to be bijective? An injective function would be enough, right?\r\n\r\nI think it is fairly easy to prove that SSZ is injective",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268279234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268471443",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268471443",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268471443,
    "node_id": "IC_kwDOCOoGbc5Lm1aT",
    "user": {
      "login": "kevaundray",
      "id": 37423678,
      "node_id": "MDQ6VXNlcjM3NDIzNjc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevaundray",
      "html_url": "https://github.com/kevaundray",
      "followers_url": "https://api.github.com/users/kevaundray/followers",
      "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
      "organizations_url": "https://api.github.com/users/kevaundray/orgs",
      "repos_url": "https://api.github.com/users/kevaundray/repos",
      "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevaundray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T13:54:13Z",
    "updated_at": "2022-10-05T13:54:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Why does it need to be bijective? An injective function would be enough, right?\n> \n> \n> \n> I think it is fairly easy to prove that SSZ is injective\n\nRight, but this dependency on ssz is not necessary and doesn't seem to provide any advantages, since the cryptography library is able to handle the Fiat-Shamir protocol internally.\n\nShould something ever change with the way clients implement the necessary methods on a user defined struct for ssz, the cryptography will not need to be re-analysed, for example. \n\nI don't know how likely that example is, but if we can avoid the dependency, I see no reason not to?\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268471443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268489169",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268489169",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268489169,
    "node_id": "IC_kwDOCOoGbc5Lm5vR",
    "user": {
      "login": "kevaundray",
      "id": 37423678,
      "node_id": "MDQ6VXNlcjM3NDIzNjc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevaundray",
      "html_url": "https://github.com/kevaundray",
      "followers_url": "https://api.github.com/users/kevaundray/followers",
      "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
      "organizations_url": "https://api.github.com/users/kevaundray/orgs",
      "repos_url": "https://api.github.com/users/kevaundray/repos",
      "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevaundray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T14:10:02Z",
    "updated_at": "2022-10-05T14:10:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Hello,\n> \n> \n> \n> You are effectively saying that you don't trust that `ssz_serialize()` is a bijective function. And that instead we should handle the Fiat-Shamir in the crypto library where we have more control.\n> \n> \n> \n> I think that's a reasonable defense in-depth argument given what's at stake. I also think your pseudocode for `hash_to_bls_field()` looks reasonable, but it will probably require modifications to run.\n> \n> \n> \n> I guess the counter argument for this is that the crypto library does not know that Fiat-Shamir is used above it. It only exposes a `bytes_to_bls_field()` func, and it's the responsibility of the caller to use that correctly for her agenda. In this case the caller's choice of using `ssz_serialize()` might be a reasonable decision. Why does the crypto library need to test the Fiat-Shamir functionality, since it doesn't expose such a function?\n> \n> \n> \n> All in all, I think a patch for this would be a reasonable improvement.\n\nGood point, I find testing and modularising the Fiat-Shamir protocol hardens the code and makes it easier to reason about security.\n\nAn example of what I was referring to can be seen here:\n\nhttps://github.com/crate-crypto/proto-danksharding-crypto/blob/master/crypto/src/kzg/transcript.rs#L46\n\nSo the Fiat-Shamir protocol is encapsulated in this Transcript struct which allows you to add polynomials and points.\n\nI tend to do it this way because the Fiat-Shamir protocol usually has its own set of recommended practices such as domain separators, so this isolates it even further.\n\nNot relevant to this issue, but domain separator usage can be seen here for example: https://github.com/zcash/halo2/blob/main/halo2_proofs/src/transcript.rs#L140\n\nIf the Fiat-Shamir protocol ever needs changing, the code for kzg can stay exactly the same and we just modify the transcript file.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268489169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268960131",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268960131",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268960131,
    "node_id": "IC_kwDOCOoGbc5LosuD",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T20:49:37Z",
    "updated_at": "2022-10-05T20:49:37Z",
    "author_association": "MEMBER",
    "body": "> Should something ever change with the way clients implement the necessary methods on a user defined struct for ssz, the cryptography will not need to be re-analysed, for example.\r\n\r\nRight, but I guess SSZ (which is a strict dependency of Ethereum) would also be fundamentally broken if SSZ were not injective. So from my point of view this does not introduce any new assumptions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268960131/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268993023",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1268993023",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1268993023,
    "node_id": "IC_kwDOCOoGbc5Lo0v_",
    "user": {
      "login": "kevaundray",
      "id": 37423678,
      "node_id": "MDQ6VXNlcjM3NDIzNjc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevaundray",
      "html_url": "https://github.com/kevaundray",
      "followers_url": "https://api.github.com/users/kevaundray/followers",
      "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
      "organizations_url": "https://api.github.com/users/kevaundray/orgs",
      "repos_url": "https://api.github.com/users/kevaundray/repos",
      "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevaundray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-10-05T21:24:05Z",
    "updated_at": "2022-10-05T21:24:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > Should something ever change with the way clients implement the necessary methods on a user defined struct for ssz, the cryptography will not need to be re-analysed, for example.\n> \n> \n> \n> Right, but I guess SSZ (which is a strict dependency of Ethereum) would also be fundamentally broken if SSZ were not injective. So from my point of view this does not introduce any new assumptions.\n\nYep, though it would still be an unnecessary abstraction leak into the cryptography module.\n\nI think it's advantageous to not have the cryptography rely on any extraneous assumptions. I linked some code above to show how one can encapsulate the Fiat-Shamir protocol if this extra assumption is removed. \n\nIn terms of conventions, I think using ssz or some other objective function for Fiat-Shamir is more out of the norm than using the serialisation format that comes with points and field elements, see the halo2 impl I linked above",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1268993023/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1302250056",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/3026#issuecomment-1302250056",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/3026",
    "id": 1302250056,
    "node_id": "IC_kwDOCOoGbc5NnsJI",
    "user": {
      "login": "kevaundray",
      "id": 37423678,
      "node_id": "MDQ6VXNlcjM3NDIzNjc4",
      "avatar_url": "https://avatars.githubusercontent.com/u/37423678?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevaundray",
      "html_url": "https://github.com/kevaundray",
      "followers_url": "https://api.github.com/users/kevaundray/followers",
      "following_url": "https://api.github.com/users/kevaundray/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevaundray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevaundray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevaundray/subscriptions",
      "organizations_url": "https://api.github.com/users/kevaundray/orgs",
      "repos_url": "https://api.github.com/users/kevaundray/repos",
      "events_url": "https://api.github.com/users/kevaundray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevaundray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-03T15:04:41Z",
    "updated_at": "2022-11-03T15:04:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "Closing as #3030 and #3038 have been merged  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/1302250056/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
