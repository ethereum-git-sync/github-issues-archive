{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2538",
  "id": 959340808,
  "node_id": "MDU6SXNzdWU5NTkzNDA4MDg=",
  "number": 2538,
  "title": "Determine `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` result",
  "user": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295439957,
      "node_id": "MDU6TGFiZWwxMjk1NDM5OTU3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:CI/tests/pyspec",
      "name": "scope:CI/tests/pyspec",
      "color": "BDC0BA",
      "default": false,
      "description": ""
    },
    {
      "id": 1534063048,
      "node_id": "MDU6TGFiZWwxNTM0MDYzMDQ4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:BLS",
      "name": "scope:BLS",
      "color": "fef2c0",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2021-08-03T17:34:56Z",
  "updated_at": "2021-09-16T07:12:44Z",
  "closed_at": "2021-09-16T07:12:44Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "I'd like to confirm what's the expected behavior of `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` call.\r\n\r\n### `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` result?\r\n\r\nSince (i) `AggregatePKs` is not defined in the IETF standard and (ii) `AggregatePKs` functionality is using in Altair, we defined an [`eth2_aggregate_pubkeys`](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/bls.md#eth2_aggregate_pubkeys) function to aggregate the pubkeys. That is, aggregate pubkeys logic will be in the consensus layer since Altair HF.\r\n\r\nSince it's not part of IETF standard, the BLS libs may have implemented the \"basic\" `AggregatePKs` API differently:\r\n- Let `G1_POINT_AT_INFINITY = b'\\xc0' + b'\\x00' * 47`\r\n- py_ecc: `py_ecc._AggregatePKs([G1_POINT_AT_INFINITY])` is VALID\r\n- milagro: `milagro_bls._AggregatePKs([G1_POINT_AT_INFINITY])` is INVALID\r\n    - It seems that `PublicKeys` cannot be the point at infinity in Milagro: https://github.com/sigp/milagro_bls/issues/40#issuecomment-712645746.\r\n    - IIUC, Milagro allows aggregating G2 point at infinity (signatures). I think it's because Milagro assumes that pubkeys *should have passed `KeyValidate` so inf point is not in the allowed domain*. It's similar to how we handled pubkeys in IETF `FastAggregateVerify`.\r\n\r\n### Discussions\r\n1. Should we have `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` test vectors?\r\n    - Note that `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` should never be triggered in Altair since all the possible pubkeys should have passed `KeyValidate`.\r\n    - However, I'm not sure about the future usage of `eth2_aggregate_pubkeys` and other Ethereum-specific BLS functions. e.g., we may want to use G1 point at infinity to represent the *\"emptiness\"* in other cases; similar to how we use `G2_POINT_AT_INFINITY` in `eth2_fast_aggregate_verify`.\r\n2. If so, should we make `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` invalid in the test vectors?\r\n    - If yes, I'd say we should describe this behavior in the `eth2_fast_aggregate_verify` description or pseudo code.\r\n\r\n\r\n/cc @kirk-baird @mratsim @benjaminion @nisdas @wemeetagain @ChihChengLiang  üôè",
  "closed_by": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892051323",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-892051323",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 892051323,
    "node_id": "IC_kwDOCOoGbc41K597",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-03T18:04:03Z",
    "updated_at": "2021-08-03T18:06:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "In the spec at https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.5\r\nthe infinity pubkey is invalid:\r\n![image](https://user-images.githubusercontent.com/22738317/128063336-5fe37a2a-4020-4bf7-9ca6-51b13694cb29.png)\r\n\r\nFrom the discussion in https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/33#issuecomment-865170648, the next revision of the spec will explicitly mention that `KeyValidate` can be cached by doing it only at deserialization (if a key is reused multiple times like validator pubkeys), or before verification (current spec).\r\n\r\nI think having `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` invalid will cause the less edge cases to all clients. We can just apply KeyValidate at deserialization. Otherwise special cases need to be applied for aggregation in our libraries.\r\n\r\nRegarding future usage of `G1_POINT_AT_INFINITY`, in Nimbus we distinguish between the serialized representation of BLS objects which allow both all zero objects and infinity objects (0xc000...) and the deserialized version that is only for spec-compliant cases.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892051323/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892266017",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-892266017",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 892266017,
    "node_id": "IC_kwDOCOoGbc41LuYh",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-04T00:36:20Z",
    "updated_at": "2021-08-04T00:36:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "I too like the idea of having it `INVALID` since it would fail `KeyValidate`, hence we can cache the validation (which lighthouse does).\r\n\r\nI think it's also beneficial to fail as early as possible when given malicious / malformed data as it reduces the edgecases and improves performance, thus being able to reject these at deserialisation time is beneficial.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892266017/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892293038",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-892293038",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 892293038,
    "node_id": "IC_kwDOCOoGbc41L0-u",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-04T01:44:01Z",
    "updated_at": "2021-08-04T01:44:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "As has been mentioned above having it marked as `INVALID` would be the change with the least friction. It does seem that all clients do cache keys at deserialization. Since `KeyValidate` checks for `G1_POINT_AT_INFINITY` , this can also by applied to \r\n`eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` in relation. If we choose to mark it as `VALID` , it does introduce some not very nice edge cases in terms of usage with very little benefit. \r\n\r\n> we may want to use G1 point at infinity to represent the \"emptiness\" in other cases; similar to how we use\r\n\r\nIf we do want to represent 'emptiness' , maybe such a check should be done at the application layer rather than adding it to the core BLS library.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892293038/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892419596",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-892419596",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 892419596,
    "node_id": "IC_kwDOCOoGbc41MT4M",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-04T07:07:18Z",
    "updated_at": "2021-08-04T07:08:53Z",
    "author_association": "MEMBER",
    "body": "@mratsim @kirk-baird @nisdas \r\nThank you for your responses! I think we have a rough consensus that it's safer to have `eth2_aggregate_pubkeys([G1_POINT_AT_INFINITY])` INVALID. üôÇ\r\n\r\n\r\n@mratsim \r\n\r\n> From the discussion in https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/33#issuecomment-865170648, the next revision of the spec will explicitly mention that `KeyValidate` can be cached by doing it only at deserialization (if a key is reused multiple times like validator pubkeys), or before verification (current spec).\r\n\r\nIIUC, (1) the discussion was mainly about subgroup checks, but (2) `G1_POINT_AT_INFINITY` can pass subgroup checks anyway so it won't raise an error in deserialization?\r\n\r\nMilagro already checks `KeyValidate` during deserialization. Does anyone know how `blst` handles it now?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892419596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892434536",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-892434536",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 892434536,
    "node_id": "IC_kwDOCOoGbc41MXho",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-04T07:33:14Z",
    "updated_at": "2021-08-04T07:33:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "> IIUC, (1) the discussion was mainly about subgroup checks, but (2) `G1_POINT_AT_INFINITY` can pass subgroup checks anyway so it won't raise an error in deserialization?\r\n\r\nYes it's mainly about subgroup checks but then drifted to KeyValidate / all checks see quote\r\n\r\n> * `deserialize` = deserialize + curve check + subgroup check <- default option\r\n> \r\n> * `deserialize_curve_check` = deserialize + curve check\r\n> \r\n> * `deserialize_unchecked` = deserialize only\r\n>   presumably people who invokes the second or the third API know what they are doing...\r\n\r\n\r\n> Milagro already checks `KeyValidate` during deserialization. Does anyone know how `blst` handles it now?\r\n\r\nBLST provides the primitives, there is no check by default on deserialization https://github.com/supranational/blst/blob/3f7d97e2/bindings/rust/src/lib.rs#L500-L513\r\n\r\n```Rust\r\n            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {\r\n                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)\r\n                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)\r\n                {\r\n                    let mut pk = <$pk_aff>::default();\r\n                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };\r\n                    if err != BLST_ERROR::BLST_SUCCESS {\r\n                        return Err(err);\r\n                    }\r\n                    Ok(Self { point: pk })\r\n                } else {\r\n                    Err(BLST_ERROR::BLST_BAD_ENCODING)\r\n                }\r\n            }\r\n```\r\n\r\nand a validate proc can be called afterwards https://github.com/supranational/blst/blob/3f7d97e2/bindings/rust/src/lib.rs#L443-L459\r\n\r\n```Rust\r\n            // key_validate\r\n            pub fn validate(&self) -> Result<(), BLST_ERROR> {\r\n                unsafe {\r\n                    if $pk_is_inf(&self.point) {\r\n                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);\r\n                    }\r\n                    if !$pk_in_group(&self.point) {\r\n                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);\r\n                    }\r\n                }\r\n                Ok(())\r\n            }\r\n\r\n            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {\r\n                let pk = PublicKey::from_bytes(key)?;\r\n                pk.validate()?;\r\n                Ok(pk)\r\n            }\r\n```\r\n\r\nWhen aggregating you have a boolean to indicate is validation is needed or was cached https://github.com/supranational/blst/blob/3f7d97e2/bindings/rust/src/lib.rs#L558-L614\r\n\r\n```Rust\r\n            // Aggregate\r\n            pub fn aggregate(\r\n                pks: &[&PublicKey],\r\n                pks_validate: bool,\r\n            ) -> Result<Self, BLST_ERROR> {\r\n                if pks.len() == 0 {\r\n                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);\r\n                }\r\n                if pks_validate {\r\n                    pks[0].validate()?;\r\n                }\r\n                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);\r\n                for s in pks.iter().skip(1) {\r\n                    if pks_validate {\r\n                        s.validate()?;\r\n                    }\r\n                    unsafe {\r\n                        $pk_add_or_dbl_aff(\r\n                            &mut agg_pk.point,\r\n                            &agg_pk.point,\r\n                            &s.point,\r\n                        );\r\n                    }\r\n                }\r\n                Ok(agg_pk)\r\n            }\r\n\r\n            pub fn aggregate_serialized(\r\n                pks: &[&[u8]],\r\n                pks_validate: bool,\r\n            ) -> Result<Self, BLST_ERROR> {\r\n                // TODO - threading\r\n                if pks.len() == 0 {\r\n                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);\r\n                }\r\n                let mut pk = if pks_validate {\r\n                    PublicKey::key_validate(pks[0])?\r\n                } else {\r\n                    PublicKey::from_bytes(pks[0])?\r\n                };\r\n                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);\r\n                for s in pks.iter().skip(1) {\r\n                    pk = if pks_validate {\r\n                        PublicKey::key_validate(s)?\r\n                    } else {\r\n                        PublicKey::from_bytes(s)?\r\n                    };\r\n                    unsafe {\r\n                        $pk_add_or_dbl_aff(\r\n                            &mut agg_pk.point,\r\n                            &agg_pk.point,\r\n                            &pk.point,\r\n                        );\r\n                    }\r\n                }\r\n                Ok(agg_pk)\r\n            }\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/892434536/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/920638253",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2538#issuecomment-920638253",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2538",
    "id": 920638253,
    "node_id": "IC_kwDOCOoGbc4239Mt",
    "user": {
      "login": "hwwhww",
      "id": 9263930,
      "node_id": "MDQ6VXNlcjkyNjM5MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hwwhww",
      "html_url": "https://github.com/hwwhww",
      "followers_url": "https://api.github.com/users/hwwhww/followers",
      "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
      "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
      "organizations_url": "https://api.github.com/users/hwwhww/orgs",
      "repos_url": "https://api.github.com/users/hwwhww/repos",
      "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hwwhww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-16T07:12:44Z",
    "updated_at": "2021-09-16T07:12:44Z",
    "author_association": "MEMBER",
    "body": "closing via #2539",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/920638253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
