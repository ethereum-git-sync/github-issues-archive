{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/644",
  "id": 411076941,
  "node_id": "MDU6SXNzdWU0MTEwNzY5NDE=",
  "number": 644,
  "title": "Challenges in standardizing light client Merkle proofs",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1244766996,
      "node_id": "MDU6TGFiZWwxMjQ0NzY2OTk2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:light-clients",
      "name": "scope:light-clients",
      "color": "211E55",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2019-02-16T14:19:13Z",
  "updated_at": "2019-04-17T23:01:30Z",
  "closed_at": "2019-04-17T23:01:29Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "A light client interacting with the beacon chain will often need to make many types of accesses, including calling functions like `get_persistent_committee(state, epoch)` to determine which validators are the committee at some epoch, accessing elements of `validator_registry` and other arrays, accessing specific ranges of data in shards, etc. Many of these operations will require Merkle branches for the specific variables that they access, and in some cases the required accesses are dynamic.\r\n\r\nThis presents challenges in specifying how light client proofs would work. Specifically, how do we specify what Merkle proofs a full client gives to a light client that is interested in computing the output of a function?\r\n\r\nOne approach is to be very function-specific, and specify \"for operation X, we need Merkle proofs A, B and C\".\r\n\r\nAnother approach is to be maximally general, and define a helper:\r\n\r\n* `GenerateMerkleProof(f, args)`, which computes `f(args)`, and saves all Merkle proofs for all values in `args` that needed to be accessed to make the computation, and returns a `MerklePartial[arg]` object for every `arg` in `args`.\r\n* A `MerklePartial[arg]` can be fully substituted in for `arg` in any computation (eg. the BeaconState is likely to be the most common use case), except that it triggers an error if an access is attempted that goes outside of what the Merkle proofs for the object can provide.\r\n\r\nThis would allow light client algorithms to be specified much more easily, eg. a light client syncing could work as follows:\r\n\r\n* Ask for a `GenerateMerkleProof(get_persistent_committee, [state, state.slot])` where `state` is the state whose SSZ root is the state root of a block that is being provided.\r\n* Set `committee` to `get_persistent_committee(merkle_partial_state, merkle_partial_state.slot)`.\r\n* If `current_state` is the current state the light client knows about, ask for a `GenerateMerkleProof(lambda x: [x.validator_registry[c] for c in committee], current_state)`. Set `validator_registry_items` to equal  `[merkle_partial_state.validator_registry[c] for c in committee]`\r\n\r\nAnd so forth. The `GenerateMerkleProof` on the full-node side, and the use of a `MerklePartial` in place of a regular complete object on the light-client side, does all of the heavy lifting.\r\n\r\nDo people have any thoughts on which approach makes the most sense here?\r\n\r\nIn general, there are many light client syncing algorithms, but if we go this route it would make sense to standardize `GenerateMerkleProof` and `MerklePartial`, including the format for these Merkle proofs, fairly early.\r\n\r\nSee https://ethresear.ch/t/optimizing-merkle-tree-multi-queries/4912 for a thread on optimizing multi-proofs for single trees; though note that here the proofs would need to be generic and cover SSZ serialization of any object of arbitrary depth, and would ideally have optimal data-deduplication properties in these cases.",
  "closed_by": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468259445",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-468259445",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 468259445,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODI1OTQ0NQ==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T12:45:24Z",
    "updated_at": "2019-02-28T12:45:24Z",
    "author_association": "MEMBER",
    "body": "> Do people have any thoughts on which approach makes the most sense here?\r\n\r\nThe generalised approach feels like a long-term winner, and we may be able to pull it off in the short-term also. One idea would be to have WASM be the standardised VM for such \"light client queries\" where `f` is a WASM executable. That would yield stronger synergies between light clients and stateless clients, and calling `GenerateMerkleProof` would be somewhat like executing a \"beacon chain smart contract\".\r\n\r\nThe work to find an optimal Merkle proof batching and data-deduplication technique sounds like nice piece of low-hanging fruit for someone to get their hands dirty.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468259445/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468980374",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-468980374",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 468980374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODk4MDM3NA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-03T02:20:58Z",
    "updated_at": "2019-03-03T02:20:58Z",
    "author_association": "MEMBER",
    "body": "> The work to find an optimal Merkle proof batching and data-deduplication technique sounds like nice piece of low-hanging fruit for someone to get their hands dirty.\r\n\r\nActually not that hard!\r\n\r\nhttps://medium.com/@jgm.orinoco/understanding-sparse-merkle-multiproofs-9b9f049e8f08",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468980374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468990961",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-468990961",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 468990961,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODk5MDk2MQ==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-03T05:36:30Z",
    "updated_at": "2019-03-03T05:36:30Z",
    "author_association": "MEMBER",
    "body": "The one thing I'm concerned about here is the requesting of particular functions with particular inputs and outputs by a particular name across clients. This either reduces optionality in client design _or_ at least requires them to maintain an interface to mapping these spec functions to their own internal structures.\r\n\r\nAn alternative is the maintain a clear mapping of these spec level functions to the parameters needed to execute them. Then we can use these functions in the light client specs freely, knowing that light clients know exactly what to request to be able to compute the outputs locally. So instead of requiring a full client to be able to come up with the require proofs depending on the function requested, the light client can instead just make the explicit requests for the required data. I suppose this comes at a small cost of bandwidth on the request side.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468990961/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469991052",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-469991052",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 469991052,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTk5MTA1Mg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-06T06:52:57Z",
    "updated_at": "2019-03-06T06:52:57Z",
    "author_association": "MEMBER",
    "body": "I'm not suggesting that we actually use function names in the spec as identifiers in the wire protocol. It's more just standardizing the idea that expected behavior of clients can be defined by \"calculate this function of the state and return a Merkle proof of a sufficient set of values to allow recipients to recalculate the result\".",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/469991052/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470241884",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-470241884",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 470241884,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDI0MTg4NA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-06T19:25:35Z",
    "updated_at": "2019-03-06T19:25:35Z",
    "author_association": "MEMBER",
    "body": "How do you expect the request from a light client to be made then?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/470241884/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/484292947",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/644#issuecomment-484292947",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/644",
    "id": 484292947,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NDI5Mjk0Nw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-17T23:01:29Z",
    "updated_at": "2019-04-17T23:01:29Z",
    "author_association": "MEMBER",
    "body": "this is handled in [merkle_proofs.md](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/light_client/merkle_proofs.md)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/484292947/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
