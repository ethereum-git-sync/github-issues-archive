{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/626",
  "id": 410385093,
  "node_id": "MDU6SXNzdWU0MTAzODUwOTM=",
  "number": 626,
  "title": "The integer debate",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 32,
  "created_at": "2019-02-14T16:30:33Z",
  "updated_at": "2021-10-13T12:02:25Z",
  "closed_at": "2019-03-06T14:06:55Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Follow up issue after earlier gitter chat and implementers call today (https://github.com/ethereum/eth2.0-pm/issues/29)\r\n\r\nTo pick the best solution, we need a more structural approach, and list the arguments for each \"problem-class\".\r\n\r\nNote that I highlight Java and javascript as special considerations, due to the different support for integers than most other languages provide.\r\n\r\n**Go, Rust, Swift, Nim all support signed/unsigned 32/64 bit numbers.**\r\n\r\n## Problem classes\r\n\r\n1) Slot numbers\r\n2) Validator indices\r\n3) Balances\r\n\r\n## Slot numbers\r\n\r\nRange here: 1 slot per 6 seconds, for a few thousand years (could upgrade earlier...) = approx. `1000*365*24*60*60/6=5,256,000,000`.\r\n\r\nSigned numbers: No. However, there is a case for the first few epochs, where logic is looking back at old history, beyond the genesis. This could potentially result in an underflow.\r\n\r\nWays to catch the underflow:\r\n- `x < 0`: signed number check\r\n- `x < genesis_slot`, with `genesis_slot >> 0` (i.e. sufficiently large offset from 0.) One potential offset is `1 << 63`, **_effectively simulating a signed number_** (but worse: sign bit inverted, if you think of it as two's complement), but not human readable in decimal base. If this becomes the \"blocknumber\" of the future, we want it to be readable, right?\r\n\r\nIf we don't care about very long-term consistency, we can go for 32 bits. It seems unnecessary however, as there's more range available to every language/platform. E.g. we could even opt for an imaginary 48 bit (un)signed integer.\r\n\r\n### Javascript\r\n\r\nHighlight from earlier gitter chat:\r\n\r\n> Well, if we're not using the higher bits (i.e. [53, 63]) of the signed 64 bit number for the next ~ 800K years, javascript can just keep using 52 bit mantissa based numbers (the 11 unused bits being the exponent part of the float). And then we can choose for a signed 64 bit number. With genesis at a clean 0.\r\n\r\nI.e. by exploiting the range of slot numbers, we could choose for a 64 bit number (signed or unsigned), and have it be compatible with the 52 bit (excl. sign bit) range of javascript float-based (i.e. mantissa) integers.\r\n\r\nAlternative would be to use big-numbers, like the alternative that Java also has, see below.\r\n\r\n### Java\r\n\r\nJava only supports signed 64 bit numbers (\"long\"). Of course, you could transport a unsigned 64 bit number over a signed number, as done previously in [Guava](https://github.com/google/guava/wiki/PrimitivesExplained#generic-utilities) and supported in [Java 8](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#divideUnsigned-int-int-). This does introduce other things to consider, please refer to comments: [A](https://github.com/ethereum/eth2.0-specs/issues/626#issuecomment-464421346), [B](https://github.com/ethereum/eth2.0-specs/issues/626#issuecomment-464442595).\r\n\r\nAlternative would be Big integers. (something that looks like `z.Set(y).Add(x)` instead of `z = y + x`). Special limits have to be imposed to keep it at 64-bit big-numbers as well.\r\nPlease refer to comments below about the Pros and Cons of Java options [A](https://github.com/ethereum/eth2.0-specs/issues/626#issuecomment-464421346), [B](https://github.com/ethereum/eth2.0-specs/issues/626#issuecomment-464442595).\r\n\r\n## Validator indices\r\n\r\nThe **approximate** range here: 0...4,000,000 (worst case validator count).\r\nNote that due to in-active validators, the list may actually be even bigger. But it's somewhere in this order, worst case.\r\n\r\nSigned numbers: No. However, there could be a case for an `indexOf` function that returns a -1 when some validator is not included in a list. Common practice in quite a few languages.\r\n\r\nValidator indices are realtively low, and would fit easily in 32 bits:\r\n\r\n```\r\n2**31 = 2,147,483,648\r\n2**32 = 4,294,967,296\r\n```\r\nNow the questions here are:\r\n\r\n1) Do we want unnecessary but easy \"consistency\" by going for 64 bit numbers?\r\n2) Do we want signed numbers?\r\n\r\n### Javascript\r\n\r\nFits in a 52 bit mantissa. ES6 supports bitwise operations only for 32 bits. If we want to do bit-magic on indices, we may want to just go for 32 bits or less.\r\n\r\n### Java\r\n\r\nJava only supports signed integers. \"int\": 32 bits, signed. [docs](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\r\n\r\n\r\n## Balances\r\n\r\nFor balances there is a valid concern where we may not even want to use a 64 bit number, if we want precise/small balances.\r\n\r\nRange: two options:\r\n1) Same as ETH 1.0, requires big-numbers in every language (some with more readable usage than others)\r\n2) Less resolution. Making it fit in a 64 bit number\r\n\r\nSigned: No. However, there is a case for ease in math to consider that clients may want to convert to signed numbers internally. Signs are not necessary anywhere after being encoded.\r\n\r\n### Javascript / Java\r\n\r\nWe know the limitations of these by now. Balances are likely to require the most resolution in the near-term. No shortcuts with ranges (like with slots). Highly important to get right and prevent bugs.\r\n\r\nPersonally a fan of using big-ints here, and use safe-math.\r\n\r\n-----\r\n\r\nI tried to outline the problem cases + options + considerations. Please comment if you think anything is missing, or want to make a strong case for any of the options.\r\n",
  "closed_by": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463702116",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-463702116",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 463702116,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MzcwMjExNg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-14T16:50:47Z",
    "updated_at": "2019-02-17T11:25:48Z",
    "author_association": "MEMBER",
    "body": "Personal opinion:\r\n\r\n1) Slot numbers with (un)signed int64\r\n  - clean genesis at 0\r\n  - human readable\r\n  - if signed: negative numbers are sufficient to account for pre-genesis logic.\r\n  - support by every platform\r\n  - Alternatively, if encoding size is a big issue, and we want to get rid of the sign bit, I would prefer unsigned 64 bits, with genesis still at 0 for readability. We can handle the pre-genesis underflow differently with some logic or something.\r\n2) Validator indices with (un)signed int32\r\n  - if signed: intuitive (for most) indexOf behaviour\r\n  - sufficiently big (afaik)\r\n  - if signed: 4 bytes is not that bad at all\r\n  - if unsigned: minimal encoding, no sign bit, readable.\r\n  - support by every platform (32 bits is easy regardless of sign)\r\n3) Balances: big-ints\r\n  - Alternatively open for unsigned 64 bits, if it fits, and Java/JS teams are ok with some performance differences\r\n\r\nPlease share if you have a different view, and why.\r\n\r\nEdit: changed opinion slightly, still same integer sizes, but open for either signed or unsigned ints. If I really had to make a choice at gunpoint, I think I would rather have unsigned ints (mostly because of simplicity of having no signs, although they could be just fine).\r\nEdit 2: Engrish\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463702116/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463702414",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-463702414",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 463702414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MzcwMjQxNA==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-14T16:51:29Z",
    "updated_at": "2019-02-14T17:22:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "## Spec considerations\r\nBeyond the implementers story there is also the spec side to consider.\r\n\r\nPotentially the early slots become an edge case with special complex (?) treatment in the spec.\r\n\r\n## Ergonomics\r\n\r\nAs discussed during the implementer calls, using signed integers requires conversion at very specific boundaries:\r\n  - EVM\r\n  - serialization\r\n\r\nHowever using unsigned integers requires:\r\n  - conversion in almost all logic and debugging code as we need to substract or add the epoch/slot constants before indexing an array or displaying a value.\r\n  - lots of attention towards underflow when comparing values.\r\n\r\n## My position\r\n\r\nI do not support unsigned int because:\r\n  - it's harder to use the natural programming language syntax because everyone will probably use something like `state.slots.at(idx)` with `at` hiding `idx - GENESIS_START_SLOT`.\r\n  - it's harder to write natural math because unsigned integers do not behave like intuitive math when substracting or comparing. We're actually doing math modulo 2^32 or 2^64.\r\n  - If a value needs to be compared with another or substracted to another for processing (length, count, quantity), unsigned int tends to create more implementation bugs.\r\n  - We had a lot of bugs due to unsigned memory addressing and length in EVM1 (see https://github.com/status-im/nimbus/pull/97) and this is exemplified by a number of test cases that ensure clients can handle under and overflow in the EVM:\r\n    - calldatacopy_DataIndexTooHigh.json\r\n    - calldatacopy_DataIndexTooHigh2.json\r\n    - calldatacopy_DataIndexTooHigh2_return.json\r\n    - calldataloadSizeTooHigh.json\r\n    - codecopy_DataIndexTooHigh.json\r\n    - extcodecopy_DataIndexTooHigh.json\r\n\r\n    While a VM is a special case, I'd like to avoid that in normal higher level code like the beacon chain.\r\n\r\nIn short, signed  integers when we need to do math, logic and indexing and unsigned when we need control over memory representation (EVM, serialization).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463702414/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463723308",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-463723308",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 463723308,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MzcyMzMwOA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-14T17:48:48Z",
    "updated_at": "2019-02-14T17:48:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "An important distinction I'd add is to differentiate serialization and logic. \r\n\r\nFor slots etc, it's entirely reasonable that the serialization is `uint64` while the logic is expressed in signed integer arithmetic that's natural to read (which also happened to be the status quo until the offset solution was introduced). Implementers can deal with that as they wish (and contribute back to the spec!), including proving parts of the spec as being unsigned-safe, turning subtractions into additions etc - as long as we establish \"safe ranges\" that are reasonable.\r\n\r\nI'd consider the offset solution impractical mainly because it encourages cutting corners on correctness to gain some performance in the near term - going for that smaller data type when you should be doing a bigint thus effectively penalizing languages that don't naturally support the given \"reasonable\" range and thus making the real-world deployment either more bug-prone or less rich in terms of implementation diversity.\r\n\r\nAs an aside, I also find signed integers to be more difficult from a serialization perspective - their byte encoding (now little-endian) is onerous to work with in general (parsing, debugging etc)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463723308/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463777085",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-463777085",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 463777085,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Mzc3NzA4NQ==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-14T20:15:21Z",
    "updated_at": "2019-02-14T20:15:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "It's my opinion that the spec should use unsigned integers in all situations where the described value should never be negative. Additionally, the spec should use unsigned integers of the minimal bit length required for the given purpose, and explicitly define under/overflow behavior.\r\n\r\nImplementors can then use signed or unsigned integers as they see fit, as long as the requirements of the specification are maintained.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/463777085/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464420619",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464420619",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464420619,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDQyMDYxOQ==",
    "user": {
      "login": "atoulme",
      "id": 16758,
      "node_id": "MDQ6VXNlcjE2NzU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/16758?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/atoulme",
      "html_url": "https://github.com/atoulme",
      "followers_url": "https://api.github.com/users/atoulme/followers",
      "following_url": "https://api.github.com/users/atoulme/following{/other_user}",
      "gists_url": "https://api.github.com/users/atoulme/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/atoulme/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/atoulme/subscriptions",
      "organizations_url": "https://api.github.com/users/atoulme/orgs",
      "repos_url": "https://api.github.com/users/atoulme/repos",
      "events_url": "https://api.github.com/users/atoulme/events{/privacy}",
      "received_events_url": "https://api.github.com/users/atoulme/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-17T05:58:36Z",
    "updated_at": "2019-02-17T05:58:59Z",
    "author_association": "MEMBER",
    "body": "All,\r\n\r\nI believe it is important to properly support teams that work in Java/Kotlin and build Ethereum 2.0 clients. We (hat tip to @cleishm) have implemented an unsigned 64 bit number in Cava:\r\nhttps://github.com/ConsenSys/cava/blob/master/units/src/main/java/net/consensys/cava/units/bigints/UInt64.java\r\n\r\nI have prepared a commit for Artemis to change its logic to use it (I replaced all uses of UnsignedLong):\r\nhttps://github.com/atoulme/artemis/commit/eb4ef009358a63b31ed7942cc6165f7c44760924\r\n\r\nI believe this alleviates some of the pains, especially as UInt64 supports bit shifting, exact additions and subtractions, and more.\r\n\r\nIf I can supply an opinion - Kotlin offers the flexibility you seek if you're looking for a flexible DSL that allows overloading operators.\r\n\r\nCheers.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464420619/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464421346",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464421346",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464421346,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDQyMTM0Ng==",
    "user": {
      "login": "lookfirst",
      "id": 85355,
      "node_id": "MDQ6VXNlcjg1MzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/85355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lookfirst",
      "html_url": "https://github.com/lookfirst",
      "followers_url": "https://api.github.com/users/lookfirst/followers",
      "following_url": "https://api.github.com/users/lookfirst/following{/other_user}",
      "gists_url": "https://api.github.com/users/lookfirst/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lookfirst/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lookfirst/subscriptions",
      "organizations_url": "https://api.github.com/users/lookfirst/orgs",
      "repos_url": "https://api.github.com/users/lookfirst/repos",
      "events_url": "https://api.github.com/users/lookfirst/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lookfirst/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-17T06:14:54Z",
    "updated_at": "2019-02-17T06:24:49Z",
    "author_association": "NONE",
    "body": "@protolambda \r\n\r\n> Java only supports signed integers. \"int\": 32 bits, signed.\r\n\r\n\"int: By default, the int data type is a 32-bit signed two's complement integer, which has a minimum value of -231 and a maximum value of 231-1. **In Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 232-1.** Use the Integer class to use int data type as an unsigned integer. See the section The Number Classes for more information. Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers.\"\r\n\r\n> Java only supports signed 64 bit numbers (\"long\").\r\n\r\n\"long: The long data type is a 64-bit two's complement integer. The signed long has a minimum value of -263 and a maximum value of 263-1. **In Java SE 8 and later, you can use the long data type to represent an unsigned 64-bit long, which has a minimum value of 0 and a maximum value of 264-1.** Use this data type when you need a range of values wider than those provided by int. The Long class also contains methods like compareUnsigned, divideUnsigned etc to support arithmetic operations for unsigned long.\"\r\n\r\n> Of course, you could transport a unsigned 64 bit number over a signed number, but it's not nice to work with.\r\n\r\nTotally subjective opinion and not enough empirical evidence to argue for a debate.\r\n\r\n> Alternative would be slow and unreadable Big integers. (due to `z.Set(y).Add(x)` instead of `z = y + x`). Special limits have to be imposed to keep it at 64-bit big-numbers as well.\r\n\r\nHave you tested the speed of this? This should get easily optimized in the JIT. Many large financial institutions use Java for HFT (high frequency trading), which requires insane performance with large numbers.\r\n\r\nAs for the 'unreadable' part... it is common to build an API to simplify it for your use case.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464421346/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464442595",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464442595",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464442595,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDQ0MjU5NQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-17T11:04:15Z",
    "updated_at": "2019-02-17T11:24:37Z",
    "author_association": "MEMBER",
    "body": ">  **In Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 232-1.**\r\n\r\nTrue, this is what I meant with \"transporting over a signed int\", because this \"support\" is completely artificial.\r\n\r\nWhy?\r\n- It has no type. Ridiculous in a language such as Java imho.\r\n- It is prone to bugs, you have to know which operations are different than the default signed integers, to use the unsigned method variant.\r\n- You can work-around above limitations, but this would require you to either:\r\n  - Box every int. Slow and a painful amount of boilerplate for simple 64 bit math\r\n  - Use annotations for unsigned variables. And enforce them for all developers. And annotations don't compile, so you won't know after compile-time if you distribute without sources.\r\n- Java 8 is not special. The [Guava library already supported it](https://github.com/google/guava/wiki/PrimitivesExplained). And both do so through a SDK addition of a set of methods for missing unsigned behavior (a hack). The overhead of calling a method is already too much for me personally to not start looking for better alternatives (I want the very best here, not a hack if possible).\r\n- Readability, math through method calls is not a good.\r\n- On a JVM bytecode level, there is **nothing new, it's just emulated, afaik**. I would say performance is affected for those operations that are not the same between signed and unsigned, e.g. division, modulo.\r\n- It starts to become **even worse** with different JDKs, openJDK literally says \"could be better, check other options\" in its documentation of unsigned behavior, [here](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/dc4322602480/src/share/classes/java/lang/Long.java). Guess what they use to implement it? They convert it to big-integers. Nobody wants to burn itself with hacky but more optimal alternatives.\r\n- The JIT can inline whatever, but if it doesn't magically reduce multiple alternating additions and if-statements, it's not going to equal the same performance, even for simple unsigned integer comparisons.\r\n\r\n>> Java only supports signed 64 bit numbers (\"long\"). ...  \r\n>\r\n> **In Java SE 8 and later** ...\r\n\r\nSee above, it's really just the same data-type, with a hacky workaround to provide support for unsigned behavior. It's not completely native to the JVM bytecode afaik (please correct me if I'm wrong).\r\n\r\n>> Of course, you could transport a unsigned 64 bit number over a signed number, but it's not nice to work with.\r\n>\r\n> Totally subjective opinion and not enough empirical evidence to argue for a debate.\r\n\r\nI literally wrote up an entire post to start a debate on considerations with integers, with special attestation to Java. And I'm familiar enough with the JVM and Java bytecode to work with JNI, reflection and know of awful hacks such as the lower integer cache. I tried my best documenting everything, and noted the transport-over-signed integer support, but yes I have my opinions.\r\nI will edit it to not include \"not nice to work with\", and point out both of our comments. \"not nice to work with\" really was the nicest thing I could say about it.\r\n\r\n>> Alternative would be slow and unreadable Big integers. (due to `z.Set(y).Add(x)` instead of `z = y + x`). Special limits have to be imposed to keep it at 64-bit big-numbers as well.\r\n>\r\n> Have you tested the speed of this? This should get easily optimized in the JIT. Many large financial institutions use Java for HFT (high frequency trading), which requires insane performance with large numbers.\r\n\r\nHave not tested it myself, but there's plenty of other research/benchmarks into big-integers. And generally, the standard BigInteger is much slower than the one in Go. Now compare it to a native 64 bit integer with native operations, no boxing/allocations, and it's far behind.\r\n\r\nPersonally, I fundamentally dislike it because of the boxing (it's not necessary if you're on a 64 bit platform) and awful syntax. There's reasons where I would use it however, like safe-math, or > 64 bit integers.\r\n\r\nAlso, I don't care about \"usage in HFT\" when it's not the bottleneck of the actual example application. Streaming and distribution across compute are much more important in such a case afaik. As a side note; I wonder if we can make the beacon-chain processing itself more parallelized...\r\n\r\nI will just edit this, if it's too subjective.\r\n\r\nMy proposed alternative, if you want to pursue JVM with less of the concerns that Java raises: Kotlin.\r\n\r\nGenerally, Kotlin does a much better job at implementing the same thing (although still \"experimental\" phase in 1.3), but with types, readable constants, and readable operators. Still the same JVM limitations tho, as far as I know (but Kotlin also has a native target as well). For reasons like these, I think it deserves a look to transition to as a JVM based client now that it's still a relatively early phase.\r\n\r\n**TLDR**: avoid hacky pseudo unsigned 64 bit support if possible, i.e. see if just signed numbers would work first. And if you do, use annotations, enforce them, and document the dangers.\r\n\r\n\r\n\r\n\r\nEdit: fix quoting markup\r\nEdit 2: fix some typos\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464442595/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464452010",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464452010",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464452010,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDQ1MjAxMA==",
    "user": {
      "login": "lookfirst",
      "id": 85355,
      "node_id": "MDQ6VXNlcjg1MzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/85355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lookfirst",
      "html_url": "https://github.com/lookfirst",
      "followers_url": "https://api.github.com/users/lookfirst/followers",
      "following_url": "https://api.github.com/users/lookfirst/following{/other_user}",
      "gists_url": "https://api.github.com/users/lookfirst/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lookfirst/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lookfirst/subscriptions",
      "organizations_url": "https://api.github.com/users/lookfirst/orgs",
      "repos_url": "https://api.github.com/users/lookfirst/repos",
      "events_url": "https://api.github.com/users/lookfirst/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lookfirst/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-17T12:38:58Z",
    "updated_at": "2019-02-17T12:40:38Z",
    "author_association": "NONE",
    "body": "This got me digging into the performance and I found this: \r\n\r\nhttps://github.com/bwakell/Huldra\r\nhttps://codeforces.com/blog/entry/17235",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464452010/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464455062",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464455062",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464455062,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDQ1NTA2Mg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-17T13:08:32Z",
    "updated_at": "2019-02-17T13:08:32Z",
    "author_association": "MEMBER",
    "body": "If we're comparing big-ints, take a look at http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/\r\nSome languages are just better suited for heavy optimization.\r\n\r\nThat said, I think we need to stay on topic, and discuss the benefits and drawbacks of all integer signs and sizes. Let's not get stuck talking about just big-ints, as clearly, we can do better.\r\n\r\nThe question is: *what is the best choice for a **solid** and **fast** implementation, while still being **reasonable to implement** in all the involved languages?* (x3, the different problems may require different types of solutions)\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464455062/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464554286",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464554286",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464554286,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDU1NDI4Ng==",
    "user": {
      "login": "lookfirst",
      "id": 85355,
      "node_id": "MDQ6VXNlcjg1MzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/85355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lookfirst",
      "html_url": "https://github.com/lookfirst",
      "followers_url": "https://api.github.com/users/lookfirst/followers",
      "following_url": "https://api.github.com/users/lookfirst/following{/other_user}",
      "gists_url": "https://api.github.com/users/lookfirst/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lookfirst/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lookfirst/subscriptions",
      "organizations_url": "https://api.github.com/users/lookfirst/orgs",
      "repos_url": "https://api.github.com/users/lookfirst/repos",
      "events_url": "https://api.github.com/users/lookfirst/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lookfirst/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T02:11:03Z",
    "updated_at": "2019-02-18T02:11:03Z",
    "author_association": "NONE",
    "body": "@protolambda What is the relevance of quoting a blog post from 2014 with tests against Java 1.7?\r\n\r\nIn the case of ETH 2.0, which is still being heavily developed and worked on, shouldn't the focus be less on premature optimization and more on a **solid** implementation? **Solid** meaning that it passes all unit and integration tests.\r\n\r\nPretty and fast is optimizations that can be added later. Java makes profiling and refactoring quite straightforward.\r\n\r\nKotlin is a bike shed issue. Switching to a whole new language just over this issue seems like another premature optimization. It isn't trivial. Documentation, build systems, technical skills of the developers, etc... all need to be updated and changed. In other words, a whole number of risks for benefit of unknown percentage.\r\n\r\nI'd just go with @atoulme's suggestion and use Cava's implementation of UInt64. Problem solved.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464554286/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464557559",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464557559",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464557559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDU1NzU1OQ==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T02:28:17Z",
    "updated_at": "2019-02-18T02:28:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Kotlin is a bike shed issue. Switching to a whole new language just over this issue seems like another premature optimization. _It isn't trivial._\r\n\r\nI agree that Java/Kotlin is a bit of a bike shed issue, much like big vs little endian, signed vs unsigned, etc. ;-)\r\n\r\nThat said, I disagree about the triviality. Kotlin is highly compatible with Java, you can mix it in the same source tree, and it all works in the same IDE. I'd argue it's more like a syntax variation than a different language. Indeed, much of Cava is implemented in Kotlin but consumed using each module's Java visible APIs. We do this because it's much easier to use Kotlin in many situations. Such a situation would be if there really is an extensive need to use extensively use unsigned integers - one can switch a bunch of classes into the Kotlin syntax and that problem is solved. Fairly trivially.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464557559/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464558214",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464558214",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464558214,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDU1ODIxNA==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T02:31:51Z",
    "updated_at": "2019-02-18T02:31:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "(BTW, Cava already provides an SSZ implementation using Kotlin unsigned integers: https://github.com/ConsenSys/cava/blob/master/ssz/src/main/kotlin/net/consensys/cava/ssz/experimental/SSZWriter.kt#L183. I expect other eth-2.0 related libraries in Cava will, where relevant, also expose Kotlin API using unsigned ints.)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464558214/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464558233",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464558233",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464558233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDU1ODIzMw==",
    "user": {
      "login": "lookfirst",
      "id": 85355,
      "node_id": "MDQ6VXNlcjg1MzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/85355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lookfirst",
      "html_url": "https://github.com/lookfirst",
      "followers_url": "https://api.github.com/users/lookfirst/followers",
      "following_url": "https://api.github.com/users/lookfirst/following{/other_user}",
      "gists_url": "https://api.github.com/users/lookfirst/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lookfirst/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lookfirst/subscriptions",
      "organizations_url": "https://api.github.com/users/lookfirst/orgs",
      "repos_url": "https://api.github.com/users/lookfirst/repos",
      "events_url": "https://api.github.com/users/lookfirst/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lookfirst/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T02:31:57Z",
    "updated_at": "2019-02-18T02:31:57Z",
    "author_association": "NONE",
    "body": "Ah, so more like TypeScript/JavaScript. Sweet. Maybe that is the answer here then.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464558233/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464562293",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464562293",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464562293,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDU2MjI5Mw==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T02:52:38Z",
    "updated_at": "2019-02-18T02:52:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Ah, so more like TypeScript/JavaScript.\r\n\r\nThat's a much more succinct way of explaining it! 😂",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464562293/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 1,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464625914",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464625914",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464625914,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDYyNTkxNA==",
    "user": {
      "login": "benjaminion",
      "id": 20796281,
      "node_id": "MDQ6VXNlcjIwNzk2Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20796281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benjaminion",
      "html_url": "https://github.com/benjaminion",
      "followers_url": "https://api.github.com/users/benjaminion/followers",
      "following_url": "https://api.github.com/users/benjaminion/following{/other_user}",
      "gists_url": "https://api.github.com/users/benjaminion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benjaminion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benjaminion/subscriptions",
      "organizations_url": "https://api.github.com/users/benjaminion/orgs",
      "repos_url": "https://api.github.com/users/benjaminion/repos",
      "events_url": "https://api.github.com/users/benjaminion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benjaminion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T08:02:23Z",
    "updated_at": "2019-02-18T08:02:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "Even though I'm in one of the teams working in Java, I don't think this discussion should be driven by what suits Java - one way or another we'll cope with whatever the final decision is.\r\n\r\nFor me, this ought to be a more purist conversation around formulating the spec in the safest way for implementers generally. Yesterday, I wrote a long justification for using signed integers, or, alternatively, providing clear bounds on valid ranges so implementers could safely do as they please. But then I realised I was just repeating the wisdom of @protolambda and @mratsim above, and there's no point going round in circles.\r\n\r\n---\r\n\r\nHaving said that... 😂 \r\n\r\n> I'd just go with @atoulme's suggestion and use Cava's implementation of UInt64. Problem solved.\r\n\r\nUsing a native type if we can (e.g. signed long for epochs/slots) would be immensely simpler. The main challenge with the wrapped types is the extremely clunky syntax which is horrible to write, awful to read and horrendous to maintain. But, as I said, we'd cope. [Yes, we know about Kotlin!]",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464625914/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464799707",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464799707",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464799707,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDc5OTcwNw==",
    "user": {
      "login": "lookfirst",
      "id": 85355,
      "node_id": "MDQ6VXNlcjg1MzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/85355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lookfirst",
      "html_url": "https://github.com/lookfirst",
      "followers_url": "https://api.github.com/users/lookfirst/followers",
      "following_url": "https://api.github.com/users/lookfirst/following{/other_user}",
      "gists_url": "https://api.github.com/users/lookfirst/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lookfirst/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lookfirst/subscriptions",
      "organizations_url": "https://api.github.com/users/lookfirst/orgs",
      "repos_url": "https://api.github.com/users/lookfirst/repos",
      "events_url": "https://api.github.com/users/lookfirst/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lookfirst/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T16:29:08Z",
    "updated_at": "2019-02-18T16:29:08Z",
    "author_association": "NONE",
    "body": "What I'd like to see is this issue updated with some actual code to be used in ETH2.0, done both ways (native types vs. 'extremely clunky syntax which is horrible to write'), in Java and maybe even Kotlin.\r\n\r\nThen we can do a bit of performance testing as well as syntax evaluation and discussion and work towards a good middle ground. Right now, it is all to subjective IMHO, we should be letting the code speak for itself.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464799707/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464856771",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464856771",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464856771,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDg1Njc3MQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T19:51:49Z",
    "updated_at": "2019-02-18T19:51:49Z",
    "author_association": "MEMBER",
    "body": "> @protolambda What is the relevance of quoting a blog post from 2014 with tests against Java 1.7?\r\n\r\n@lookfirst OpenJDK hasn't even changed the big-number implementation since 2014. JDK 8 is from Mar 2014: https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/math/BigInteger.java\r\nBut, I don't care so much about Java in the comparison, or the details, it's more about the approaches other languages have taken to make big-integers efficient. (you don't have to stick to the approach of the Java SDK to get something working in Java, e.g. see Cava)\r\n\r\n-------------\r\n\r\n> Even though I'm in one of the teams working in Java, I don't think this discussion should be driven by what suits Java - one way or another we'll cope with whatever the final decision is.\r\n\r\n@benjaminion Agree, to a certain extent. If there's something to choose, let's go for compatibility.\r\n\r\n> Using a native type if we can (e.g. signed long for epochs/slots) would be immensely simpler\r\n\r\nYep, we should definitely be able to handle slots through native types for most languages. All we have to do is define a working range (enforced in spec) to support a distant but not too big future (e.g. 1000 years), and then we can support every client, each working with their native types. And unsigned/signed needs to be decided.\r\n\r\nSo let me try to simplify this slot debate to get it done with:\r\n\r\nSlot/Epoch format debate nr. 1:\r\n\r\nA) unsigned, `genesis = 0`: needs good design and testing to avoid/detect underflows for early epoch/slot logic, but will make encoding life easy, and has readable slot numbers. Also more pure, as there won't be negative slots.\r\nB) unsigned, `genesis = (1 << x)`: no underflows (if implemented well), but unreadable slot numbers. If `x = 63` here, then it's effectively unreadable signed integers with worse encoding (because of starting 1, no var-length int option without sign bit if you want to)\r\nC) signed, `genesis = 0`: readable, easy to deal with from a logic perspective (i.e. first few slots looking back in old history, catching < 0 to return nothing). Supported by every language (JS number has a sign bit in addition to mantissa, it's native to Java). The negative slot can be important to future API response designs, e.g. return -1 for slot of non-existing block-hash. However, it may be difficult to deal with the potential of having a negative slot number.\r\n\r\nSlot/Epoch format debate nr. 2:\r\n\r\nA) Enforce a range of max. x bits (e.g. 52) to be used (good enough for ... years/centuries), so that every client can safely use their native types.\r\nB) Do not enforce anything. Clients may still use native types, but may also end up with some sort of failure if done wrong.\r\n\r\nFair to say epochs have the same encoding: epochs are not that long, so the encoding is only like 6 bits less. (64 slots). Also just nice for consistency and ease in conversion.\r\n\r\n\r\n----------\r\n\r\nThen there is the validator index encoding: given the \"4 million\" worst case number, you would think that 32 bits is good and simple enough. So there's two questions to answer:\r\n\r\n- Will we need more than 32 bits? (E.g. we use index instead of pubkey as an ID for some reason, and it's not really limited by the 4M number, but the amount of entries)\r\n- Do we go for signed or unsigned? (See original post for pros/cons of options)\r\n\r\nThis should also be easy enough to decide on.\r\n\r\n----------\r\n\r\nThen lastly, we have balances, which don't have a low range to start thinking about wide native support, and are hard to get right.\r\n\r\nFor this particular problem class, I kinda agree with @lookfirst here (although it is a lot of work):\r\n\r\n> What I'd like to see is this issue updated with some actual code to be used in ETH2.0, done both ways (native types vs. 'extremely clunky syntax which is horrible to write'), in Java and maybe even Kotlin.\r\n>\r\n>Then we can do a bit of performance testing as well as syntax evaluation and discussion and work towards a good middle ground. Right now, it is all to subjective IMHO, we should be letting the code speak for itself.\r\n\r\n--------\r\n\r\nGiven that slots and indices are important, yet relatively easy to solve, I would prioritize this, and continue the debate on balances later.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464856771/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464877826",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464877826",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464877826,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDg3NzgyNg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T21:03:39Z",
    "updated_at": "2019-02-18T21:06:45Z",
    "author_association": "MEMBER",
    "body": "Proposal to get the debate to 2/3 problems solved:\r\n\r\n# Slots & Epochs\r\n\r\n`int64`, with enforced range check during block processing.\r\n\r\n## Why?\r\n\r\n- Readable in human format\r\n- Easy to deal with from a logic perspective (i.e. first few slots looking back in old history, catching < 0 to return nothing)\r\n- Supported by every language (JS number has a sign bit in addition to mantissa, it's native to Java).\r\n- The negative slot can be important to future API response designs, e.g. return -1 for slot of non-existing block-hash.\r\n\r\n## How?\r\n\r\nWe have to deal with the possibility that someone tries to propagate a block, created in a:\r\n1) negative slot (already enforced, since block.slot > parent_block.slot, genesis = 0)\r\n2) too distant future (thousands of years from now, we'll likely ignore them anyway), outside of the range we agree upon (52 bits (excl. sign bit) being the max. if we want wide support)\r\n\r\n1. is already enforced, 2. likely needs to be done anyway, just do the range check on ingestion and be done with it. (add sanity checks to spot occurrences of these two options wherever you see fit tho)\r\n\r\n# Validator Indices\r\n\r\n`int32`\r\n\r\n## Why?\r\n\r\nGiven the 4M worst case often cited, or 8M if you go by the `EJECTION_BALANCE` constant of 16M and 128M ETH in circulation in the distant future, there's a lot to say about just not using 64 bits.\r\n\r\nAs mentioned in the original write-up:\r\n\r\n> Validator indices are realtively low, and would fit easily in 32 bits:\r\n```\r\n2**31 = 2,147,483,648\r\n2**32 = 4,294,967,296\r\n```\r\n\r\nAnd since indices are just indices, not out-of-context keys (unlike the public key that everyone knows of for verification etc.), 32 bits should be enough for a long time. (IMO: Once we get to a point where we need to design to billions of validators, it's mainstream and big enough to have gone through much, much more updates/forks)\r\n\r\nI'm think signed integers work slightly better for API-like reasons, but okay with unsigned here.\r\n\r\nIf anyone can make a strong case for unsigned / against signed, raise your voice.\r\n\r\n\"indices are not negative\" is not good enough imho, as it's useful to have in special-cases (like mentioned above), and negative indices are no different than indices out of range on the other end, i.e. `index >= length`. \r\n\r\nBesides, life for Java is slightly easier with it being signed, since they never have to wrap them in a `int64` (`long`).\r\n\r\n## How?\r\n\r\nTake `Let proposer = state.validator_registry[proposer_slashing.proposer_index]` as example: you handle `index < 0` exactly the same as `index >= len(validator_registry)`.\r\n\r\nSame for everywhere else, just update the current implicit `range_check_index(i)` function of your validator registry to check for negative indices too.\r\n\r\nIf some negative validator index is ever encoded and used in a slashing/block/whatever, it's the same as an index being out of range on the other side of the registry, and we mark it as invalid.\r\n\r\n# Balances\r\n\r\nTBD later, part 3/3 of the debate.\r\n\r\nSince big-integers are involved for some languages that don't support `uint64` (if we would want to keep using that), it warrants some extra discussion on style and testing to get things right for everyone.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464877826/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464891616",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-464891616",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 464891616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDg5MTYxNg==",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T21:46:07Z",
    "updated_at": "2019-02-18T22:23:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "For indices signed works better because indices at low-level are pointer accesses and those are signed (cf [ptrdiff_t](https://en.cppreference.com/w/c/types/ptrdiff_t)) so this maps very well with C on 32 and 64-bit platforms but if we have the range that is implementation detail.\r\n\r\n\r\nEdit - Side-note: [Quoting Google C++ style guide](https://google.github.io/styleguide/cppguide.html#Integer_Types)\r\n\r\n> On Unsigned Integers\r\n> Unsigned integers are good for representing bitfields and modular arithmetic. Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point. The fact that unsigned arithmetic doesn't model the behavior of a simple integer, but is instead defined by the standard to model modular arithmetic (wrapping around on overflow/underflow), means that a significant class of bugs cannot be diagnosed by the compiler. In other cases, the defined behavior impedes optimization.\r\n> \r\n> That said, mixing signedness of integer types is responsible for an equally large class of problems. The best advice we can provide: try to use iterators and containers rather than pointers and sizes, try not to mix signedness, and try to avoid unsigned types (except for representing bitfields or modular arithmetic). Do not use an unsigned type merely to assert that a variable is non-negative.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/464891616/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465264466",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465264466",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465264466,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTI2NDQ2Ng==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-19T18:57:12Z",
    "updated_at": "2019-02-19T18:57:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "Google C++ style guide may be fine for Google, but I [don't](https://www.quora.com/Why-isn%E2%80%99t-it-good-to-follow-Googles-C++-style-guide) [think](https://news.ycombinator.com/item?id=18555771) [it's](https://news.ycombinator.com/item?id=8690952) [widely](https://www.reddit.com/r/learnprogramming/comments/9bp8b7/c_google_says_to_avoid_unsigned_integer_types/) [accepted](http://www.cplusplus.com/forum/beginner/241974/) as best practice, and it's focussed on implementation rather than on specifications.\r\n\r\nFor a specification, I still contend that it should describe the minimal requirement. If slots & epoch only need a range of 0 .. 2**52, then define it that way in the spec. If a bit-flag is needed to indicate an error, add that in the specification also. Implementations can then use whatever types their language of choice provides, as long as they can represent the required range and the implementation handles under/overflow as specified.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465264466/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465521609",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465521609",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465521609,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTUyMTYwOQ==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T10:42:06Z",
    "updated_at": "2019-02-20T10:42:06Z",
    "author_association": "MEMBER",
    "body": "> Even though I'm in one of the teams working in Java, I don't think this discussion should be driven by what suits Java - one way or another we'll cope with whatever the final decision is.\r\n\r\nMy teammates and I totally agree with @benjaminion. We are another Java team working on beacon chain implementation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465521609/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465672885",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465672885",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465672885,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTY3Mjg4NQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T17:18:30Z",
    "updated_at": "2019-02-20T17:18:30Z",
    "author_association": "MEMBER",
    "body": "# Alternative proposal, the unsigned int one\r\n\r\nOk, so alternatively, to make the spec more \"pure\", we can say the types for slots/epochs and validator indices are unsigned. But with very clear wording on the allowed range, and encoding. This way, clients can safely use the native types that they like (\"long\" (java signed int64), \"Number\" (JS sign + mantissa)).\r\n\r\n*Below representation is big-endian, to make it easy to read. Little-endian does not change much, other than the actual memory order of the bytes.*\r\n```\r\n\r\n| 63 | 62 | 61 | 60 | 59 | 58 | 57 | 56 | 55 | 54 | 53 | 52 | 51 | 50 | 49 | 48 | 47 | 46 | 45 | 44 | 43 | 42 | 41 | 40 | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |\r\n| S  |   A: unused till later soft fork, 11 bits       |                 B: allowed range, but subject to spec rules (time)                                                                                                                                                                                                     |\r\n```\r\n\r\n`S` = Sign bit. Disallowed to be 1 in input/output, unless explicitly stated.\r\n\r\nExceptions can be made for API design (e.g. -1 for slot of unknown block-root).\r\nNote that it can be 1 in the internal processes, e.g. an implementation can choose to encode it as a signed-number to not have to work-around unsigned math.\r\n\r\n`A` = Explicitly disallowed for now. Higher end of the encoding range for integers. Can soft-fork in a looong time from now to enable this range.\r\n`B` = Explicitly allowed, but subject to specification rules. I.e. slot must not be larger than X slots of latest finalized slot number to be accepted.\r\n\r\n52 bits should be plenty for slot/epoch numbers.\r\n\r\nFor validator numbers, we could use the same policy above for maximum capacity.\r\n\r\nIf you like this better than the earlier proposal, please add an emoji. If not, please show support for the earlier proposal, or write your own.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465672885/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465679365",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465679365",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465679365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTY3OTM2NQ==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T17:35:37Z",
    "updated_at": "2019-02-20T17:35:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "@protolambda So to paraphrase, are you saying that slot/epoch should be an unsigned 52-bit integer, but any part of the specifications that encodes these values should do so as 64-bits with the top 12 always set to zero?\r\n\r\nDo we know all the places these values will be encoded?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465679365/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465699835",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465699835",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465699835,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTY5OTgzNQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T18:31:40Z",
    "updated_at": "2019-02-20T18:31:40Z",
    "author_association": "MEMBER",
    "body": "@cleishm Not exactly.\r\n\r\nSimplified:\r\n- encoding and decoding should enforce 12 top bits to be 0.\r\n- 64 bits is used on encoding, because it:\r\n  - aligns well\r\n  - is very standard, easy to encode, unlike 52 bits, or possibly 48 bits.\r\n  - encoding does not affect the platforms, if they can just decode into their own smaller types (by making use of the explicit range). All platforms will get to use their native types.\r\n  - leaves room for an update, when the need arises (very long from now)\r\n  - many platforms already support it. If someone wants to make their own clone of the beacon-chain, they can choose these clients, and go for a higher range (e.g. they want a lower slot time, which reaches the limit sooner)\r\n\r\n\r\nWhat I'm saying is that we can loosen the design space by just stating that every client has to support 52 bits. Every platform can do this. This requirement is important, because if you transfer data through a peer, you want them to be able to handle it (without something alike to reduction in resolution), so that the data can propagate to other peers without problem.\r\n\r\nAnd it's two's complement, so the sign bit will be left-most, next to the unused bits, and all will be 0 for our use case (positive numbers from 0 ... n, with n bounded by time or validator count).\r\n\r\nAnd we encode it as 64 bits, because it's much more standard, and we can loosen up the range towards 64 bits as soon as the need arises (in millions of years with current slot time, or when ethereum validator count explodes beyond imagination...).\r\n\r\nAlso, being unsigned would just mean the spec has to be explicit on simple underflows (e.g. slot lookback early in the chain, looking for data before genesis). And clients can choose to handle it as signed numbers instead of extra if statements, if they want to.\r\n\r\nThe alternative-alternative proposal would be to just use `uint64`, but that's status quo. Similar, but not good enough for client to use their native types safely, while they could if they wanted so. If we want to stick to unsigned, then better make a good and minimal (see proposal, not this :joy:) statement on what to expect from clients, so that everyone can use their best integer choice for slots/epoch/indices.\r\n\r\nTLDR:\r\n- This proposal is for unsigned ints, but makes sure every platform can use their native types\r\n- Only problem is the enforcing of the range. However, this is only necessary when encoding/decoding something, which is not too bad.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465699835/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465702803",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465702803",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465702803,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTcwMjgwMw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T18:39:58Z",
    "updated_at": "2019-02-20T18:39:58Z",
    "author_association": "MEMBER",
    "body": "Also, if neither the Java nor the Javascript teams want to use their native types, we could just as well forget about all of this, and keep it at `uint64`. But reverting that decision later may not be so easy (if not near-impossible), hence all of this (boring) effort to get it sorted.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465702803/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465718610",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-465718610",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 465718610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTcxODYxMA==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T19:23:28Z",
    "updated_at": "2019-02-20T19:24:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "@protolambda Thanks for the clarification - I think that agrees with [what I had in mind](https://github.com/ethereum/eth2.0-specs/issues/626#issuecomment-465679365). Specify slot/epoch as an integer value in the range 0 .. 2^52, and specifying any encoding of that to use 64-bits (thus the most significant 12 bits must be zero). Additionally, define under/overflow semantics as wrap-around or error.\r\n\r\nImplementations are then free, in their code, to treat slot/epoch as unsigned 52-bit integers, or 64-bit signed or unsigned values. They just have to make sure it encodes & decodes correctly, and handles under/overflow as specified.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/465718610/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466195391",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-466195391",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 466195391,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NjE5NTM5MQ==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-21T22:34:33Z",
    "updated_at": "2019-02-21T22:34:33Z",
    "author_association": "MEMBER",
    "body": "> Implementations are then free, in their code, to treat slot/epoch as unsigned 52-bit integers, or 64-bit signed or unsigned values.\r\n\r\n#655 provides this flexibility for implementers :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466195391/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466196943",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-466196943",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 466196943,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NjE5Njk0Mw==",
    "user": {
      "login": "cleishm",
      "id": 79651,
      "node_id": "MDQ6VXNlcjc5NjUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/79651?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cleishm",
      "html_url": "https://github.com/cleishm",
      "followers_url": "https://api.github.com/users/cleishm/followers",
      "following_url": "https://api.github.com/users/cleishm/following{/other_user}",
      "gists_url": "https://api.github.com/users/cleishm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cleishm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cleishm/subscriptions",
      "organizations_url": "https://api.github.com/users/cleishm/orgs",
      "repos_url": "https://api.github.com/users/cleishm/repos",
      "events_url": "https://api.github.com/users/cleishm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cleishm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-21T22:39:44Z",
    "updated_at": "2019-02-21T22:39:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "@JustinDrake That's cool. Do you think overflow needs to be addressed? I suspect it should be an error.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466196943/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466330913",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-466330913",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 466330913,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NjMzMDkxMw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-22T09:22:16Z",
    "updated_at": "2019-02-22T09:22:16Z",
    "author_association": "MEMBER",
    "body": "> Do you think overflow needs to be addressed? I suspect it should be an error.\r\n\r\nI wouldn't be opposed to adding something like \"Any `uint64` overflow should throw an error.\" assuming we make `justification_bitfield` a byte array. (At the moment `justification_bitfield` is awkwardly a `uint64` designed to overflow.)\r\n\r\nIn practice, `uint64`s should not overflow because of time and economic constraints. And if we miss an overflow edge case that can be triggered (e.g. by an attacker) then whatever the spec defines (wrap around or throw an error) it may not make a meaningful difference as in either case it would likely require manual intervention.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/466330913/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468813005",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/626#issuecomment-468813005",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/626",
    "id": 468813005,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODgxMzAwNQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-01T21:11:12Z",
    "updated_at": "2019-03-01T21:11:12Z",
    "author_association": "MEMBER",
    "body": "After experimenting with SSZ encoding implementation and spec implementation more (to be published), I feel like the choice for unsigned integers works much better: it's not hard to deal with the unsigned math at all in practice, and exclusiveness of unsigned numbers reduces the complexity of encoding/decoding.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468813005/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
