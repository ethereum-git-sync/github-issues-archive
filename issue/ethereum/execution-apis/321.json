{
  "url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
  "repository_url": "https://api.github.com/repos/ethereum/execution-apis",
  "labels_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321/comments",
  "events_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321/events",
  "html_url": "https://github.com/ethereum/execution-apis/issues/321",
  "id": 1440217537,
  "node_id": "I_kwDOFoG9Gs5V1_nB",
  "number": 321,
  "title": "Engine API spec improvement proposal",
  "user": {
    "login": "mkalinin",
    "id": 1892772,
    "node_id": "MDQ6VXNlcjE4OTI3NzI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mkalinin",
    "html_url": "https://github.com/mkalinin",
    "followers_url": "https://api.github.com/users/mkalinin/followers",
    "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
    "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
    "organizations_url": "https://api.github.com/users/mkalinin/orgs",
    "repos_url": "https://api.github.com/users/mkalinin/repos",
    "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mkalinin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 13,
  "created_at": "2022-11-08T13:34:51Z",
  "updated_at": "2023-01-09T21:23:28Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "*Main ideas behind this proposal were brought up during the Engine API session at the Devcon R&D workshop. Thanks everyone attended for fruitful and engaged conversation. Special thanks to @protolambda for taking notes.*\r\n\r\nUpcoming HFs introduce changes to existing Engine API data structures and method semantics, and also may require new methods to be added. Outside of HFs scope, there are a number of proposals to add auxiliary methods for optimisation and usability purposes (https://github.com/ethereum/execution-apis/pull/218, https://github.com/ethereum/execution-apis/pull/318). In some cases auxiliary methods may be *optional*, i.e. EL may not support such a method but if supported it can be utilized by CL.\r\n\r\nOn the other side, we need a convenient way of deprecating unused or redundant methods (e.g.  `engine_exchangeTransitionConfigurationV1`).\r\n\r\nCapability of introducing changes to the Engine API without coordinated upgrades between the layers is an important property of proposed design.\r\n\r\n## Method and structure versioning\r\n\r\nThis proposal doesn't affect requirements described in the [Versioning](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#versioning) section of the original specification. Any changes to a method behaviour or its parameter set, likewise, changes to the fields of a data structure should be signified by bumping its version. A version is reflected in the name of each method and structure in a `VX` suffix, where `X` is a number of the version.\r\n\r\nThis approach makes specification clearer by shaping changes into separate self-contained definitions. CL and EL client implementations are free to maintain versioning of data structures according to their preferences and may utilize optionality of JSON fields whenever it is suitable.\r\n\r\n## Capabilities\r\n\r\nNew `engine_getCaps` method is proposed (accepts no parameters, returns array of strings). The new method returns a list of Engine API methods (capabilities) that are currently supported by the corresponding EL client. Every method must be represented by all supported versions, i.e. `engine_newPayloadV1` and `engine_newPayloadV2` must be in the return list if EL currently supports both.\r\n\r\nThe method may not return itself in the list, a version suffix for this method doesn't seem relevant too.\r\n\r\nIt is assumed that CL clients request EL capabilities at the beginning of the Websocket session, and do this on demand while communicating via HTTP (periodically or after EL gets back from outage).\r\n\r\n*Note:* **`Deprecated`** methods may be listed in the response to `engine_getCaps` if EL client does still support them.\r\n\r\n*Note:* **`Optional`** methods are not required to be supported by EL clients, thus, may not be listed in the response to `engine_getCaps`.\r\n\r\n### Method status\r\n\r\nThe following method statuses are proposed:\r\n\r\n* **`Experimental`** -- yet under development, semantics and parameter set changes are expected. Such a method may have no version suffix (name of a feature as a suffix does seem more convenient, e.g.  `engine_newPayloadWithdrwals`, `engine_getPayload4844` etc).\r\n* **`Final`** -- method specification is considered solid, changes may only be done in order to fix a bug.\r\n* **`Optional`** -- same as **`Final`**, but for optional methods.\r\n* **`Deprecated`** -- the method is deprecated and may no longer be supported by EL clients.\r\n\r\n*Note:* These statuses are only used in the capabilities table described below, they don't explicitly appear in the client software implementations.\r\n\r\nWe propose deprecating a method as soon as it becomes irrelevant to the protocol as a general rule of thumb.\r\n\r\nFor instance, `engine_exchangeTransitionConfigurationV1` has been used for the Merge transition and isn't required anymore, thus, should be deprecated. A post-Shanghai HF bumping some core methods to `V3` would be a good moment to deprecate `V1` versions of these methods introduced in Paris, or it even can be done some time after the Shanghai block event.\r\n\r\n### Table\r\n\r\nMaintenance of the capabilities table is proposed to keep track of all Engine API methods and their statuses. A change of a status of any method version should be signified by the corresponding update in this table.\r\n\r\nThe table looks as follows:\r\n\r\n| Method | Source | Status |\r\n| - | - | - |\r\n| [`engine_newPayloadV1`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_newpayloadv1) | Bellatrix | Final |\r\n| [`engine_forkchoiceUpdatedV1`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_forkchoiceupdatedv1) | Bellatrix | Final |\r\n| [`engine_getPayloadV1`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_getpayloadv1) | Bellatrix | Final |\r\n| `engine_getPayloadBodiesByRangeV1` | Deduplication | Optional |\r\n| `engine_getPayloadBodiesByHashV1` | Deduplication | Optional |\r\n| [`engine_newPayloadV2`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_newpayloadv2) | Capella | Experimental |\r\n| [`engine_forkchoiceUpdatedV2`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_forkchoiceupdatedv2) | Capella | Experimental |\r\n| [`engine_getPayloadV2`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_getpayloadv2) | Capella | Experimental |\r\n| [`engine_getBlobsBundleV1`](https://github.com/ethereum/execution-apis/blob/main/src/engine/blob-extension.md#engine_getblobsbundlev1) | EIP-4844 | Experimental |\r\n| [`engine_exchangeTransitionConfigurationV1`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_exchangetransitionconfigurationv1) | Bellatrix | Deprecated |\r\n\r\n*Note:* \"Source\" column is added for clarity and may be omitted.\r\n\r\n*Note*: We may want to keep a lean version of the table in the `README` which doesn't include old deprecated and stale experimental methods, and track statuses of entire set of methods and versions in a separate markdown file.\r\n\r\n\r\n## Directory structure\r\n\r\nThe following directory structure is proposed:\r\n\r\n```\r\nexecution-apis/src/engine\r\nâ”œâ”€ schemas/           # Schema files\r\nâ”‚  â”œâ”€ paris.yaml\r\nâ”‚  â”œâ”€ shanghai.yaml\r\nâ”‚  â”œâ”€ deduplication.yaml\r\nâ”œâ”€ common.md         # Common definitions and specification\r\nâ”œâ”€ paris.md          # Paris HF\r\nâ”œâ”€ shanghai.md       # Shanghai HF\r\nâ”œâ”€ eip4844.md        # Specification of a feature\r\n                     # that may be included in an upcoming HF\r\n                     \r\nâ”œâ”€ deduplication.md  # Specification of a feature outside of any HF\r\nâ”œâ”€ README.md         # Description of the process and lifecycle,\r\n                     # summary of capabilities\r\nâ”œâ”€ capabilities.md   # List of all capabilities\r\n```\r\n\r\n## Method and spec document lifecycle\r\n\r\nThis section recommends a general procedure of working with spec documents and tracking Engine API methods/versions.\r\n\r\nEvery method and a new version of a method starts its way with **`Experimental`** status whether it is a new EIP that is planned for inclusion in one of the next HFs or simply a method providing an optimisation opportunity and tends to be deployed between HFs. This allows for a quick PR merge into Engine API specification and facilitates prototyping by adding experimental methods into the list returned by `engine_getCaps` call. Note that new methods should not be added to any document that is representing a HF that has already happened and which specification is considered as final.\r\n\r\nOnce the work on the HF gets more mature and the scope of changes to Engine API is more or less understood, it does make sense to move methods from multiple separate files into one `hardfork.md` file. When the work is done and HF specification is considered as final then statuses of involved methods should be changed to **`Final`** and the document should not have any further updates except for bug fixes.\r\n\r\nFor methods introduced outside of HFs the same process should be applied. When specification of optional method is finalized its status must be changed to the **`Optional`** instead of **`Final`**.\r\n\r\nWhenever method specification is finalized its description should be added to the OpenRPC schema.\r\n\r\nDeprecation of a method version should be reflected in the capabilities table by changing the status of the version to the **`Deprecated`** and removing it from the OpenRPC schema. Once this happens EL clients are free to get rid of the code of deprecated method version from their codebases, and remove it from the response to `engine_getCaps` method call. Note that documents containing specification of already deprecated methods must remain unchanged in the repository as other specification documents may refer to them.\r\n\r\nSometimes the deprecation flow may require more steps. For instance, let's see how deprecation of the `engine_exchangeTransitionConfigurationV1` may work out:\r\n1. CL clients remove hard dependency on making this call. It implies that if the method is still in the capabilities list, CL must follow the previous convention and call it periodically to prevent an EL client from complaining.\r\n1. After that the status of this method is set to **`Deprecated`** and EL client devs remove its support.\r\n1. CL client code may be cleaned up when all EL clients have removed `engine_exchangeTransitionConfigurationV1` from the list of supported methods.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/321/reactions",
    "total_count": 3,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 2,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1317754387",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1317754387",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1317754387,
    "node_id": "IC_kwDOFoG9Gs5Oi1YT",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-16T22:24:08Z",
    "updated_at": "2022-11-16T22:24:08Z",
    "author_association": "MEMBER",
    "body": "Thanks a lot for writing this up! :+1: from me on the capabilities method. I think this is important information for the CL to ascertain. \r\n\r\nI do wonder if we really want/need optional methods? My worry is about the extra degree of freedom this gives clients and could lead to a bit of frustration if CLs rely on the method and certain ELs don't provide it.\r\n\r\nI'm not sure I follow what the content of the HF markdown files will be vs. the general spec. It might be useful to consider the two paths to upgrading the functionality of a method:\r\n* version bump -- client knows it is getting the new functionality because the method name is different\r\n* hardfork -- client knows (to the best of its ability) it is getting the new functionality because the chain has been upgraded\r\n\r\nI think we've all agreed we'd like to bump the version always, regardless of HF or not. In that case, it feels we may be over indexing a bit on the HF side of things? Would it be better to lay out the spec more in terms of functionality (see current layout of [`src/eth`](src/eth)) and make notes about the functions behavior given certain HFs?\r\n\r\nSomewhat related, should we consider whether API changes are totally backwards compatible? Contrived example: we add support for withdrawals and one day decide to remove them, remove it from the engine API, and then it isn't possible to run a chain that supports withdrawals?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1317754387/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1318299648",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1318299648",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1318299648,
    "node_id": "IC_kwDOFoG9Gs5Ok6gA",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-17T08:57:26Z",
    "updated_at": "2022-11-17T08:57:26Z",
    "author_association": "MEMBER",
    "body": "@lightclient thanks a lot for your feedback!\r\n\r\n> I do wonder if we really want/need optional methods? My worry is about the extra degree of freedom this gives clients and could lead to a bit of frustration if CLs rely on the method and certain ELs don't provide it.\r\n\r\nOptional methods is an alternative to fallback on error [approach](#diff-571851156237b81c20006ce9d7a70b3421f19540cead91f45955316c52fe94c0R443), demand for optionality is only represented by this proposal https://github.com/ethereum/execution-apis/pull/218. We may not care about optionality in the first iteration of setting up the process and debate on it later on in a separate iteration.\r\n\r\n> Would it be better to lay out the spec more in terms of functionality (see current layout of [src/eth](https://github.com/ethereum/execution-apis/issues/src/eth)) and make notes about the functions behavior given certain HFs?\r\n\r\nThis is interesting idea, and it is more practical in some sense. Like we have a separate file for say `newPayload` which contains all versions of this function and call this file `new-payload.md` (I guess this is what you mean), it would be easier to spec them out this way and look for the history of changes. One of the downsides is that we have structures shared by different methods, e.g. `ExecutionPayload` shared by `newPayload` and `getPayload` but I think it's manageable. The other property of HF distinction is that we can discern yet experimental methods from solidified parts of the spec, but we may have `experimental/` folder where files will be broken down not by functionality but rather by proposals that may affect all functionality at once, e.g. `eip4844.md`.\r\n\r\n> Somewhat related, should we consider whether API changes are totally backwards compatible?\r\n\r\nI think we should follow the common sense, and make them backward compatible when it is reasonable, but do not make backward compatibility promise.\r\n\r\n> Contrived example: we add support for withdrawals and one day decide to remove them, remove it from the engine API, and then it isn't possible to run a chain that supports withdrawals?\r\n\r\nThis proposal suggests to have a reference table of all Engine API methods with their statuses, and instead of removing method from the spec we should mark it as `Deprecated` in that table and remain the spec for this method unchanged. So, one will be able to either dig out this method from client's code or just re-implement it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1318299648/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1319853466",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1319853466",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1319853466,
    "node_id": "IC_kwDOFoG9Gs5Oq12a",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-18T11:04:57Z",
    "updated_at": "2022-11-18T11:04:57Z",
    "author_association": "MEMBER",
    "body": "Alternative structure with functional breakdown and statuses next to each version of a method (no need for a reference table):\r\n```\r\nâ”œâ”€ experimental/      # Experimental features\r\nâ”‚  â”œâ”€ eip4844.md\r\nâ”‚  â”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”‚  â”œâ”€ BlobsBundleV1\r\nâ”‚  â”‚  â”‚  â”œâ”€ PayloadAttributesV1\r\nâ”‚  â”‚  â”‚  â”œâ”€ PayloadAttributesV2\r\nâ”‚  â”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”‚  â”œâ”€ getBlobsBundle\r\nâ”‚  â”‚  â”‚  â”‚  â”œâ”€ V1\r\nâ”‚  â”œâ”€ feature-name.md\r\nâ”‚  â”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”‚  â”œâ”€ ExecutionPayloadFeatureName\r\nâ”‚  â”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”‚  â”œâ”€ newPayloadFeatureName\r\nâ”‚  â”‚  â”‚  â”œâ”€ getPayloadFeatureName\r\nâ”‚\r\nâ”œâ”€ schemas/           # Schema files\r\nâ”‚  â”œâ”€ blob.yaml\r\nâ”‚  â”œâ”€ capability.yaml\r\nâ”‚  â”œâ”€ configuration.yaml\r\nâ”‚  â”œâ”€ forkchoice.yaml\r\nâ”‚  â”œâ”€ payload.yaml\r\nâ”‚  â”œâ”€ payload-body.yaml\r\nâ”‚\t\r\nâ”œâ”€ common.md\r\nâ”‚  â”œâ”€ Underlying protocol\r\nâ”‚  â”œâ”€ Versioning\r\nâ”‚  â”œâ”€ Message ordering\r\nâ”‚  â”œâ”€ Load-balancing and advanced configurations\r\nâ”‚  â”œâ”€ Errors\r\nâ”‚  â”œâ”€ Timeouts\r\nâ”‚  â”œâ”€ Capabilities\r\nâ”‚  â”‚  â”œâ”€ getCaps\r\nâ”‚\r\nâ”œâ”€ configuration.md\r\nâ”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”œâ”€ TransitionConfigurationV1\r\nâ”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”œâ”€ exchangeTransitionConfigurationV1\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Deprecated\r\nâ”‚\r\nâ”œâ”€ forkchoice.md\r\nâ”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”œâ”€ ForkchoiceStateV1\r\nâ”‚  â”‚  â”œâ”€ PayloadAttributesV1\r\nâ”‚  â”‚  â”œâ”€ PayloadAttributesV2\r\nâ”‚  â”œâ”€ Routines\r\nâ”‚  â”‚  â”œâ”€ Payload building\r\nâ”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”œâ”€ forkchoiceUpdated\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Final\r\nâ”‚  â”‚  â”‚  â”œâ”€ V2: Draft\r\nâ”‚\r\nâ”œâ”€ payload.md\r\nâ”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”œâ”€ ExecutionPayloadV1\r\nâ”‚  â”‚  â”œâ”€ ExecutionPayloadV2\r\nâ”‚  â”‚  â”œâ”€ PayloadStatusV1\r\nâ”‚  â”‚  â”œâ”€ WithdrawalV1\r\nâ”‚  â”œâ”€ Routines\r\nâ”‚  â”‚  â”œâ”€ Payload validation\r\nâ”‚  â”‚  â”œâ”€ Sync\r\nâ”‚  â”‚  â”œâ”€ Payload building\r\nâ”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”œâ”€ newPayload\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Final\r\nâ”‚  â”‚  â”‚  â”œâ”€ V2: Draft\r\nâ”‚  â”‚  â”œâ”€ getPayload\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Final\r\nâ”‚  â”‚  â”‚  â”œâ”€ V2: Draft\r\nâ”‚\r\nâ”œâ”€ payload-body.md\r\nâ”‚  â”œâ”€ Structures\r\nâ”‚  â”‚  â”œâ”€ ExecutionPayloadBodyV1\r\nâ”‚  â”œâ”€ Methods\r\nâ”‚  â”‚  â”œâ”€ getPayloadBodiesByHash\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Final\r\nâ”‚  â”‚  â”œâ”€ getPayloadBodiesByRange\r\nâ”‚  â”‚  â”‚  â”œâ”€ V1: Optional\r\n```\r\n\r\ncc @lightclient",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1319853466/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326332551",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1326332551",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1326332551,
    "node_id": "IC_kwDOFoG9Gs5PDjqH",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-24T11:38:49Z",
    "updated_at": "2022-11-24T11:39:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "> New engine_getCaps method is proposed \r\n\r\nWhile it's not wrong to have a capabilities function, reality is such that users upgrade their systems independently of each other and/or run round-robins on multiple versions of the same API - hence, when consuming the API we rarely assume that such support stays stable.\r\n\r\nInstead, in the ideal case we would standardise:\r\n\r\n* an error code for when an API is missing (to cover \"old clients\" not yet supporting an API\") (ie [404](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404))\r\n* an error code for when an API has been removed permanently (ie [410](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410))\r\n\r\nClients then operate the following way:\r\n\r\n* the try the newest API - if this gives a 404, they fall back on an earlier version, while at the same time notifying the user that they likely need to upgrade the API _server_\r\n* if the earlier version gives 410, they can notify their users they need to upgrade their API _client_\r\n\r\nThis optmistic strategy works well in practice, throughout the lifecycle of a feature: during testnets and development, it uses the latest version available without making any assumptions about support in the EL - then, when the feature is \"released\", it takes advantage of the new version where possible (without any messy assumptions about fork activation epochs etc) and gracefully falls back - finally, once the deprecation period for the old version has passed, old consumers can degrade gracefully as well (by showing an appropriate error).\r\n\r\nThis strategy also implies that when we add new API:\r\n\r\n*  the new API should  ideally cover the \"previous\" version (ie V-1 but not necessarily V-2)\r\n* ditto implementations should provide both API for a few versions\r\n\r\nIt is unlikely we would use a getCapabilities function with the above in place because that only introduces an extra call / complexity that still has to be handled at the per-call level - in other words: capabilities introduce an additional way interacting with the EL can fail but not much benefit, because the same information also has to be dealt with on a per-call basis. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326332551/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326474709",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1326474709",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1326474709,
    "node_id": "IC_kwDOFoG9Gs5PEGXV",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-24T13:44:39Z",
    "updated_at": "2022-11-24T13:44:39Z",
    "author_association": "MEMBER",
    "body": "> run round-robins on multiple versions of the same API\r\n\r\nI am not sure I understand this in the context of Engine API. If CL drives multiple ELs (not sure that this is what you meant by running round-robins) then there should be a multiplexer propagating calls to all of them, if Engine API versions of those ELs are different it can be an issue with whatever approach we take.\r\n\r\n> an error code for when an API is missing (to cover \"old clients\" not yet supporting an API\") (ie [404](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404))\r\n\r\nWe already have such error: [`-32601: Method not found`](https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#errors).\r\n\r\n> if the earlier version gives 410, they can notify their users they need to upgrade their API client\r\n\r\nConsidering we agree that V-1 stays for quite long period of time, the case when 410 would be hit is pretty rare. I can imagine this happening when we're deprecating `exchangeTransitionConfiguration` as this method is going to be removed entirely. Based on 404 only CL may surface a complain to a user that it doesn't see a required Engine API method and either CL or EL should be upgraded. Supporting such status implies EL remembers all deprecated methods which doesn't seem to be worth it.\r\n\r\n> This optmistic strategy works well in practice\r\n\r\nCL client will fallback to V-1 every method call until EL is upgraded, this is suboptimal. There can be more fancy logic when CL tries V+1 every Nth calls and if succeeded starts using the new version onwards. While `getCapabilities` allows for the following strategy:\r\n* CL knows the latest version of each method it is compatible with\r\n* CL calls `getCapabilities` every N minutes in parallel to the main communication flow, and if newer version of existing method or a new method is found, CL starts using it from now and onwards. This is why backwards compatibility at least up to V-1 is important.\r\n* This strategy may also utilise 404 to stop calling deprecated method if it is expected to disappear\r\n\r\nIMO, both strategies may co-exist, if no CL team will use `getCapabilities` then we can avoid specifying and implementing it. Standardising 410 doesn't sound like a good idea to me because it requires a list of old methods kept by EL client software\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326474709/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326484180",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1326484180",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1326484180,
    "node_id": "IC_kwDOFoG9Gs5PEIrU",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-24T13:53:37Z",
    "updated_at": "2022-11-24T13:53:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "> CL client will fallback to V-1 every method call until EL is upgraded, this is suboptimal. \r\n\r\nIt's suboptimal but also temporary and cheap - further, it's those that  haven't upgraded that pay the cost, which is appropriate: once everyone has upgraded (as happens eventually), the cost goes back to 0.\r\n\r\n> There can be more fancy logic\r\n\r\nThis fancy logic is surface area for bugs _and_ breaks redundant round-robin setups - it's easier to not make this assumption thanks to how cheap it is to make a call, and if that fails, make another (ie this is really simple and cheap: you maintain a connection then try one after the other) - it's also foolproof in that the consumer doesn't have to maintain state beyond the \"logical\" request. Capabilities calls make simple scenarios more simple and optimal, but make more advanced scenarios harder or impossible. \r\n\r\n> IMO, both strategies may co-exist\r\n\r\nTrue, it's not like it disturbs anyone, except those that have to implement the server and keep it up to date ;)\r\n\r\n> Standardising 410 doesn't sound like a good idea to me because it requires a list of old methods kept by EL client software\r\n\r\nit's not required - it's more of a quality of implementation matter where during the transition period, we often get users that haven't upgraded part of their setup - 410 (or a reasonable `-xxxxx` code, whichever fits the current design better) give a way to give them a better error message - servers don't have to support this, but it can be used to good effect.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326484180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326504698",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1326504698",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1326504698,
    "node_id": "IC_kwDOFoG9Gs5PENr6",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-24T14:10:22Z",
    "updated_at": "2022-11-24T14:10:22Z",
    "author_association": "MEMBER",
    "body": "> True, it's not like it disturbs anyone, except those that have to implement the server and keep it up to date ;)\r\n\r\nOnce `getCapabilities` is implemented there is no need to update the list, the list should be self-adjusting. I feel like implementation cost of this method is really low",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1326504698/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1328941794",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1328941794",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1328941794,
    "node_id": "IC_kwDOFoG9Gs5PNgri",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-28T11:47:18Z",
    "updated_at": "2022-11-28T11:47:18Z",
    "author_association": "MEMBER",
    "body": "@arnetheduck \r\n>  it's those that haven't upgraded that pay the cost\r\n\r\nThis is not always true. If https://github.com/ethereum/execution-apis/pull/218 makes into the spec, CL clients will have to use fallback approach or alternatively cache Engine API server configuration.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1328941794/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1329174757",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1329174757",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1329174757,
    "node_id": "IC_kwDOFoG9Gs5POZjl",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-28T14:09:47Z",
    "updated_at": "2022-11-28T14:09:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This is not always true.\r\n\r\nWhile this is true in theory, I believe that if all CL:s start using that request (or any other similar \"semi-optional\" API), I'm pretty sure no EL will be want to be left behind as *the* slow API implementation and we'll see conformity within a few versions - fallback merely gives us a way to cover the interim period. \r\n\r\nThe EL-CL api is special in that there are only so many clients implementing it - it's not a generic thing where we expect a lot of \"partial\" implementations, so I'm inclined to believe that we'll mostly be using \"full\" implementations.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1329174757/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1330872474",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1330872474",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1330872474,
    "node_id": "IC_kwDOFoG9Gs5PU4Ca",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-11-29T16:00:25Z",
    "updated_at": "2022-11-29T16:03:17Z",
    "author_association": "MEMBER",
    "body": "I'm ðŸ‘ on the functional structure of the spec. Minor nit: might be better to combine `payload-body.md` into `payload.md`. I don't feel strongly about it though.\r\n\r\nAnd re: `getCaps` -- I'm mostly indifferent. I will wait to see what CL teams prefer. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1330872474/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1342793099",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1342793099",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1342793099,
    "node_id": "IC_kwDOFoG9Gs5QCWWL",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-08T14:08:36Z",
    "updated_at": "2022-12-08T14:10:08Z",
    "author_association": "MEMBER",
    "body": "Will just toss in that I like fork-diff format. It works well for CL specs. This path, imo, is optimized for *spec writers* and *sophisticated readers* (e.g. client teams). \"What do I need to know/change in relation to what I already know\".\r\n\r\nGiven this is not a user facing API, I bias toward optimizing for hte sophisticated user at the potential cost of slowing of onboarding of new users of the api",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1342793099/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1344136561",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1344136561",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1344136561,
    "node_id": "IC_kwDOFoG9Gs5QHeVx",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-09T10:37:31Z",
    "updated_at": "2022-12-09T10:41:21Z",
    "author_association": "MEMBER",
    "body": "> I bias toward optimizing for hte sophisticated user at the potential cost of slowing of onboarding of new users of the api\r\n\r\nOpenRPC schema is supposed to contain a reference of all stable and not yet deprecated Engine API methods, i.e. methods that EL clients must support. Therefore, it should alleviate the pain of non-experienced reader and reduce the entrance barrier.\r\n\r\nConsideration of recent arguments makes me in favour of by-fork decomposition.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1344136561/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1376337081",
    "html_url": "https://github.com/ethereum/execution-apis/issues/321#issuecomment-1376337081",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/321",
    "id": 1376337081,
    "node_id": "IC_kwDOFoG9Gs5SCTy5",
    "user": {
      "login": "ethDreamer",
      "id": 37123614,
      "node_id": "MDQ6VXNlcjM3MTIzNjE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/37123614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ethDreamer",
      "html_url": "https://github.com/ethDreamer",
      "followers_url": "https://api.github.com/users/ethDreamer/followers",
      "following_url": "https://api.github.com/users/ethDreamer/following{/other_user}",
      "gists_url": "https://api.github.com/users/ethDreamer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ethDreamer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ethDreamer/subscriptions",
      "organizations_url": "https://api.github.com/users/ethDreamer/orgs",
      "repos_url": "https://api.github.com/users/ethDreamer/repos",
      "events_url": "https://api.github.com/users/ethDreamer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ethDreamer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-09T21:23:27Z",
    "updated_at": "2023-01-09T21:23:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "Strongly support `engine_getCapabilities` (provided it's called `engine_getCapabilities` and not `engine_getCaps` since none of the other method names are truncated).\r\n\r\nIn fact I've already stubbed out this functionality in lighthouse based on earlier talks that a function of this nature would be supported. Lighthouse essentially caches a data structure that enumerates the methods that the execution engine supports. It's trivial to implement functionality that would refresh this data structure (with a call to `engine_getCapabilities`) periodically or if lighthouse has detected the execution engine has gone offline (to update to a newer version for example).\r\n\r\n> reality is such that users upgrade their systems independently of each other and/or run round-robins on multiple versions of the same API - hence, when consuming the API we rarely assume that such support stays stable.\r\n\r\nlighthouse docs explicitly state that we do not support `1:many` or `many:1` configurations between `CL` and `EE`. You would certainly require a multiplexer to support this. And if you've already written a custom multiplexer then it should be trivial to handle parsing the response from `engine_getCapabilities` and returning the highest version method supported by all execution engines.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1376337081/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
