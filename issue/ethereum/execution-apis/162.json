{
  "url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
  "repository_url": "https://api.github.com/repos/ethereum/execution-apis",
  "labels_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162/comments",
  "events_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162/events",
  "html_url": "https://github.com/ethereum/execution-apis/issues/162",
  "id": 1103365105,
  "node_id": "I_kwDOFoG9Gs5BxAPx",
  "number": 162,
  "title": "Engine API: proposal for authentication",
  "user": {
    "login": "holiman",
    "id": 142290,
    "node_id": "MDQ6VXNlcjE0MjI5MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/holiman",
    "html_url": "https://github.com/holiman",
    "followers_url": "https://api.github.com/users/holiman/followers",
    "following_url": "https://api.github.com/users/holiman/following{/other_user}",
    "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
    "organizations_url": "https://api.github.com/users/holiman/orgs",
    "repos_url": "https://api.github.com/users/holiman/repos",
    "events_url": "https://api.github.com/users/holiman/events{/privacy}",
    "received_events_url": "https://api.github.com/users/holiman/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 33,
  "created_at": "2022-01-14T09:46:00Z",
  "updated_at": "2022-03-07T07:38:26Z",
  "closed_at": "2022-03-07T07:38:26Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This is an RFC for authenticated JSON rpc API\r\n\r\n\r\n\r\n# Authentication\r\n\r\nThe `engine` JSON-RPC interface, exposed by EL and consumed by CL, needs to be authenticated. The authentication scheme chosen for thus purpose is [JWT](https://jwt.io/). \r\n\r\nThe type of attacks that this authentication scheme attempts to protect against are the following: \r\n\r\n- RPC port exposed towards the internet, allowing attackers to exchange messages with EL engine api. \r\n- RPC port exposed towards the browser, allowing malicious webpages to submit messages to the EL engine api. \r\n\r\nThe authentication scheme is _not_ designed to \r\n\r\n- Prevent attackers with capability to read ('sniff') network traffic from reading the traffic, \r\n- Prevent attackers with capability to read ('sniff') network traffic from performing replay-attacks of earlier messages. \r\n\r\nAuthentication is performed as follows: \r\n\r\n- For `HTTP` dialogue, each `jsonrpc` request is individually authenticated by supplying `JWT` token in the HTTP header. \r\n- For a WebSocket dialogue, only the initial handshake is authenticated, after which the message dialogue proceeds without further use of JWT.\r\n- For `inproc`, a.k.a raw ipc communication, no authentication is required, under the assumption that a process able to access `ipc` channels for the process, which usually means local file access, is already sufficiently permissioned that further authentication requirements do not add security. \r\n\r\n\r\n## JWT specifications\r\n\r\n- The EL **MUST** support the at least the following `alg` `HMAC + SHA256` (`HS256`)\r\n- The EL **MUST** reject the `alg` `none`. \r\n\r\nThe HMAC algorithm means that symmetric encryption is used, thus several CL's will be able to use the same key, and, from an authentication perspective be able to impersonate each other. From a deployment perspective, it means that an EL does not need to be provisioned with individual keys for each caller. \r\n\r\n## Key distribution\r\n\r\nThe `EL` and `CL` clients **MUST** accept a cli/config parameter: `jwt-secret`, a `256` bit key, to be used for verifying/generating jwt tokens. \r\nIf such a parameter is not given, the client **SHOULD** generate such a token, valid for the duration of the execution, and show the token in the output, which the user can then use to provision the counterpart client with.\r\n",
  "closed_by": {
    "login": "holiman",
    "id": 142290,
    "node_id": "MDQ6VXNlcjE0MjI5MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/holiman",
    "html_url": "https://github.com/holiman",
    "followers_url": "https://api.github.com/users/holiman/followers",
    "following_url": "https://api.github.com/users/holiman/following{/other_user}",
    "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
    "organizations_url": "https://api.github.com/users/holiman/orgs",
    "repos_url": "https://api.github.com/users/holiman/repos",
    "events_url": "https://api.github.com/users/holiman/events{/privacy}",
    "received_events_url": "https://api.github.com/users/holiman/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/162/reactions",
    "total_count": 4,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 1
  },
  "timeline_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1013021264",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1013021264",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1013021264,
    "node_id": "IC_kwDOFoG9Gs48YXpQ",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-14T11:03:17Z",
    "updated_at": "2022-01-14T11:03:17Z",
    "author_association": "MEMBER",
    "body": "Would you mind to provide more details and examples of exact payloads during the handshake for the WebSocket case? It seems like we need to add a new error code that would signal the caller that it's not authenticated.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1013021264/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1013080868",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1013080868",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1013080868,
    "node_id": "IC_kwDOFoG9Gs48YmMk",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-14T12:34:46Z",
    "updated_at": "2022-01-14T12:34:46Z",
    "author_association": "MEMBER",
    "body": "The websocket handshake starts with the client performing a websocket upgrade request. This must be a regular http `GET` request, and the actual \r\nparameters for the WS-handshake is carried in the http headers. \r\n\r\nExample: \r\n\r\n```\r\nGET / HTTP/1.1\r\nHost: localhost:1337\r\nUser-Agent: Mozilla/5.0..\r\nOrigin: ..\r\nConnection: keep-alive, Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Protocol: echo-protocol\r\nSec-WebSocket-Extensions: permessage-deflate\r\nSec-WebSocket-Key: VOPn9g/2WnfiJbxBw4aZkQ==\r\nSec-Fetch-Dest: websocket\r\nSec-Fetch-Mode: websocket\r\nSec-Fetch-Site: cross-site\r\n```\r\n\r\nThe response, if accepted, is \r\n```\r\nHTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n...\r\n```\r\nAfter that, the connection is kept open, and is now full duplex. \r\nSince the handshake is a regular HTTP request, it is easy to integrate with any previously existing HTTP authentication scheme, in our case: add jwt authentication to the request. One thing I'm not sure about, though, is exactly what to sign. I guess nothing (empty payload), since the initial `GET` request does not have a `json` payload. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1013080868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014375509",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1014375509",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1014375509,
    "node_id": "IC_kwDOFoG9Gs48diRV",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-17T10:38:18Z",
    "updated_at": "2022-01-17T10:38:18Z",
    "author_association": "MEMBER",
    "body": "After having investigated/tested this a bit, I've come across a couple of problems.\r\n\r\nFrom https://testdriven.io/courses/taxi-react/websockets-part-one/#H-3-authenticating-socket-connections : \r\n\r\n> Anything that can be sent with an HTTP request can be sent with the handshake -- i.e., headers and cookies, query string parameters, and request bodies. Unfortunately, the JavaScript WebSocket API does not support custom headers. That means we need to find a different way to authenticate our WebSocket connection than an authorization header.\r\n\r\n- https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\r\n\r\n\r\nSo. the `Authorization: Bearer <token>` technically does work, but only with custom clients and/or curl examples, not with browser communication. I'm not sure if this is a blocker -- do we want to expose the `engine` api for browser interaction?\r\n\r\nThe suggested solution is to pass the token in url query parameters. This, however, means that the token will/can be exposed in proxy caches and/or server logs -- which further means that we can definitely not use the empty payload for initial connect, but rather something based on a nonce or a timestap. \r\n\r\nI'm not sure what the best solution is here. \r\n\r\ncc @fjl\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014375509/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014400171",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1014400171",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1014400171,
    "node_id": "IC_kwDOFoG9Gs48doSr",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-17T11:08:18Z",
    "updated_at": "2022-01-17T11:08:18Z",
    "author_association": "MEMBER",
    "body": "> I'm not sure if this is a blocker -- do we want to expose the engine api for browser interaction?\r\n\r\nEngine API is planned to be used by CL client to interact with EL one. I don't see the case when browser plays a role of CL client",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014400171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014814305",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1014814305",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1014814305,
    "node_id": "IC_kwDOFoG9Gs48fNZh",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-17T18:53:23Z",
    "updated_at": "2022-01-17T18:54:26Z",
    "author_association": "MEMBER",
    "body": "Looks good!\r\n\r\nRegarding \"key distribution\" -- is the common flow to start one side (either EL or CL), grab the key, then start the other side with that key?\r\n\r\nAnd advanced usage is to generate in some independent flow and provide the key on both sides?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014814305/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014815486",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1014815486",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1014815486,
    "node_id": "IC_kwDOFoG9Gs48fNr-",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-17T18:55:42Z",
    "updated_at": "2022-01-17T18:55:42Z",
    "author_association": "MEMBER",
    "body": "> Engine API is planned to be used by CL client to interact with EL one. I don't see the case when browser plays a role of CL client\r\n\r\nThere is a desire to see CL light clients in the browser but (1) I'm not sure if/when this will happen and (2) it's unclear if it would drive an external EL client in such a case",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014815486/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014903398",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1014903398",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1014903398,
    "node_id": "IC_kwDOFoG9Gs48fjJm",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-17T21:37:17Z",
    "updated_at": "2022-01-17T21:37:17Z",
    "author_association": "MEMBER",
    "body": "> Regarding \"key distribution\" -- is the common flow to start one side (either EL or CL), grab the key, then start the other side with that key?\r\n>And advanced usage is to generate in some independent flow and provide the key on both sides?\r\n\r\nThat was my idea, yes. \r\n\r\nThe main point I'm not happy about right now is the empty payload at ws connect.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1014903398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1015394106",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1015394106",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1015394106,
    "node_id": "IC_kwDOFoG9Gs48ha86",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-18T13:06:36Z",
    "updated_at": "2022-01-18T13:06:36Z",
    "author_association": "MEMBER",
    "body": "Perhaps it would be good to also include the `iat` claim in the JWT: https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6 . This means that the websocket connect token will not be identical each time, and the EL can verify the freshness of each token, and only allow access if the issuance time is within a certain time window, maybe 5 seconds in either direction.  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1015394106/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1017637119",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1017637119",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1017637119,
    "node_id": "IC_kwDOFoG9Gs48p-j_",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-20T15:41:10Z",
    "updated_at": "2022-01-20T15:41:10Z",
    "author_association": "MEMBER",
    "body": "> Perhaps it would be good to also include the iat claim in the JWT\r\n\r\nThis seems like a reasonable approach to me",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1017637119/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018553848",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1018553848",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1018553848,
    "node_id": "IC_kwDOFoG9Gs48teX4",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-21T14:30:49Z",
    "updated_at": "2022-01-21T14:30:49Z",
    "author_association": "MEMBER",
    "body": "Is there any limits to what is a valid `jwt-secret`, or is any 256-bit value acceptable?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018553848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018559975",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1018559975",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1018559975,
    "node_id": "IC_kwDOFoG9Gs48tf3n",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-21T14:37:01Z",
    "updated_at": "2022-01-21T14:37:01Z",
    "author_association": "MEMBER",
    "body": "Is there any expectation to include `exp` (expiration) on the tokens?  Feels like we should, and it would be good to have some \"general advice\" for what a reasonable expiration time is.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018559975/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018566407",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1018566407",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1018566407,
    "node_id": "IC_kwDOFoG9Gs48thcH",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-21T14:41:44Z",
    "updated_at": "2022-01-21T14:41:44Z",
    "author_association": "MEMBER",
    "body": "> Is there any limits to what is a valid jwt-secret, or is any 256-bit value acceptable?\r\n\r\nWell, we can prohibit 0x00, but not sure what else we can do. \r\n\r\n> Is there any expectation to include exp (expiration) on the tokens \r\n\r\nThe idea with `iat` would be to make it so that there's a 5 (?) - second window where it is valid. So it would implicitly carry the `exp`. Or rather, the expiry would be enforced on the EL, not settable by the CL. \r\n\r\nThe canonical usecase for `exp` is when a federated server issues \"this is John, he's an admin, token is valid for one hour\". It's not quite our usecase",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1018566407/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1019342764",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1019342764",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1019342764,
    "node_id": "IC_kwDOFoG9Gs48we-s",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-22T19:22:09Z",
    "updated_at": "2022-01-22T19:22:15Z",
    "author_association": "MEMBER",
    "body": "Is there anything else here to discuss?\r\n\r\nWe're looking to get a release out early this week to keep engineering moving. Shall we write up a PR?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1019342764/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1019379608",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1019379608",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1019379608,
    "node_id": "IC_kwDOFoG9Gs48wn-Y",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-22T23:58:21Z",
    "updated_at": "2022-01-22T23:58:21Z",
    "author_association": "MEMBER",
    "body": "Yup. I can get started tomorrow at the earliest, if anyone wants to get it going before that please go aheadÂ ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1019379608/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1021335039",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1021335039",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1021335039,
    "node_id": "IC_kwDOFoG9Gs484FX_",
    "user": {
      "login": "jflo",
      "id": 345937,
      "node_id": "MDQ6VXNlcjM0NTkzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/345937?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jflo",
      "html_url": "https://github.com/jflo",
      "followers_url": "https://api.github.com/users/jflo/followers",
      "following_url": "https://api.github.com/users/jflo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jflo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jflo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jflo/subscriptions",
      "organizations_url": "https://api.github.com/users/jflo/orgs",
      "repos_url": "https://api.github.com/users/jflo/repos",
      "events_url": "https://api.github.com/users/jflo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jflo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-25T15:55:37Z",
    "updated_at": "2022-01-25T19:04:01Z",
    "author_association": "NONE",
    "body": "is there a conversation happening about different key sharing formats between CL and EL for the JWT signing key? For instance, Besu could trivially support loading it from a java keystore on the filesystem, but thats really only friendly to Teku. Is there a more agnostic format we want to support across combinations?\r\n\r\nBesu does this today https://besu.hyperledger.org/en/stable/HowTo/Interact/APIs/Authentication/#jwt-public-key-authentication",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1021335039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1053475844",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1053475844",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1053475844,
    "node_id": "IC_kwDOFoG9Gs4-ysQE",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-27T10:34:03Z",
    "updated_at": "2022-02-27T10:34:03Z",
    "author_association": "NONE",
    "body": "I have concerns about JWT, it seems like a complex protocol with many options and so pitfalls.\r\n\r\nFor instance:\r\n- https://news.ycombinator.com/item?id=14292223\r\n- https://news.ycombinator.com/item?id=14291059\r\n- https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid\r\n- https://redis.com/blog/json-web-tokens-jwt-are-dangerous-for-user-sessions/\r\n- https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md\r\n- http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/\r\n- http://cryto.net/%7Ejoepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/\r\n- https://latacora.micro.blog/2018/06/12/a-childs-garden.html\r\n\r\nExcerpts:\r\n\r\n> So, as someone who does some work in crypto engineering, arguments about JWT being problematic only if implementations are \"bungled\" or developers are \"incompetent\" are sort of an obvious \"tell\" that the people behind those arguments aren't really crypto people. In crypto, this debate is over.\r\n>\r\n>I know a lot of crypto people who do not like JWT. I don't know one who does. Here are some general JWT concerns:\r\n>\r\n>* It's kitchen-sink complicated and designed without a single clear use case. The track record of cryptosystems with this property is very poor. Resilient cryptosystems tend to be simple and optimized for a specific use case.\r\n>\r\n>* It's designed by a committee and, as far as anyone I know can tell, that committee doesn't include any serious cryptographers. I joked about this on Twitter after the last JWT disaster, saying that JWT's support for static-ephemeral P-curve ECDH was the cryptographic engineering equivalent of a \"kick me\" sign on the standard. You could look at JWT, see that it supported both RSA and P-curve ECDH, and immediately conclude that crypto experts hadn't had a guiding hand in the standard.\r\n>\r\n>* Flaws in crypto protocols aren't exclusive to, but tend to occur mostly in, the joinery of the protocol. So crypto protocol designers are moving away from algorithm and \"cipher suite\" negotiation towards other mechanisms. Trevor Perrin's Noise framework is a great example: rather than negotiating, it defines a family of protocols and applications can adopt one or the other without committing themselves to supporting different ones dynamically. Not only does JWT do a form of negotiation, but it actually allows implementations to negotiate NO cryptography. That's a disqualifying own-goal.\r\n>\r\n>* JWT's defaults are incoherent. For instance: non-replayability, one of the most basic questions to answer about a cryptographic token, is optional. Someone downthread made a weird comparison between JWT and Nacl (weird because Nacl is a library of primitives, not a protocol) based on forward-security. But for a token, replayability is a much more urgent concern.\r\n>\r\n>* The protocol mixes metadata and application data in two different bag-of-attributes structures and generally does its best to maximize all the concerns you'd have doing cryptography with a format as malleable as JSON. Seemingly the only reason it does that is because it's \"layered\" on JOSE, leaving the impression that making a pretty lego diagram is more important to its designers than coming up with a simple, secure standard.\r\n>\r\n>* It's 2017 and the standard still includes X.509, via JWK, which also includes indirected key lookups.\r\n>\r\n>* The standard supports, and some implementations even default to, compressed plaintext. It feels like 2012 never happened for this project.\r\n>\r\n>For almost every use I've seen in the real world, JWT is drastic overkill; often it's just an gussied-up means of expressing a trivial bearer token, the kind that could be expressed securely with virtually no risk of implementation flaws simply by hexifying 20 bytes of urandom. For the rare instances that actually benefit from public key cryptography, JWT makes a hard task even harder. I don't believe anyone is ever better off using JWT. Avoid it. \r\n\r\nAnd another one\r\n\r\n> The problems, for people who don't want to read articles from comment links, are:\r\n>\r\n>  - JSON Web Signing\r\n>    - alg headers\r\n>    - \"This Header Parameter MUST be present and MUST be understood and processed by implementations.\"\r\n>  - JSON Web Encryption\r\n>    - RSA with PKCS1v1.5 padding (power word: Bleichenbacher 1998)\r\n>    - ECDH over NIST curves (and, in practice, invalid-curve attacks)\r\n>    - AES-GCM included in a list of asymmetric algorithm choices, for added confusion\r\n>    - AES-GCM for shared-key encryption, without guidance over nonces or key rotation\r\n>\r\n>A better solution from JOSE would only give developers two options:\r\n>\r\n>  - Version (v1, v2, v3, etc. which hard-coded the algorithm choices)\r\n>  - Operation\r\n>    - enc -> crypto_secretbox()\r\n>    - auth -> crypto_auth()\r\n>    - pub-enc -> crypto_box_seal()\r\n>    - pub-sign -> crypto_sign_detached()\r\n\r\n![image](https://user-images.githubusercontent.com/22738317/155878647-7ea2cb58-81c1-4b7b-a5d6-722016d79047.png)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1053475844/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1053907816",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1053907816",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1053907816,
    "node_id": "IC_kwDOFoG9Gs4-0Vto",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T05:35:26Z",
    "updated_at": "2022-02-28T05:35:26Z",
    "author_association": "MEMBER",
    "body": "@mratsim Do you have a recommendation for a good alternative solution?  One of the things I like about JWT is there is a library for every language (often multiple libraries).  While I agree with some of the arguments made in the links you provided about JWTs being overkill (especially since we aren't leveraging capabilities), I would like to see a concrete proposal for an alternative that is either so trivially simple that a library isn't necessary, or has a large selection of libraries that could be used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1053907816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054008203",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054008203",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054008203,
    "node_id": "IC_kwDOFoG9Gs4-0uOL",
    "user": {
      "login": "tersec",
      "id": 11422416,
      "node_id": "MDQ6VXNlcjExNDIyNDE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/11422416?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tersec",
      "html_url": "https://github.com/tersec",
      "followers_url": "https://api.github.com/users/tersec/followers",
      "following_url": "https://api.github.com/users/tersec/following{/other_user}",
      "gists_url": "https://api.github.com/users/tersec/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tersec/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tersec/subscriptions",
      "organizations_url": "https://api.github.com/users/tersec/orgs",
      "repos_url": "https://api.github.com/users/tersec/repos",
      "events_url": "https://api.github.com/users/tersec/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tersec/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T08:28:09Z",
    "updated_at": "2022-02-28T08:28:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "TOTP?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054008203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054025616",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054025616",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054025616,
    "node_id": "IC_kwDOFoG9Gs4-0yeQ",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T08:52:08Z",
    "updated_at": "2022-02-28T08:52:08Z",
    "author_association": "MEMBER",
    "body": "AFAICS, this articles are explaining why JWT is bad for user authentication and in-browser use cases. I haven't found any issues in application to our particular use case, please, correct me if it's been overlooked. Our use case seems very simple and I don't think that if we were designing auth by ourselves without relying on already existing schemas we wouldn't end up with a pretty similar scheme that we have with JWT utilization.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054025616/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054034434",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054034434",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054034434,
    "node_id": "IC_kwDOFoG9Gs4-00oC",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:03:24Z",
    "updated_at": "2022-02-28T09:03:24Z",
    "author_association": "MEMBER",
    "body": "The argument is basically that JWT is extremely unnecessary for our needs.  We literally just need a preshared key and a signature over the payload (or similar).  JWT provides things like capabilities, permissions, etc., All features we aren't going to use.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054034434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054035919",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054035919",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054035919,
    "node_id": "IC_kwDOFoG9Gs4-00_P",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:05:05Z",
    "updated_at": "2022-02-28T09:05:05Z",
    "author_association": "MEMBER",
    "body": "I think a very reasonable question to ask would be, \"what features exactly do we need from the authentication?\". I haven't seen that listed anywhere, is it?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054035919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054041190",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054041190",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054041190,
    "node_id": "IC_kwDOFoG9Gs4-02Rm",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:10:29Z",
    "updated_at": "2022-02-28T09:10:29Z",
    "author_association": "NONE",
    "body": "@mkalinin \r\n> AFAICS, this articles are explaining why JWT is bad for user authentication and in-browser use cases. I haven't found any issues in application to our particular use case, please, correct me if it's been overlooked. Our use case seems very simple and I don't think that if we were designing auth by ourselves without relying on already existing schemas we wouldn't end up with a pretty similar scheme that we have with JWT utilization.\r\n\r\nThat's exactly why I think JWT is overkill and exposing us to many implementation bugs in third-party libraries and/or supply chain attacks while our use-case and threat model is very simple.\r\n\r\n@MicahZoltu \r\n> Do you have a recommendation for a good alternative solution? One of the things I like about JWT is there is a library for every language (often multiple libraries). While I agree with some of the arguments made in the links you provided about JWTs being overkill (especially since we aren't leveraging capabilities), I would like to see a concrete proposal for an alternative that is either so trivially simple that a library isn't necessary, or has a large selection of libraries that could be used.\r\n\r\nI've been looking into very simple schemes that would be misuse-resistant and came across Branca: https://github.com/tuupola/branca-spec\r\n\r\nIt only needs XChaCha20-Poly1305, has test vectors, has 3 libraries in Go, 2 in Java, 1 Javascript, 1 Python and 1 Rust among other languages.\r\n\r\nThe Python impl by the spec for reference is just 50 lines of code, assuming XChaCha20-Poly1305 provided by a crypto lib.\r\n\r\nTagging @asanso since he is mentioned by name in JWT best practices at https://tools.ietf.org/id/draft-ietf-oauth-jwt-bcp-02.html#insecure-use-of-elliptic-curve-encryption\r\n\r\nhttps://github.com/tuupola/pybranca/blob/79366150353727c0410e111eef7dbaf2ed97ec8e/branca.py\r\n\r\n```python\r\n\"\"\"\r\nBranca\r\nAuthenticated and encrypted API tokens using modern crypto.\r\n\"\"\"\r\n\r\nimport base62\r\nimport calendar\r\nimport ctypes\r\nimport struct\r\nfrom binascii import unhexlify\r\nfrom datetime import datetime\r\nfrom xchacha20poly1305 import generate_nonce\r\nfrom xchacha20poly1305 import crypto_aead_xchacha20poly1305_ietf_encrypt\r\nfrom xchacha20poly1305 import crypto_aead_xchacha20poly1305_ietf_decrypt\r\nfrom xchacha20poly1305 import CRYPTO_AEAD_XHCACHA20POLY1305_IETF_NPUBBYTES\r\nfrom xchacha20poly1305 import CRYPTO_AEAD_XHCACHA20POLY1305_IETF_KEYBYTES\r\n\r\nclass Branca:\r\n    VERSION = 0xBA\r\n\r\n    def __init__(self, key):\r\n        if isinstance(key, bytes):\r\n            self._key = key\r\n        else:\r\n            self._key = unhexlify(key)\r\n\r\n        if len(self._key) is not CRYPTO_AEAD_XHCACHA20POLY1305_IETF_KEYBYTES:\r\n            raise ValueError(\r\n                \"Secrect key should be {} bytes long\".format(\r\n                    CRYPTO_AEAD_XHCACHA20POLY1305_IETF_KEYBYTES\r\n                )\r\n            )\r\n\r\n        self._nonce = None # Used only for unit testing!\r\n\r\n    def encode(self, payload, timestamp=None):\r\n\r\n        if not isinstance(payload, bytes):\r\n            payload = payload.encode()\r\n\r\n        if timestamp is None:\r\n            timestamp = calendar.timegm(datetime.utcnow().timetuple())\r\n\r\n        version = struct.pack(\"B\", self.VERSION)\r\n        time = struct.pack(\">L\", timestamp)\r\n\r\n        if self._nonce is None:\r\n            nonce = generate_nonce()\r\n        else:\r\n            nonce = self._nonce\r\n\r\n        header = version + time + nonce\r\n        ciphertext = crypto_aead_xchacha20poly1305_ietf_encrypt(payload, header, nonce, self._key)\r\n\r\n        return base62.encodebytes(header + ciphertext)\r\n\r\n    def decode(self, token, ttl=None):\r\n        token = base62.decodebytes(token)\r\n        header = token[0:CRYPTO_AEAD_XHCACHA20POLY1305_IETF_NPUBBYTES + 5]\r\n        nonce = header[5:CRYPTO_AEAD_XHCACHA20POLY1305_IETF_NPUBBYTES + 5]\r\n        ciphertext = token[CRYPTO_AEAD_XHCACHA20POLY1305_IETF_NPUBBYTES + 5:]\r\n\r\n        version, time = struct.unpack(\">BL\", bytes(header[0:5]))\r\n\r\n        # Implementation should accept only current version.\r\n        if version is not self.VERSION:\r\n            raise RuntimeError(\"Invalid token version\")\r\n\r\n        payload = crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, header, nonce, self._key)\r\n\r\n        if ttl is not None:\r\n            future = time + ttl\r\n            timestamp = calendar.timegm(datetime.utcnow().timetuple())\r\n            if future < timestamp:\r\n                raise RuntimeError(\"Token is expired\")\r\n\r\n        return payload\r\n\r\n    def timestamp(self, token):\r\n        token = base62.decodebytes(token)\r\n        version, time = struct.unpack(\">BL\", bytes(token[0:5]))\r\n\r\n        return time\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054041190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054056948",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054056948",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054056948,
    "node_id": "IC_kwDOFoG9Gs4-06H0",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:27:15Z",
    "updated_at": "2022-02-28T09:27:15Z",
    "author_association": "NONE",
    "body": "Note compared to the desired properties, Branca is also overkill in the following way:\r\n- Payload is encrypted. Depending on the volume of data between CL and EL this might be too much latency? But it might opens up new use-cases when CL and EL are on dedicated VM/machines and XChaCha20-Poly1305 is likely to become heavily optimized in the future as it's easier to make it fast compared to AES (which requires hardware acceleration to reach GB throughput https://www.bearssl.org/speed.html).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054056948/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054057982",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054057982",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054057982,
    "node_id": "IC_kwDOFoG9Gs4-06X-",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:28:24Z",
    "updated_at": "2022-02-28T09:28:24Z",
    "author_association": "MEMBER",
    "body": "> That's exactly why I think JWT is overkill and exposing us to many implementation bugs in third-party libraries and/or supply chain attacks while our use-case and threat model is very simple.\r\n\r\nVulnerabilities in a 3rd party libraries is a good point. The spec is currently based on `HMAC + SHA256`, vulnerabilities in JWT libraries are related to EC based algorithms. I am not against using custom auth scheme, using any other 3rd party solution is prone to vulnerabilities, though, may be less prone if the solution is tiny. Just want to be sure that JWT is not an option.\r\n\r\n> what features exactly do we need from the authentication?\r\n\r\nCurrently it is 1) be able to prove that CL knows a secret 2) basic replay protection for auth tokens (via \"iat\") 3) optional: versioning. I believe we don't need anything on top of that. cc @holiman ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054057982/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054062686",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054062686",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054062686,
    "node_id": "IC_kwDOFoG9Gs4-07he",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T09:33:47Z",
    "updated_at": "2022-02-28T09:33:47Z",
    "author_association": "MEMBER",
    "body": "Btw, could we implement current auth scheme avoiding usage of 3rd party JWT libs? We have crypto libs and `HMAC + SHA256` is widely supported, we have JSON libs and Base64 codecs -- all these dependencies should already be used by client implementations.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054062686/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054097733",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054097733",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054097733,
    "node_id": "IC_kwDOFoG9Gs4-1EFF",
    "user": {
      "login": "asanso",
      "id": 494825,
      "node_id": "MDQ6VXNlcjQ5NDgyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asanso",
      "html_url": "https://github.com/asanso",
      "followers_url": "https://api.github.com/users/asanso/followers",
      "following_url": "https://api.github.com/users/asanso/following{/other_user}",
      "gists_url": "https://api.github.com/users/asanso/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asanso/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asanso/subscriptions",
      "organizations_url": "https://api.github.com/users/asanso/orgs",
      "repos_url": "https://api.github.com/users/asanso/repos",
      "events_url": "https://api.github.com/users/asanso/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asanso/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T10:14:17Z",
    "updated_at": "2022-02-28T10:14:17Z",
    "author_association": "MEMBER",
    "body": ">Tagging @asanso since he is mentioned by name in JWT best practices at https://tools.ietf.org/id/draft-ietf-oauth-jwt-bcp-02.html#insecure-use-of-elliptic-curve-encryption\r\n\r\nSince I have been mentioned by @mratsim here my 2 cents.  I actually already gave a look to this proposal (thanks @djrtwo  for pointing this out) and while I share some of the concerns about JWT as a whole (as  you can also see from some of my previous research) the subset used in this proposal seem to be immune to those vulnerabilities.\r\n\r\nSo it might really just a quick win to just use JWT (specifically HMAC + SHA256) for this use case rather than invent yet another solution. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054097733/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054148668",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054148668",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054148668,
    "node_id": "IC_kwDOFoG9Gs4-1Qg8",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T11:14:23Z",
    "updated_at": "2022-02-28T11:14:23Z",
    "author_association": "NONE",
    "body": "> Btw, could we implement current auth scheme avoiding usage of 3rd party JWT libs? We have crypto libs and `HMAC + SHA256` is widely supported, we have JSON libs and Base64 codecs -- all these dependencies should already be used by client implementations.\r\n\r\nI think this is reasonable, though for censorship resistance and also to enable more distributed use-cases in the future I do think adding encryption would be interesting (and leaving key negotiation out of scope).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054148668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054199968",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054199968",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054199968,
    "node_id": "IC_kwDOFoG9Gs4-1dCg",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T12:19:13Z",
    "updated_at": "2022-02-28T12:19:13Z",
    "author_association": "MEMBER",
    "body": "> I do think adding encryption would be interesting (and leaving key negotiation out of scope)\r\n\r\nWe have been discussing this and ended up with TLS as a solution for encrypting communication channel between CL and EL. In this case extra auth scheme becomes redundant.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054199968/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054279833",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054279833",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054279833,
    "node_id": "IC_kwDOFoG9Gs4-1wiZ",
    "user": {
      "login": "mratsim",
      "id": 22738317,
      "node_id": "MDQ6VXNlcjIyNzM4MzE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mratsim",
      "html_url": "https://github.com/mratsim",
      "followers_url": "https://api.github.com/users/mratsim/followers",
      "following_url": "https://api.github.com/users/mratsim/following{/other_user}",
      "gists_url": "https://api.github.com/users/mratsim/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mratsim/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
      "organizations_url": "https://api.github.com/users/mratsim/orgs",
      "repos_url": "https://api.github.com/users/mratsim/repos",
      "events_url": "https://api.github.com/users/mratsim/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mratsim/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T13:54:07Z",
    "updated_at": "2022-02-28T13:54:56Z",
    "author_association": "NONE",
    "body": "> > I do think adding encryption would be interesting (and leaving key negotiation out of scope)\r\n> \r\n> We have been discussing this and ended up with TLS as a solution for encrypting communication channel between CL and EL. In this case extra auth scheme becomes redundant.\r\n\r\nWhat about the certificates and the certificate authorities though? Or do we use self-signing certificates? In that case a pre-shared key is likely better because it allows end-users negotiating them with whatever they want, cli-config/copy-pasting as suggested in this RFC or Diffie-Hellman in more complex infra.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054279833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054296239",
    "html_url": "https://github.com/ethereum/execution-apis/issues/162#issuecomment-1054296239",
    "issue_url": "https://api.github.com/repos/ethereum/execution-apis/issues/162",
    "id": 1054296239,
    "node_id": "IC_kwDOFoG9Gs4-10iv",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-28T14:11:18Z",
    "updated_at": "2022-02-28T14:11:18Z",
    "author_association": "MEMBER",
    "body": "> What about the certificates and the certificate authorities though? Or do we use self-signing certificates? In that case a pre-shared key is likely better because it allows end-users negotiating them with whatever they want, cli-config/copy-pasting as suggested in this RFC or Diffie-Hellman in more complex infra.\r\n\r\nI think there are options here and TLS with self-signed certificates is one of them. IMHO, more sophisticated encryption and auth schemas shouldn't be a part of client implementations and rather be set up as additional infra alongside with clients. For instance, it could be an HTTPS/WSS server in front of EL and a corresponding client on the other side that CL has access through",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/execution-apis/issues/comments/1054296239/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
