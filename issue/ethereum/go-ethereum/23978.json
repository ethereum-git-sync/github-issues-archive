{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/23978",
  "id": 1063920982,
  "node_id": "I_kwDOAOvK984_aiVW",
  "number": 23978,
  "title": "TestNewAdjustTimeFail goroutine leaks",
  "user": {
    "login": "charlesxsh",
    "id": 8362565,
    "node_id": "MDQ6VXNlcjgzNjI1NjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8362565?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/charlesxsh",
    "html_url": "https://github.com/charlesxsh",
    "followers_url": "https://api.github.com/users/charlesxsh/followers",
    "following_url": "https://api.github.com/users/charlesxsh/following{/other_user}",
    "gists_url": "https://api.github.com/users/charlesxsh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/charlesxsh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/charlesxsh/subscriptions",
    "organizations_url": "https://api.github.com/users/charlesxsh/orgs",
    "repos_url": "https://api.github.com/users/charlesxsh/repos",
    "events_url": "https://api.github.com/users/charlesxsh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/charlesxsh/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233650,
      "node_id": "MDU6TGFiZWw3MjIzMzY1MA==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:bug",
      "name": "type:bug",
      "color": "FF5E5E",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2021-11-25T21:10:51Z",
  "updated_at": "2022-05-29T21:13:36Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "#### System information\r\n\r\nOS & Version: Linux\r\nCommit hash : 56e9001a1a8ddecc478943170b00207ef46109b9\r\n\r\n#### Expected behaviour\r\nAll goroutines exit properly\r\n\r\n#### Actual behaviour\r\n\r\n```\r\n//accounts/abi/bind/backends/simulated_test.go\r\nfunc TestNewAdjustTimeFail(t *testing.T) {\r\n\ttestAddr := crypto.PubkeyToAddress(testKey.PublicKey)\r\n\tsim := simTestBackend(testAddr)\r\n\r\n\t...\r\n}\r\n```\r\n\r\nFunction simTestBackend(testAddr) creates two goroutines. Goroutine-1 blocks in a select and waits for a message from one of the four error channels. If Goroutine-1 can continue, it will unblock goroutine-2. \r\n\r\n\r\n```\r\n//accounts/abi/bind/backends/simulated_test.go\r\nfunc simTestBackend(testAddr common.Address) *SimulatedBackend {\r\n\treturn NewSimulatedBackend(\r\n\t\tcore.GenesisAlloc{\r\n\t\t\ttestAddr: {Balance: big.NewInt(10000000000000000)},\r\n\t\t}, 10000000,\r\n\t)\r\n}\r\n```\r\n\r\n```\r\n//accounts/abi/bind/backends/simulated.go\r\nfunc NewSimulatedBackend(alloc core.GenesisAlloc, gasLimit uint64) *SimulatedBackend {\r\n\treturn NewSimulatedBackendWithDatabase(rawdb.NewMemoryDatabase(), alloc, gasLimit)\r\n}\r\n```\r\n\r\n```\r\n//accounts/abi/bind/backends/simulated.go\r\nfunc NewSimulatedBackendWithDatabase(database ethdb.Database, alloc core.GenesisAlloc, gasLimit uint64) *SimulatedBackend {\r\n\tgenesis := core.Genesis{Config: params.AllEthashProtocolChanges, GasLimit: gasLimit, Alloc: alloc}\r\n\tgenesis.MustCommit(database)\r\n\tblockchain, _ := core.NewBlockChain(database, nil, genesis.Config, ethash.NewFaker(), vm.Config{}, nil, nil)\r\n\r\n\tbackend := &SimulatedBackend{\r\n\t\tdatabase:   database,\r\n\t\tblockchain: blockchain,\r\n\t\tconfig:     genesis.Config,\r\n\t\tevents:     filters.NewEventSystem(&filterBackend{database, blockchain}, false),\r\n\t}\r\n\tbackend.rollback(blockchain.CurrentBlock())\r\n\treturn backend\r\n}\r\n```\r\n\r\n\r\n```\r\n//eth/filters/filter_system.go\r\nfunc NewEventSystem(backend Backend, lightMode bool) *EventSystem {\r\n\tm := &EventSystem{\r\n\t\tbackend:       backend,\r\n\t\tlightMode:     lightMode,\r\n\t\tinstall:       make(chan *subscription),\r\n\t\tuninstall:     make(chan *subscription),\r\n\t\ttxsCh:         make(chan core.NewTxsEvent, txChanSize),\r\n\t\tlogsCh:        make(chan []*types.Log, logsChanSize),\r\n\t\trmLogsCh:      make(chan core.RemovedLogsEvent, rmLogsChanSize),\r\n\t\tpendingLogsCh: make(chan []*types.Log, logsChanSize),\r\n\t\tchainCh:       make(chan core.ChainEvent, chainEvChanSize),\r\n\t}\r\n\r\n\t// Subscribe events\r\n\tm.txsSub = m.backend.SubscribeNewTxsEvent(m.txsCh)\r\n\tm.logsSub = m.backend.SubscribeLogsEvent(m.logsCh)\r\n\tm.rmLogsSub = m.backend.SubscribeRemovedLogsEvent(m.rmLogsCh)\r\n\tm.chainSub = m.backend.SubscribeChainEvent(m.chainCh)\r\n\tm.pendingLogsSub = m.backend.SubscribePendingLogsEvent(m.pendingLogsCh)\r\n\r\n\t...\r\n\r\n\tgo m.eventLoop()  // line 1: create the first goroutine \r\n\treturn m\r\n}\r\n```\r\n\r\nThe first goroutine is created at line 1. It keeps executing a select in a loop and does not leave from the loop until it receives an err message from one of the four error channels or one of the four error channels is closed. \r\n\r\nAfter it leaves from the loop, it executes a deferred function, which can unblock the second goroutine. \r\n\r\n```\r\n//eth/filters/filter_system.go\r\nfunc (es *EventSystem) eventLoop() {\r\n\t// Ensure all subscriptions get cleaned up\r\n\tdefer func() {\r\n\t\tes.txsSub.Unsubscribe()\r\n\t\tes.logsSub.Unsubscribe()\r\n\t\tes.rmLogsSub.Unsubscribe()\r\n\t\tes.pendingLogsSub.Unsubscribe()  // unblock the second goroutine\r\n\t\tes.chainSub.Unsubscribe()\r\n\t}()\r\n\r\n\tindex := make(filterIndex)\r\n\tfor i := UnknownSubscription; i < LastIndexSubscription; i++ {\r\n\t\tindex[i] = make(map[rpc.ID]*subscription)\r\n\t}\r\n\r\n\tfor {\r\n\t\tselect {  // blocking\r\n\t\tcase ev := <-es.txsCh:\r\n\t\t\tes.handleTxsEvent(index, ev)\r\n\t\tcase ev := <-es.logsCh:\r\n\t\t\tes.handleLogs(index, ev)\r\n\t\tcase ev := <-es.rmLogsCh:\r\n\t\t\tes.handleRemovedLogs(index, ev)\r\n\t\tcase ev := <-es.pendingLogsCh:\r\n\t\t\tes.handlePendingLogs(index, ev)\r\n\t\tcase ev := <-es.chainCh:\r\n\t\t\tes.handleChainEvent(index, ev)\r\n\r\n\t\tcase f := <-es.install:\r\n\t\t\tif f.typ == MinedAndPendingLogsSubscription {\r\n\t\t\t\t// the type are logs and pending logs subscriptions\r\n\t\t\t\tindex[LogsSubscription][f.id] = f\r\n\t\t\t\tindex[PendingLogsSubscription][f.id] = f\r\n\t\t\t} else {\r\n\t\t\t\tindex[f.typ][f.id] = f\r\n\t\t\t}\r\n\t\t\tclose(f.installed)\r\n\r\n\t\tcase f := <-es.uninstall:\r\n\t\t\tif f.typ == MinedAndPendingLogsSubscription {\r\n\t\t\t\t// the type are logs and pending logs subscriptions\r\n\t\t\t\tdelete(index[LogsSubscription], f.id)\r\n\t\t\t\tdelete(index[PendingLogsSubscription], f.id)\r\n\t\t\t} else {\r\n\t\t\t\tdelete(index[f.typ], f.id)\r\n\t\t\t}\r\n\t\t\tclose(f.err)\r\n\r\n\t\t// System stopped\r\n\t\tcase <-es.txsSub.Err():\r\n\t\t\treturn\r\n\t\tcase <-es.logsSub.Err():\r\n\t\t\treturn\r\n\t\tcase <-es.rmLogsSub.Err():\r\n\t\t\treturn\r\n\t\tcase <-es.chainSub.Err():\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n```\r\n//event/subscription.go\r\nfunc (s *funcSub) Unsubscribe() {\r\n\ts.mu.Lock()\r\n\tif s.unsubscribed {\r\n\t\ts.mu.Unlock()\r\n\t\treturn\r\n\t}\r\n\ts.unsubscribed = true\r\n\tclose(s.unsub) // unblock the second goroutine\r\n\ts.mu.Unlock()\r\n\t// Wait for producer shutdown.\r\n\t<-s.err\r\n}\r\n```\r\n\r\n\r\n\r\nThe following call chain leads the second goroutine to be created. \r\n\r\n```\r\n//accounts/abi/bind/backends/simulated.go\r\nfunc (fb *filterBackend) SubscribePendingLogsEvent(ch chan<- []*types.Log) event.Subscription {\r\n\treturn nullSubscription()\r\n}\r\n```\r\n\r\n```\r\n//accounts/abi/bind/backends/simulated.go\r\nfunc nullSubscription() event.Subscription {\r\n\treturn event.NewSubscription(func(quit <-chan struct{}) error {\r\n\t\t<-quit // blocking\r\n\t\treturn nil\r\n\t})\r\n}\r\n```\r\n\r\n```\r\n//event/subscription.go\r\nfunc NewSubscription(producer func(<-chan struct{}) error) Subscription {\r\n\ts := &funcSub{unsub: make(chan struct{}), err: make(chan error, 1)}\r\n\tgo func() {  // line 2: second goroutine\r\n\t\tdefer close(s.err)       // line 4\r\n\t\terr := producer(s.unsub) // line 3\r\n\t\ts.mu.Lock()\r\n\t\tdefer s.mu.Unlock()\r\n\t\tif !s.unsubscribed {\r\n\t\t\tif err != nil {\r\n\t\t\t\ts.err <- err\r\n\t\t\t}\r\n\t\t\ts.unsubscribed = true\r\n\t\t}\r\n\t}()\r\n\treturn s\r\n}\r\n```\r\n\r\nThe second goroutine is created in function NewSubscription() at line 2. Function producer() called at line 3 is the anonymous function created in function nullSubscription(). The second goroutine is waiting to pull a message from channel quit, which is the unsub field of the funcSub struct created in function NewSubscription(). \r\n\r\n#### Steps to reproduce the behaviour\r\nRunning TestNewAdjustTimeFail at github.com/ethereum/go-ethereum/accounts/abi/bind/backends package.\r\n\r\n#### Backtrace\r\n\r\n````\r\n[backtrace]\r\n...\r\n\r\ngoroutine 31 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1(0xc00008cf80, 0x0, 0x0)\r\n\t/fuzz/target/accounts/abi/bind/backends/simulated.go:1546 +0x85\r\ngithub.com/ethereum/go-ethereum/event.NewSubscription.func1(0xc000520150, 0xc8c020)\r\n\t/fuzz/target/event/subscription.go:54 +0x69\r\ncreated by github.com/ethereum/go-ethereum/event.NewSubscription\r\n\t/fuzz/target/event/subscription.go:52 +0x151\r\n\r\ngoroutine 32 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1(0xc00008d300, 0x0, 0x0)\r\n\t/fuzz/target/accounts/abi/bind/backends/simulated.go:1546 +0x85\r\ngithub.com/ethereum/go-ethereum/event.NewSubscription.func1(0xc0005201c0, 0xc8c020)\r\n\t/fuzz/target/event/subscription.go:54 +0x69\r\ncreated by github.com/ethereum/go-ethereum/event.NewSubscription\r\n\t/fuzz/target/event/subscription.go:52 +0x151\r\n\r\ngoroutine 33 [select]:\r\ngithub.com/ethereum/go-ethereum/eth/filters.(*EventSystem).eventLoop(0xc0001be210)\r\n\t/fuzz/target/eth/filters/filter_system.go:1122 +0x1b05\r\ncreated by github.com/ethereum/go-ethereum/eth/filters.NewEventSystem\r\n\t/fuzz/target/eth/filters/filter_system.go:139 +0x57c\r\n````\r\n\r\nWhen submitting logs: please submit them as text and not screenshots.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/984457871",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23978#issuecomment-984457871",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23978",
    "id": 984457871,
    "node_id": "IC_kwDOAOvK9846raKP",
    "user": {
      "login": "ligi",
      "id": 111600,
      "node_id": "MDQ6VXNlcjExMTYwMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/111600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ligi",
      "html_url": "https://github.com/ligi",
      "followers_url": "https://api.github.com/users/ligi/followers",
      "following_url": "https://api.github.com/users/ligi/following{/other_user}",
      "gists_url": "https://api.github.com/users/ligi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ligi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ligi/subscriptions",
      "organizations_url": "https://api.github.com/users/ligi/orgs",
      "repos_url": "https://api.github.com/users/ligi/repos",
      "events_url": "https://api.github.com/users/ligi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ligi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-02T09:41:31Z",
    "updated_at": "2021-12-02T09:41:31Z",
    "author_association": "MEMBER",
    "body": "Would you be willing to submit a PR to fix the leak?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/984457871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
