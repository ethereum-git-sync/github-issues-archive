{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/16674",
  "id": 320142720,
  "node_id": "MDU6SXNzdWUzMjAxNDI3MjA=",
  "number": 16674,
  "title": "Block processing time slowdown following trie persistence",
  "user": {
    "login": "maxgillett",
    "id": 1622077,
    "node_id": "MDQ6VXNlcjE2MjIwNzc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1622077?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/maxgillett",
    "html_url": "https://github.com/maxgillett",
    "followers_url": "https://api.github.com/users/maxgillett/followers",
    "following_url": "https://api.github.com/users/maxgillett/following{/other_user}",
    "gists_url": "https://api.github.com/users/maxgillett/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/maxgillett/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/maxgillett/subscriptions",
    "organizations_url": "https://api.github.com/users/maxgillett/orgs",
    "repos_url": "https://api.github.com/users/maxgillett/repos",
    "events_url": "https://api.github.com/users/maxgillett/events{/privacy}",
    "received_events_url": "https://api.github.com/users/maxgillett/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2018-05-04T03:15:52Z",
  "updated_at": "2018-06-04T07:47:44Z",
  "closed_at": "2018-06-04T07:47:44Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "#### System information\r\n\r\nGeth version: `Geth/v1.8.3`\r\nOS & Version: Ubuntu 16.04\r\n\r\nMy block processing time is typically on the order of 250ms, but I have noticed that there are occasional extended periods (can last more than an hour) during which this time increase drastically, sometimes averaging between 2-6 seconds on my machine.  This almost always happens immediately following a log message indicating that the state trie in memory has been persisted to disk.\r\n\r\nIf I understand it correctly, this makes sense as this part of the state trie is no longer located in RAM, and thus slower to retrieve when verifying a block. Is there a way to avoid this slowdown in processing time? Could this be avoided by always making sure that the cache contains a substantial portion of the recent state, and not purging too much of the it when its persisted to disk?",
  "closed_by": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386510439",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386510439",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
    "id": 386510439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjUxMDQzOQ==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-04T05:45:36Z",
    "updated_at": "2018-05-04T05:45:36Z",
    "author_association": "MEMBER",
    "body": "The extra overhead may introduced by the **leveldb compaction**. \r\n\r\nGeth will persist a part of state data to the disk following some rules. In other words, geth will accumulate many state data generated in the past several blocks in memory, and batch write a part at a certain moment.\r\n\r\nWhen the size of whole database become large, leveldb compaction will appear more and more frequently. And when the compaction burden is heavy, normal database writes will be blocked, which will result in a longer time for the block process. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386510439/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386536123",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386536123",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
    "id": 386536123,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjUzNjEyMw==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-04T08:27:38Z",
    "updated_at": "2018-05-04T08:27:38Z",
    "author_association": "MEMBER",
    "body": "OP's intuition is most probably correct on this one. When we flush the cache on mainnet, we push out about 256MB worth of trie data to disk. However, probably a lot of that will be read back in for the next blocks.\r\n\r\nA good optimization would be to have some form of LRU cache integrated and avoid flushing out everything, rather keep the recently accessed ones in. It's not a trivial thing to implement though, as flushing the data destroys the internal reference counters used by the garbage collector.\r\n\r\n@rjl493456442 You are also right that compaction might influence it, but if we were to keep some of the flushed data in memory, then compaction would have less of an impact.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386536123/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386545042",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386545042",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
    "id": 386545042,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjU0NTA0Mg==",
    "user": {
      "login": "ghost",
      "id": 10137,
      "node_id": "MDQ6VXNlcjEwMTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ghost",
      "html_url": "https://github.com/ghost",
      "followers_url": "https://api.github.com/users/ghost/followers",
      "following_url": "https://api.github.com/users/ghost/following{/other_user}",
      "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
      "organizations_url": "https://api.github.com/users/ghost/orgs",
      "repos_url": "https://api.github.com/users/ghost/repos",
      "events_url": "https://api.github.com/users/ghost/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ghost/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-04T09:09:27Z",
    "updated_at": "2018-05-04T09:09:27Z",
    "author_association": "NONE",
    "body": "Wonder why I am here, sorry for bother, went too far from real life.\nDowngrade. Thank you all, I am leaving net for real jobs. Tired and lost.\nSencirely Serik.\n\nOn Fri, 4 May 2018 14:28 Péter Szilágyi, <notifications@github.com> wrote:\n\n> OP's intuition is most probably correct on this one. When we flush the\n> cache on mainnet, we push out about 256MB worth of trie data to disk.\n> However, probably a lot of that will be read back in for the next blocks.\n>\n> A good optimization would be to have some form of LRU cache integrated and\n> avoid flushing out everything, rather keep the recently accessed ones in.\n> It's not a trivial thing to implement though, as flushing the data destroys\n> the internal reference counters used by the garbage collector.\n>\n> @rjl493456442 <https://github.com/rjl493456442> You are also right that\n> compaction might influence it, but if we were to keep some of the flushed\n> data in memory, then compaction would have less of an impact.\n>\n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386536123>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/Ac3rNfPH3J3_Aq5v4-rYJeVbWjD7d4F5ks5tvBEigaJpZM4TyD7r>\n> .\n>\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386545042/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386778391",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386778391",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
    "id": 386778391,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4Njc3ODM5MQ==",
    "user": {
      "login": "maxgillett",
      "id": 1622077,
      "node_id": "MDQ6VXNlcjE2MjIwNzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1622077?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maxgillett",
      "html_url": "https://github.com/maxgillett",
      "followers_url": "https://api.github.com/users/maxgillett/followers",
      "following_url": "https://api.github.com/users/maxgillett/following{/other_user}",
      "gists_url": "https://api.github.com/users/maxgillett/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maxgillett/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maxgillett/subscriptions",
      "organizations_url": "https://api.github.com/users/maxgillett/orgs",
      "repos_url": "https://api.github.com/users/maxgillett/repos",
      "events_url": "https://api.github.com/users/maxgillett/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maxgillett/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-05T04:32:56Z",
    "updated_at": "2018-05-05T04:32:56Z",
    "author_association": "NONE",
    "body": "I can look at some options for implementing this. \r\n\r\n@rjl493456442 Is there a way to manually turn compaction on and off? I only see API methods to initiate a compaction.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386778391/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386863802",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/16674#issuecomment-386863802",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/16674",
    "id": 386863802,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4Njg2MzgwMg==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-06T08:43:36Z",
    "updated_at": "2018-05-06T08:43:36Z",
    "author_association": "MEMBER",
    "body": "@maxgillett Unfortunately, i think it's difficult for us to adjust the leveldb's compaction strategy to avoid the overhead.\r\nThe leveldb for compaction is due to the following reasons：\r\n\r\n1. Remove redundant data. Since leveldb is a typical LSM Tree implementation, so it will save all versions for an entry. To avoid disk waste, it will clean redundant data during the compaction.\r\n\r\n2. Balance reading and writing speed difference. For leveldb, writing a data entry is really fast, it only evolve one O(log(n)) memory insert operation and ordered file writing. While for reading operation, the cost is much higher, especially when the speed of writing and the amount of data are large. So leveldb will balance these two operations by merging the level0 files and \r\nslowing down or even pausing write operation according the situation of compaction.\r\n\r\nFor the compaction trigger, although you can change the compaction trigger configuration to postpone the compaction, but can not avoid.\r\n\r\nAnyway, the overhead of compaction is inevitable for LSM Tree type databases. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/386863802/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
