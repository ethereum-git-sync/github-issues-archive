{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/3702",
  "id": 209668951,
  "node_id": "MDU6SXNzdWUyMDk2Njg5NTE=",
  "number": 3702,
  "title": "JSON-RPC over IPC should envelope messages.",
  "user": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 8,
  "created_at": "2017-02-23T05:37:38Z",
  "updated_at": "2017-02-24T09:42:07Z",
  "closed_at": "2017-02-24T09:42:07Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Crossposted https://github.com/ethcore/parity/issues/4647, since this is a systemic ecosystem issue.\r\n\r\nWhen receiving JSON-RPC requests over WS or HTTP, the underlying protocol deals with ensuring that messages are well separated and that the connection can gracefully recover from bad bytes put onto the wire.  While domain sockets/named pipes will deal with ordering and guaranteeing arrival, they do not do anything to separate messages.  This leads to a sort of cascade of problems.  The first being that the developer wanting to utilize the IPC needs to write code that can identify end of one message and beginning of another.  Unfortunately, the only way to correctly deal with this is to write or use a streaming JSON parser that can stop when it reaches the end of an object.  Unfortunately, most off-the-shelf parsers will error indicating malformed JSON if you try to parse a byte stream that has multiple separate JSON payloads concatenated together (such as the JSON-RPC over IPC protocol).\r\n\r\nEven if the user writes a fully JSON compliant streaming parser, it also needs to deal with the fact that JSON is UTF-8 which means a surrogate pair may cross buffer boundaries.  This means that not only does the user have to deal with the fact that messages themselves may cross buffer boundaries, but it also needs to deal with the fact that individual characters may cross message boundaries.  This is a solvable problem but it introduces a lot of complexity for the developer to deal with.\r\n\r\nI think most critically is the fact that I don't _believe_ there is a *recoverable* way to write an end-on-end JSON parser without some kind of enveloping.  Imagine someone sent this over HTTP, WS and IPC:\r\n```\r\n{ jsonrpc: \"2.0\", id: 5, method: \"truncat\r\n{ jsonrpc: \"2.0\", id: 6, method: \"complete\", params: \"}{\" }\r\n```\r\nWith HTTP and WS, the channel would remain open and the receiver would be able to respond with an appropriate error message indicating one of the messages was malformed.  For IPC however, there is *no correct way* to deal with this.  As far as the receiver is concerned, it is in the middle of parsing a JSON string until it receives the next quote, at which point it will see some invalid JSON following it.  Unfortunately, the parser doesn't know where to read up to in order to \"skip to the next message\" and start over.  It could try looking for something like `}{`, but as you can see in this example the `}{` would be in the middle of another message (inside a string) but the parser doesn't know that, so it would fail again.  Hypothetically you could keep repeating this process (look for some sort of boundary character sequence) until you find a valid message, but that is incredibly complex and I'm not entirely certain there isn't an edge case that would \r\n\r\nProposal\r\n----\r\nI propose that a version 2 (or are we up to 3?) of the JSON-RPC over IPC be built that envelopes messages with a sentinel header and a length prefix.  The length prefix would allow parsers to simply wait until they have the whole message before trying to process any JSON and if the JSON or UTF-8 inside the envelope is invalid it can throw away the whole message without any trouble.  The sentinel would be a special byte sequence that would need to be escaped if found anywhere in the payload (could be as little as one byte, but that would require more frequent escaping) and would allow the channel to recover cleanly from malformed input by simply reading until the next sentinel.\r\n\r\nRe: sentinel, is a `0` byte valid anywhere in a JSON string?  If not, then the null byte could be used as the sentinel without need for escaping.\r\n\r\nNotes\r\n----\r\nThere are several Ethereum JSON-RPC over IPC clients that I know of at this point (Geth, Parity, Web3, Ethrpc) and so far I haven't seen anyone fully solve this problem.  I'm not entirely certain what Geth is doing since it appears to be relying on something from go-lang, but I would be mildly surprised if it correctly deals with all of the problems associated with un-enveloped IPC payloads.",
  "closed_by": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281900627",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-281900627",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 281900627,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTkwMDYyNw==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-23T05:43:37Z",
    "updated_at": "2017-02-23T05:43:37Z",
    "author_association": "MEMBER",
    "body": "It should be noted that this problem makes it much easier for attackers to write injection attacks since writing a good parser is so difficult.  The current `web3.js` implementation, for example, currently is open to an injection attack if the attacker can get a `}{` into the payload of a message (I suspect not hard).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281900627/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281933323",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-281933323",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 281933323,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTkzMzMyMw==",
    "user": {
      "login": "bas-vk",
      "id": 4280775,
      "node_id": "MDQ6VXNlcjQyODA3NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4280775?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bas-vk",
      "html_url": "https://github.com/bas-vk",
      "followers_url": "https://api.github.com/users/bas-vk/followers",
      "following_url": "https://api.github.com/users/bas-vk/following{/other_user}",
      "gists_url": "https://api.github.com/users/bas-vk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bas-vk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bas-vk/subscriptions",
      "organizations_url": "https://api.github.com/users/bas-vk/orgs",
      "repos_url": "https://api.github.com/users/bas-vk/repos",
      "events_url": "https://api.github.com/users/bas-vk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bas-vk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-23T08:57:12Z",
    "updated_at": "2017-02-23T08:57:12Z",
    "author_association": "MEMBER",
    "body": "> The first being that the developer wanting to utilize the IPC needs to write code that can identify end of one message and beginning of another. \r\n\r\nIf you want to use the streaming feature it means you need to have support for streaming json messages on the client. If you don't want to use streaming messages it is possible to open multiple IPC connections and use the request/reply pattern just like http. This is up to the client. To be complete, geth also supports pipelining. Therefore responses can be returned out of order and clients needs to keep track of req/res ids.\r\n\r\n> Even if the user writes a fully JSON compliant streaming parser, it also needs to deal with the fact that JSON is UTF-8 which means a surrogate pair may cross buffer boundaries.\r\n\r\nIn the Ethereum world this is not an issue because data is transferred hex encoded. As long as the client uses ascii for the id, jsonrpc and method fields you are fine with a naive implementation that assumes 1 char equals 1 byte.\r\n\r\n> For IPC however, there is no correct way to deal with this.\r\n\r\nCorrect, geth responds with an error indication that the request was invalid and closes the connection since this is a non recoverable situation. This makes it explicit for the client that something went horribly wrong.\r\n\r\n\r\n> I propose that a version 2 (or are we up to 3?) of the JSON-RPC over IPC be built that envelopes messages with a sentinel header and a length prefix.\r\n\r\nI think this solves a really small problem. Most clients that use IPC will probably use something like Mist that takes case of these situations (Mist has a custom \"dechuncker\"). DApps that connect directly to the IPC endpoint are probably specialised applications that have access to a good streaming decoder. Or can use the simple req/res pattern with multiple IPC connections or fallback to the http/ws interface.\r\n\r\nSecond, it is a custom protocol that only makes sense for IPC connections. Clients that want to use this will need to write their own encoders/decoders instead of using some default library. If we move towards such a protocol we will make either the majority of client developers unhappy or need to support both protocols. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281933323/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281978946",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-281978946",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 281978946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTk3ODk0Ng==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-23T12:27:19Z",
    "updated_at": "2017-02-23T12:27:49Z",
    "author_association": "MEMBER",
    "body": "As I mentioned in the chat channel, I don't see how message corruption can occur. HTTP, WS are TCP based, IPC is backed by unix sockets or windows pipes; all take care of data chunking, ordering, retransmits, etc. Client and server side you should have a single thread reading a data stream and similarly either a single thread writing it or multiple ones properly synchronized. There is literally no way to corrupt a data stream.\r\n\r\nRegarding the proposal, the data transport we are currently using is a standard JSON stream. It is a well understood and commonly used protocol. I'm certain any decent programming language is able to process it either out of the box or there are a number of libraries to do it. Converting it into a custom stream would only worsen the scenario, with everyone needing to implement our \"new standard\".\r\n\r\n:-1: ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281978946/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281979852",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-281979852",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 281979852,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTk3OTg1Mg==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-23T12:31:39Z",
    "updated_at": "2017-02-23T12:31:39Z",
    "author_association": "MEMBER",
    "body": ">  I'm not entirely certain what Geth is doing since it appears to be relying on something from go-lang, but I would be mildly surprised if it correctly deals with all of the problems associated with un-enveloped IPC payloads.\r\n\r\nI would be extremely surprised if it didn't work flawlessly. There are no problems with un-enveloped IPC payloads. It is called a plain data stream.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/281979852/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282235091",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-282235091",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 282235091,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjIzNTA5MQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-24T08:35:53Z",
    "updated_at": "2017-02-24T08:44:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "I do agree with @MicahZoltu here. The current IPC streaming is error prone and not clearly defined. Thats also the reason why i had to come up with this quirk: https://github.com/ethereum/web3.js/blob/develop/lib/web3/ipcprovider.js#L84-L89\r\n\r\nI together with @bas-vk implemented the IPC, and i do remember bringing up the possibility to properly send END characters, tho i came then with that workaround and we never looked at it again.\r\n\r\n@bas-vk The issue is that when you receive a JSON object which is larger than the buffer of the socket, so that it comes in chunks. Then receiving and parsing becomes problematic. Thats the reason why i had to come up with that dechunker.\r\n\r\nTho i do agree that this can become an issue and we should solve it. \r\nAs you can see all JSON streaming libs use `/n` as a separator, which is a valid way to separate the incoming json.\r\n\r\nSo my proposal is that we end JSON objects by `/n`, which is already supported by Mist since 8 versions and i think already like this in geth. BUT we need to make sure that any /n inside a result object now or in the future (of method results and notifications) is properly escaped `\\/n`.\r\n\r\nThis would give us backwards compatibility in mist, is a small change and prevent future hacks to break the stream.\r\nAt the same time this will reduce the parsing Mist and others have to do with the current try-to-parse implementation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282235091/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282244958",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-282244958",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 282244958,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjI0NDk1OA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-24T09:25:51Z",
    "updated_at": "2017-02-24T09:25:51Z",
    "author_association": "MEMBER",
    "body": "> So my proposal is that we end JSON objects by /n, which is already supported by Mist since 8 versions and i think already like this in geth. BUT we need to make sure that any /n inside a result object now or in the future (of method results and notifications) is properly escaped \\/n.\r\n\r\nThat's a requirement in JSON, failure to encode `\\n` means that it's invalid JSON. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282244958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282247481",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-282247481",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 282247481,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjI0NzQ4MQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-24T09:37:54Z",
    "updated_at": "2017-02-24T09:37:54Z",
    "author_association": "MEMBER",
    "body": "The `\\n` character should _not_ be used as any kind of meaningful separator in the json response, since json is well defined as is. A proper JSON streaming parser does not need to rely on `\\n`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282247481/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282248358",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3702#issuecomment-282248358",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3702",
    "id": 282248358,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjI0ODM1OA==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-24T09:42:07Z",
    "updated_at": "2017-02-24T09:42:07Z",
    "author_association": "MEMBER",
    "body": "https://github.com/ethcore/parity/issues/4647#issuecomment-282247655",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/282248358/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
