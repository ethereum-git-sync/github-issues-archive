{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/26364",
  "id": 1497834750,
  "node_id": "I_kwDOAOvK985ZRyT-",
  "number": 26364,
  "title": "provider access race condition",
  "user": {
    "login": "NakedKoala",
    "id": 14815380,
    "node_id": "MDQ6VXNlcjE0ODE1Mzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/14815380?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/NakedKoala",
    "html_url": "https://github.com/NakedKoala",
    "followers_url": "https://api.github.com/users/NakedKoala/followers",
    "following_url": "https://api.github.com/users/NakedKoala/following{/other_user}",
    "gists_url": "https://api.github.com/users/NakedKoala/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/NakedKoala/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/NakedKoala/subscriptions",
    "organizations_url": "https://api.github.com/users/NakedKoala/orgs",
    "repos_url": "https://api.github.com/users/NakedKoala/repos",
    "events_url": "https://api.github.com/users/NakedKoala/events{/privacy}",
    "received_events_url": "https://api.github.com/users/NakedKoala/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 268304226,
      "node_id": "MDU6TGFiZWwyNjgzMDQyMjY=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:docs",
      "name": "type:docs",
      "color": "fef2c0",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2022-12-15T05:54:56Z",
  "updated_at": "2022-12-15T06:00:59Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "My program uses `ethclient.Client` and `gethclient.Client` from multiple goroutines and it has experienced infrequent error due to race condition issues related to http and websocket.\r\n\r\nIn the beginning, all my goroutines try to use the same singleton instance of`Client`.\r\n\r\nTo address the issue, I refactor the code to have each goroutine creating its own provider via \r\n\r\n```\r\nethclient.Dial(\"http://127.0.0.1:8545\")\r\nethclient.Dial(\"ws://127.0.0.1:8546\")\r\nrpc.Dial(\"http://127.0.0.1:8545\")\r\nrpc.Dial(\"ws://127.0.0.1:8546\")\r\n\r\n```\r\n\r\nNote that I have a large number (can be up to 2 gouroutines per second) of ephemeral goroutines each creating its own provider to avoid race condition. \r\n\r\nHowever,  I still run into http & ws related race condition error  even after assigning unique provider to each goroutine.\r\n\r\n\r\n```\r\ngoroutine 19491 [IO wait]:\r\ninternal/poll.runtime_pollWait(0x7f4cf147c700, 0x72)\r\n        /usr/local/go/src/runtime/netpoll.go:305 +0x89\r\ninternal/poll.(*pollDesc).wait(0xc0025c2080?, 0xc003f39c00?, 0x0)\r\n        /usr/local/go/src/internal/poll/fd_poll_runtime.go:84 +0x32\r\ninternal/poll.(*pollDesc).waitRead(...)\r\n        /usr/local/go/src/internal/poll/fd_poll_runtime.go:89\r\ninternal/poll.(*FD).Read(0xc0025c2080, {0xc003f39c00, 0x400, 0x400})\r\n        /usr/local/go/src/internal/poll/fd_unix.go:167 +0x25a\r\nnet.(*netFD).Read(0xc0025c2080, {0xc003f39c00?, 0x7f4cf8167c20?, 0x0?})\r\n        /usr/local/go/src/net/fd_posix.go:55 +0x29\r\nnet.(*conn).Read(0xc000ab4490, {0xc003f39c00?, 0x981c00?, 0xc002ecc380?})\r\n        /usr/local/go/src/net/net.go:183 +0x45\r\nbufio.(*Reader).fill(0xc003ca95c0)\r\n        /usr/local/go/src/bufio/bufio.go:106 +0xff\r\nbufio.(*Reader).Peek(0xc003ca95c0, 0x2)\r\n        /usr/local/go/src/bufio/bufio.go:144 +0x5d\r\ngithub.com/gorilla/websocket.(*Conn).read(0xc003eb91e0, 0xc001eaa0c0?)\r\n        /root/go/pkg/mod/github.com/gorilla/websocket@v1.4.2/conn.go:370 +0x2c\r\ngithub.com/gorilla/websocket.(*Conn).advanceFrame(0xc003eb91e0)\r\n        /root/go/pkg/mod/github.com/gorilla/websocket@v1.4.2/conn.go:798 +0x7b\r\ngithub.com/gorilla/websocket.(*Conn).NextReader(0xc003eb91e0)\r\n        /root/go/pkg/mod/github.com/gorilla/websocket@v1.4.2/conn.go:980 +0xcc\r\ngithub.com/gorilla/websocket.(*Conn).ReadJSON(0x18?, {0x927640, 0xc001ddd428})\r\n        /root/go/pkg/mod/github.com/gorilla/websocket@v1.4.2/json.go:50 +0x27\r\ngithub.com/ethereum/go-ethereum/rpc.(*jsonCodec).readBatch(0xc002a35270)\r\n        /root/workspace/go-ethereum/rpc/json.go:214 +0x4d\r\ngithub.com/ethereum/go-ethereum/rpc.(*Client).read(0xc0025c2400, {0xadfd08, 0xc0009582d0})\r\n        /root/workspace/go-ethereum/rpc/client.go:633 +0xb7\r\ncreated by github.com/ethereum/go-ethereum/rpc.(*Client).dispatch\r\n        /root/workspace/go-ethereum/rpc/client.go:557 +0x155\r\n\r\ngoroutine 19528 [select]:\r\ngithub.com/ethereum/go-ethereum/rpc.(*Client).dispatch(0xc003de2880, {0xadfd08?, 0xc0007e3b00})\r\n        /root/workspace/go-ethereum/rpc/client.go:560 +0x2cc\r\ncreated by github.com/ethereum/go-ethereum/rpc.initClient\r\n        /root/workspace/go-ethereum/rpc/client.go:224 +0x311\r\n\r\ngoroutine 19501 [select]:\r\ngithub.com/ethereum/go-ethereum/rpc.(*Client).dispatch(0xc00080a280, {0xadfd08?, 0xc003703560})\r\n        /root/workspace/go-ethereum/rpc/client.go:560 +0x2cc\r\ncreated by github.com/ethereum/go-ethereum/rpc.initClient\r\n        /root/workspace/go-ethereum/rpc/client.go:224 +0x311\r\nexit status 2\r\n\r\n```\r\n\r\n\r\nQuestions:\r\n1.Is access of `Client` from multiple goroutines thread-safe without a global mutex ? \r\n2.Is creating multiple instances of provider from different goroutine thread-safe ? \r\n3.Is creating a large number of ephemeral instances of provider anti-pattern ? ( ie: would too many instances create unnecessary stress on the node ? )\r\n4.If answer to question 3 is yes, what is the best way to access provider from many goroutines safely  ? ( I am hesitant to use a global mutex to protect singleton provider as it can become performance bottleneck)\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26364/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
