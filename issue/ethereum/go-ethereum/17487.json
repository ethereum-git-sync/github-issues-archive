{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/17487",
  "id": 353139906,
  "node_id": "MDU6SXNzdWUzNTMxMzk5MDY=",
  "number": 17487,
  "title": "Proposal: Paginated Filter Queries",
  "user": {
    "login": "mslipper",
    "id": 67953,
    "node_id": "MDQ6VXNlcjY3OTUz",
    "avatar_url": "https://avatars.githubusercontent.com/u/67953?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mslipper",
    "html_url": "https://github.com/mslipper",
    "followers_url": "https://api.github.com/users/mslipper/followers",
    "following_url": "https://api.github.com/users/mslipper/following{/other_user}",
    "gists_url": "https://api.github.com/users/mslipper/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mslipper/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mslipper/subscriptions",
    "organizations_url": "https://api.github.com/users/mslipper/orgs",
    "repos_url": "https://api.github.com/users/mslipper/repos",
    "events_url": "https://api.github.com/users/mslipper/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mslipper/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233652,
      "node_id": "MDU6TGFiZWw3MjIzMzY1Mg==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:feature",
      "name": "type:feature",
      "color": "84b6eb",
      "default": false,
      "description": null
    },
    {
      "id": 856638432,
      "node_id": "MDU6TGFiZWw4NTY2Mzg0MzI=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:inactive",
      "name": "status:inactive",
      "color": "ffffff",
      "default": false,
      "description": null
    },
    {
      "id": 1269313112,
      "node_id": "MDU6TGFiZWwxMjY5MzEzMTEy",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:backlog",
      "name": "status:backlog",
      "color": "29ceb3",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2018-08-22T21:53:24Z",
  "updated_at": "2020-09-20T03:46:21Z",
  "closed_at": "2020-09-20T03:46:21Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Proposal: Paginated Log Queries\r\n\r\nCurrently, RPC endpoints that support filtering logs by topic and block number return all matched logs in a single request. When a non-streaming client requests those logs (i.e., any HTTP client expecting a JSON-RPC response), they are buffered in memory before being marshalled. This leads to memory exhaustion errors when the number of matched logs is very large. Consider the following RPC query, for example:\r\n\r\n```bash\r\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLogs\",\"params\":[{\"fromBlock\": 1, \"toBlock\": \"latest\"}],\"id\":73}'\r\n```\r\n\r\nWhen you send this request to a live Geth node (which I have, accidentally), the request will block and the node will steadily use more memory until it crashes.\r\n\r\nThis issue exists for the following RPC methods:\r\n\r\n- `eth_getLogs`\r\n- `eth_getFilterLogs`\r\n- `eth_getFilterChanges`\r\n\r\nTo solve this problem, I'd like to propose adding pagination to the above methods. Below, see my proposal for how we could implement it.\r\n\r\n> Note: This _will_ be a breaking change, so I thought this issue could be used for discussion before submitting a formal EIP.\r\n\r\n## Paginated Response Schema\r\n\r\nThe above three RPC methods all share the same response, represented in the codebase by the `Log` struct in `core/types`. The response, in JSON, looks like this:\r\n\r\n```json\r\n{\r\n  \"id\":1,\r\n  \"jsonrpc\":\"2.0\",\r\n  \"result\": [{\r\n    \"logIndex\": \"0x1\", // 1\r\n    \"blockNumber\":\"0x1b4\", // 436\r\n    \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\",\r\n    \"transactionHash\":  \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcf\",\r\n    \"transactionIndex\": \"0x0\", // 0\r\n    \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\",\r\n    \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\r\n    \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"]\r\n    },{\r\n      ...\r\n    }]\r\n}\r\n```\r\n\r\nLogs are ordered based on their ascending block number. I propose wrapping the result in a 'cursor' object as follows:\r\n\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"jsonrpc\": \"2.0\",\r\n  \"result\": {\r\n    \"cursorStartBlock\": \"0x1\",\r\n    \"cursorEndBlock\": \"0x64\",\r\n    \"cursorNextBlock\": \"0x65\",\r\n    \"logs\": [\r\n      {\r\n        \"logIndex\": \"0x1\",\r\n        \"blockNumber\": \"0x64\",\r\n        \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\",\r\n        \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcf\",\r\n        \"transactionIndex\": \"0x0\",\r\n        \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\",\r\n        \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\r\n        \"topics\": [\r\n          \"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nThe cursor is defined as a view of logs in some constant number of blocks. When the latest block is reached, `cursorNextBlock` will be `null`. `cursorStartBlock` and `cursorEndBlock` represent the start and end blocks (inclusively) in the _cursor_, not the filter that created the cursor. All numeric values in the cursor will be returned as hex.\r\n\r\nI think paginating by blocks is cleaner than simply paginating by offsets for the following reasons:\r\n\r\n- The RPC API is already allows filtering based on block numbers.\r\n- Returning a window of blocks simplifies 'inner loop' logic in clients that want to consume large lists of transactions. For example, to iterate through all transactions in the chain the following pseudocode would suffice:\r\n\r\n```\r\nvar id = eth.newFilter(fromBlock: 0, toBlock: 'latest')\r\nwhile (res.cursorNextBlock != null) {\r\n  res = eth.getFilterLogs(id: id)\r\n  // do something with res.logs\r\n}\r\n```\r\n\r\nIt also _appears_ simpler to implement given the existing filter backend and event system - see the 'Implementation Details' section for my research here.\r\n\r\n## Requesting Specific Pages\r\n\r\nTo request the next page in the cursor, I propose modifying the following RPC endpoints as follows:\r\n\r\n### `eth_getFilterChanges`\r\n\r\nModify the request payload to be an object with the following schema:\r\n\r\n```json\r\n{\r\n\t\"filterId\": \"0x16\",\r\n\t\"cursorStartBlock\": \"0x65\r\n}\r\n```\r\n\r\nFor filters created with `eth_newBlockFilter` or `eth_newPendingTransactionFilter`, the `cursorStartBlock` parameter will be ignored.\r\n\r\nIf `cursorStartBlock` is omitted, is defaults to the filter's `startBlock` parameter. If `cursorStartBlock` is less than the filter's `fromBlock` parameter or larger than its `toBlock` parameter, an error is returned.\r\n\r\n### `eth_getFilterLogs`\r\n\r\nSee `eth_getFilterChanges`.\r\n\r\n### `eth_getLogs`\r\n\r\nModify the request payload to support an additional `cursorStartBlock` field. If `cursorStartBlock` is omitted, is defaults to the `fromBlock` parameter. If `cursorStartBlock` is less than the `fromBlock` parameter or larger than the `toBlock` parameter, an error is returned.\r\n\r\nIt probably doesn't make sense to paginate datasets when the a client knows the number of blocks they want to query beforehand - i.e., `toBlock` is not `latest`. In cases like this, we can enforce a maximum difference between `fromBlock` and `toBlock` to only return a single page of results.\r\n\r\n## Implementation Details\r\n\r\nThe current log filtration system is handled by two subsystems: `filters.EventSystem`, and `filters.Backend`. `EventSystem` handles filters that are explcitly installed/uninstalled by wrapping an instance of `Backend` in an event loop. `Backend` is used directly by `eth_getLogs`. Both `Backend` and `EventSystem` already support queries between two block numbers. Thus, to support cursors at the API level it should be straightforward to modify the RPC event handlers to call the filter system with modified start and end blocks based on the provided cursor. This avoids having to modify additional code within Geth that relies upon the filter system. \r\n\r\nNote that we will need to manage an additional pointer in the mapping of active filters to IDs that represents the last block number read for `eth_getFilterChanges`.\r\n\r\ncc @karalabe - we talked about this today. What do you think, particularly about the proposal to modify the API layer rather than refactoring the event system?",
  "closed_by": {
    "login": "stale[bot]",
    "id": 26384082,
    "node_id": "MDM6Qm90MjYzODQwODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stale%5Bbot%5D",
    "html_url": "https://github.com/apps/stale",
    "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487/reactions",
    "total_count": 4,
    "+1": 4,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/419376132",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/17487#issuecomment-419376132",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487",
    "id": 419376132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxOTM3NjEzMg==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-07T09:12:02Z",
    "updated_at": "2018-09-07T09:12:02Z",
    "author_association": "MEMBER",
    "body": "Cc @zsfelfoldi",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/419376132/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/670841383",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/17487#issuecomment-670841383",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/17487",
    "id": 670841383,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MDg0MTM4Mw==",
    "user": {
      "login": "stale[bot]",
      "id": 26384082,
      "node_id": "MDM6Qm90MjYzODQwODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stale%5Bbot%5D",
      "html_url": "https://github.com/apps/stale",
      "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2020-08-08T07:56:33Z",
    "updated_at": "2020-08-08T07:56:33Z",
    "author_association": "NONE",
    "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/670841383/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
