{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/2672",
  "id": 159150883,
  "node_id": "MDU6SXNzdWUxNTkxNTA4ODM=",
  "number": 2672,
  "title": "Deficiences regarding geth local security",
  "user": {
    "login": "MesserArtStudio",
    "id": 18182590,
    "node_id": "MDQ6VXNlcjE4MTgyNTkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/18182590?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MesserArtStudio",
    "html_url": "https://github.com/MesserArtStudio",
    "followers_url": "https://api.github.com/users/MesserArtStudio/followers",
    "following_url": "https://api.github.com/users/MesserArtStudio/following{/other_user}",
    "gists_url": "https://api.github.com/users/MesserArtStudio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MesserArtStudio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MesserArtStudio/subscriptions",
    "organizations_url": "https://api.github.com/users/MesserArtStudio/orgs",
    "repos_url": "https://api.github.com/users/MesserArtStudio/repos",
    "events_url": "https://api.github.com/users/MesserArtStudio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MesserArtStudio/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 856638432,
      "node_id": "MDU6TGFiZWw4NTY2Mzg0MzI=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:inactive",
      "name": "status:inactive",
      "color": "ffffff",
      "default": false,
      "description": null
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2016-06-08T12:26:26Z",
  "updated_at": "2018-04-16T17:37:47Z",
  "closed_at": "2018-04-16T17:37:47Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "@Gustav-Simonsson suggested to file my thoughts as an issue here. These are not explicitly bugs, deficiencies rather.\nAn excerpt from our mail conversation will explain my thought path.\nMe:\n\n> environment: Linux x64\n> Attack scenario: Attacker gets access to userspace (not root). Attacker modifies geth file alone that sits in the userspace using simple command like 'printf '9' | dd of=gethc bs=1 seek=20401747 count=1 conv=notrunc'.\n> Impact: Above command modifies default timeout of TimedUnlock. Thus it makes nothing really important, but I executed this only to see if it can work (I've also changed more bytes too). Geth compiled code is almost not obfuscated and is quite easy to read. Attacker can find many other ways to alter geth functionality. As proven by experiment there is no even simple checksum checking or other more sophisticated integrity check, as everything works normally after change and raises no alarm. It makes attacker work easier as injection can be performed via simple script driven by bot, no downloading of altered file is needed (this could trigger suspicions and leave more traces). Due to \"download and run\" nature of geth it lives in userspace without any permission restrictions thus can be altered without leaving traces.\n> Fix: Obfuscate code, add integrity checks, force some kind of permissions isolation. Can suggest more if asked.\n\nGustav:\n\n> Thanks for the report! It's indeed true geth naively assumes it has not been tampered with and the current security assumption is that its the users responsibility to verify the geth binary they have has not been tampered with.\n> \n> We're working on improving builds and publishing hashes of all built geth binaries (currently done for cross-compilation builds) and internal integrity checks is definitely something we could consider.\n> \n> However if geth has an internal integrity check that code could also be modified by the attacker so I'm not sure how much that gives compared to simply verifying the hash of the binary itself against expected value.\n> \n> Code obfuscation would give limited security since geth is an open source project using open source build tools. In particular, in the long term we may want to move to deterministic builds (https://blog.torproject.org/blog/deterministic-builds-part-one-cyberwar-and-global-compromise).\n\nMe:\n\n> Good that you are aware of the issues I pointed out.\n> While I agree that the integrity check can also be compromised, patching several places inside the code is less straight forward and less universal in case of updates (from attacker's point of view).\n> Simple verification of the hash of the binary is usually performed only upon download. Integrity checks can be fired many times even during a single session. It just gives another security wall to be passed by attackers.\n> Agree that code obfuscation gives limited security. But limited doesn't mean none. Deterministic builds will be a long run I assume. Meanwhile using just some code packers on every subsequent binary distribution will at least force potential attackers to disassemble these distributions every time a new one appears. It requires time and some skills. Something like a primitive filter to exclude hack kiddies.\n> \n> Malware is widespread nowadays and basic malware skeletons are available at hand for mere few bucks. Building malware focused on geth isn't something extremely hard. More, geth resides only in userspace, thus no privileges escalation is needed (less risk and easier to accomplish from attacker's point of view). More, golang has no ASLR which eases memory analysis. I already pointed it out elsewhere that zeroKey routine used while unlocking an account to erase stored private key from memory writes zeros in place. It's like asking for trouble as it gives a clear hint about where an attacker can expect the private key to appear next time. Not exact place, but heuristic analysis of geth behavior can give enough clues. Especially when there is so nice a hint. Fill it with random, please.\n> \n> Can you tell me why there is no privileges separation between user and geth? There are tested schemes like those used by web servers software for instance. This forces an attacker to pass another security wall before being able to even see the process memory or file.\n> \n> In my free time I play trying to abuse geth. While golang is really good in terms of security it also has some minor flaws. As everything. Sth for sth. I now descended from analyzing the source to analyzing the behavior of binary in memory. Tried also to abuse its net interface. It's not easy, as it's written well, but have been able to crash the app few times. If I succeed in executing my own code I will let you know. Some trails looks promising.\n> \n> To sum it up - some more than basic integrity check would be nice (for instance calculating hashes of different parts of the file). Change the algorithm from distro to distro, just to make it harder for malware for instance to adapt. Obfuscate the code using some build tools (there's a wide choice) just to make the analysis between the source and binary harder. And do something with privileges - install it with root and create a separate user for it at least.\n> The above aren't fail-proof countermeasures but at least limit the exposition of the app.\n\nTo sum all above: geth as an application offers no security measures aimed at restricting potential attack vectors from inside a system. Neither it introduces any damage control.\n\nAdditional note: Should be good to have a rigged geth aimed at testing. I already thought about making one, but maybe such a tool already exists?\n\nP.S. I know that due to buffer security it's hard to RCE in golang. Nevertheless it's worth trying.\n",
  "closed_by": {
    "login": "stale[bot]",
    "id": 26384082,
    "node_id": "MDM6Qm90MjYzODQwODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stale%5Bbot%5D",
    "html_url": "https://github.com/apps/stale",
    "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225717747",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/2672#issuecomment-225717747",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672",
    "id": 225717747,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTcxNzc0Nw==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-13T21:42:35Z",
    "updated_at": "2016-06-13T21:42:35Z",
    "author_association": "MEMBER",
    "body": "> Tried also to abuse its net interface. It's not easy, as it's written well, but have been able to crash the app few times. \n\nIf you find a way to crash geth via the p2p port, that probably qualifies for a bounty.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225717747/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225719133",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/2672#issuecomment-225719133",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672",
    "id": 225719133,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTcxOTEzMw==",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-13T21:48:26Z",
    "updated_at": "2016-06-13T21:48:26Z",
    "author_association": "MEMBER",
    "body": "Many of the things that you have listed (e.g. installing/running as separate user) are tasks that users should perform if they wish to defend themselves against potential attacks. Conscious users can also sign transactions on an air-gapped computer or using a hardware signing device such as Trezor.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225719133/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225749713",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/2672#issuecomment-225749713",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672",
    "id": 225749713,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTc0OTcxMw==",
    "user": {
      "login": "Hibryda",
      "id": 7373208,
      "node_id": "MDQ6VXNlcjczNzMyMDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7373208?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Hibryda",
      "html_url": "https://github.com/Hibryda",
      "followers_url": "https://api.github.com/users/Hibryda/followers",
      "following_url": "https://api.github.com/users/Hibryda/following{/other_user}",
      "gists_url": "https://api.github.com/users/Hibryda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Hibryda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Hibryda/subscriptions",
      "organizations_url": "https://api.github.com/users/Hibryda/orgs",
      "repos_url": "https://api.github.com/users/Hibryda/repos",
      "events_url": "https://api.github.com/users/Hibryda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Hibryda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-14T00:39:30Z",
    "updated_at": "2016-06-14T00:39:30Z",
    "author_association": "NONE",
    "body": "Thanks for your comments @fjl \nAbusing geth via p2p isn't simple (not sure whether even possible) as golang has it all written pretty well. More, no C linked lib is anywhere where it could enable RCE in common way. But it's always fun to try. BTW, is there any rigged geth for testing, or I have to eviscerate it on my own?\nAs to conscious users - geth+Mist is intended to be a kind of retail app. At least it's its general perception. Look at daohub and problems that possibly IT illiterate users have with it.\nTrusting in users consciousness is naive. Moreover, while isolated cases of abuse wouldn't be a problem and wouldn't cause much harm to Ether, coordinated and targeted would be much worse. \nAnd against malicious botnet there are currently no, even basic, countermeasures. This was my point. \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/225749713/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/370482501",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/2672#issuecomment-370482501",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/2672",
    "id": 370482501,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDQ4MjUwMQ==",
    "user": {
      "login": "stale[bot]",
      "id": 26384082,
      "node_id": "MDM6Qm90MjYzODQwODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stale%5Bbot%5D",
      "html_url": "https://github.com/apps/stale",
      "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2018-03-05T16:44:20Z",
    "updated_at": "2018-03-05T16:44:20Z",
    "author_association": "NONE",
    "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/370482501/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
