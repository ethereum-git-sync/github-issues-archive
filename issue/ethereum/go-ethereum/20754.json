{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/20754",
  "id": 578680376,
  "node_id": "MDU6SXNzdWU1Nzg2ODAzNzY=",
  "number": 20754,
  "title": "Idiomatic way to use RLP encoding when a field is a union type ",
  "user": {
    "login": "fxfactorial",
    "id": 3036816,
    "node_id": "MDQ6VXNlcjMwMzY4MTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3036816?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fxfactorial",
    "html_url": "https://github.com/fxfactorial",
    "followers_url": "https://api.github.com/users/fxfactorial/followers",
    "following_url": "https://api.github.com/users/fxfactorial/following{/other_user}",
    "gists_url": "https://api.github.com/users/fxfactorial/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fxfactorial/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fxfactorial/subscriptions",
    "organizations_url": "https://api.github.com/users/fxfactorial/orgs",
    "repos_url": "https://api.github.com/users/fxfactorial/repos",
    "events_url": "https://api.github.com/users/fxfactorial/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fxfactorial/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2020-03-10T15:48:39Z",
  "updated_at": "2020-03-19T08:05:44Z",
  "closed_at": "2020-03-19T08:05:44Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Say we have a struct like so:\r\n\r\n```go\r\ntype F struct {\r\n  A string \r\n  B interface{}\r\n}\r\n```\r\n\r\nWhere B is a type that could be Either \r\n\r\n```go\r\ntype G struct {\r\n  C *big.Int\r\n}\r\n```\r\n\r\nOr\r\n \r\n```go\r\ntype H struct {\r\n  D string \r\n}\r\n```\r\nIâ€™m not clear on the idiomatic way to represent F under the intention of RLP encoding scheme because the interface will make it awkward. What is the usual way to structure types with fields that represent a union type ?",
  "closed_by": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/599056312",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/20754#issuecomment-599056312",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754",
    "id": 599056312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5OTA1NjMxMg==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-14T12:57:58Z",
    "updated_at": "2020-03-14T12:57:58Z",
    "author_association": "MEMBER",
    "body": "Union types are a bit messy, because RLP does not include type metadata into the encoded blobs, so there's nothing to guide decoding. We use them very rarely in Ethereum for this exact reason.\r\n\r\nThe only way to handle such cases if you write the decoder explicitly yourself, and even then you need to be able to differentiate between the cases based on the encoded data (e.g. is the \"next\" field an int, or a list? Is it of size x or y?). If you can differentiate using this trick, unions are kind of possible in a limited way. Generic unions are definitely not something you want to do.\r\n\r\nIn your specific case, you'll have a hard time because `G` and `H` are both structs, so they will both get marshalled as a list. You'd need to look inside further to see if the item is a number or another list. It gets messy fast.\r\n\r\nOne possible way out would be to add a type marker (e.g. an enum field before the interface) that could be used to direct the decoder (you'd still need to roll your own decoder though, there's no support for dynamic types).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/599056312/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/599107934",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/20754#issuecomment-599107934",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754",
    "id": 599107934,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5OTEwNzkzNA==",
    "user": {
      "login": "fxfactorial",
      "id": 3036816,
      "node_id": "MDQ6VXNlcjMwMzY4MTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3036816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxfactorial",
      "html_url": "https://github.com/fxfactorial",
      "followers_url": "https://api.github.com/users/fxfactorial/followers",
      "following_url": "https://api.github.com/users/fxfactorial/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxfactorial/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxfactorial/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxfactorial/subscriptions",
      "organizations_url": "https://api.github.com/users/fxfactorial/orgs",
      "repos_url": "https://api.github.com/users/fxfactorial/repos",
      "events_url": "https://api.github.com/users/fxfactorial/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxfactorial/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-14T17:44:53Z",
    "updated_at": "2020-03-14T17:44:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "thank you so much for such a great answer. \r\n\r\nI tried the type marker approach but it is definitely hacky and error prone. \r\n\r\nI assume then that the best way to avoid this is to bite the bullet and just remove the polymorphism that a union type provides. \r\n\r\nIs there an example in the ethereum codebase that went this way? To avoid this awkward situation under RLP encoding. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/599107934/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/601041871",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/20754#issuecomment-601041871",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20754",
    "id": 601041871,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMTA0MTg3MQ==",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-19T08:05:44Z",
    "updated_at": "2020-03-19T08:05:44Z",
    "author_association": "MEMBER",
    "body": "> I assume then that the best way to avoid this is to bite the bullet and just remove the polymorphism that a union type provides.\r\n\r\nIf possible, yes, I'd suggest that path.\r\n\r\n> Is there an example in the ethereum codebase that went this way? To avoid this awkward situation under RLP encoding.\r\n\r\nWe've always tried to avoid polymorphism. AFAIK there are only 2 cases in that are live:\r\n\r\n * The receipts prior to Byzantium had intermediate state roots and post Byzantium a status code. The decoding is here: https://github.com/ethereum/go-ethereum/blob/master/core/types/receipt.go#L135\r\n * The headers in the networking protocol can be retrieved either via a number or via a hash. These are stored in the same `origin` field and decoded depending on their size: https://github.com/ethereum/go-ethereum/blob/master/eth/protocol.go#L153\r\n\r\nIn both cases above however decoding is easy, because the \"polymorphism\" is simply \"either a hash or a number\", which is very easily distinguishable based on size.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/601041871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
