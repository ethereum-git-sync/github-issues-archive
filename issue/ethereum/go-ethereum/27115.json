{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/27115",
  "id": 1673505143,
  "node_id": "I_kwDOAOvK985jv6l3",
  "number": 27115,
  "title": "Some thoughts on opSload and dynamic type array slot calculation.",
  "user": {
    "login": "joohhnnn",
    "id": 68833933,
    "node_id": "MDQ6VXNlcjY4ODMzOTMz",
    "avatar_url": "https://avatars.githubusercontent.com/u/68833933?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/joohhnnn",
    "html_url": "https://github.com/joohhnnn",
    "followers_url": "https://api.github.com/users/joohhnnn/followers",
    "following_url": "https://api.github.com/users/joohhnnn/following{/other_user}",
    "gists_url": "https://api.github.com/users/joohhnnn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/joohhnnn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/joohhnnn/subscriptions",
    "organizations_url": "https://api.github.com/users/joohhnnn/orgs",
    "repos_url": "https://api.github.com/users/joohhnnn/repos",
    "events_url": "https://api.github.com/users/joohhnnn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/joohhnnn/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 268304226,
      "node_id": "MDU6TGFiZWwyNjgzMDQyMjY=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:docs",
      "name": "type:docs",
      "color": "fef2c0",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2023-04-18T16:50:03Z",
  "updated_at": "2023-04-19T14:11:41Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "### Background: \r\nI have been pondering why Ethereum has an OPCODE like SELFDESTRUCT to clear the entire storage, but no OPCODE to copy the complete storage from a specified address to a new contract during deployment. After discussing with @jsvisa , we concluded that since slots are calculated based on the contract address, even if the storage is copied, it cannot be used due to the slot calculation rules. This has led me to think more deeply about the issue.\r\n### questionï¼š\r\n1. Why doesn't SLOAD have a specified account (contract) input? Currently, it is impossible to use any OPCODE to access data on a specific slot of another account during EVM runtime. Perhaps we can add an input parameter to SLOAD to achieve this, or introduce a brand new opcode.\r\n2. Ethereum may adopt Verkle trees in the future. When calculating the storage location for dynamic data types, the contract address is involved. My understanding is that this design was initially intended to prevent hash collisions and enhance security (this is just my personal speculation; there may be deeper reasons). However, considering the development timeline for Verkle trees, it is unlikely that hash collisions could be caused by computational power. Using a fixed value instead of the contract address to participate in slot calculations could not only optimize performance but also facilitate future expansion (e.g., replicating the entire storage for data migration or adding new SLOAD functionality mentioned above). Keeping forked code slots consistent would be beneficial for the development of fork-based derivatives, aggregators, etc., such as those seen with Uniswap.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514460407",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27115#issuecomment-1514460407",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115",
    "id": 1514460407,
    "node_id": "IC_kwDOAOvK985aRNT3",
    "user": {
      "login": "s1na",
      "id": 1591639,
      "node_id": "MDQ6VXNlcjE1OTE2Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1591639?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/s1na",
      "html_url": "https://github.com/s1na",
      "followers_url": "https://api.github.com/users/s1na/followers",
      "following_url": "https://api.github.com/users/s1na/following{/other_user}",
      "gists_url": "https://api.github.com/users/s1na/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/s1na/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/s1na/subscriptions",
      "organizations_url": "https://api.github.com/users/s1na/orgs",
      "repos_url": "https://api.github.com/users/s1na/repos",
      "events_url": "https://api.github.com/users/s1na/events{/privacy}",
      "received_events_url": "https://api.github.com/users/s1na/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-19T09:59:08Z",
    "updated_at": "2023-04-19T09:59:08Z",
    "author_association": "MEMBER",
    "body": "What you raise here is not directly related to go-ethereum. They are questions about the protocol and would be best discussed on Eth R&D channels or ethresear.ch.\r\n\r\nAnd while I'm not the best person to answer these questions I'll take a stab at writing a short comment:\r\n\r\n- As for SCOPYALL: There are plans to drop SELFDESTRUCT, in fact as of Shanghai it is already [\"deprecated\"](https://eips.ethereum.org/EIPS/eip-6049). The main reason why it will be dropped is because SELFDESTRUCT is the only opcode which has a variable resource requirement. Imagine having to remove a contract with many slots. The opcode you propose (say SCOPYALL) has the same issue.\r\n- I don't understand the point of allowing a contract to directly read storage of other accounts. It can call functions of the target contract and get the data it needs. And if a storage slot is not exposed in the interface of the target contract, well maybe there's a reason for it.\r\n- The biggest reason for a switch to verkle is in fact not avoiding hash collisions, rather allowing for stateless ethereum. I.e. being able to prove parts of state cheaply. MPT proofs are heavyweight.\r\n- Storage slots belong to contracts. It is required to hash together the contract address with the slot to be able to distinguish between slot 0x00...1 of contract A and B.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514460407/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514513448",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27115#issuecomment-1514513448",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115",
    "id": 1514513448,
    "node_id": "IC_kwDOAOvK985aRaQo",
    "user": {
      "login": "joohhnnn",
      "id": 68833933,
      "node_id": "MDQ6VXNlcjY4ODMzOTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/68833933?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/joohhnnn",
      "html_url": "https://github.com/joohhnnn",
      "followers_url": "https://api.github.com/users/joohhnnn/followers",
      "following_url": "https://api.github.com/users/joohhnnn/following{/other_user}",
      "gists_url": "https://api.github.com/users/joohhnnn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/joohhnnn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/joohhnnn/subscriptions",
      "organizations_url": "https://api.github.com/users/joohhnnn/orgs",
      "repos_url": "https://api.github.com/users/joohhnnn/repos",
      "events_url": "https://api.github.com/users/joohhnnn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/joohhnnn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-19T10:40:53Z",
    "updated_at": "2023-04-19T10:45:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "First of all, I apologize for not asking the question in the right place, and I appreciate your  @s1na \r\n\r\n1. Indeed, earlier today, I saw gballet's post about several Verkle tree migration methods. It seems that Verkle trees are coming sooner than expected, and operations based on MPT trees might not be suitable anymore.\r\n2. During development, directly reading specific slots can save some gas compared to calling functions (by avoiding gas consumption from processes like function selector traversal). Moreover, some fields might be needed for secondary development but not exposed by the original contract through functions.\r\n3. I agree with that. Apologies for the confusion earlier. but I was saying using the contract address to participate in slot calculation helps avoid hash collisions, rather than Verkle trees themselves. This point is indeed somewhat related to question four below\r\n4. I am a bit confused. When reading slots, isn't the specific contract located first? In which scenarios do we need to distinguish between different slots like 0x00...1?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514513448/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514660960",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27115#issuecomment-1514660960",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115",
    "id": 1514660960,
    "node_id": "IC_kwDOAOvK985aR-Rg",
    "user": {
      "login": "s1na",
      "id": 1591639,
      "node_id": "MDQ6VXNlcjE1OTE2Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1591639?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/s1na",
      "html_url": "https://github.com/s1na",
      "followers_url": "https://api.github.com/users/s1na/followers",
      "following_url": "https://api.github.com/users/s1na/following{/other_user}",
      "gists_url": "https://api.github.com/users/s1na/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/s1na/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/s1na/subscriptions",
      "organizations_url": "https://api.github.com/users/s1na/orgs",
      "repos_url": "https://api.github.com/users/s1na/repos",
      "events_url": "https://api.github.com/users/s1na/events{/privacy}",
      "received_events_url": "https://api.github.com/users/s1na/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-19T12:36:55Z",
    "updated_at": "2023-04-19T12:36:55Z",
    "author_association": "MEMBER",
    "body": "I'll ask a clarifying question. What are you referring to by slot calculation, e.g. in this sentence: \"When calculating the storage location for dynamic data types, the contract address is involved\"?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514660960/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514808721",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27115#issuecomment-1514808721",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27115",
    "id": 1514808721,
    "node_id": "IC_kwDOAOvK985aSiWR",
    "user": {
      "login": "joohhnnn",
      "id": 68833933,
      "node_id": "MDQ6VXNlcjY4ODMzOTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/68833933?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/joohhnnn",
      "html_url": "https://github.com/joohhnnn",
      "followers_url": "https://api.github.com/users/joohhnnn/followers",
      "following_url": "https://api.github.com/users/joohhnnn/following{/other_user}",
      "gists_url": "https://api.github.com/users/joohhnnn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/joohhnnn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/joohhnnn/subscriptions",
      "organizations_url": "https://api.github.com/users/joohhnnn/orgs",
      "repos_url": "https://api.github.com/users/joohhnnn/repos",
      "events_url": "https://api.github.com/users/joohhnnn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/joohhnnn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-19T14:11:41Z",
    "updated_at": "2023-04-19T14:11:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I'll ask a clarifying question. What are you referring to by slot calculation, e.g. in this sentence: \"When calculating the storage location for dynamic data types, the contract address is involved\"?\r\n\r\nohhhhhh, No worries at all! I just get momentarily confused between the slot's position in the EVM and its position in LevelDB (contract address + MPT node hash).\r\nNow let's focus on question two, concerning directly reading the value of a specific slot in a specific contract. Currently, many frameworks, such as Foundry, have a `getStorageAt() `function. However, sometimes during dApp development, it is necessary to access values that are not exposed through functions in runtime.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1514808721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
