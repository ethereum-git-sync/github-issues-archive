{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/26954",
  "id": 1635883790,
  "node_id": "I_kwDOAOvK985hgZsO",
  "number": 26954,
  "title": "May the header height fall back after crash?",
  "user": {
    "login": "jongrun",
    "id": 31625057,
    "node_id": "MDQ6VXNlcjMxNjI1MDU3",
    "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jongrun",
    "html_url": "https://github.com/jongrun",
    "followers_url": "https://api.github.com/users/jongrun/followers",
    "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
    "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
    "organizations_url": "https://api.github.com/users/jongrun/orgs",
    "repos_url": "https://api.github.com/users/jongrun/repos",
    "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jongrun/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2023-03-22T14:31:12Z",
  "updated_at": "2023-03-22T15:16:44Z",
  "closed_at": "2023-03-22T14:46:00Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Does it mean that the header height may fall back when geth crashes and restarts? If so, a user of node service can not have the assumption that the height is ascending unless reorg. Is my understanding correct?\r\nhttps://github.com/ethereum/go-ethereum/blob/e5eb32acee19cc9fca6a03b10283b7484246b15a/core/blockchain.go#L291-L317",
  "closed_by": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479701698",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26954#issuecomment-1479701698",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954",
    "id": 1479701698,
    "node_id": "IC_kwDOAOvK985YMnTC",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T14:46:00Z",
    "updated_at": "2023-03-22T14:46:00Z",
    "author_association": "MEMBER",
    "body": "Geth stores a lot of freshly generates dirty state in RAM. We do that because a lot of it will get update or deleted in a few blocks, so it's a lot of saved disk writes. However, if we crash, then all that unwritten data will be lost. To regenerate it, we need to go back to a past point in history where we had the full state and rerun the blocks from there.\r\n\r\nWe're slowly merging a new trie data structure that will not have this aspect, that will be resilient to crashes from a head revertal perspective. Currently however, the head will go back in case of a crash for full nodes, yes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479701698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479759897",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26954#issuecomment-1479759897",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26954",
    "id": 1479759897,
    "node_id": "IC_kwDOAOvK985YM1gZ",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T15:16:05Z",
    "updated_at": "2023-03-22T15:16:44Z",
    "author_association": "NONE",
    "body": "> Geth stores a lot of freshly generates dirty state in RAM. We do that because a lot of it will get update or deleted in a few blocks, so it's a lot of saved disk writes. However, if we crash, then all that unwritten data will be lost. To regenerate it, we need to go back to a past point in history where we had the full state and rerun the blocks from there.\r\n> \r\n> We're slowly merging a new trie data structure that will not have this aspect, that will be resilient to crashes from a head revertal perspective. Currently however, the head will go back in case of a crash for full nodes, yes.\r\n\r\n@karalabe Is it possible that we don't start the rpc service util all blocks between the past point and last height (before crash) finishes to rerun? If so, the head does not go back when viewed from the outside. We don't do like this because the start-up time will be too long?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479759897/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
