{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/20583",
  "id": 552434989,
  "node_id": "MDU6SXNzdWU1NTI0MzQ5ODk=",
  "number": 20583,
  "title": "IPC/Websockets requests continue executing after connection closes",
  "user": {
    "login": "AusIV",
    "id": 977954,
    "node_id": "MDQ6VXNlcjk3Nzk1NA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/977954?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AusIV",
    "html_url": "https://github.com/AusIV",
    "followers_url": "https://api.github.com/users/AusIV/followers",
    "following_url": "https://api.github.com/users/AusIV/following{/other_user}",
    "gists_url": "https://api.github.com/users/AusIV/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AusIV/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AusIV/subscriptions",
    "organizations_url": "https://api.github.com/users/AusIV/orgs",
    "repos_url": "https://api.github.com/users/AusIV/repos",
    "events_url": "https://api.github.com/users/AusIV/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AusIV/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1157707837,
      "node_id": "MDU6TGFiZWwxMTU3NzA3ODM3",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/area:rpc",
      "name": "area:rpc",
      "color": "d4c5f9",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    {
      "login": "renaynay",
      "id": 41963722,
      "node_id": "MDQ6VXNlcjQxOTYzNzIy",
      "avatar_url": "https://avatars.githubusercontent.com/u/41963722?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/renaynay",
      "html_url": "https://github.com/renaynay",
      "followers_url": "https://api.github.com/users/renaynay/followers",
      "following_url": "https://api.github.com/users/renaynay/following{/other_user}",
      "gists_url": "https://api.github.com/users/renaynay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/renaynay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/renaynay/subscriptions",
      "organizations_url": "https://api.github.com/users/renaynay/orgs",
      "repos_url": "https://api.github.com/users/renaynay/repos",
      "events_url": "https://api.github.com/users/renaynay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/renaynay/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2020-01-20T17:42:35Z",
  "updated_at": "2020-08-13T08:51:06Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "#### System information\r\n\r\nGeth\r\nVersion: 1.9.9-stable\r\nArchitecture: amd64\r\nProtocol Versions: [64 63]\r\nGo Version: go1.13.3\r\nOperating System: linux\r\nGOPATH=/home/aroberts/Projects/gopath\r\nGOROOT=/usr/lib/go-1.13\r\n\r\n#### Expected behaviour\r\n\r\nA long running RPC request made via IPC, such as `{\"jsonrpc\":\"2.0\",\"id\":547951,\"method\":\"eth_getLogs\",\"params\":[{\"fromBlock\":\"0x0\",\"toBlock\":\"latest\"}]}` should stop executing if the IPC connection is closed. This is the behavior for HTTP.\r\n\r\n#### Actual behaviour\r\n\r\nThe RPC requests continues executing until the response is calculated.\r\n\r\n#### Steps to reproduce the behaviour\r\n\r\nRun:\r\n\r\n`echo '{\"jsonrpc\":\"2.0\",\"id\":547951,\"method\":\"eth_getLogs\",\"params\":[{\"fromBlock\":\"0x0\",\"toBlock\":\"latest\"}]}' | nc -U ~/.ethereum/geth.ipc `\r\n\r\nThen Ctrl+C to kill the request. CPU usage remains high until geth finishes processing the request.\r\n\r\n#### Analysis\r\n\r\nI've dug pretty deep into the RPC module to understand why this is happening, why it cancels properly with HTTP but not with IPC. Having looked at not only the code but the Git history, I think there are several things in the RPC module that aren't working as intended.\r\n\r\nStarting with https://github.com/ethereum/go-ethereum/blob/master/rpc/client.go#L554 - Here it seems to be assumed that as soon as an read error is received, that the connection is closed and things should be cleaned up. This doesn't necessarily hold up with IPC. An EOF message can be received, but that only indicates that the last request has been sent; the other end of the IPC connection may still be waiting for a response, and the connection is not actually closed. But when a read error occurs, that takes us to https://github.com/ethereum/go-ethereum/blob/master/rpc/client.go#L118, which in turn takes us to https://github.com/ethereum/go-ethereum/blob/master/rpc/handler.go#L152.\r\n\r\nThe handler.close() function attempts to cancel outstanding requests, waits for the requests to finish executing, cancels the root context for this connection, then closes any subscriptions. The next problem is that `handler.cancelAllRequests()` doesn't seem to actually stop the execution of any outstanding requests, so they run to completion anyway. If you cancel the root context at that point, the processes stemming from this connection will terminate pretty quickly, but we don't necessarily want to do that because in both the HTTP and IPC implementations (and possibly others) the client dispatcher (linked above) can receive an EOF error even while they're still capable of completing the request and sending a response.\r\n\r\nAt one point in the past, the `handler.close()` function attempted to cancel the root context before waiting for requests to finish, but this was changed in [this commit](https://github.com/ethereum/go-ethereum/pull/19430) with relatively little explanation. From what I can gather, it looks like `handler.close()` was getting called erroneously because of EOF errors that don't really mean the connection has closed. The fact that `handler.cancelAllRequests()` doesn't actually stop requests from executing combined with moving the context cancellation after the waitgroup made things work, but in a way that seems rather fragile.\r\n\r\nIt seems to me that properly cancelling requests when the connection that made them gets disconnected need to involve directly monitoring the connection to see if it closed, and cancelling the context when the request closed. Unfortunately, given limitations of the Go net.Conn interface, the only way to really tell if a connection is \"closed\" is to attempt to write to it and see if you get an error - I haven't really found another clean approach that works across the board (though you can send an empty message to see if you get an error).\r\n\r\nI have a viable workaround for my own purposes, but I wanted to bring this up, as the current implementation seems to have several pieces that don't work like I would expect, and fixing some components to work as they seem to be intended would actually cause other things to break.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20583/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
