{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/3379",
  "id": 192294728,
  "node_id": "MDU6SXNzdWUxOTIyOTQ3Mjg=",
  "number": 3379,
  "title": "RFC: Go API handling of missing items",
  "user": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/milestones/42",
    "html_url": "https://github.com/ethereum/go-ethereum/milestone/42",
    "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/milestones/42/labels",
    "id": 2157555,
    "node_id": "MDk6TWlsZXN0b25lMjE1NzU1NQ==",
    "number": 42,
    "title": "1.5.5",
    "description": "",
    "creator": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 38,
    "state": "closed",
    "created_at": "2016-11-25T12:00:10Z",
    "updated_at": "2016-12-15T14:52:05Z",
    "due_on": "2016-12-14T08:00:00Z",
    "closed_at": "2016-12-15T14:52:05Z"
  },
  "comments": 2,
  "created_at": "2016-11-29T14:23:35Z",
  "updated_at": "2016-12-05T19:08:19Z",
  "closed_at": "2016-12-05T19:08:19Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This is a design question about the top-level Go API. What should API methods return if an\r\nitem (block, header, transaction, receipt) does not exist? Package ethclient returns `nil`\r\nfor the item and `nil` as the error, mirroring the RPC API.\r\n\r\nThe decision here will make its way into docs, examples, etc.\r\n\r\n### To err or not to err\r\n\r\n```go\r\nhead, err := client.BlockByHash(ctx, common.Hash{})\r\n// head and err are nil\r\n```\r\n\r\nThis looks fine at first because the non-existence of an item is a special condition that\r\nisn't necessarily an error. But it's also easy to forget and can lead to crash-prone code\r\nbecause each call must check for a nil result before using it.\r\n\r\nAn alternative solution to this is to return a non-nil error in case of non-existence.\r\nCallers already assume that the result is not useable if the error is non-nil, which would\r\nprotect against accidental crashes where the check is missing. But it's still useful to be\r\nable to check for this specific error (similar to `io.EOF`).\r\n\r\n### What should the error look like\r\n\r\nAssuming that we want to add an error for non-existence, these are our options.\r\n Since the API is defined as a set of interfaces and users of the API should avoid depending\r\non a specific implementation, the error must be defined in the top-level ethereum package.\r\n\r\n#### ethereum.NotFound\r\n\r\n```go\r\npackage ethereum\r\n\r\nvar NotFound = errors.New(\"not found\")\r\n```\r\n\r\nThis is the simplest way, mirroring `io.EOF` directly. It's easy to use:\r\n\r\n```go\r\nhead, err := client.BlockByHash(ctx, common.Hash{})\r\nif err != nil && err != ethereum.NotFound {\r\n     ... \r\n}\r\n// head might still be nil, but the check is explicit.\r\n```\r\n\r\n#### NotFound method on error\r\n\r\n```go\r\npackage ethereum\r\n\r\ntype NotFound interface{\r\n    NotFound() bool\r\n}\r\n```\r\n\r\nThis error is more cumbersome to check for, but allows placing contextual information\r\ninto the error (i.e. the message can be different depending on the implementation and\r\ntype of item).\r\n\r\n```go\r\nhead, err := client.BlockByHash(ctx, common.Hash{})\r\nif enf, ok := err.(ethereum.NotFound); ok && enf.NotFound() {\r\n     // now you know\r\n} else if err != nil {\r\n     fmt.Println(\"oops\", err)\r\n}\r\n```\r\n\r\nThis might seem pointless, but can be useful if the error is handled further up\r\nthe call stack. The standard [net package uses this style](https://godoc.org/net#Error) for special conditions.\r\n\r\nWe can even get the easy syntax back with a helper function:\r\n\r\n```go\r\nhead, err := client.BlockByHash(ctx, common.Hash{})\r\nif err != nil && !ethereum.IsNotFound(err) {\r\n     ... \r\n}\r\n// head might still be nil, but the check is explicit.\r\n```\r\n\r\n### What should it be then?\r\n\r\nPlease provide feedback and tell me about your preferred choice.",
  "closed_by": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/263583851",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3379#issuecomment-263583851",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379",
    "id": 263583851,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzU4Mzg1MQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-29T14:27:11Z",
    "updated_at": "2016-11-29T14:27:11Z",
    "author_association": "MEMBER",
    "body": "I prefer `ethereum.NotFound`, personally; as you observe, this mirrors `EOF`, and also how `leveldb` handles nonexistent keys.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/263583851/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/263630912",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/3379#issuecomment-263630912",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/3379",
    "id": 263630912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzYzMDkxMg==",
    "user": {
      "login": "bas-vk",
      "id": 4280775,
      "node_id": "MDQ6VXNlcjQyODA3NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4280775?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bas-vk",
      "html_url": "https://github.com/bas-vk",
      "followers_url": "https://api.github.com/users/bas-vk/followers",
      "following_url": "https://api.github.com/users/bas-vk/following{/other_user}",
      "gists_url": "https://api.github.com/users/bas-vk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bas-vk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bas-vk/subscriptions",
      "organizations_url": "https://api.github.com/users/bas-vk/orgs",
      "repos_url": "https://api.github.com/users/bas-vk/repos",
      "events_url": "https://api.github.com/users/bas-vk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bas-vk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-29T17:01:49Z",
    "updated_at": "2016-11-29T17:01:49Z",
    "author_association": "MEMBER",
    "body": "I dislike the net interface solution.\r\n\r\nIt is possible that a requested resource is actually on the network but the node cannot access it at the time. In that situation returning `nil` describes that situation the best. But I can see this leading to crashes. Therefore I'm slightly in favor of `ethereum.NotFound`.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/263630912/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
