{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/24397",
  "id": 1139318996,
  "node_id": "I_kwDOAOvK985D6KDU",
  "number": 24397,
  "title": "There appears to be a memory leak in RLP after several hours of heavy use",
  "user": {
    "login": "jwinkler2083233",
    "id": 11068226,
    "node_id": "MDQ6VXNlcjExMDY4MjI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/11068226?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jwinkler2083233",
    "html_url": "https://github.com/jwinkler2083233",
    "followers_url": "https://api.github.com/users/jwinkler2083233/followers",
    "following_url": "https://api.github.com/users/jwinkler2083233/following{/other_user}",
    "gists_url": "https://api.github.com/users/jwinkler2083233/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jwinkler2083233/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jwinkler2083233/subscriptions",
    "organizations_url": "https://api.github.com/users/jwinkler2083233/orgs",
    "repos_url": "https://api.github.com/users/jwinkler2083233/repos",
    "events_url": "https://api.github.com/users/jwinkler2083233/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jwinkler2083233/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 13,
  "created_at": "2022-02-15T23:28:15Z",
  "updated_at": "2022-03-28T08:58:37Z",
  "closed_at": "2022-03-28T08:58:37Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "#### System information\r\n\r\nOS & Version: Linux\r\nCommit hash : latest\r\n\r\n#### Expected behaviour\r\n\r\nI would expect RLP allocations to be garbage collected after a few hours of heavy use.\r\n\r\n#### Actual behaviour\r\n\r\n'pprof' is reporting that the 'encbuf.list()' function is allocating memory, and that memory is not getting garbage collected.\r\n\r\nI verified that the allocation done by the only 'append' call in the 'encbuf.list()' method in 'rlp/encode.go' could be eliminated via the use of an additional 'sync.Pool' for 'listhead' objects.  That worked great, I can submit the change if desired.\r\n\r\n#### Steps to reproduce the behaviour\r\n\r\nI enabled memory profiling in my application.\r\nMy application makes heavy use of the 'EncodeToBytes()' public method\r\nI ran a three-hour load test, to see what the GC did, and then ran a memory profile.\r\n\r\nHere is the relevant data from pprof:\r\n\r\n```\r\n(pprof) Showing nodes accounting for 2557379131, 86.13% of 2969340570 total\r\nDropped 1799 nodes (cum <= 14846702)\r\nShowing top 100 nodes out of 162\r\n      flat  flat%   sum%        cum   cum%\r\n 905631166 30.50% 30.50%  905631166 30.50%  github.com/ethereum/go-ethereum/rlp.(*encbuf).list (inline)\r\n 130792360  4.40% 71.80%  130792360  4.40%  github.com/ethereum/go-ethereum/rlp.(*encbuf).toBytes\r\n ```\r\n \r\n The 'toBytes' function doesn't appear to be GC'd either.  I don't have a workaround for that one.  The reason I don't think the GC accessed these objects is because the 'cumulative' value from the 'pprof' output above matches the 'flat' output.  That is not the case for other, smaller, allocations in my test.  The GC worked normally for other objects.  I've run this test several times as well as multiple variations, and I'm seeing similar results, where the 'cumulative' value matches the 'flat' column.\r\n \r\n My theory is that the 'encbuf.reset()' method is somehow creating a shortcut and the sync.Pool loses track of the allocations.\r\n The other alternative I can think of is that there is a bug in pprof, but I doubt that.\r\n \r\n#### Backtrace\r\n\r\n````\r\n[backtrace]\r\n````\r\n\r\nWhen submitting logs: please submit them as text and not screenshots.",
  "closed_by": {
    "login": "fjl",
    "id": 6915,
    "node_id": "MDQ6VXNlcjY5MTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fjl",
    "html_url": "https://github.com/fjl",
    "followers_url": "https://api.github.com/users/fjl/followers",
    "following_url": "https://api.github.com/users/fjl/following{/other_user}",
    "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
    "organizations_url": "https://api.github.com/users/fjl/orgs",
    "repos_url": "https://api.github.com/users/fjl/repos",
    "events_url": "https://api.github.com/users/fjl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fjl/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041243644",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1041243644",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1041243644,
    "node_id": "IC_kwDOAOvK984-EB38",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-16T08:38:30Z",
    "updated_at": "2022-02-16T08:38:30Z",
    "author_association": "MEMBER",
    "body": "Interesting. Does it make any difference if you call `reset()` before returning it to the pool in EncodeToBytes? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041243644/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041501451",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1041501451",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1041501451,
    "node_id": "IC_kwDOAOvK984-FA0L",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-16T13:38:48Z",
    "updated_at": "2022-02-16T14:01:03Z",
    "author_association": "MEMBER",
    "body": "In memory profiles, the 'cumulative' and 'flat' measurements are not related to GC. Rather, what they mean is:\r\n\r\n- 'flat': memory allocated specifically in this function\r\n- 'cumulative': memory allocated in this function and all functions called by it\r\n\r\nThe same is also true for CPU profiles, but instead of memory allocated, it is 'time spent'.\r\n\r\nSince allocation happens directly in `list` and `toBytes` and they do not call other functions that allocate, the flat and cumulative measurements are the same. But this does not mean that memory allocated by these functions can't released by GC. In fact, the reporting of held memory through memory profiles is not super precise because it only reports *where allocation happened* and not how much of the memory is still held.\r\n\r\nI think that, if your load test is about RLP encoding, then it's pretty certain most allocation will happen in package rlp.\r\n\r\nYou can identify whether there is a memory leak by observing the memory held by your process. If the memory is steadily increasing while your load test runs, there is a leak. If possible, please provide a link to your test code, so that we are able to reproduce your issue.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041501451/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041518130",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1041518130",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1041518130,
    "node_id": "IC_kwDOAOvK984-FE4y",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-16T13:57:34Z",
    "updated_at": "2022-02-16T17:19:36Z",
    "author_association": "MEMBER",
    "body": "btw, I think adding a sync.Pool for `listhead` will not help because list headers are not allocated on their own. The slice of list headers in `rlp.encbuf` contains them as values and not pointers, so the allocation you are seeing in the profile is allocation of the slice's backing array when it is extended by `append`. \r\n\r\nIf you allocate the `listhead` value in sync.Pool and then pass the pooled value to append, you are moving the allocation to another function (i.e. 'flat' and 'cumulative' will not match anymore), but it ultimately just allocates more.\r\n\r\nOne thing that should be noted is that `rlp.encbuf` does not have any limits on the size of objects that will be returned to the pool. What I mean is: when you encode a large object where the output contains many RLP lists, the `encbuf` list header slice will be very long at the end of the encoding process. `encbuf` will be returned to the pool with the full slice length. When subsequent encoding operations reuse the buffer, they truncate the `len` of the list header slice to zero, but leave the `cap` as-is, so the backing array will never shrink again.\r\n\r\nI decided on this behavior because it is not trivial to determine when and by how much these internal buffers should shrink. For go-ethereum's RLP encoding needs, this has never been a problem because our encoding operations only create at most single-digit megabytes of output. Also, GC will occasionally empty the pool and thus remove the large buffers. If your use of package rlp involves heavy concurrent encoding with very large outputs, then I would not be surprised to see high memory use. It still doesn't mean there is a leak, but if you are constantly encoding, GC will not empty the pool and those large buffers can stick around for a while.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1041518130/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1048597616",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1048597616",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1048597616,
    "node_id": "IC_kwDOAOvK984-gFRw",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-23T09:37:35Z",
    "updated_at": "2022-02-23T09:37:35Z",
    "author_association": "MEMBER",
    "body": "Seems to a non-issue. Please reopen if it's indeed an issue here somewhere",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1048597616/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1048911082",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1048911082",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1048911082,
    "node_id": "IC_kwDOAOvK984-hRzq",
    "user": {
      "login": "jwinkler2083233",
      "id": 11068226,
      "node_id": "MDQ6VXNlcjExMDY4MjI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/11068226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jwinkler2083233",
      "html_url": "https://github.com/jwinkler2083233",
      "followers_url": "https://api.github.com/users/jwinkler2083233/followers",
      "following_url": "https://api.github.com/users/jwinkler2083233/following{/other_user}",
      "gists_url": "https://api.github.com/users/jwinkler2083233/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jwinkler2083233/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jwinkler2083233/subscriptions",
      "organizations_url": "https://api.github.com/users/jwinkler2083233/orgs",
      "repos_url": "https://api.github.com/users/jwinkler2083233/repos",
      "events_url": "https://api.github.com/users/jwinkler2083233/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jwinkler2083233/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-23T15:35:30Z",
    "updated_at": "2022-02-23T15:35:30Z",
    "author_association": "NONE",
    "body": "Thank you for the comments.\r\nI'll have to create a minimum example to prove my point.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1048911082/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1049859893",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1049859893",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1049859893,
    "node_id": "IC_kwDOAOvK984-k5c1",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-24T13:26:58Z",
    "updated_at": "2022-02-24T13:26:58Z",
    "author_association": "MEMBER",
    "body": "Yeah, closing the ticket was a bit premature. I'm happy to check out your example!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1049859893/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1050368184",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1050368184",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1050368184,
    "node_id": "IC_kwDOAOvK984-m1i4",
    "user": {
      "login": "jwinkler2083233",
      "id": 11068226,
      "node_id": "MDQ6VXNlcjExMDY4MjI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/11068226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jwinkler2083233",
      "html_url": "https://github.com/jwinkler2083233",
      "followers_url": "https://api.github.com/users/jwinkler2083233/followers",
      "following_url": "https://api.github.com/users/jwinkler2083233/following{/other_user}",
      "gists_url": "https://api.github.com/users/jwinkler2083233/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jwinkler2083233/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jwinkler2083233/subscriptions",
      "organizations_url": "https://api.github.com/users/jwinkler2083233/orgs",
      "repos_url": "https://api.github.com/users/jwinkler2083233/repos",
      "events_url": "https://api.github.com/users/jwinkler2083233/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jwinkler2083233/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-24T23:42:44Z",
    "updated_at": "2022-02-24T23:53:40Z",
    "author_association": "NONE",
    "body": "This is just a draft, but it's closer to how I'd do this in native code (C++).  I noticed a recent change that added an encbuffer.go file and an 'internal' directory.  I haven't integrated those changes yet:\r\n\r\nhttps://github.com/onflow/flow-go/blob/a42e624e8b77ce819e053e328485a5703374adcd/model/flow/rlp/encode.go\r\n\r\nMy tests are showing a 1.5% speed improvement, along with a drop in heap usage.  Your mileage may vary..\r\n\r\nI'm still wondering how the 'append' method would increase the backing store by so much over time, for the original version.  When I modified it to store pointers instead, it dropped to zero.\r\n\r\nLet me know if you like it, and I'll put together a formal PR.   thx",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1050368184/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1050723406",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1050723406",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1050723406,
    "node_id": "IC_kwDOAOvK984-oMRO",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-25T10:19:35Z",
    "updated_at": "2022-02-25T12:16:09Z",
    "author_association": "MEMBER",
    "body": "Hmm, so now you are talking about optimizations though.\r\n\r\nThis issue was originally about a 'leak'. Can you provide a code example (it can be your entire application) that exhibits a memory leak related to package rlp? And by leak, I mean *unbounded* heap growth.\r\n\r\n> I'm still wondering how the 'append' method would increase the backing store by so much over time, for the\r\n> original version. When I modified it to store pointers instead, it dropped to zero.\r\n\r\nI would like to know how you arrive at this conclusion (\"dropped to zero\"). `append` will always allocate if the existing slice capacity is not sufficient to hold another item. It doesn't matter whether the slice holds pointers or not. Specifically, `append` in Go grows slices by doubling their capacity, i.e. `append(slice, x)` is equivalent to\r\n\r\n```\r\nfunc append(slice []X, x X) []X {\r\n    if len(slice) == cap(slice) {\r\n        newslice := make([]X, cap(slice)*2)\r\n        copy(newslice, slice)\r\n        slice = newslice[:len(slice)]\r\n    }\r\n    end := len(slice)\r\n    slice = slice[:end+1]\r\n    slice[end] = x\r\n    return slice\r\n}\r\n```\r\n\r\n\r\nPlease provide additional data about your use of package rlp. For example, you could sample and collect the list header slice `len` and `cap` at the end of encoding and then provide the data here.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1050723406/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1051397468",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1051397468",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1051397468,
    "node_id": "IC_kwDOAOvK984-qw1c",
    "user": {
      "login": "jwinkler2083233",
      "id": 11068226,
      "node_id": "MDQ6VXNlcjExMDY4MjI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/11068226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jwinkler2083233",
      "html_url": "https://github.com/jwinkler2083233",
      "followers_url": "https://api.github.com/users/jwinkler2083233/followers",
      "following_url": "https://api.github.com/users/jwinkler2083233/following{/other_user}",
      "gists_url": "https://api.github.com/users/jwinkler2083233/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jwinkler2083233/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jwinkler2083233/subscriptions",
      "organizations_url": "https://api.github.com/users/jwinkler2083233/orgs",
      "repos_url": "https://api.github.com/users/jwinkler2083233/repos",
      "events_url": "https://api.github.com/users/jwinkler2083233/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jwinkler2083233/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-26T00:34:03Z",
    "updated_at": "2022-02-26T21:18:51Z",
    "author_association": "NONE",
    "body": "Exactly.  I'm going by what the profiler is reporting.  When I changed 'list()' to use pointers, the apparent memory leak went away, according to pprof.  By using pointers in the 'lheads' slice, I was able to store/reuse pointers to 'listhead' objects that were retrieved from sync.Pool.  What's odd is that the pointers should have taken up the same amount of space as the list head object (8 bytes for a 64-bit pointer), and the pointers were allocated via append(), but the memory they used didn't even register with pprof.\r\nIt's possible that the garbage collector has something to do with this.  Maybe it's tuned to skip over the 'listhead'-style allocations because they're values.  \r\nThe impetus for this is that our servers are overloaded with billions of small allocations, and then the garbage collection eventually takes up > 30% of CPU.\r\n\r\nHere's the latest before and after comparison.\r\n\r\nBefore:\r\n```\r\n(pprof) Showing nodes accounting for 96635006, 82.81% of 116700167 total\r\nDropped 989 nodes (cum <= 583500)\r\nShowing top 100 nodes out of 226\r\nflat  flat%   sum%        cum   cum%\r\n28836259 24.71% 24.71%   28836259 24.71%  [github.com/ethereum/go-ethereum/rlp.(*encbuf](http://github.com/ethereum/go-ethereum/rlp.(*encbuf)).list (inline)\r\n4239344  3.63% 63.58%    4239344  3.63%  [github.com/ethereum/go-ethereum/rlp.(*encbuf](http://github.com/ethereum/go-ethereum/rlp.(*encbuf)).toBytes\r\n```\r\n\r\nAfter:\r\n```\r\n(pprof) Showing nodes accounting for 1713208044, 82.77% of 2069818576 total\r\nDropped 1757 nodes (cum <= 10349092)\r\nShowing top 100 nodes out of 183\r\n      flat  flat%   sum%        cum   cum%\r\n 128612311  6.21% 58.03%  132281690  6.39%  github.com/onflow/flow-go/model/flow/rlp.EncodeToBytes\r\n ```\r\n \r\n As you can see, the percentage dropped from (24.7 + 3.6 = 28.3%), to 6.4%",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1051397468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069117377",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1069117377",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1069117377,
    "node_id": "IC_kwDOAOvK984_uW_B",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-03-16T13:16:26Z",
    "updated_at": "2022-03-16T13:22:03Z",
    "author_association": "MEMBER",
    "body": "> What's odd is that the pointers should have taken up the same amount of space as the list head object (8 bytes for a 64-bit pointer),\r\n\r\nA listhead is a struct with two ints, so `16 bytes`. The pointer is `8` bytes. So a pointer is only half the size. And if you pool the listheads, avoiding those allocs, then I'm not surprised you see a drop in allocs. Am I missing something? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069117377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069130640",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1069130640",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1069130640,
    "node_id": "IC_kwDOAOvK984_uaOQ",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-03-16T13:29:15Z",
    "updated_at": "2022-03-16T13:29:15Z",
    "author_association": "MEMBER",
    "body": "I still don't understand this issue.\r\n\r\nAs mentioned earlier, I think our existing pooling strategy should cover this: When encoding, a `encBuffer` instance is taken from the pool, then used, growing `encBuffer.lheads`. After encoding, the buffer instance is returned back into the pool. When encoding is heavily used, all pooled `encBuffer` instances will have reasonably-sized `lheads` and no allocation should happen at all.\r\n\r\nMy own profiling of geth itself confirmed this in the past, we don't usually allocate much in `encBuffer.list`. However, in the profile shown here, there is significant allocation in this method.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069130640/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069146288",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1069146288",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1069146288,
    "node_id": "IC_kwDOAOvK984_ueCw",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-03-16T13:43:33Z",
    "updated_at": "2022-03-16T13:58:37Z",
    "author_association": "MEMBER",
    "body": "@jwinkler2083233 What I would really like to see is a report of `encBuffer` sizes before and after encoding.\r\n\r\nTo get this, you could apply this change for example: \r\n\r\nhttps://github.com/fjl/go-ethereum/commit/a51db444cf38d1347c448956579f81dd0db17b84\r\n\r\nAnd then observe the metrics somehow.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069146288/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069165940",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/24397#issuecomment-1069165940",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/24397",
    "id": 1069165940,
    "node_id": "IC_kwDOAOvK984_ui10",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-03-16T14:03:44Z",
    "updated_at": "2022-03-17T11:25:59Z",
    "author_association": "MEMBER",
    "body": "One more thing:\r\n\r\nOn the go-ethereum master branch, the recent changes in package rlp permit doing manual encoder buffer management, like this:\r\n\r\n\r\n```go\r\n\r\nvar (\r\n    buf = rlp.NewEncoderBuffer(nil)\r\n    encbytes []byte\r\n)\r\n\r\nfor {\r\n    buf.Reset(nil)\r\n    err := rlp.Encode(buf, value)\r\n    if err != nil {\r\n         // handle it\r\n    }\r\n    encbytes = buf.AppendToBytes(encbytes[:0])\r\n    // here, encbytes contains the RLP encoding of value\r\n}\r\n```\r\n\r\nUsing it like this will for sure allocate less.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1069165940/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
