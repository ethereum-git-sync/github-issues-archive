{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/21818",
  "id": 740168235,
  "node_id": "MDU6SXNzdWU3NDAxNjgyMzU=",
  "number": 21818,
  "title": "go routine leaks when deploying a contract",
  "user": {
    "login": "krasi-georgiev",
    "id": 8903888,
    "node_id": "MDQ6VXNlcjg5MDM4ODg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8903888?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/krasi-georgiev",
    "html_url": "https://github.com/krasi-georgiev",
    "followers_url": "https://api.github.com/users/krasi-georgiev/followers",
    "following_url": "https://api.github.com/users/krasi-georgiev/following{/other_user}",
    "gists_url": "https://api.github.com/users/krasi-georgiev/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/krasi-georgiev/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/krasi-georgiev/subscriptions",
    "organizations_url": "https://api.github.com/users/krasi-georgiev/orgs",
    "repos_url": "https://api.github.com/users/krasi-georgiev/repos",
    "events_url": "https://api.github.com/users/krasi-georgiev/events{/privacy}",
    "received_events_url": "https://api.github.com/users/krasi-georgiev/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233655,
      "node_id": "MDU6TGFiZWw3MjIzMzY1NQ==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:wontfix",
      "name": "status:wontfix",
      "color": "ffffff",
      "default": false,
      "description": null
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2020-11-10T19:05:29Z",
  "updated_at": "2022-02-17T17:14:08Z",
  "closed_at": "2020-11-26T09:38:58Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "`goleak.VerifyTestMain` tracks goroutines and shows few leaks. this is probably not easy to solve, but it is worth looking into.\r\n\r\n```\r\n// Copyright (c) The Tellor Authors.\r\n// Licensed under the MIT License.\r\n\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"math/big\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\r\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind/backends\"\r\n\t\"github.com/ethereum/go-ethereum/core\"\r\n\t\"github.com/ethereum/go-ethereum/crypto\"\r\n\t\"go.uber.org/goleak\"\r\n)\r\n\r\n// TestMain check for goroutine leaks.\r\n// It ensures that at the end of the tests there are no remaining go routines.\r\nfunc TestMain(m *testing.M) {\r\n\tgoleak.VerifyTestMain(m)\r\n}\r\n\r\nfunc TestProfitCalc(t *testing.T) {\r\n\t// Generate a new random account and a funded simulator\r\n\tkey, err := crypto.GenerateKey()\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\tauth := bind.NewKeyedTransactor(key)\r\n\r\n\tsim := backends.NewSimulatedBackend(core.GenesisAlloc{auth.From: {Balance: big.NewInt(10000000000)}}, 100000000000000000)\r\n\r\n\t// Deploy a token contract on the simulated blockchain\r\n\t_, tx, tellor, err := DeployMyToken(auth, sim, new(big.Int), \"Simulated blockchain tokens\", 0, \"SBT\")\r\n\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\t// Print the current (non existent) and pending name of the contract\r\n\tname, _ := tellor.Name(nil)\r\n\tfmt.Println(\"Pre-mining name:\", name)\r\n\r\n\tname, _ = tellor.Name(&bind.CallOpts{Pending: true})\r\n\tfmt.Println(\"Pre-mining pending name:\", name)\r\n\r\n\t// Commit all pending transactions in the simulator and print the names again\r\n\tsim.Commit()\r\n\r\n\tname, _ = tellor.Name(nil)\r\n\tfmt.Println(\"Post-mining name:\", name)\r\n\r\n\tname, _ = tellor.Name(&bind.CallOpts{Pending: true})\r\n\tfmt.Println(\"Post-mining pending name:\", name)\r\n\r\n\trcpt, err := bind.WaitMined(context.Background(), sim, tx)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\tif rcpt.Status != 1 {\r\n\t\tt.Fatal(\"deploy transaction failed\")\r\n\t}\r\n}\r\n\r\n```\r\n\r\nThis is the code from Blockchain simulator in https://geth.ethereum.org/docs/dapp/native-bindings\r\n\r\nIt downloads the latest available versions of all dependencies.\r\n\r\nand here is the output\r\n\r\n<details>\r\n<summary>Details</summary>\r\n\r\n```\r\n=== RUN   TestProfitCalc\r\nPre-mining name: \r\nPre-mining pending name: Simulated blockchain tokens\r\nPost-mining name: Simulated blockchain tokens\r\nPost-mining pending name: Simulated blockchain tokens\r\n--- PASS: TestProfitCalc (0.01s)\r\nPASS\r\ngoleak: Errors on successful test run: found unexpected goroutines:\r\n[Goroutine 8 in state chan receive, with github.com/rjeczalik/notify.(*nonrecursiveTree).dispatch on top of the stack:\r\ngoroutine 8 [chan receive]:\r\ngithub.com/rjeczalik/notify.(*nonrecursiveTree).dispatch(0xc00007ed20, 0xc00007ec60)\r\n\t/home/krasi/pkg/mod/github.com/rjeczalik/notify@v0.9.1/tree_nonrecursive.go:36 +0xb6\r\ncreated by github.com/rjeczalik/notify.newNonrecursiveTree\r\n\t/home/krasi/pkg/mod/github.com/rjeczalik/notify@v0.9.1/tree_nonrecursive.go:29 +0xe5\r\n\r\n Goroutine 9 in state chan receive, with github.com/rjeczalik/notify.(*nonrecursiveTree).internal on top of the stack:\r\ngoroutine 9 [chan receive]:\r\ngithub.com/rjeczalik/notify.(*nonrecursiveTree).internal(0xc00007ed20, 0xc00007ecc0)\r\n\t/home/krasi/pkg/mod/github.com/rjeczalik/notify@v0.9.1/tree_nonrecursive.go:81 +0x58\r\ncreated by github.com/rjeczalik/notify.newNonrecursiveTree\r\n\t/home/krasi/pkg/mod/github.com/rjeczalik/notify@v0.9.1/tree_nonrecursive.go:30 +0x111\r\n\r\n Goroutine 10 in state chan receive, with github.com/ethereum/go-ethereum/metrics.(*meterArbiter).tick on top of the stack:\r\ngoroutine 10 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/metrics.(*meterArbiter).tick(0x1242f00)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/metrics/meter.go:290 +0x7d\r\ncreated by github.com/ethereum/go-ethereum/metrics.NewMeterForced\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/metrics/meter.go:71 +0x105\r\n\r\n Goroutine 11 in state select, with github.com/ethereum/go-ethereum/consensus/ethash.(*remoteSealer).loop on top of the stack:\r\ngoroutine 11 [select]:\r\ngithub.com/ethereum/go-ethereum/consensus/ethash.(*remoteSealer).loop(0xc0002562d0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/consensus/ethash/sealer.go:278 +0x25c\r\ncreated by github.com/ethereum/go-ethereum/consensus/ethash.startRemoteSealer\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/consensus/ethash/sealer.go:262 +0x2b2\r\n\r\n Goroutine 12 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 12 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 13 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 13 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 14 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 14 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 15 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 15 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 16 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 16 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 18 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 18 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 19 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 19 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 20 in state chan receive, with github.com/ethereum/go-ethereum/core.(*txSenderCacher).cache on top of the stack:\r\ngoroutine 20 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core.(*txSenderCacher).cache(0xc00034cfe0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:63 +0x97\r\ncreated by github.com/ethereum/go-ethereum/core.newTxSenderCacher\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/tx_cacher.go:55 +0x9f\r\n\r\n Goroutine 36 in state select, with github.com/ethereum/go-ethereum/core.(*BlockChain).update on top of the stack:\r\ngoroutine 36 [select]:\r\ngithub.com/ethereum/go-ethereum/core.(*BlockChain).update(0xc00009d900)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/blockchain.go:2213 +0x115\r\ncreated by github.com/ethereum/go-ethereum/core.NewBlockChain\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/blockchain.go:345 +0xdab\r\n\r\n Goroutine 66 in state chan receive, with github.com/ethereum/go-ethereum/core/state/snapshot.(*diskLayer).generate on top of the stack:\r\ngoroutine 66 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/core/state/snapshot.(*diskLayer).generate(0xc000120000, 0xc000122000)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/state/snapshot/generate.go:277 +0x1b66\r\ncreated by github.com/ethereum/go-ethereum/core/state/snapshot.generateSnapshot\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/core/state/snapshot/generate.go:114 +0x23f\r\n\r\n Goroutine 67 in state chan receive, with github.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1 on top of the stack:\r\ngoroutine 67 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1(0xc00011e0c0, 0x0, 0x0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/accounts/abi/bind/backends/simulated.go:790 +0x34\r\ngithub.com/ethereum/go-ethereum/event.NewSubscription.func1(0xc000138060, 0xcb20b8)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/event/subscription.go:53 +0x66\r\ncreated by github.com/ethereum/go-ethereum/event.NewSubscription\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/event/subscription.go:51 +0xc5\r\n\r\n Goroutine 68 in state chan receive, with github.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1 on top of the stack:\r\ngoroutine 68 [chan receive]:\r\ngithub.com/ethereum/go-ethereum/accounts/abi/bind/backends.nullSubscription.func1(0xc00011e360, 0x0, 0x0)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/accounts/abi/bind/backends/simulated.go:790 +0x34\r\ngithub.com/ethereum/go-ethereum/event.NewSubscription.func1(0xc0001380e0, 0xcb20b8)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/event/subscription.go:53 +0x66\r\ncreated by github.com/ethereum/go-ethereum/event.NewSubscription\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/event/subscription.go:51 +0xc5\r\n\r\n Goroutine 69 in state select, with github.com/ethereum/go-ethereum/eth/filters.(*EventSystem).eventLoop on top of the stack:\r\ngoroutine 69 [select]:\r\ngithub.com/ethereum/go-ethereum/eth/filters.(*EventSystem).eventLoop(0xc0003e0000)\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/eth/filters/filter_system.go:459 +0x4cc\r\ncreated by github.com/ethereum/go-ethereum/eth/filters.NewEventSystem\r\n\t/home/krasi/pkg/mod/github.com/ethereum/go-ethereum@v1.9.23/eth/filters/filter_system.go:138 +0x345\r\n]\r\nFAIL\tgithub.com/tellor-io/TellorDocs\t0.471s\r\nFAIL\r\n\r\n```\r\n\r\n</details>",
  "closed_by": {
    "login": "ligi",
    "id": 111600,
    "node_id": "MDQ6VXNlcjExMTYwMA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/111600?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ligi",
    "html_url": "https://github.com/ligi",
    "followers_url": "https://api.github.com/users/ligi/followers",
    "following_url": "https://api.github.com/users/ligi/following{/other_user}",
    "gists_url": "https://api.github.com/users/ligi/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ligi/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ligi/subscriptions",
    "organizations_url": "https://api.github.com/users/ligi/orgs",
    "repos_url": "https://api.github.com/users/ligi/repos",
    "events_url": "https://api.github.com/users/ligi/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ligi/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/725277046",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-725277046",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 725277046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNTI3NzA0Ng==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-11T08:18:00Z",
    "updated_at": "2020-11-11T08:18:00Z",
    "author_association": "MEMBER",
    "body": "core/tx_cacher.go: \r\n```golang\r\n// senderCacher is a concurrent transaction sender recoverer and cacher.\r\nvar senderCacher = newTxSenderCacher(runtime.NumCPU())\r\n```\r\nThat one is used by both `blockchain` during block insertion, and the `txpool`. I guess it could be initialized using `sync.Once` when initializing either one of them, instead of always doing it. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/725277046/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734187518",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734187518",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734187518,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDE4NzUxOA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T09:37:44Z",
    "updated_at": "2020-11-26T09:37:44Z",
    "author_association": "MEMBER",
    "body": "The `tx_cacher` is actually fine, it's a global variable `var senderCacher = newTxSenderCacher(runtime.NumCPU())` -- that's why there's eight of them. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734187518/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734188288",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734188288",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734188288,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDE4ODI4OA==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T09:39:12Z",
    "updated_at": "2020-11-26T09:39:12Z",
    "author_association": "MEMBER",
    "body": "Adding shutdown hooks for libraries will just complicate things",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734188288/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734297210",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734297210",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734297210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDI5NzIxMA==",
    "user": {
      "login": "krasi-georgiev",
      "id": 8903888,
      "node_id": "MDQ6VXNlcjg5MDM4ODg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8903888?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/krasi-georgiev",
      "html_url": "https://github.com/krasi-georgiev",
      "followers_url": "https://api.github.com/users/krasi-georgiev/followers",
      "following_url": "https://api.github.com/users/krasi-georgiev/following{/other_user}",
      "gists_url": "https://api.github.com/users/krasi-georgiev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/krasi-georgiev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/krasi-georgiev/subscriptions",
      "organizations_url": "https://api.github.com/users/krasi-georgiev/orgs",
      "repos_url": "https://api.github.com/users/krasi-georgiev/repos",
      "events_url": "https://api.github.com/users/krasi-georgiev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/krasi-georgiev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T13:25:32Z",
    "updated_at": "2020-11-26T13:26:35Z",
    "author_association": "NONE",
    "body": "IIUC you prefer to leave the leaking go routines over adding shutdown logic? Just want to make sure I understand your decision.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734297210/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734311833",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734311833",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734311833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDMxMTgzMw==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T13:55:33Z",
    "updated_at": "2020-11-26T13:55:33Z",
    "author_association": "MEMBER",
    "body": "Yes, the 'leaks' are just a few routines that will live until the program terminates. It costs a few kb in memory, but goroutines aren't full threads so it doesn't really matter whether there are a few extra ones in existence, basically. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734311833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734312173",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734312173",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734312173,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDMxMjE3Mw==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T13:56:15Z",
    "updated_at": "2020-11-26T13:56:15Z",
    "author_association": "MEMBER",
    "body": "I originally thought that the `tx_fetcher` goutines would be piled up when e.g. instantiating blockchain. But that wasn't the case",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734312173/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734414033",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734414033",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734414033,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDQxNDAzMw==",
    "user": {
      "login": "krasi-georgiev",
      "id": 8903888,
      "node_id": "MDQ6VXNlcjg5MDM4ODg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8903888?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/krasi-georgiev",
      "html_url": "https://github.com/krasi-georgiev",
      "followers_url": "https://api.github.com/users/krasi-georgiev/followers",
      "following_url": "https://api.github.com/users/krasi-georgiev/following{/other_user}",
      "gists_url": "https://api.github.com/users/krasi-georgiev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/krasi-georgiev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/krasi-georgiev/subscriptions",
      "organizations_url": "https://api.github.com/users/krasi-georgiev/orgs",
      "repos_url": "https://api.github.com/users/krasi-georgiev/repos",
      "events_url": "https://api.github.com/users/krasi-georgiev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/krasi-georgiev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T17:20:38Z",
    "updated_at": "2020-11-26T23:44:53Z",
    "author_association": "NONE",
    "body": "but at shutdown, all of these should also be removed, no? If that complicates the code execution too much I agree that it is not worth the hassle, just a good common practice.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734414033/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734424336",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734424336",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734424336,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDQyNDMzNg==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T17:49:18Z",
    "updated_at": "2020-11-26T17:49:18Z",
    "author_association": "MEMBER",
    "body": "So, let's  use this as an example: https://github.com/ethereum/go-ethereum/blob/9940d93a43bab1f060e8fbfadff510c3298f2726/core/tx_cacher.go#L26\r\n\r\n```\r\n// senderCacher is a concurrent transaction sender recoverer and cacher.\r\nvar senderCacher = newTxSenderCacher(runtime.NumCPU())\r\n```\r\n\r\nIt lives in the global context, and this spawns numcpu (in your case `8`) goroutines which sit idle. We don't worry about them, they do their work in the background, and when the go runtime exits, they simply die. \r\nFor `geth`, this is totally what we want. \r\n\r\nNow, if someone wants to use go-ethereum  as a library, it's fully possible that these 8 goroutines are unnecessary, and, as you observed, stay alive even after whatever call you wanted to make inside the go-ethereum-codebase is over and done with. They'll die eventually when your program exits, but from a niceness-perspective, it's a couple of extra idle goroutines that _strictly speaking_ wouldn't be needed. \r\n\r\nIf we were to fix that, we'd have to remove them from the global scope, and instead tie them to e.g. an instance of a `blockchain`. We would then also extend this little listenere (https://github.com/ethereum/go-ethereum/blob/9940d93a43bab1f060e8fbfadff510c3298f2726/core/tx_cacher.go#L63 ) to also check some shutdown-channel, so that they'd be torn down when the blockchain is torn down. \r\n\r\nIt's basically a lot of hassle that doesn't improve `geth`, but make go-ethereum ever so slightly more well-behaving when used as a library. \r\n\r\nIt's a very well-behaving \"leak\" -- usually a \"leak\" means that some resource is being drip-drained, and more resources lost as time goes by. This is just a constant little penalty of using go-ethereum as a library ;-) \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734424336/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734509423",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-734509423",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 734509423,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDUwOTQyMw==",
    "user": {
      "login": "krasi-georgiev",
      "id": 8903888,
      "node_id": "MDQ6VXNlcjg5MDM4ODg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8903888?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/krasi-georgiev",
      "html_url": "https://github.com/krasi-georgiev",
      "followers_url": "https://api.github.com/users/krasi-georgiev/followers",
      "following_url": "https://api.github.com/users/krasi-georgiev/following{/other_user}",
      "gists_url": "https://api.github.com/users/krasi-georgiev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/krasi-georgiev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/krasi-georgiev/subscriptions",
      "organizations_url": "https://api.github.com/users/krasi-georgiev/orgs",
      "repos_url": "https://api.github.com/users/krasi-georgiev/repos",
      "events_url": "https://api.github.com/users/krasi-georgiev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/krasi-georgiev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-26T23:48:01Z",
    "updated_at": "2020-11-27T00:02:51Z",
    "author_association": "NONE",
    "body": "Yep, I see your point, what about passing a context and just cancel it shutdown?\r\nWouldn't this solve the problem? \r\nThen library users can also provide the context and cancel according to the execution workflow. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/734509423/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1043200689",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21818#issuecomment-1043200689",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21818",
    "id": 1043200689,
    "node_id": "IC_kwDOAOvK984-Lfqx",
    "user": {
      "login": "screwyprof",
      "id": 1536274,
      "node_id": "MDQ6VXNlcjE1MzYyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1536274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/screwyprof",
      "html_url": "https://github.com/screwyprof",
      "followers_url": "https://api.github.com/users/screwyprof/followers",
      "following_url": "https://api.github.com/users/screwyprof/following{/other_user}",
      "gists_url": "https://api.github.com/users/screwyprof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/screwyprof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/screwyprof/subscriptions",
      "organizations_url": "https://api.github.com/users/screwyprof/orgs",
      "repos_url": "https://api.github.com/users/screwyprof/repos",
      "events_url": "https://api.github.com/users/screwyprof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/screwyprof/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-02-17T17:11:14Z",
    "updated_at": "2022-02-17T17:14:08Z",
    "author_association": "NONE",
    "body": "> It's a very well-behaving \"leak\" -- usually a \"leak\" means that some resource is being drip-drained, and more resources lost as time goes by. This is just a constant little penalty of using go-ethereum as a library ;-)\r\n\r\nI've added this amazing quote to one of the projects I'm working on before adding the exceptions to the `goleak` :)\r\n\r\nIt's strange that we have data races when using the library and not running the node. Does the simulated Backed spawn the leaking goroutines?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1043200689/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
