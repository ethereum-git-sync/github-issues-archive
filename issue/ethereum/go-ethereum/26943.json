{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/26943",
  "id": 1634974080,
  "node_id": "I_kwDOAOvK985hc7mA",
  "number": 26943,
  "title": "Can we prune the stale state offline by iterating a recent trie if snapshot is not open?",
  "user": {
    "login": "jongrun",
    "id": 31625057,
    "node_id": "MDQ6VXNlcjMxNjI1MDU3",
    "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jongrun",
    "html_url": "https://github.com/jongrun",
    "followers_url": "https://api.github.com/users/jongrun/followers",
    "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
    "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
    "organizations_url": "https://api.github.com/users/jongrun/orgs",
    "repos_url": "https://api.github.com/users/jongrun/repos",
    "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jongrun/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2023-03-22T02:54:27Z",
  "updated_at": "2023-03-27T06:27:37Z",
  "closed_at": "2023-03-22T08:47:54Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "@rjl493456442 Itâ€˜s more efficient pruning the stale state offline by iterating the snapshot. But if performance is put aside, is it feasible to prune by iterating a recent trie.\r\nhttps://github.com/ethereum/go-ethereum/blob/b3f43c89b3b884d5d0b8e1a239847f54a291a19b/core/state/pruner/pruner.go#L64-L81\r\n",
  "closed_by": {
    "login": "rjl493456442",
    "id": 5959481,
    "node_id": "MDQ6VXNlcjU5NTk0ODE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rjl493456442",
    "html_url": "https://github.com/rjl493456442",
    "followers_url": "https://api.github.com/users/rjl493456442/followers",
    "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
    "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
    "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
    "repos_url": "https://api.github.com/users/rjl493456442/repos",
    "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479123267",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1479123267",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1479123267,
    "node_id": "IC_kwDOAOvK985YKaFD",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T08:47:54Z",
    "updated_at": "2023-03-22T08:47:54Z",
    "author_association": "MEMBER",
    "body": "@jongrun It's feasible to iterate the target state by trie, but it's just extremely slow(10x slower).\r\n\r\nThere are multiple reasons for the huge performance difference between trie and snapshot:\r\n- trie nodes are stored by hash in database with no space locality, reads them out will involve huge read amplification\r\n- all the internal trie nodes must be resolved first in order to access the state\r\n- snapshot data are stored in order in disk, iterate them out is fast with good space locality\r\n- snapshot data can be iterated directly without reading any internal trie nodes\r\n\r\nIt's the main reason we choose snapshot as the entry point.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479123267/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479170063",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1479170063",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1479170063,
    "node_id": "IC_kwDOAOvK985YKlgP",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T09:15:04Z",
    "updated_at": "2023-03-22T09:15:35Z",
    "author_association": "NONE",
    "body": "> @jongrun It's feasible to iterate the target state by trie, but it's just extremely slow(10x slower).\r\n> \r\n> There are multiple reasons for the huge performance difference between trie and snapshot:\r\n> \r\n> * trie nodes are stored by hash in database with no space locality, reads them out will involve huge read amplification\r\n> * all the internal trie nodes must be resolved first in order to access the state\r\n> * snapshot data are stored in order in disk, iterate them out is fast with good space locality\r\n> * snapshot data can be iterated directly without reading any internal trie nodes\r\n> \r\n> It's the main reason we choose snapshot as the entry point.\r\n\r\n@rjl493456442 At present, we have no choice to use the target trie to prune when the snapshot is not open.\r\nSnapshot can accelerate data reading but is also requires more space. If someone have no demand on reading performance but low space occupation is more important for him, he may close the snapshot, which make pruning impossible. Why is there no option to prune by iterating the target trie. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479170063/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479248111",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1479248111",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1479248111,
    "node_id": "IC_kwDOAOvK985YK4jv",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T09:59:13Z",
    "updated_at": "2023-03-22T09:59:13Z",
    "author_association": "MEMBER",
    "body": "> If someone have no demand on reading performance but low space occupation\r\n>  Why is there no option to prune by iterating the target trie.\r\n\r\nBecause if the constraints are: \r\n- We have all the time in the world (doesn't matter if it takes months to sync, or weeks to prune), \r\n- But we are so limited on disk that we cannot take an ~30 % overhead using snapshots\r\n\r\nThen those constraints do not match most real-world situations, and we target common users, not nice usecases. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479248111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479641768",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1479641768",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1479641768,
    "node_id": "IC_kwDOAOvK985YMYqo",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-22T14:14:10Z",
    "updated_at": "2023-03-22T14:14:10Z",
    "author_association": "NONE",
    "body": "If pruning by snapshot takes 2 hours, then 10x is 20 hours. If we prune periodically, e.g. one time per month, the cost is tolerable.\r\nOr in other words, before the snapshot released, why don't we prune the database by a target trie, but resync? Is it more time-consuming than resyncing?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1479641768/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480576108",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1480576108",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1480576108,
    "node_id": "IC_kwDOAOvK985YP8xs",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-23T04:11:10Z",
    "updated_at": "2023-03-23T04:11:10Z",
    "author_association": "MEMBER",
    "body": "@jongrun Offline pruner will be deprecated soonish. We will ship path-based storage scheme and encourage people to use it as default, in which the stale data is pruned by default. \r\n\r\nSo we don't pay too much attention to the existent pruner, but focus one the new scheme instead.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480576108/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480617524",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1480617524",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1480617524,
    "node_id": "IC_kwDOAOvK985YQG40",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-23T05:19:50Z",
    "updated_at": "2023-03-23T05:20:23Z",
    "author_association": "NONE",
    "body": "> @jongrun Offline pruner will be deprecated soonish. We will ship path-based storage scheme and encourage people to use it as default, in which the stale data is pruned by default.\r\n> \r\n> So we don't pay too much attention to the existent pruner, but focus one the new scheme instead.\r\n\r\n@rjl493456442 Thank you for your reply. Is there any describtion or discuss about the path-based storage scheme you refered? And when is this feature scheduled for release? Is the issue https://github.com/ethereum/go-ethereum/issues/23427 relevant?\r\n\r\nBy the way, what is the recommended way to prune data before the new storage scheme releases, prune by snapshot or resync?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480617524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480705050",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1480705050",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1480705050,
    "node_id": "IC_kwDOAOvK985YQcQa",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-23T07:16:14Z",
    "updated_at": "2023-03-23T07:16:14Z",
    "author_association": "MEMBER",
    "body": "We are actively working on the path-based storage one https://github.com/ethereum/go-ethereum/pull/25963/, need reviews still.\r\n\r\nIf you don't maintain snapshot, just resync, otherwise you can run this tool. Iterating trie directly will take more than a day which can be even slower than resync. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480705050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480773568",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1480773568",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1480773568,
    "node_id": "IC_kwDOAOvK985YQs_A",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-23T08:27:59Z",
    "updated_at": "2023-03-26T02:37:03Z",
    "author_association": "NONE",
    "body": "> We are actively working on the path-based storage one #25963, need reviews still.\r\n> \r\n> If you don't maintain snapshot, just resync, otherwise you can run this tool. Iterating trie directly will take more than a day which can be even slower than resync.\r\n\r\n@rjl493456442  Great work! Is another issue https://github.com/ethereum/go-ethereum/issues/23427 has the same or similar idea? Or it is another direction?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1480773568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1484572064",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/26943#issuecomment-1484572064",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/26943",
    "id": 1484572064,
    "node_id": "IC_kwDOAOvK985YfMWg",
    "user": {
      "login": "jongrun",
      "id": 31625057,
      "node_id": "MDQ6VXNlcjMxNjI1MDU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/31625057?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jongrun",
      "html_url": "https://github.com/jongrun",
      "followers_url": "https://api.github.com/users/jongrun/followers",
      "following_url": "https://api.github.com/users/jongrun/following{/other_user}",
      "gists_url": "https://api.github.com/users/jongrun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jongrun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jongrun/subscriptions",
      "organizations_url": "https://api.github.com/users/jongrun/orgs",
      "repos_url": "https://api.github.com/users/jongrun/repos",
      "events_url": "https://api.github.com/users/jongrun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jongrun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-27T06:27:36Z",
    "updated_at": "2023-03-27T06:27:36Z",
    "author_association": "NONE",
    "body": "@rjl493456442 Can we archive states for the last N months only?\r\nIn current version, we have two extreme options:\r\n- either run archive node with ALL historical states\r\n- or full node with only recent state (last 128 blocks in momery for mini reorg)\r\n\r\nBut in archive node case, some too-old states (e.g. 3 months ago) may not be used in most cases. Is there any solution to store states for only the last N months or last N blocks? Looking forward to your reply.\r\n\r\nrelated issue: https://github.com/ethereum/go-ethereum/issues/26981",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1484572064/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
