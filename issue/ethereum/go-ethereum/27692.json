{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/27692",
  "id": 1797708340,
  "node_id": "I_kwDOAOvK985rJto0",
  "number": 27692,
  "title": "Warp sync via snap",
  "user": {
    "login": "lightclient",
    "id": 14004106,
    "node_id": "MDQ6VXNlcjE0MDA0MTA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lightclient",
    "html_url": "https://github.com/lightclient",
    "followers_url": "https://api.github.com/users/lightclient/followers",
    "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
    "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
    "organizations_url": "https://api.github.com/users/lightclient/orgs",
    "repos_url": "https://api.github.com/users/lightclient/repos",
    "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lightclient/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233652,
      "node_id": "MDU6TGFiZWw3MjIzMzY1Mg==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:feature",
      "name": "type:feature",
      "color": "84b6eb",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2023-07-10T22:41:47Z",
  "updated_at": "2023-07-12T06:13:03Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Although snap is great, there are a few classes of users that I don't think it serves the best:\r\n\r\n1) Ethereum users with poor internet, but good hardware -- for these users it will take a while for the healing phase to complete\r\n1) Ethereum power-users who need to sync new nodes and have powerful hardware capable of quickly recomputing state -- yes healing will be relatively fast, but likely not as fast as fully executing the blocks from a recent state checkpoint\r\n1) Ethereum clones with high gas limits -- some of these churn state so much that _most_ hardware / networks are insufficient to ever complete healing (#25965)\r\n\r\nFor these reasons, it might be interesting to allow users to opt-in to some type of warp-sync-like-scheme using snap. \r\n\r\nThe general idea would be to have a way to tell geth to stop at certain intervals to \"preserve\" the snap layers for that block and to also allow clients to pass a specific node id to snap sync from and avoid pivoting to a later block (so long as the target continues responding).",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630485065",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1630485065",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1630485065,
    "node_id": "IC_kwDOAOvK985hLzpJ",
    "user": {
      "login": "joohhnnn",
      "id": 68833933,
      "node_id": "MDQ6VXNlcjY4ODMzOTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/68833933?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/joohhnnn",
      "html_url": "https://github.com/joohhnnn",
      "followers_url": "https://api.github.com/users/joohhnnn/followers",
      "following_url": "https://api.github.com/users/joohhnnn/following{/other_user}",
      "gists_url": "https://api.github.com/users/joohhnnn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/joohhnnn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/joohhnnn/subscriptions",
      "organizations_url": "https://api.github.com/users/joohhnnn/orgs",
      "repos_url": "https://api.github.com/users/joohhnnn/repos",
      "events_url": "https://api.github.com/users/joohhnnn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/joohhnnn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T09:33:57Z",
    "updated_at": "2023-07-11T09:33:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "like downloading number X's state, and executing the blocks from X to latest block for syncing instead of healing?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630485065/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630792731",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1630792731",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1630792731,
    "node_id": "IC_kwDOAOvK985hM-wb",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T13:04:16Z",
    "updated_at": "2023-07-11T13:04:16Z",
    "author_association": "MEMBER",
    "body": "It's not really simple to do. The snapshots are constantly moving with the chain. There's no way to freeze the snapshots, you'd need to stop and create a full copy of the entire 50-100GB thing, which can take arbitrarily long. You'd also need a new database \"location\" to store these frozen snapshots into.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630792731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631137716",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1631137716",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1631137716,
    "node_id": "IC_kwDOAOvK985hOS-0",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T16:32:08Z",
    "updated_at": "2023-07-11T16:32:08Z",
    "author_association": "MEMBER",
    "body": "I think the idea would be more to pause the client at a certain height, that way we can continue to serve that height.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631137716/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631908328",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1631908328",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1631908328,
    "node_id": "IC_kwDOAOvK985hRPHo",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-12T06:13:03Z",
    "updated_at": "2023-07-12T06:13:03Z",
    "author_association": "MEMBER",
    "body": "> The general idea would be to have a way to tell geth to stop at certain intervals to \"preserve\" the snap layers for that block and to also allow clients to pass a specific node id to snap sync from and avoid pivoting to a later block (so long as the target continues responding).\r\n\r\nBasically, you could have two geth-nodes: each would \r\n* process blocks for 12 hours\r\n* serve snap-sync for 12 hours (paused block-wise)\r\n\r\nAnd clients would sync against one of them. This would more or less \"become\" warp-sync, with minimal heal-phase after sync finished. But there are a lot of problems with this approach\r\n\r\n- How to make clients latch onto the right one, \r\n- How to make clients not discover a \"better\" server which has a higher remote block, \r\n- How to prevent client pivoting actions (driven by CL, IIRC)\r\n\r\nSeems to me like there are a lot of small problems all over, that currently would make an attempt like this into a UX nightmare. And in the end, it would all culminate in it being possible/easy for someone to set up a centralized service to serve others. Which typically doesn't work well in the long term, since most parties would rather earn than spend money. \r\n\r\nI'm not sure what actionable parts exist, but we can keep the discussion open for a bit, I guess. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631908328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
