{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/27692",
  "id": 1797708340,
  "node_id": "I_kwDOAOvK985rJto0",
  "number": 27692,
  "title": "Warp sync via snap",
  "user": {
    "login": "lightclient",
    "id": 14004106,
    "node_id": "MDQ6VXNlcjE0MDA0MTA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lightclient",
    "html_url": "https://github.com/lightclient",
    "followers_url": "https://api.github.com/users/lightclient/followers",
    "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
    "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
    "organizations_url": "https://api.github.com/users/lightclient/orgs",
    "repos_url": "https://api.github.com/users/lightclient/repos",
    "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lightclient/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233652,
      "node_id": "MDU6TGFiZWw3MjIzMzY1Mg==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:feature",
      "name": "type:feature",
      "color": "84b6eb",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2023-07-10T22:41:47Z",
  "updated_at": "2023-07-26T02:40:26Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Although snap is great, there are a few classes of users that I don't think it serves the best:\r\n\r\n1) Ethereum users with poor internet, but good hardware -- for these users it will take a while for the healing phase to complete\r\n1) Ethereum power-users who need to sync new nodes and have powerful hardware capable of quickly recomputing state -- yes healing will be relatively fast, but likely not as fast as fully executing the blocks from a recent state checkpoint\r\n1) Ethereum clones with high gas limits -- some of these churn state so much that _most_ hardware / networks are insufficient to ever complete healing (#25965)\r\n\r\nFor these reasons, it might be interesting to allow users to opt-in to some type of warp-sync-like-scheme using snap. \r\n\r\nThe general idea would be to have a way to tell geth to stop at certain intervals to \"preserve\" the snap layers for that block and to also allow clients to pass a specific node id to snap sync from and avoid pivoting to a later block (so long as the target continues responding).",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630485065",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1630485065",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1630485065,
    "node_id": "IC_kwDOAOvK985hLzpJ",
    "user": {
      "login": "joohhnnn",
      "id": 68833933,
      "node_id": "MDQ6VXNlcjY4ODMzOTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/68833933?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/joohhnnn",
      "html_url": "https://github.com/joohhnnn",
      "followers_url": "https://api.github.com/users/joohhnnn/followers",
      "following_url": "https://api.github.com/users/joohhnnn/following{/other_user}",
      "gists_url": "https://api.github.com/users/joohhnnn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/joohhnnn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/joohhnnn/subscriptions",
      "organizations_url": "https://api.github.com/users/joohhnnn/orgs",
      "repos_url": "https://api.github.com/users/joohhnnn/repos",
      "events_url": "https://api.github.com/users/joohhnnn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/joohhnnn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T09:33:57Z",
    "updated_at": "2023-07-11T09:33:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "like downloading number X's state, and executing the blocks from X to latest block for syncing instead of healing?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630485065/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630792731",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1630792731",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1630792731,
    "node_id": "IC_kwDOAOvK985hM-wb",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T13:04:16Z",
    "updated_at": "2023-07-11T13:04:16Z",
    "author_association": "MEMBER",
    "body": "It's not really simple to do. The snapshots are constantly moving with the chain. There's no way to freeze the snapshots, you'd need to stop and create a full copy of the entire 50-100GB thing, which can take arbitrarily long. You'd also need a new database \"location\" to store these frozen snapshots into.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1630792731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631137716",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1631137716",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1631137716,
    "node_id": "IC_kwDOAOvK985hOS-0",
    "user": {
      "login": "lightclient",
      "id": 14004106,
      "node_id": "MDQ6VXNlcjE0MDA0MTA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14004106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lightclient",
      "html_url": "https://github.com/lightclient",
      "followers_url": "https://api.github.com/users/lightclient/followers",
      "following_url": "https://api.github.com/users/lightclient/following{/other_user}",
      "gists_url": "https://api.github.com/users/lightclient/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lightclient/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lightclient/subscriptions",
      "organizations_url": "https://api.github.com/users/lightclient/orgs",
      "repos_url": "https://api.github.com/users/lightclient/repos",
      "events_url": "https://api.github.com/users/lightclient/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lightclient/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-11T16:32:08Z",
    "updated_at": "2023-07-11T16:32:08Z",
    "author_association": "MEMBER",
    "body": "I think the idea would be more to pause the client at a certain height, that way we can continue to serve that height.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631137716/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631908328",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1631908328",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1631908328,
    "node_id": "IC_kwDOAOvK985hRPHo",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-12T06:13:03Z",
    "updated_at": "2023-07-12T06:13:03Z",
    "author_association": "MEMBER",
    "body": "> The general idea would be to have a way to tell geth to stop at certain intervals to \"preserve\" the snap layers for that block and to also allow clients to pass a specific node id to snap sync from and avoid pivoting to a later block (so long as the target continues responding).\r\n\r\nBasically, you could have two geth-nodes: each would \r\n* process blocks for 12 hours\r\n* serve snap-sync for 12 hours (paused block-wise)\r\n\r\nAnd clients would sync against one of them. This would more or less \"become\" warp-sync, with minimal heal-phase after sync finished. But there are a lot of problems with this approach\r\n\r\n- How to make clients latch onto the right one, \r\n- How to make clients not discover a \"better\" server which has a higher remote block, \r\n- How to prevent client pivoting actions (driven by CL, IIRC)\r\n\r\nSeems to me like there are a lot of small problems all over, that currently would make an attempt like this into a UX nightmare. And in the end, it would all culminate in it being possible/easy for someone to set up a centralized service to serve others. Which typically doesn't work well in the long term, since most parties would rather earn than spend money. \r\n\r\nI'm not sure what actionable parts exist, but we can keep the discussion open for a bit, I guess. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1631908328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1649840840",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1649840840",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1649840840,
    "node_id": "IC_kwDOAOvK985iVpLI",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-25T13:23:33Z",
    "updated_at": "2023-07-25T13:23:33Z",
    "author_association": "MEMBER",
    "body": "We've chatted a bit about this today at stabby and had the following ideas / steps:\r\n\r\nFirst up, it is definitely possible even now to have a number of rotating seed nodes to sync from internally within an org, which pause every 6 hours for a day and then resume. In between new nodes can be spun up being pointed to those. That kind of works but is not useful in a public setting since it means the seeding org would need to foot the bill for the bandwidth + bottleneck for all.\r\n\r\nAn alternative proposal would be to drop the healing phase in favor of a witness request, where upon every pivot change we would fetch a witness to \"fix up\" the previously downloaded data.\r\n\r\nThe thing where this gets complicated is that if we need multiple requests to serve the witness (due to size), we need to transmit range proofs to verify the subtries fixed up, and with concurrently downloading account/storage trie segments, we also need range proofs corresponding to those regions.\r\n\r\nAll in all it's complicated, but probably worth it. @rjl493456442 will post some numbers to see how much bandwidth would be entail to fix up a single pivot move.\r\n\r\nThe open question however is what happens if someone stops their node for a longer time that the state retention period (128 blocks) as then no node in the network would be able to serve a witness from a \"very old\" pivot to a new one. In that case we might still need to fall back to healing, which would 1) prevent us from getting rid of it and 2) would hit exactly those people who have already been hit by healing (low bandwidth/high latency).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1649840840/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1650886826",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/27692#issuecomment-1650886826",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27692",
    "id": 1650886826,
    "node_id": "IC_kwDOAOvK985iZoiq",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-26T02:40:26Z",
    "updated_at": "2023-07-26T02:40:26Z",
    "author_association": "MEMBER",
    "body": "For a single pivot move( 64 blocks ), we need to fill up the state changes of these blocks. I dumped it out from a mainnet node, it turns out:\r\n\r\n- account data: 1.19MiB, each entry includes (a) account hash(32 bytes) (b) account data (slim format)\r\n- storage data: 1.08MiB, each entry includes (a) storage hash(32 bytes) (b) storage data (slim format)\r\n\r\nAfter aggregating them together\r\n- account data: 446.61KiB\r\n- storage data: 548.16KiB\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/1650886826/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
