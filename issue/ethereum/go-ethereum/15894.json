{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/15894",
  "id": 288689776,
  "node_id": "MDU6SXNzdWUyODg2ODk3NzY=",
  "number": 15894,
  "title": "Feature suggestion: option to download raw block data from HTTP servers?",
  "user": {
    "login": "mariushudea",
    "id": 34661103,
    "node_id": "MDQ6VXNlcjM0NjYxMTAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/34661103?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mariushudea",
    "html_url": "https://github.com/mariushudea",
    "followers_url": "https://api.github.com/users/mariushudea/followers",
    "following_url": "https://api.github.com/users/mariushudea/following{/other_user}",
    "gists_url": "https://api.github.com/users/mariushudea/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mariushudea/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mariushudea/subscriptions",
    "organizations_url": "https://api.github.com/users/mariushudea/orgs",
    "repos_url": "https://api.github.com/users/mariushudea/repos",
    "events_url": "https://api.github.com/users/mariushudea/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mariushudea/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 856638432,
      "node_id": "MDU6TGFiZWw4NTY2Mzg0MzI=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:inactive",
      "name": "status:inactive",
      "color": "ffffff",
      "default": false,
      "description": null
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2018-01-15T19:04:37Z",
  "updated_at": "2019-03-02T03:17:59Z",
  "closed_at": "2019-03-02T03:17:59Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "I tried to post these questions on ethereum developer forum, but couldn't figure out how to post something (i guess my account has to be manually confirmed or something like that?)\r\n\r\nHow difficult would it be to be able to download the raw block data of each block and have some option to do fast sync or regular sync from a file containing a bunch of raw blocks? \r\n\r\nIs there some dependency between blocks, is some computation required to be done on previous blocks in order to process/import new blocks or would it be possible to just download in advance thousands of blocks and then import receipts and whatever else geth does with the data in the blocks ?\r\n\r\nHTTP 2 has some cool features like using one request to get multiple files without closing the connection , but even without this feature, one could simply program a web server to respond to requests like \r\n\r\nGET 1234.block  to download a single block (in case the web server serves only static files, no scripting, or it's some CDN type of system) - note that multiple blocks could be asked for and received using a single get request using http/2\r\n\r\nor GET blocks?number=1234 to get single block  or\r\nGET blocks?from=100&to=500 or GET blocks?from=100&to=latest/[empty]  (server could have a max limit set to let's say 128...1024 blocks) \r\nMultiple blocks could also easily be sent along with a header for each block as a zip/gz files with minimal/no compression or as basic TAR files (a basic perl/python/php script could package multiple blocks into such files easily).\r\n\r\nWhy would this make sense? not everyone has high upload speeds, but download speeds are usually much higher. Some users may not be able to keep nodes (that send raw block data to other users) because of the upload speeds they have but may be willing to keep a node if it's very low traffic.\r\n \r\nStatic files are also cheap to serve, you can rent these days dedicated servers with 100 mbps unmetered or 1gbps / 10 TB for less than 30-40$ a month - people who rent such servers to host websites could easily set up a subdomain or a virtualhost and configure it to serve up to 1000-5000 people simultaneously, optionally setting speed limits per connection or by setting a total bandwidth cap at let's say 10-30 mbps out of their network connections.\r\nEven with 10KB/s per connection, geth could easily connect to 20-50 such http servers in parallel and download raw blocks at megabytes/s. \r\nThe p2p exchanges between computers would be smaller and maybe this would help in other areas.\r\n\r\ngeth could use p2p to retrieve blocks and then either function as http server or push/upload the block along with some metadata like some sha or crc32 for the whole block to a http server \r\ngeth could retrieve from network just the hash of each raw block and then connect to multiple such http servers and retrieve thousands of blocks and check the integrity of each block using those hashes and re-download as needed (if a block is corrupt).\r\nThe web server address would have to be broadcast as a peer and probably nodes would have to periodically check if the web server is live (maybe once every hour or every 4 hours) and if it's not online for some amount, the nodes could stop broadcasting it to other peers (or however geth receives new peers from other nodes)\r\n\r\nIf user tries to create a full node or use sync fast from nothing, besides being able to sync using an import feature and a big file with raw blocks downloaded from somewhere, such feature could also open up the possibility of optimizing the storage or how the data is kept by geth on disk. \r\n\r\nFor example, how many unique addresses are there? I'm guessing (i may be extremely wrong though) that there's not billions of them. Maybe it would be worth to download chunks of 100.000 blocks , make a list of unique addresses and add them to a database giving each address a unique ID in a table and then instead of storing 20 bytes for each address, use only 8 bytes. When the number of unique addresses exceeds what can be addressed using 8 bytes, then \"upgrade\" the tables to 12 bytes for each address then 16 bytes and so on (using multiples of 4 byes in case it would be faster to work with 32 bits at a time but i guess the jumps could be smaller) ",
  "closed_by": {
    "login": "stale[bot]",
    "id": 26384082,
    "node_id": "MDM6Qm90MjYzODQwODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stale%5Bbot%5D",
    "html_url": "https://github.com/apps/stale",
    "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/455743633",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/15894#issuecomment-455743633",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/15894",
    "id": 455743633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTc0MzYzMw==",
    "user": {
      "login": "stale[bot]",
      "id": 26384082,
      "node_id": "MDM6Qm90MjYzODQwODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/1724?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stale%5Bbot%5D",
      "html_url": "https://github.com/apps/stale",
      "followers_url": "https://api.github.com/users/stale%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/stale%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stale%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/stale%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/stale%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/stale%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stale%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2019-01-19T03:00:10Z",
    "updated_at": "2019-01-19T03:00:10Z",
    "author_association": "NONE",
    "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/455743633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
