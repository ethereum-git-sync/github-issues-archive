{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/2693",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/2693/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/2693/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/2693/events",
  "html_url": "https://github.com/ethereum/solidity/issues/2693",
  "id": 247862084,
  "node_id": "MDU6SXNzdWUyNDc4NjIwODQ=",
  "number": 2693,
  "title": "Discussion: Stack Limits & Spills",
  "user": {
    "login": "pruby",
    "id": 133988,
    "node_id": "MDQ6VXNlcjEzMzk4OA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/133988?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/pruby",
    "html_url": "https://github.com/pruby",
    "followers_url": "https://api.github.com/users/pruby/followers",
    "following_url": "https://api.github.com/users/pruby/following{/other_user}",
    "gists_url": "https://api.github.com/users/pruby/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/pruby/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/pruby/subscriptions",
    "organizations_url": "https://api.github.com/users/pruby/orgs",
    "repos_url": "https://api.github.com/users/pruby/repos",
    "events_url": "https://api.github.com/users/pruby/events{/privacy}",
    "received_events_url": "https://api.github.com/users/pruby/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2017-08-03T23:19:47Z",
  "updated_at": "2022-08-12T11:45:34Z",
  "closed_at": "2022-08-12T11:44:53Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "On any of my experiments which go beyond very basic wallets, coins, etc, I tend to run very quickly in to the \"stack too deep\" error. While I understand the reasons for this happening (the hard cap of 16 on SWAP, DUP calls), this seems like a low-level detail which conventional languages deal with automatically and transparently. It would be nice if Solidity could move towards this for more complicated cases.\r\n\r\nI've been considering and researching some possible solutions, and I'd like to discuss what people have already tried and possible migration paths towards that. This is the sort of thing I'd be interested in coding if we can come up with a simple enough way of doing it.\r\n\r\nI'm going to dump some of my thoughts on how this could work here, but please tell me if things have already been tried, don't work, or if you have further thoughts/analysis before I try to implement anything.\r\n\r\nAs far as I can tell from reading, stack machine languages normally store local variables in memory rather than on the stack. This raises one possible solution - allocate a stack frame for functions and simply change the compiler convention so that variable assignments result in an MSTORE and use in an MLOAD. This would have a greater impact on code which is currently small enough to do without, and would still leave the possibility of getting this error if we nest function calls deeply enough without storing in a variable.\r\n\r\nAnother possible solution would be to dynamically detect overflow; and spill entries from the stack (could be produced by any types of operation) only when necessary. This would, however, be very complicated to implement.\r\n\r\nWe couldn't do this in the optimiser _after_ converting to concrete EVM opcodes as EVM has no way of expressing DUP17 or higher. We'd need to add methods to traverse AST nodes which allowed us to precalculate maximum stack depth, find appropriate spills, record that these nodes are memory-stored, add the store procedure at the end of the node's assembly output, and make DUP opcodes referencing them use a load procedure instead.\r\n\r\nAllocating stack frames on EVM would be decidedly non-trivial, as we're quite heavily penalised for leaving a hole in memory. This forces our stack to have a small, fixed length, or share the same compact space as the heap. A stack could be allocated in a segmented manner using the heap allocator, though we would need to store at least one word of metadata on each segment (previous segment, next segment, within-segment usage pointer).\r\n\r\nWe would need two globals at fixed addresses to store a frame pointer and a segment pointer for a segmented stack. Both of these would need to be saved and restored on calling in to any function which used the stack.\r\n\r\nA function preamble would need to check whether there is space in the current segment for our stack frame, and move on to or allocate the next frame if there wasn't. To keep code within the function simple, I would suggest that the function's stack frame should always fit within one segment.",
  "closed_by": {
    "login": "ekpyron",
    "id": 1347491,
    "node_id": "MDQ6VXNlcjEzNDc0OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ekpyron",
    "html_url": "https://github.com/ekpyron",
    "followers_url": "https://api.github.com/users/ekpyron/followers",
    "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
    "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
    "organizations_url": "https://api.github.com/users/ekpyron/orgs",
    "repos_url": "https://api.github.com/users/ekpyron/repos",
    "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ekpyron/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/2693/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/2693/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/320119766",
    "html_url": "https://github.com/ethereum/solidity/issues/2693#issuecomment-320119766",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/2693",
    "id": 320119766,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDExOTc2Ng==",
    "user": {
      "login": "pruby",
      "id": 133988,
      "node_id": "MDQ6VXNlcjEzMzk4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/133988?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pruby",
      "html_url": "https://github.com/pruby",
      "followers_url": "https://api.github.com/users/pruby/followers",
      "following_url": "https://api.github.com/users/pruby/following{/other_user}",
      "gists_url": "https://api.github.com/users/pruby/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pruby/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pruby/subscriptions",
      "organizations_url": "https://api.github.com/users/pruby/orgs",
      "repos_url": "https://api.github.com/users/pruby/repos",
      "events_url": "https://api.github.com/users/pruby/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pruby/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-03T23:51:39Z",
    "updated_at": "2017-08-04T02:21:54Z",
    "author_association": "NONE",
    "body": "Just sketching out this idea and getting an idea of the costs associated with a segmented stack - preliminary look indicates they may be quite high. None of this is tested or even checked to see whether the stack balances, just trying to work out a cost estimate.\r\n\r\nStack storage / retrieval code could look like:\r\n\r\n```\r\nPUSH (frame pointer)\r\nMLOAD\r\nPUSH (offset in frame)\r\nSUB\r\nMSTORE / MLOAD\r\n\r\nAll of these are W_{verylow} cost instructions, so cost would be 7 bytes of code & 15 gas per load/store.\r\n\r\nThe function preamble could look something like:\r\n\r\nPUSH (segment pointer)\r\nMLOAD\r\nPUSH (mask for lower bits)\r\nAND (yields the current usage)\r\nPUSH (required usage)\r\nADD (yields the required frame capacity)\r\nPUSH (segment pointer)\r\nMLOAD\r\nPUSH (offset for current segment capacity)\r\nDIV\r\nPUSH (mask for lower bits)\r\nAND (yields the current frame's capacity).\r\nLT (yields 1 if capacity is less than required)\r\n\r\n// Running cost: 41 gas\r\n\r\n// We now have one stack entry with whether or not we have space in the current frame\r\n\r\nPUSH (segment pointer)\r\nMLOAD\r\nDUP1 (segment pointer copied)\r\nPUSH (offset for next segment pointer)\r\nDIV\r\nPUSH (mask for lower bits)\r\nAND (yields next segment pointer).\r\nSUB (difference between pointers)\r\nMUL (difference between pointers if capacity less than required, zero otherwise)\r\nADD (combine with existing segment pointer - yields current segment pointer if enough space, next one otherwise).\r\n\r\n// Running cost: 75 gas\r\n\r\n// We now have one stack entry containing the stack frame we should use, zero if empty\r\n\r\n// We will have to allocate another frame if there is none. This is too complicated to do in a\r\n// non-branching fashion, so branch if our next segment address contains zero. No idea\r\n// what the calling convention is - might need to adjust that.\r\n\r\nPC\r\nDUP2\r\nISZERO\r\nPUSH (address of allocation routine)\r\nJUMPI\r\nPOP // Discard PC for balance if we didn't jump\r\n\r\nDUP1 (copy calculated segment pointer)\r\nPUSH (mask for lower bits)\r\nAND (yields the current usage)\r\nPUSH (required usage)\r\nADD (yields the new top-of-frame).\r\n\r\n// Running cost (no branch taken): 113 gas\r\n\r\n// We have two entries in the stack here - the new frame pointer on top, and the new segment underneath\r\n\r\n// Push the last function's global values to the stack\r\n\r\nPUSH (frame pointer)\r\nMLOAD\r\nDUP2 (new top-of-frame)\r\nMSTORE\r\n\r\nPUSH (segment pointer)\r\nMLOAD\r\nDUP2 (new top of frame)\r\nPUSH1 0x20\r\nSUB\r\nMSTORE\r\n\r\nPUSH (frame pointer)\r\nMSTORE\r\n\r\nPUSH (segment pointer)\r\nMSTORE\r\n\r\n// Running cost: 155 gas\r\n```\r\n\r\nThis is looking like quite a lot of code, and doesn't even implement the case where a frame has to be allocated.\r\n\r\nGas when we don't need to allocate a new segment looks to be around 155. Exactly how much code this takes depends on how cheap we can make the masks and offsets. Not sure how you do that now - assume some might actually be loaded from code memory to reduce instruction size?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/320119766/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/320214409",
    "html_url": "https://github.com/ethereum/solidity/issues/2693#issuecomment-320214409",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/2693",
    "id": 320214409,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDIxNDQwOQ==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-04T10:23:08Z",
    "updated_at": "2017-08-04T10:23:08Z",
    "author_association": "MEMBER",
    "body": "We can address that with the new backend. Also, with the introduction of structs to the ABI, this problem also becomes less relevant.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/320214409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1213017615",
    "html_url": "https://github.com/ethereum/solidity/issues/2693#issuecomment-1213017615",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/2693",
    "id": 1213017615,
    "node_id": "IC_kwDOAm_5kc5ITS4P",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-12T11:34:31Z",
    "updated_at": "2022-08-12T11:34:45Z",
    "author_association": "MEMBER",
    "body": "@ekpyron How relevant is this now that we have the memory escalator? Should we close this?\r\n\r\nAlso, if it's still relevant, perhaps we should close this anyway and move the discussion to the [forum](https://forum.soliditylang.org/)? Now that we have one it seems to be a better place for such open-ended discussions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1213017615/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1213025842",
    "html_url": "https://github.com/ethereum/solidity/issues/2693#issuecomment-1213025842",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/2693",
    "id": 1213025842,
    "node_id": "IC_kwDOAm_5kc5ITU4y",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-12T11:44:53Z",
    "updated_at": "2022-08-12T11:45:34Z",
    "author_association": "MEMBER",
    "body": "Oh wow, I wasn't aware of this issue :-).\r\nBut yes, this is largely implemented in the via-IR pipeline with stack-to-memory (the main corner cases being non-memory-safe inline assembly and recursive functions, but we had few reports about that, so it doesn't seem like a huge issue in practice at least yet).\r\nFYI: the issue of allocating stack frames is avoided in the current implementation by allocating globally fixed memory locations for variables, which is safe in all cases other than recursive functions (which is easy to tell on the Yul level). And following https://github.com/ethereum/solidity/issues/2693#issuecomment-320214409 it was indeed much easier to implement this for the via-IR pipeline.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1213025842/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
