{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/1050",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/1050/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/1050/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/1050/events",
  "html_url": "https://github.com/ethereum/solidity/issues/1050",
  "id": 175678893,
  "node_id": "MDU6SXNzdWUxNzU2Nzg4OTM=",
  "number": 1050,
  "title": "Reversion in 0.3.6-2016-09-07-24524d6: invalid jump",
  "user": {
    "login": "Arachnid",
    "id": 17865,
    "node_id": "MDQ6VXNlcjE3ODY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Arachnid",
    "html_url": "https://github.com/Arachnid",
    "followers_url": "https://api.github.com/users/Arachnid/followers",
    "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
    "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
    "organizations_url": "https://api.github.com/users/Arachnid/orgs",
    "repos_url": "https://api.github.com/users/Arachnid/repos",
    "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Arachnid/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2016-09-08T06:55:58Z",
  "updated_at": "2016-09-08T10:01:59Z",
  "closed_at": "2016-09-08T09:36:50Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Compiling the following code with 0.3.6-2016-09-07-24524d6, then calling `deposit([\"e980b7c6dd381723b1ab9def3e1557ab\", \"fedc538db81453138562cfa9ffd186ef\", \"9f10db0c3188d26375ff9a03bc4fdf1b\", \"cab9af3c051a03747876386012f58510\", \"9fc89ae3141e1715f56809802d62d3f6\", \"b8fb65eaf18c926555dd7dd9883e96eb\", \"b6370208acde5be010a830095fb112f0\", \"19175762cfbfd14e94edd8874a3e99f0\", \"90af5d9d6b20a7e85157c6900d7e7ef5\", \"b8c0d379c8b54fee670f4e2e10b4e5a3\"], \"100000000000000000\")` with a value of 1 ether causes an \"invalid JUMP\" to address 2 - oddly enough, via a JUMPI, not a JUMP. Compiling with the next most recent version, 0.3.6-2016-09-06-114502f, works as expected.\n\nCode:\n\n```\npragma solidity ^0.3.5;\n\ncontract DepositHolder {\n    uint constant GUARANTEE_PERIOD = 365 days;\n\n    event Claim(address addr, uint amount);\n\n    struct Entry {\n        bytes16 next;\n        uint64 deposit;\n        uint64 expires;\n    }\n\n    address owner;\n    address auditor;\n\n    mapping(bytes16=>Entry) entries;\n    bytes16 oldestHash;\n    bytes16 newestHash;\n\n    uint public paidOut;\n    uint public totalPaidOut;\n    uint public depositCount;\n\n    function DepositHolder() {\n        owner = msg.sender;\n        auditor = owner;\n    }\n\n    modifier owner_only {\n        if(msg.sender != owner) throw;\n        _;\n    }\n\n    modifier auditor_only {\n        if(msg.sender != auditor) throw;\n        _;\n    }\n\n    /**\n     * @dev Lodge deposits for a set of address hashes. Automatically uses\n     *      expired deposits to pay for new ones.\n     * @param values A list of hashes of addresses to place deposits for.\n     *        Each value is the first 16 bytes of the keccak-256 hash of the\n     *        address the deposit is for.\n     * @param deposit The amount of the deposit on each address.\n     */\n    function deposit(bytes16[] values, uint64 deposit) owner_only {\n        uint required = values.length * deposit;\n        if(msg.value < required) {\n            throw;\n        } else if(msg.value > required) {\n            if(!msg.sender.send(msg.value - required))\n                throw;\n        }\n\n        extend(values, uint64(deposit));\n    }\n\n    function extend(bytes16[] values, uint64 deposit) private {\n        uint64 expires = uint64(now + GUARANTEE_PERIOD);\n\n        if(oldestHash == 0) {\n            oldestHash = values[0];\n            newestHash = values[0];\n        } else {\n            entries[newestHash].next = values[0];\n        }\n\n        for(uint i = 0; i < values.length - 1; i++) {\n            if(entries[values[i]].expires != 0)\n                throw;\n            entries[values[i]] = Entry(values[i + 1], deposit, expires);\n        }\n\n        newestHash = values[values.length - 1];\n        if(entries[newestHash].expires != 0)\n            throw;\n        entries[newestHash] = Entry(0, deposit, expires);\n\n        depositCount += values.length;\n    }\n\n    /**\n     * @dev Withdraw funds held for expired deposits.\n     * @param max Maximum number of deposits to claim.\n     */\n    function withdraw(uint max) owner_only {\n        uint recovered = recover(max);\n        if(!msg.sender.send(recovered))\n            throw;\n    }\n\n    function recover(uint max) private returns(uint recovered) {\n        // Iterate through entries deleting them, until we find one\n        // that's new enough, or hit the limit.\n        bytes16 ptr = oldestHash;\n        uint count;\n        for(uint i = 0; i < max && ptr != 0 && entries[ptr].expires < now; i++) {\n            recovered += entries[ptr].deposit;\n            ptr = entries[ptr].next;\n            count += 1;\n        }\n\n        oldestHash = ptr;\n        if(oldestHash == 0)\n            newestHash = 0;\n\n        // Deduct any outstanding payouts from the recovered funds\n        if(paidOut > 0) {\n            if(recovered > paidOut) {\n                recovered -= paidOut;\n                paidOut = 0;\n            } else {\n                paidOut -= recovered;\n                recovered = 0;\n            }\n        }\n\n        depositCount -= count;\n    }\n\n    /**\n     * @dev Fetches information on a future withdrawal event\n     * @param hash The point at which to start scanning; 0 for the first event.\n     * @return when Unix timestamp at which a withdrawal can next happen.\n     * @return count Number of addresses expiring at this time\n     * @return value Total amount withdrawable at this time\n     * @return next Hash of the start of the next withdrawal event, if any.\n     */\n    function nextWithdrawal(bytes16 hash) constant returns(uint when, uint count, uint value, bytes16 next) {\n        if(hash == 0) {\n            hash = oldestHash;\n        }\n        next = hash;\n        when = entries[hash].expires;\n        while(next != 0 && entries[next].expires == when) {\n            count += 1;\n            value += entries[next].deposit;\n            next = entries[next].next;\n        }\n    }\n\n    /**\n     * @dev Checks if a deposit is held for the provided address.\n     * @param addr The address to check.\n     * @return expires The unix timestamp at which the deposit on this address\n     *         expires, or 0 if there is no deposit.\n     * @return deposit The amount deposited against this address.\n     */\n    function check(address addr) constant returns (uint expires, uint deposit) {\n        Entry storage entry = entries[bytes16(sha3(addr))];\n        expires = entry.expires;\n        deposit = entry.deposit;\n    }\n\n    /**\n     * @dev Pays out a claim.\n     * @param addr The address to pay.\n     * @param amount The amount to send.\n     */\n    function disburse(address addr, uint amount) auditor_only {\n        paidOut += amount;\n        totalPaidOut += amount;\n        Claim(addr, amount);\n        if(!addr.send(amount))\n            throw;\n    }\n}\n```\n\nThe VMtrace shows the exception happening just after function dispatch, where it does \"JUMPDEST CALLVALUE PUSH2(2) JUMPI\".\n",
  "closed_by": {
    "login": "axic",
    "id": 20340,
    "node_id": "MDQ6VXNlcjIwMzQw",
    "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/axic",
    "html_url": "https://github.com/axic",
    "followers_url": "https://api.github.com/users/axic/followers",
    "following_url": "https://api.github.com/users/axic/following{/other_user}",
    "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
    "organizations_url": "https://api.github.com/users/axic/orgs",
    "repos_url": "https://api.github.com/users/axic/repos",
    "events_url": "https://api.github.com/users/axic/events{/privacy}",
    "received_events_url": "https://api.github.com/users/axic/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/1050/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/1050/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/245545528",
    "html_url": "https://github.com/ethereum/solidity/issues/1050#issuecomment-245545528",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/1050",
    "id": 245545528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NTU0NTUyOA==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-08T09:36:50Z",
    "updated_at": "2016-09-08T09:49:26Z",
    "author_association": "MEMBER",
    "body": "This is the main breaking change we have for the next release (0.4.0 - see changelog) and that is the first nightly which includes it.\n\nNeed to use the payable keyword on methods receiving ether.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/245545528/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/245551692",
    "html_url": "https://github.com/ethereum/solidity/issues/1050#issuecomment-245551692",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/1050",
    "id": 245551692,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0NTU1MTY5Mg==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-08T10:01:59Z",
    "updated_at": "2016-09-08T10:01:59Z",
    "author_association": "MEMBER",
    "body": "> `pragma solidity ^0.3.5;`\n\nThis should have catched it, but the new versioning system I'm advocating isn't in place yet.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/245551692/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
