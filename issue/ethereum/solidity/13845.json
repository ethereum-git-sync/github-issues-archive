{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/13845",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/13845/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/13845/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/13845/events",
  "html_url": "https://github.com/ethereum/solidity/issues/13845",
  "id": 1519411852,
  "node_id": "I_kwDOAm_5kc5akGKM",
  "number": 13845,
  "title": "[codegen] Enforce Re-Entrancy Protections by Default (Solidity `0.9.X`)",
  "user": {
    "login": "alex-ppg",
    "id": 31933616,
    "node_id": "MDQ6VXNlcjMxOTMzNjE2",
    "avatar_url": "https://avatars.githubusercontent.com/u/31933616?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alex-ppg",
    "html_url": "https://github.com/alex-ppg",
    "followers_url": "https://api.github.com/users/alex-ppg/followers",
    "following_url": "https://api.github.com/users/alex-ppg/following{/other_user}",
    "gists_url": "https://api.github.com/users/alex-ppg/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alex-ppg/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alex-ppg/subscriptions",
    "organizations_url": "https://api.github.com/users/alex-ppg/orgs",
    "repos_url": "https://api.github.com/users/alex-ppg/repos",
    "events_url": "https://api.github.com/users/alex-ppg/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alex-ppg/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2023-01-04T18:33:53Z",
  "updated_at": "2023-01-04T23:51:53Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nAs the security space around EVM-based smart contracts matures, we can observe a recurring pattern in security vulnerabilities across all EVM spectrums; a significant portion of them arise from re-entrancy vulnerabilities,\r\n\r\nWith this issue, we aim to introduce a built-in re-entrancy check across all functions of a generated contract by default, permitting programmers to explicitly mark their functions as re-entrant via the newly introduced `reentrant` keyword, being declared akin to `override` and co.\r\n\r\n## Motivation\r\n\r\n### Rationale\r\n\r\nRe-entrancy attacks are one of the most common root causes of multi-million dollar exploits we can observe by going through historical exploits. Additionally, the concept of a re-entrancy is very hard to grasp when coming from a traditional programming background due to the unique nature of the EVM.\r\n\r\nSolidity is an evolving language that attempts to cater to the wider EVM development community and has historically introduced tools to aid in developing using the language more securely, such as built-in arithmetic checks introduced in `0.8.X`. \r\n\r\nWith this change, we aim to introduce built-in re-entrancy protections by default with the ability to bypass these protections explicitly, empowering seasoned developers with maximum flexibility while protecting newcomers from EVM-related caveats they may not be aware of. \r\n\r\n### Proposal\r\n\r\nThe proposed keyword (`reentrant`) is meant to **mark a function explicitly re-entrant**. As a result, code generation of Solidity would need to introduce **a breaking change** that will cause the \"entrypoint\" of the bytecode to evaluate the reentrancy flag. \r\n\r\nFor the proposal to function properly, a `NON_REENTRANT_FLAG_OFFSET` compiler-literal would need to be introduced that signifies a storage slot's offset that is meant to indicate the re-entrant flag that is validated. This offset should be preferrably located in the upper-half of the `type(uint256).max` range that a smart contract's storage slot space supports to ensure no conflicts with existing implementations.\r\n\r\n### Keyword vs. Existing Syntax\r\n\r\nUpon additional feedback from @pcaversaccio and issue #12996, I would like to add some additional insight as to why a new keyword was chosen over the existing syntax. The original issue revolved around the concept of a new keyword and switched over to the idea of using `unchecked` to perform external calls without triggering any re-entrancy safety checks.\r\n\r\nThe `unchecked` keyword is meant to be utilized in the locale it is declared in (i.e. an upper-most `unchecked` block will not affect the statements of internal calls it makes), as such, such a solution is not viable if we want the new re-entrancy feature to be compatible with existing programming paradigms such as inheritance.\r\n\r\nWe are faced with either breaking the existing behaviour of `unchecked` to apply to internal call chains or introducing a new keyword. The latter appears to be more explicit and easier to grasp for security auditors and developers alike, however, feedback is appreciated.\r\n\r\n### Example Showcase\r\n\r\nTo illustrate how the generated bytecode would be altered, let us take a subset of the [`WETH9`](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) contract:\r\n\r\n```solidity\r\ncontract MockWETH9 {\r\n    event  Deposit(address indexed dst, uint wad);\r\n\r\n    mapping (address => uint) public  balanceOf;\r\n    \r\n    fallback() public payable {\r\n        deposit();\r\n    }\r\n    \r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}\r\n```\r\n\r\nThe above contract contains two functions that **do mutate the state** (`fallback` & `deposit`) as well as one function that **does not mutate the state** (`balanceOf`).\r\n\r\nIts compilation with current tools would result in the following bytecode in pseudo-code format:\r\n\r\n```solidity\r\ncontract MockWETH9Bytecode {\r\n    function main() {\r\n        memory[0x40:0x60] = 0x60;\r\n        \r\n        // Fallback Function\r\n        if (msg.data.length < 0x04) {\r\n        label_00AF:\r\n            var var0 = 0x00b7;\r\n            deposit();\r\n            stop();\r\n        } else {\r\n            // Extract Function Signature\r\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\r\n\r\n            // Signature Comparison\r\n            if (var0 == 0xd0e30db0) {\r\n                // Pseudo-Code of deposit()\r\n                var1 = 0x03d2;\r\n                deposit();\r\n                stop();\r\n            } else if (var0 == 0x70a08231) {\r\n                // Pseudo-Code of balanceOf(address)\r\n\r\n                if (msg.value) { revert(memory[0x00:0x00]); }\r\n            \r\n                var1 = 0x02cc;\r\n                var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\r\n                var2 = balanceOf(var2);\r\n                var temp17 = memory[0x40:0x60];\r\n                memory[temp17:temp17 + 0x20] = var2;\r\n                var temp18 = memory[0x40:0x60];\r\n                return memory[temp18:temp18 + (temp17 + 0x20) - temp18];\r\n            } else { goto label_00AF; }\r\n        }\r\n    }\r\n\r\n    function deposit() {\r\n        memory[0x00:0x20] = msg.sender;\r\n        memory[0x20:0x40] = 0x03;\r\n        var temp0 = keccak256(memory[0x00:0x40]);\r\n        storage[temp0] = storage[temp0] + msg.value;\r\n        var temp1 = memory[0x40:0x60];\r\n        memory[temp1:temp1 + 0x20] = msg.value;\r\n        var temp2 = memory[0x40:0x60];\r\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\r\n    }\r\n\r\n    function balanceOf(var arg0) returns (var arg0) {\r\n        memory[0x20:0x40] = 0x03;\r\n        memory[0x00:0x20] = arg0;\r\n        return storage[keccak256(memory[0x00:0x40])];\r\n    }\r\n}\r\n```\r\n\r\nGiven that the compiler can detect which parts of the generated bytecode will mutate the state and which will not (based on the `view` / `pure` keywords), we have two cases of code generation:\r\n\r\n- No `reentrant` Functions Defined\r\n- n > 1 `reentrant` Functions Defined\r\n\r\n### No `reentrant` Function Case\r\n\r\nFor the first case, the bytecode generation module would inject a blanket check at the beginning of `main` that would validate the re-entrant state of the contract. Afterwards, the bytecode generation module would introduce an assignment to the re-entrant flag **solely in the `if-else` clauses that execute code mutating the state**. \r\n\r\nIdentifying the correct points of injection should be trivial as the compiler is already aware of which functions mutate the state via the `view` and `pure` keywords. To illustrate how the bytecode generated would look like, let us take the first case with the original `MockWETH9` smart contract code:\r\n\r\n```solidity\r\ncontract MockWETH9Bytecode {\r\n    function main() {\r\n        memory[0x40:0x60] = 0x60;\r\n\r\n        // INJECTED CODE: Evaluate whether flag is already set and yield an error in case of re-entrancy\r\n        if (storage[NON_REENTRANT_FLAG_OFFSET] == 0x02) { revert(memory[0x00:0x00]); }\r\n        \r\n        // Fallback Function\r\n        if (msg.data.length < 0x04) {\r\n        label_00AF:\r\n            // INJECTED CODE: Mutating Function -> Set Non-Reentrant Flag\r\n            storage[NON_REENTRANT_FLAG_OFFSET] = 0x02;\r\n\r\n            var var0 = 0x00b7;\r\n            deposit();\r\n\r\n            // INJECTED CODE: Mutating Function -> Reset Non-Reentrant Flag\r\n            storage[NON_REENTRANT_FLAG_OFFSET] = 0x01;\r\n\r\n            stop();\r\n        } else {\r\n            // Extract Function Signature\r\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\r\n\r\n            // Signature Comparison\r\n            if (var0 == 0xd0e30db0) {\r\n                // Pseudo-Code of deposit()\r\n\r\n                // INJECTED CODE: Mutating Function -> Set Non-Reentrant Flag\r\n                storage[NON_REENTRANT_FLAG_OFFSET] = 0x02;\r\n\r\n                var1 = 0x03d2;\r\n                deposit();\r\n\r\n                // INJECTED CODE: Mutating Function -> Reset Non-Reentrant Flag\r\n                storage[NON_REENTRANT_FLAG_OFFSET] = 0x01;\r\n\r\n                stop();\r\n            } else if (var0 == 0x70a08231) {\r\n                // Pseudo-Code of balanceOf(address)\r\n                // Code Injection not necessary as function cannot mutate state\r\n\r\n                if (msg.value) { revert(memory[0x00:0x00]); }\r\n            \r\n                var1 = 0x02cc;\r\n                var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\r\n                var2 = balanceOf(var2);\r\n                var temp17 = memory[0x40:0x60];\r\n                memory[temp17:temp17 + 0x20] = var2;\r\n                var temp18 = memory[0x40:0x60];\r\n                return memory[temp18:temp18 + (temp17 + 0x20) - temp18];\r\n            } else { goto label_00AF; }\r\n        }\r\n    }\r\n\r\n    function deposit() {\r\n        memory[0x00:0x20] = msg.sender;\r\n        memory[0x20:0x40] = 0x03;\r\n        var temp0 = keccak256(memory[0x00:0x40]);\r\n        storage[temp0] = storage[temp0] + msg.value;\r\n        var temp1 = memory[0x40:0x60];\r\n        memory[temp1:temp1 + 0x20] = msg.value;\r\n        var temp2 = memory[0x40:0x60];\r\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\r\n    }\r\n\r\n    function balanceOf(var arg0) returns (var arg0) {\r\n        memory[0x20:0x40] = 0x03;\r\n        memory[0x00:0x20] = arg0;\r\n        return storage[keccak256(memory[0x00:0x40])];\r\n    }\r\n}\r\n```\r\n\r\nThe bytecode generator can further optimize the gas cost of the injection by performing the re-entrant flag assignment conditionally via a temporary variable which will hold the value of `storage[NON_REENTRANT_FLAG_OFFSET]` that is evaluated at the very start of the `main` block.\r\n\r\n### `reentrant` Function Case\r\n\r\nThis case would simply require the blanket check in the `main` code block showcased above to be relocated to all `if-else` bodies **that do NOT have the `reentrant` modifier** set. To illustrate how the `reentrant` keyword would be used, let us adjust the original `MockWETH9` code to now permit re-entrancy solely for the `deposit` function:\r\n\r\n```solidity\r\ncontract MockWETH9 {\r\n    event  Deposit(address indexed dst, uint wad);\r\n\r\n    mapping (address => uint) public  balanceOf;\r\n    \r\n    fallback() public payable {\r\n        deposit();\r\n    }\r\n    \r\n    function deposit() public payable reentrant {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}\r\n```\r\n\r\nThe bytecode generation would look like the following:\r\n\r\n```solidity\r\ncontract MockWETH9Bytecode {\r\n    function main() {\r\n        memory[0x40:0x60] = 0x60;\r\n        \r\n        // Fallback Function\r\n        if (msg.data.length < 0x04) {\r\n        label_00AF:\r\n            // INJECTED CODE: Evaluate whether flag is already set and yield an error in case of re-entrancy, else set flag\r\n            if (storage[NON_REENTRANT_FLAG_OFFSET] == 0x02) { revert(memory[0x00:0x00]); }\r\n            else { storage[NON_REENTRANT_FLAG_OFFSET] = 0x02; }\r\n\r\n            var var0 = 0x00b7;\r\n            deposit();\r\n\r\n            // INJECTED CODE: Mutating Function -> Reset Non-Reentrant Flag\r\n            storage[NON_REENTRANT_FLAG_OFFSET] = 0x01;\r\n\r\n            stop();\r\n        } else {\r\n            // Extract Function Signature\r\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\r\n\r\n            // Signature Comparison\r\n            if (var0 == 0xd0e30db0) {\r\n                // Pseudo-Code of deposit()\r\n\r\n                // INJECTED CODE: Mutating Function -> Set Non-Reentrant Flag\r\n                storage[NON_REENTRANT_FLAG_OFFSET] = 0x02;\r\n\r\n                var1 = 0x03d2;\r\n                deposit();\r\n\r\n                // INJECTED CODE: Mutating Function -> Reset Non-Reentrant Flag\r\n                storage[NON_REENTRANT_FLAG_OFFSET] = 0x01;\r\n\r\n                stop();\r\n            } else if (var0 == 0x70a08231) {\r\n                // Pseudo-Code of balanceOf(address)\r\n\r\n                // INJECTED CODE: Evaluate whether flag is already set and yield an error in case of re-entrancy\r\n                if (storage[NON_REENTRANT_FLAG_OFFSET] == 0x02) { revert(memory[0x00:0x00]); }\r\n\r\n                if (msg.value) { revert(memory[0x00:0x00]); }\r\n            \r\n                var1 = 0x02cc;\r\n                var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\r\n                var2 = balanceOf(var2);\r\n                var temp17 = memory[0x40:0x60];\r\n                memory[temp17:temp17 + 0x20] = var2;\r\n                var temp18 = memory[0x40:0x60];\r\n                return memory[temp18:temp18 + (temp17 + 0x20) - temp18];\r\n            } else { goto label_00AF; }\r\n        }\r\n    }\r\n\r\n    function deposit() {\r\n        memory[0x00:0x20] = msg.sender;\r\n        memory[0x20:0x40] = 0x03;\r\n        var temp0 = keccak256(memory[0x00:0x40]);\r\n        storage[temp0] = storage[temp0] + msg.value;\r\n        var temp1 = memory[0x40:0x60];\r\n        memory[temp1:temp1 + 0x20] = msg.value;\r\n        var temp2 = memory[0x40:0x60];\r\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\r\n    }\r\n\r\n    function balanceOf(var arg0) returns (var arg0) {\r\n        memory[0x20:0x40] = 0x03;\r\n        memory[0x00:0x20] = arg0;\r\n        return storage[keccak256(memory[0x00:0x40])];\r\n    }\r\n}\r\n```\r\n\r\nA yet-to-be defined behaviour arises if we declare the `fallback` function as `reentrant` when it invokes the `deposit` function which has not been declared so. To ensure maximal compatibility with existing programming paradigms, we believe that the `reentrant` keyword should mark a function as re-entrant regardless of its internal call chain. As a result, if we have the following code: \r\n\r\n```solidity\r\ncontract MockWETH9 {\r\n    event  Deposit(address indexed dst, uint wad);\r\n\r\n    mapping (address => uint) public  balanceOf;\r\n    \r\n    fallback() public payable reentrant {\r\n        deposit();\r\n    }\r\n    \r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}\r\n```\r\n\r\nThe function **`fallback` will be re-entrant even if it invokes `deposit` which we have not marked so**. This ensures compatibility with libraries / smart contract dependencies as otherwise users who wish to set their functions as `reentrant` deliberately would have to reflect that modifier to the full call-chain. Additionally, given that the introduction of the keyword is a concious and deliberate choice by the developer(s), we consider them to be fully aware of the implications of the `reentrant` keyword.\r\n\r\n### Advanced Usage\r\n\r\nWe are aware that re-entrancy is indeed desirable in a set of limited use cases, the most common being proxy implementations that follow a fragmented logic pattern and thus invoke themselves externally (i.e. Diamond standard cross-facet invocations). To accommodate for these implementations, we propose the introduction of an argument to the `reentrant` keyword similarly to how arguments are present for the `override` keyword.\r\n\r\nIn detail, we advise the introduction of a single, optional `address` argument which marks a function as `reentrant` but solely for a particular `address`. In the case of the Diamond standard, for example, we can introduce the `reentrant(address(this))` syntax to ensure that the facets of the Diamond can invoke each other without compromising the wider security guarantees of the system. \r\n\r\nAdditionally, this syntax permits complex smart contract systems that are meant to invoke one-another mid-execution to still function post-`0.9.X` securely. Multi-address support can be introduced, however, it should be delayed until a sufficient use-case is illustrated by the development community that cannot be solved by better programming practices.\r\n\r\n## Specification\r\n\r\nWhile the specification of how the new `reentrant` keyword will operate can be extracted from the above text, we would also like to highlight which sections of the [official Solidity documentation](https://docs.soliditylang.org/en/latest/index.html) would require adjustments to accommodate for this change. Reference specification can be produced upon request for all chapters outlined below should this feature request gain traction.\r\n\r\n### Contracts Section\r\n\r\nA new \"Re-Entrancy\" chapter would need to be introduced that describes how re-entrancy behaves post-`0.9.X` (in that it is prohibited) and how developers can make use of the `reentrant` keyword to bypass this security measure. A warning chapter should be introduced as well ensuring that the developers are well aware of the security guarantees they are **nullifying by using the keyword**.\r\n\r\n### Cheatsheet\r\n\r\nThe `Modifiers` section would need to be expanded with the new `reentrant` keyword and how it is meant to be used.\r\n\r\n### Language Grammar\r\n\r\nAn identical rule to the `override` specifier would need to be introduced specifying how the new `reentrant` keyword is meant to be parsed when reading Solidity code using machines.\r\n\r\n### Layout of State Variables In Storage\r\n\r\nThis chapter should specify the newly reserved `NON_REENTRANT_FLAG_OFFSET` as a matter of specification. Overwriting the storage area of the flag via overlap or a storage slot hash collision due to the usage of upgradeable patterns and standards such as [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967) should be of negligible concern with a likelihood akin to that of general hash collisions.\r\n\r\n### Solidity v0.9.0 Breaking Changes\r\n\r\nThis chapter should, as its namesake indicates, highlight the breaking change of how `reentrant` behaves and how contracts compiled in `pragma solidity ^0.9.0` will have re-entrancy protections enforced **by default**.\r\n\r\n<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow any developer to implement the functionality.-->\r\n\r\n## Backwards Compatibility\r\n\r\nAs the code generation's behaviour will change to enforce re-entrancy protection by default, **this is a breaking change** requiring a minor semver bump to prompt developers to get accustomed to the new security measure. \r\n\r\n## General Concerns\r\n\r\n### Security Bypass\r\n\r\nGiven that the change illustrated by this issue would rely on the storage space of the smart contract, developers will be able to explicitly unset the re-entrant flag via `assembly` blocks that access the low-level nature of the EVM and write to the `NON_REENTRANT_FLAG_OFFSET` storage slot. Such code is considered malicious by nature and should be flagged by auditors as well as potential static analyzers that aid them.\r\n\r\n### Bytecode & Gas Increase\r\n\r\nThe issue attempts to explain the proposed change in the Solidity language in a way that minimizes the gas footprint as well as bytecode size impact. Nevertheless, both of these numbers will increase for all contracts compiled beyond `0.9.X`. \r\n\r\nWe believe the security guarantees achieved by this change to be worth the extra units of gas and size, **which is evidenced by the developer community itself** via the common usage of libraries implementing this trait such as [`ReentrancyGuard`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/security/ReentrancyGuard.sol) by OpenZeppelin.\r\n\r\n## Resources\r\n\r\nThe pseudo-code of the bytecode was generated by the [ethervm](https://ethervm.io/) decompiler and was consequently manually edited to illustrate the smaller subset of `MockWETH9` as well as the adjustments that `reentrant` and post-`0.9.X` compilation would cause.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/13845/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/13845/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1371489939",
    "html_url": "https://github.com/ethereum/solidity/issues/13845#issuecomment-1371489939",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13845",
    "id": 1371489939,
    "node_id": "IC_kwDOAm_5kc5Rv0aT",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-04T22:12:09Z",
    "updated_at": "2023-01-04T22:12:09Z",
    "author_association": "NONE",
    "body": "Linking my issue here for obvious reasons https://github.com/ethereum/solidity/issues/12996. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1371489939/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1371555563",
    "html_url": "https://github.com/ethereum/solidity/issues/13845#issuecomment-1371555563",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13845",
    "id": 1371555563,
    "node_id": "IC_kwDOAm_5kc5RwEbr",
    "user": {
      "login": "alex-ppg",
      "id": 31933616,
      "node_id": "MDQ6VXNlcjMxOTMzNjE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/31933616?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-ppg",
      "html_url": "https://github.com/alex-ppg",
      "followers_url": "https://api.github.com/users/alex-ppg/followers",
      "following_url": "https://api.github.com/users/alex-ppg/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-ppg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-ppg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-ppg/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-ppg/orgs",
      "repos_url": "https://api.github.com/users/alex-ppg/repos",
      "events_url": "https://api.github.com/users/alex-ppg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-ppg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-04T23:51:53Z",
    "updated_at": "2023-01-04T23:51:53Z",
    "author_association": "NONE",
    "body": "Thanks @pcaversaccio for the additional context, updated original issue with additional background.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1371555563/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
