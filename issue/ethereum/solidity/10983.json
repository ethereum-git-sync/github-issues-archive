{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/10983",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/10983/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/10983/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/10983/events",
  "html_url": "https://github.com/ethereum/solidity/issues/10983",
  "id": 812808185,
  "node_id": "MDU6SXNzdWU4MTI4MDgxODU=",
  "number": 10983,
  "title": "Compiles but Error: invalid bytecode when trying to deploy ",
  "user": {
    "login": "gitpusha",
    "id": 36712489,
    "node_id": "MDQ6VXNlcjM2NzEyNDg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/36712489?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gitpusha",
    "html_url": "https://github.com/gitpusha",
    "followers_url": "https://api.github.com/users/gitpusha/followers",
    "following_url": "https://api.github.com/users/gitpusha/following{/other_user}",
    "gists_url": "https://api.github.com/users/gitpusha/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gitpusha/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gitpusha/subscriptions",
    "organizations_url": "https://api.github.com/users/gitpusha/orgs",
    "repos_url": "https://api.github.com/users/gitpusha/repos",
    "events_url": "https://api.github.com/users/gitpusha/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gitpusha/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2021-02-21T09:01:31Z",
  "updated_at": "2021-02-22T10:52:16Z",
  "closed_at": "2021-02-22T10:52:15Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nI have one specific function which compiles fine but when I try to deploy the contract which it is on with `hardhat-deploy` I get an `Error: invalid bytecode` . \r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.0\r\n- Framework/IDE: hardhat\r\n- EVM execution environment / backend / blockchain client: hardhat network\r\n- Operating system: macOS \r\n \r\n## Steps to Reproduce\r\nThe contract is not public yet but I am trying to distill down the part that is causing the bug here. \r\n\r\n1. Compile `ExecFacet` contract with `hardhat compile` using `0.8.0` (solc-js) \r\n2. No compilation error. \r\n3. Try to deploy the `ExecFacet` contract with `hardhat-deploy` \r\n4. Get `Error: invalid bytecode`\r\n\r\n![image](https://user-images.githubusercontent.com/36712489/108620046-7fb54780-7429-11eb-9183-36f04c69e83a.png)\r\n\r\n\r\n```solidity\r\npragma solidity 0.8.0;\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            set._values.length > index,\r\n            \"EnumerableSet: index out of bounds\"\r\n        );\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\nlibrary LibService {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using LibExecutor for address;\r\n    using LibService for address;\r\n\r\n    bytes32 private constant _SERVICE_STORAGE =\r\n        keccak256(\"gelato.diamond.service.storage\");\r\n\r\n    struct ServiceStorage {\r\n        EnumerableSet.AddressSet services;\r\n        mapping(address => EnumerableSet.AddressSet) servicesByExecutor;\r\n    }\r\n\r\n    function isListed(address _service) internal view returns (bool) {\r\n        return serviceStorage().services.contains(_service);\r\n    }\r\n\r\n    function isAcceptedByExecutor(address _service, address _executor)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            serviceStorage().servicesByExecutor[_executor].contains(_service);\r\n    }\r\n\r\n    function serviceStorage()\r\n        internal\r\n        pure\r\n        returns (ServiceStorage storage ss)\r\n    {\r\n        bytes32 position = _SERVICE_STORAGE;\r\n        assembly {\r\n            ss.slot := position\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary LibExecutor {\r\n    using LibService for address;\r\n\r\n    function canExec(address _service, address _executor)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _service.isListed() && _service.isAcceptedByExecutor(_executor);\r\n    }\r\n}\r\n\r\ncontract ExecFacet  {\r\n   using LibExecutor for address;\r\n    using LibService for address;\r\n\r\n    function canExec(address _service, address _executor)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _service.canExec(_executor);\r\n    }\r\n}\r\n```\r\n\r\nNow the interesting bit is that it compiles fine but doesnt deploy. \r\n\r\nHowever, when I get rid of `LibExecutor` and change the `canExec` code to this, it compiles and deploys. The `invalid bytecode` error is gone. \r\n\r\n\r\n```solidity\r\ncontract ExecFacet  {\r\n    using LibService for address;\r\n\r\n    function canExec(address _service, address _executor)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _service.isListed() && _service.isAcceptedByExecutor(_executor);\r\n    }\r\n}\r\n```\r\n\r\nTagging @wighawag who built `hardhat-deploy` . \r\n",
  "closed_by": {
    "login": "gitpusha",
    "id": 36712489,
    "node_id": "MDQ6VXNlcjM2NzEyNDg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/36712489?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gitpusha",
    "html_url": "https://github.com/gitpusha",
    "followers_url": "https://api.github.com/users/gitpusha/followers",
    "following_url": "https://api.github.com/users/gitpusha/following{/other_user}",
    "gists_url": "https://api.github.com/users/gitpusha/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gitpusha/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gitpusha/subscriptions",
    "organizations_url": "https://api.github.com/users/gitpusha/orgs",
    "repos_url": "https://api.github.com/users/gitpusha/repos",
    "events_url": "https://api.github.com/users/gitpusha/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gitpusha/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/10983/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/10983/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/782826998",
    "html_url": "https://github.com/ethereum/solidity/issues/10983#issuecomment-782826998",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/10983",
    "id": 782826998,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MjgyNjk5OA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-02-21T09:31:29Z",
    "updated_at": "2021-02-21T10:08:45Z",
    "author_association": "NONE",
    "body": "Not sure if it is about solidity. It looks like you are using libraries. if so you need to pass their address to the deploy function so it inject the address in the bytecode. \r\nThe diamond feature (that you seem to use here) is not complete and I do not remember if there is library support for the facet. that might be the problem. Probably better to move that into hardhat-deploy, unless you have more reason to believe it is a solidity issue\r\n\r\nEDIT: diamond deploy function actually support libraries, you might just not have added them",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/782826998/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/782835724",
    "html_url": "https://github.com/ethereum/solidity/issues/10983#issuecomment-782835724",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/10983",
    "id": 782835724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MjgzNTcyNA==",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-02-21T10:39:28Z",
    "updated_at": "2021-02-21T12:18:28Z",
    "author_association": "MEMBER",
    "body": "Exactly as @wighawag said, it's caused by the use of a library. If you compile your file with `solc --bin`, you'll see that the bytecode for `ExecFacet` looks like this:\r\n```\r\n======= contract.sol:ExecFacet =======\r\nBinary:\r\n608060405234801561001057600080fd5b5061029e806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80632a36291f14610030575b600080fd5b61004a60048036038101906100459190610135565b610060565b60405161005791906101e1565b60405180910390f35b60008273ffffffffffffffffffffffffffffffffffffffff1673__$02fc603ed1f5b1296c4169c74e287e9021$__632a36291f9091846040518363ffffffff1660e01b81526004016100b39291906101b8565b60206040518083038186803b1580156100cb57600080fd5b505af41580156100df573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101039190610171565b905092915050565b60008135905061011a8161023a565b92915050565b60008151905061012f81610251565b92915050565b6000806040838503121561014857600080fd5b60006101568582860161010b565b92505060206101678582860161010b565b9150509250929050565b60006020828403121561018357600080fd5b600061019184828501610120565b91505092915050565b6101a3816101fc565b82525050565b6101b28161020e565b82525050565b60006040820190506101cd600083018561019a565b6101da602083018461019a565b9392505050565b60006020820190506101f660008301846101a9565b92915050565b60006102078261021a565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b610243816101fc565b811461024e57600080fd5b50565b61025a8161020e565b811461026557600080fd5b5056fea2646970667358221220e97f4bc81ea0ee155da8f688bcbdeaeffc63a3600d78a20c0aa1f0b58cc74e7d64736f6c63430008010033\r\n\r\n// $02fc603ed1f5b1296c4169c74e287e9021$ -> contract.sol:LibExecutor\r\n```\r\n\r\nNote the `__$02fc603ed1f5b1296c4169c74e287e9021$__` placeholder in the middle of the bytecode. It means that that there is something in the code that requires the contract to know the address where the library is deployed. Normally, when you're only using internal functions from a library it does not need to get deployed at all because the compiler includes the code of internal functions in contract bytecode. In your case, however, `LibService.canExec()` is a public function which means that any calls from within a contract will be external (this is a bit different from how `public` works in contracts). This means that the library needs to get deployed first and then you need to pass the address where it was deployed to the compiler using the `--libraries` option.\r\n\r\nIn your case a simple fix would be just to make `LibService.canExec()` `internal` (unless you really want an external call here for some reason).\r\n\r\n@wighawag To make this easier for users, maybe you could detect the placeholders (they have a constant length and structure, at least the new-style ones) and make the error message more specific?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/782835724/reactions",
      "total_count": 13,
      "+1": 13,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/783285056",
    "html_url": "https://github.com/ethereum/solidity/issues/10983#issuecomment-783285056",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/10983",
    "id": 783285056,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MzI4NTA1Ng==",
    "user": {
      "login": "gitpusha",
      "id": 36712489,
      "node_id": "MDQ6VXNlcjM2NzEyNDg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/36712489?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gitpusha",
      "html_url": "https://github.com/gitpusha",
      "followers_url": "https://api.github.com/users/gitpusha/followers",
      "following_url": "https://api.github.com/users/gitpusha/following{/other_user}",
      "gists_url": "https://api.github.com/users/gitpusha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gitpusha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gitpusha/subscriptions",
      "organizations_url": "https://api.github.com/users/gitpusha/orgs",
      "repos_url": "https://api.github.com/users/gitpusha/repos",
      "events_url": "https://api.github.com/users/gitpusha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gitpusha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-02-22T10:52:15Z",
    "updated_at": "2021-02-22T10:52:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks I marked the library function as `public` by mistake. Should be `internal` like all other library functions I use on there. Stupid mistake lol. @wighawag and @cameel thanks for the tips though. Next time I get an invalid bytecode I know what to check for. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/783285056/reactions",
      "total_count": 8,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 4,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
