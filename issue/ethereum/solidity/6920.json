{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/6920/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/6920/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/6920/events",
  "html_url": "https://github.com/ethereum/solidity/issues/6920",
  "id": 454177128,
  "node_id": "MDU6SXNzdWU0NTQxNzcxMjg=",
  "number": 6920,
  "title": "Version of library that enforces functional design",
  "user": {
    "login": "snario",
    "id": 1933029,
    "node_id": "MDQ6VXNlcjE5MzMwMjk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/snario",
    "html_url": "https://github.com/snario",
    "followers_url": "https://api.github.com/users/snario/followers",
    "following_url": "https://api.github.com/users/snario/following{/other_user}",
    "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
    "organizations_url": "https://api.github.com/users/snario/orgs",
    "repos_url": "https://api.github.com/users/snario/repos",
    "events_url": "https://api.github.com/users/snario/events{/privacy}",
    "received_events_url": "https://api.github.com/users/snario/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 785717317,
      "node_id": "MDU6TGFiZWw3ODU3MTczMTc=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/language%20design%20:rage4:",
      "name": "language design :rage4:",
      "color": "9d76d3",
      "default": false,
      "description": "Any changes to the language, e.g. new features"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2019-06-10T13:41:36Z",
  "updated_at": "2022-08-17T13:48:46Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "It would be very nice for state channel based applications if we could restrict the set of applications to be `library` contracts that define a single data structure and only allow functional methods; that is, methods with a function signature like:\r\n\r\n```solidity\r\nstruct KnownState { ... }\r\nfunction functionalMethod(KnownState state, ...) returns (KnownState);\r\n```\r\n\r\nPerhaps this could also be a new kind of contract type? Maybe a `data` contract type? Ruby's `class` object seems to be similar to what I am describing by restricting class methods to return the same data type as the object the class is describing.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/6920/reactions",
    "total_count": 4,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 1,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/6920/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500787906",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500787906",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500787906,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDc4NzkwNg==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T10:44:25Z",
    "updated_at": "2019-06-11T10:44:25Z",
    "author_association": "MEMBER",
    "body": "I'd say this is somewhat related to https://github.com/ethereum/solidity/issues/4637, although a bit different - might be worth thinking about whether both requests can be satisfied with the same language construct.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500787906/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500834449",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500834449",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500834449,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDgzNDQ0OQ==",
    "user": {
      "login": "snario",
      "id": 1933029,
      "node_id": "MDQ6VXNlcjE5MzMwMjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snario",
      "html_url": "https://github.com/snario",
      "followers_url": "https://api.github.com/users/snario/followers",
      "following_url": "https://api.github.com/users/snario/following{/other_user}",
      "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
      "organizations_url": "https://api.github.com/users/snario/orgs",
      "repos_url": "https://api.github.com/users/snario/repos",
      "events_url": "https://api.github.com/users/snario/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snario/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T13:12:05Z",
    "updated_at": "2019-06-11T13:12:05Z",
    "author_association": "NONE",
    "body": "@ekpyron it is quite similar, yeah. Would be happy to go into more detail about the use case if you'd like. Generally, we feel quite confident that this would be very useful for defining state transition logic in state channel applications.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500834449/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500851343",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500851343",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500851343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDg1MTM0Mw==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T13:52:53Z",
    "updated_at": "2019-06-11T13:54:50Z",
    "author_association": "MEMBER",
    "body": "It might be good to go into some more detail, yes. If only a specific library (or a small set of libraries that is known in advance) should be able to implement such state transitions, then this will probably entirely fall under #4637, right? But you probably want arbitrary new libraries to be able to define new state transitions and just restrict the signature of functions that can use the state?\r\n\r\nI'm wondering: is it necessary to actually define a hard syntactic restriction for this? An analysis tool could easily check whether all occurrences of the struct are like this without the need of a new contract type or syntactic errors in solidity itself, couldn't it?\r\n\r\nShould the restriction only be for *writing* to the struct? I could imagine something like ``validate(KnownState state)`` or ``outputDebugInformation(KnownState state)`` to still be useful... I assume functions with the ``function(KnownState state) returns (KnownState)`` signature are generally also assumed to only *read* from ``state`` and never to modify it?\r\n\r\nIs this meant for ``KnownState`` to be in memory, in storage, in calldata or in any of those?\r\n\r\nEDIT: resp. should this apply to internal or external library functions or both? Only for library functions, or for other types of functions as well?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500851343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500856225",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500856225",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500856225,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDg1NjIyNQ==",
    "user": {
      "login": "snario",
      "id": 1933029,
      "node_id": "MDQ6VXNlcjE5MzMwMjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snario",
      "html_url": "https://github.com/snario",
      "followers_url": "https://api.github.com/users/snario/followers",
      "following_url": "https://api.github.com/users/snario/following{/other_user}",
      "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
      "organizations_url": "https://api.github.com/users/snario/orgs",
      "repos_url": "https://api.github.com/users/snario/repos",
      "events_url": "https://api.github.com/users/snario/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snario/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T14:03:58Z",
    "updated_at": "2019-06-11T14:03:58Z",
    "author_association": "NONE",
    "body": "@ekpyron I think it would only apply to external library functions, probably optionally memory, in storage, or in calldata, but for the case of handling challenges in state channels, likely in calldata.\r\n\r\nAlso, `state` would be readonly.\r\n\r\nHere is an example:\r\n\r\n```solidity\r\nlibrary FunctionalCounter {\r\n\r\n    struct State {\r\n        uint256 value;\r\n    }\r\n\r\n    function add1(State calldata state) external pure returns (State memory) { \r\n        return State(state.value + 1);\r\n    }\r\n\r\n}\r\n```\r\n\r\nI think having a syntactic restriction around it would make it very hard for developers to mess up and make the model of having data structures that can be modified only via EVM-compatible state transitions be very clear. \r\n\r\nIt would also mean that client software for state channels that want to ensure that state transitions are valid in the applications they're supporting wouldn't need to import any kind of code analysis tools and could rely on the Solidity compiler.\r\n\r\nI'm not exactly sure though if that's the right opinion to have here though, maybe having separate pieces of software validating these libraries is the cleaner approach?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500856225/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500859111",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500859111",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500859111,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDg1OTExMQ==",
    "user": {
      "login": "snario",
      "id": 1933029,
      "node_id": "MDQ6VXNlcjE5MzMwMjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snario",
      "html_url": "https://github.com/snario",
      "followers_url": "https://api.github.com/users/snario/followers",
      "following_url": "https://api.github.com/users/snario/following{/other_user}",
      "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
      "organizations_url": "https://api.github.com/users/snario/orgs",
      "repos_url": "https://api.github.com/users/snario/repos",
      "events_url": "https://api.github.com/users/snario/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snario/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T14:10:56Z",
    "updated_at": "2019-06-11T14:10:56Z",
    "author_association": "NONE",
    "body": "In state channels the state structure we are thinking of that motivates this use case will roughly look like this:\r\n\r\n```solidity\r\nstruct ChannelState {\r\n    bytes state;\r\n    address stateTransitionLibrary;\r\n    bytes transitionData;\r\n    ...\r\n}\r\n```\r\n\r\nUsing the `FunctionalCounter` example above, then `s1` might have the `state` being the encoded version of the `uint256` value `1`, the `stateTransitionLibrary` being the address of a `FunctionalCounter` library. Then, `s2` would have `transitionData` being the encoded version of `add1`.\r\n\r\nThen the client logic would compute `s2Expected = FunctionalCounter.add1(s1.state)` to get `<State value={2}>` which is what `s2.state` would encode and so if `s2Expected.state == s2.state` then the transition is valid and the party can consider it as a valid state channel update.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500859111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500871283",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500871283",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500871283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDg3MTI4Mw==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T14:37:47Z",
    "updated_at": "2019-06-11T14:44:10Z",
    "author_association": "MEMBER",
    "body": "Hm... maybe it would make sense to extend #4637 with some notion of \"library interfaces\" or \"library inheritance\"... e.g. (to sketch the rough idea):\r\n```\r\ninterface StateTransitionInterface {\r\n  private struct ChannelState {\r\n    bytes state;\r\n    StateTransitionInterface stateTransitionLibrary;\r\n  }\r\n  function stateChange(ChannelState calldata input) external returns (ChannelState);\r\n}\r\nlibrary FunctionalCounter is StateTransitionLibrary {\r\n  function stateChange(StateTransitionInterface.ChannelState calldata input) external returns (StateTransitionInterface.ChannelState) { ... }\r\n}\r\n```\r\nWhere ``private struct`` is to be replaced by whatever syntax we'd add for \"closed structs\" in #4637.\r\nThe idea being that only libraries inheriting from ``StateTransitionInterface`` can access ``ChannelState`` and can only do so in the interface functions given in ``StateTransitionInterface``...\r\n\r\nWould that work for solving your use case? I'm not entirely sure about it... and I'm wondering what @chriseth's (who is currently on vacation) and @axic's take is on this...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500871283/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500914432",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500914432",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500914432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDkxNDQzMg==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T16:14:40Z",
    "updated_at": "2019-06-11T16:14:40Z",
    "author_association": "MEMBER",
    "body": "Another question: is there a reason for the state transition contracts to be libraries in your use case? So do you need to access the callers storage and rely on delegatecall? Or are the state changes likely to be ``view`` or even ``pure`` functions anyways? So could the state transition be an ``interface`` and the \"state transition libraries\" be regular contracts implementing that interface? Then #4637 could just be extended from libraries to interfaces and we wouldn't need to add library interfaces or inheritance...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500914432/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500922065",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500922065",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500922065,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDkyMjA2NQ==",
    "user": {
      "login": "snario",
      "id": 1933029,
      "node_id": "MDQ6VXNlcjE5MzMwMjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snario",
      "html_url": "https://github.com/snario",
      "followers_url": "https://api.github.com/users/snario/followers",
      "following_url": "https://api.github.com/users/snario/following{/other_user}",
      "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
      "organizations_url": "https://api.github.com/users/snario/orgs",
      "repos_url": "https://api.github.com/users/snario/repos",
      "events_url": "https://api.github.com/users/snario/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snario/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T16:33:13Z",
    "updated_at": "2019-06-11T16:33:13Z",
    "author_association": "NONE",
    "body": "@ekpyron State changes will _only_ be `view` or `pure` functions.\r\n\r\nThe name thing I'm hoping to achieve is not requiring the implementation to have a single accessor function (e.g., `applyAction(state, action)`) and instead allow developers to just define functions like they would for any regular Solidity contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500922065/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500929821",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500929821",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500929821,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDkyOTgyMQ==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T16:51:44Z",
    "updated_at": "2019-06-11T16:51:44Z",
    "author_association": "MEMBER",
    "body": "Ok, in that case a solution involving interfaces will probably be of limited use.\r\nThen I would take a step back :-).\r\n\r\nI'm not sure about your original suggestion of restricting the function signatures in which the struct is allowed to occur - would it be enough to introduce a concept like ``immutable`` structs? I.e. a struct that can be constructed, but not modified after being constructed. That way you could construct a new \"sane\" state, but could not mess with a state by only writing to some of its members. That would basically result in a restriction very similar to what you originally proposed, right?\r\n\r\nAdditionally, it might be nice to introduce something like an ``address view`` for the ``stateTransitionLibrary`` that only allows ``staticcalls`` and thereby enforces state changes to be ``view`` or ``pure``.\r\n\r\nIs that a direction that makes sense to you?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500929821/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500975276",
    "html_url": "https://github.com/ethereum/solidity/issues/6920#issuecomment-500975276",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/6920",
    "id": 500975276,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMDk3NTI3Ng==",
    "user": {
      "login": "snario",
      "id": 1933029,
      "node_id": "MDQ6VXNlcjE5MzMwMjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1933029?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/snario",
      "html_url": "https://github.com/snario",
      "followers_url": "https://api.github.com/users/snario/followers",
      "following_url": "https://api.github.com/users/snario/following{/other_user}",
      "gists_url": "https://api.github.com/users/snario/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/snario/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/snario/subscriptions",
      "organizations_url": "https://api.github.com/users/snario/orgs",
      "repos_url": "https://api.github.com/users/snario/repos",
      "events_url": "https://api.github.com/users/snario/events{/privacy}",
      "received_events_url": "https://api.github.com/users/snario/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-11T18:51:13Z",
    "updated_at": "2019-06-11T18:51:13Z",
    "author_association": "NONE",
    "body": "That satisfies most requirements except for having a guarantee that a function call applied to the old state will return a new state of the same type.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/500975276/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
