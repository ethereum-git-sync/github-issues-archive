{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/14023",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/14023/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/14023/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/14023/events",
  "html_url": "https://github.com/ethereum/solidity/issues/14023",
  "id": 1609248744,
  "node_id": "I_kwDOAm_5kc5f6y_o",
  "number": 14023,
  "title": "Call of not existing function reverts but without reason",
  "user": {
    "login": "migoldfinger",
    "id": 106750422,
    "node_id": "U_kgDOBlzh1g",
    "avatar_url": "https://avatars.githubusercontent.com/u/106750422?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/migoldfinger",
    "html_url": "https://github.com/migoldfinger",
    "followers_url": "https://api.github.com/users/migoldfinger/followers",
    "following_url": "https://api.github.com/users/migoldfinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/migoldfinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/migoldfinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/migoldfinger/subscriptions",
    "organizations_url": "https://api.github.com/users/migoldfinger/orgs",
    "repos_url": "https://api.github.com/users/migoldfinger/repos",
    "events_url": "https://api.github.com/users/migoldfinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/migoldfinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2023-03-03T21:06:07Z",
  "updated_at": "2023-03-07T10:17:25Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\n<!--Please shortly describe the bug you have found, and what you expect instead.-->\r\nWhile writing unit tests for my contracts I did run in an unexpected behavior.\r\nA call to an non existing function did revert the transaction (as expected), but there was no reason so the caller is left in the dark about the reason of the revert. It did pop up on existing unit tests after upgrading the compiler version older compiler versions did revert with the  reason \"Transaction reverted: function returned an unexpected amount of data\". That was not ideal but it was something.\r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.17\r\n- Framework/IDE (e.g. Truffle or Remix): hardhat\r\n- Operating system: Linux (RockyLinux)\r\n\r\n## Steps to Reproduce\r\n\r\nI was taking a closer look on the SafeERC20.sol implementation of openzeppelin, especially the safeIncreaseAllowance method\r\n```\r\nfunction safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n}\r\n\r\nfunction _callOptionalReturn(IERC20 token, bytes memory data) private\r\n    {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0)\r\n        {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 call failed\");\r\n        }\r\n    }\r\n```\r\nI notices that when calling with an address that does not hold a contract this reverts with no reason. Older compiler reverted with reason \"Transaction reverted: function returned an unexpected amount of data\".\r\n\r\nIn an attempt to fix this behavior and return some useful reason I changed the method to\r\n```\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal\r\n    {\r\n        uint256 newAllowance = _callReturnUint256(token, abi.encodeWithSelector(token.allowance.selector, address(this), spender)) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private\r\n    {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0)\r\n        {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 call failed\");\r\n        }\r\n    }\r\n\r\n    function _callReturnUint256(IERC20 token, bytes memory data) private returns (uint256)\r\n    {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        console.log(returndata.length);\r\n        if (returndata.length != 32)\r\n        {\r\n            revert(\"SafeERC20: ERC20 call failed\");\r\n        }\r\n        return abi.decode(returndata, (uint256));\r\n    }\r\n```\r\nthe method functionCall is located at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\nThis solved the problem with the reason but I am still struggling with one feature yet.\r\nI was unable to find a way to check the return type in regards of type correctness.\r\nMy tests show that a token with an allowance that returns uin128 instead of uint256 is still be valid.\r\nWhile this is not problematic in my use case since I am satisfied with every value that fits in an uint256.\r\nFrom an type-safe point of view this in not optimal.\r\nI did not find a way to check for type correctness until now.\r\nI also did try to put the call inside a try/catch but it seems that a reverted transaction did not hit the catch block.\r\n\r\nSo in addition to get some revert reason strings when the called method is missing I would love to get some revert with reason if the return type is not matching the expected type. If I do not have to rely to low level calls to achieve this it would be the best option.\r\n\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/14023/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/14023/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1455896605",
    "html_url": "https://github.com/ethereum/solidity/issues/14023#issuecomment-1455896605",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14023",
    "id": 1455896605,
    "node_id": "IC_kwDOAm_5kc5Wxzgd",
    "user": {
      "login": "migoldfinger",
      "id": 106750422,
      "node_id": "U_kgDOBlzh1g",
      "avatar_url": "https://avatars.githubusercontent.com/u/106750422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/migoldfinger",
      "html_url": "https://github.com/migoldfinger",
      "followers_url": "https://api.github.com/users/migoldfinger/followers",
      "following_url": "https://api.github.com/users/migoldfinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/migoldfinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/migoldfinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/migoldfinger/subscriptions",
      "organizations_url": "https://api.github.com/users/migoldfinger/orgs",
      "repos_url": "https://api.github.com/users/migoldfinger/repos",
      "events_url": "https://api.github.com/users/migoldfinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/migoldfinger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-06T10:45:18Z",
    "updated_at": "2023-03-06T11:16:18Z",
    "author_association": "NONE",
    "body": "@Vinayak-Patil-Dev thanks for your copy & paste general answer, it was very helpful do go over all the 4 Points again with the same result.\r\n\r\nHowever I did try out different compiler versions in the meantime. And at least it looks like hardhat is not fetching the reason in this case. I am unsure why but I create an issue there maybe they changed something.\r\n\r\nHowever my second problem still stands. How can I check the returnvalue to be correct inside a contract. because the returned bytecode looks exactly the same for uint8, uint... and uint256.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1455896605/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
