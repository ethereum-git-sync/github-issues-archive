{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/14444/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/14444/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/14444/events",
  "html_url": "https://github.com/ethereum/solidity/issues/14444",
  "id": 1817760224,
  "node_id": "I_kwDOAm_5kc5sWNHg",
  "number": 14444,
  "title": "Inconsistent gas usage for conversion of calldata to memory in external call and internal call.",
  "user": {
    "login": "charlesxsh",
    "id": 8362565,
    "node_id": "MDQ6VXNlcjgzNjI1NjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8362565?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/charlesxsh",
    "html_url": "https://github.com/charlesxsh",
    "followers_url": "https://api.github.com/users/charlesxsh/followers",
    "following_url": "https://api.github.com/users/charlesxsh/following{/other_user}",
    "gists_url": "https://api.github.com/users/charlesxsh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/charlesxsh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/charlesxsh/subscriptions",
    "organizations_url": "https://api.github.com/users/charlesxsh/orgs",
    "repos_url": "https://api.github.com/users/charlesxsh/repos",
    "events_url": "https://api.github.com/users/charlesxsh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/charlesxsh/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 249074435,
      "node_id": "MDU6TGFiZWwyNDkwNzQ0MzU=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/bug%20:bug:",
      "name": "bug :bug:",
      "color": "fc1313",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2023-07-24T06:50:00Z",
  "updated_at": "2023-07-26T15:39:42Z",
  "closed_at": "2023-07-25T10:47:01Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nInconsistent gas usage for conversion of calldata to memory in external call and internal call. This is observed after 0.8.0. In 0.7.6, their gas usages are the consistent.\r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.17\r\n- Target EVM version (as per compiler settings): any\r\n- Framework/IDE (e.g. Truffle or Remix): Remix\r\n- EVM execution environment / backend / blockchain client: any\r\n- Operating system: any\r\n\r\n## Steps to Reproduce\r\n\r\n```solidity\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\ncontract Dummy {\r\n    function iacceptmem(uint256[] memory amounts) internal {\r\n    }\r\n   \r\n    function test1(uint256[] memory amounts) external {\r\n        iacceptmem(amounts);\r\n    }\r\n\r\n    function test2(uint256[] calldata amounts) external {\r\n        iacceptmem(amounts);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Tester {\r\n    Dummy d = new Dummy();\r\n\r\n    function call_test1() external {\r\n        uint256[] memory data = new uint256[](1000);\r\n        d.test1(data);\r\n    }\r\n\r\n    function call_test2() external {\r\n        uint256[] memory data = new uint256[](1000);\r\n        d.test2(data);\r\n    }\r\n}\r\n```\r\n\r\nIf you deploy Tester and call `call_test1` and `call_test2`, you will find that execution cost of `call_test2` is 295126, but `call_test1` is 517391. From yul, we can see they both have the conversion from calldata to memory once. But what is the difference is `call_test2` is converting before `iacceptmem` call, `call_test1` is converting at before executing the `test1`.\r\n\r\n",
  "closed_by": {
    "login": "r0qs",
    "id": 457348,
    "node_id": "MDQ6VXNlcjQ1NzM0OA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/457348?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/r0qs",
    "html_url": "https://github.com/r0qs",
    "followers_url": "https://api.github.com/users/r0qs/followers",
    "following_url": "https://api.github.com/users/r0qs/following{/other_user}",
    "gists_url": "https://api.github.com/users/r0qs/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/r0qs/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/r0qs/subscriptions",
    "organizations_url": "https://api.github.com/users/r0qs/orgs",
    "repos_url": "https://api.github.com/users/r0qs/repos",
    "events_url": "https://api.github.com/users/r0qs/events{/privacy}",
    "received_events_url": "https://api.github.com/users/r0qs/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/14444/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/14444/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1649599171",
    "html_url": "https://github.com/ethereum/solidity/issues/14444#issuecomment-1649599171",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
    "id": 1649599171,
    "node_id": "IC_kwDOAm_5kc5iUuLD",
    "user": {
      "login": "r0qs",
      "id": 457348,
      "node_id": "MDQ6VXNlcjQ1NzM0OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/457348?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/r0qs",
      "html_url": "https://github.com/r0qs",
      "followers_url": "https://api.github.com/users/r0qs/followers",
      "following_url": "https://api.github.com/users/r0qs/following{/other_user}",
      "gists_url": "https://api.github.com/users/r0qs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/r0qs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/r0qs/subscriptions",
      "organizations_url": "https://api.github.com/users/r0qs/orgs",
      "repos_url": "https://api.github.com/users/r0qs/repos",
      "events_url": "https://api.github.com/users/r0qs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/r0qs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-25T10:47:01Z",
    "updated_at": "2023-07-25T11:15:28Z",
    "author_association": "MEMBER",
    "body": "Hi @charlesxsh,\r\n\r\nthanks for reaching out, however this is not an issue. A possible reason of the gas difference can be the switch to [ABIEncoderV2](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics) which has more validation on calldata arguments, but there is no reason to believe those two functions should have equal cost. The fact that they had in previous releases is just coincidence.\r\n\r\nI'm cross-posting a discussion that we have with @ekpyron about your example that may help to understand what is happening:\r\n```\r\nThe first function copies from calldata to memory before entering the function, passing around merely \r\na memory reference.\r\nThe second one keeps things in calldata at first (while performing some validation on it) and then does \r\na full copy to memory later on the `iacceptmem` call.\r\nI don't see how anything else could be happening there and why that would have same cost.\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1649599171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1650028838",
    "html_url": "https://github.com/ethereum/solidity/issues/14444#issuecomment-1650028838",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
    "id": 1650028838,
    "node_id": "IC_kwDOAm_5kc5iWXEm",
    "user": {
      "login": "charlesxsh",
      "id": 8362565,
      "node_id": "MDQ6VXNlcjgzNjI1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8362565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charlesxsh",
      "html_url": "https://github.com/charlesxsh",
      "followers_url": "https://api.github.com/users/charlesxsh/followers",
      "following_url": "https://api.github.com/users/charlesxsh/following{/other_user}",
      "gists_url": "https://api.github.com/users/charlesxsh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charlesxsh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charlesxsh/subscriptions",
      "organizations_url": "https://api.github.com/users/charlesxsh/orgs",
      "repos_url": "https://api.github.com/users/charlesxsh/repos",
      "events_url": "https://api.github.com/users/charlesxsh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charlesxsh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-25T15:10:18Z",
    "updated_at": "2023-07-25T15:16:05Z",
    "author_association": "NONE",
    "body": "Hi there, thanks for replying! However, I am not sure I fully understand the point here. I believe they should have similar gas consumption because they both convert from `calldata` to `memory` once. The only difference is the happening order. From yul file, it also proves that the most heavy function `abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr` is called:\r\n1. For `Dummy.test1 `, it is called in the wrapper before actually calling `Dummy.test1`\r\n2. For `Dummy.test2`, it is called before calling `iacceptmem`\r\n\r\nIn Remix IDE, the gas consumption for `Tester.call_test1` and `Tester.call_test2` is **552455** and **316317**. Not sure I understand correctly, it seems like you both think the second one should consume more. \r\nFrom yul file, they indeed have some small differences on CALLDATALOAD and other opcode, but that cannot explain the huge gas difference here.\r\nWould you elaborate more about why they have such huge gas consumption?\r\n\r\n@r0qs @ekpyron ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1650028838/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1650036715",
    "html_url": "https://github.com/ethereum/solidity/issues/14444#issuecomment-1650036715",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
    "id": 1650036715,
    "node_id": "IC_kwDOAm_5kc5iWY_r",
    "user": {
      "login": "charlesxsh",
      "id": 8362565,
      "node_id": "MDQ6VXNlcjgzNjI1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8362565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charlesxsh",
      "html_url": "https://github.com/charlesxsh",
      "followers_url": "https://api.github.com/users/charlesxsh/followers",
      "following_url": "https://api.github.com/users/charlesxsh/following{/other_user}",
      "gists_url": "https://api.github.com/users/charlesxsh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charlesxsh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charlesxsh/subscriptions",
      "organizations_url": "https://api.github.com/users/charlesxsh/orgs",
      "repos_url": "https://api.github.com/users/charlesxsh/repos",
      "events_url": "https://api.github.com/users/charlesxsh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charlesxsh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-25T15:14:41Z",
    "updated_at": "2023-07-25T15:14:41Z",
    "author_association": "NONE",
    "body": "Attach the yul file here for convenience.\r\n```\r\nIR:\r\n\r\n/// @use-src 0:\"test.sol\"\r\nobject \"Dummy_31\" {\r\n    code {\r\n        /// @src 0:34:309  \"contract Dummy {...\"\r\n        mstore(64, memoryguard(128))\r\n        if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n\r\n        constructor_Dummy_31()\r\n\r\n        let _1 := allocate_unbounded()\r\n        codecopy(_1, dataoffset(\"Dummy_31_deployed\"), datasize(\"Dummy_31_deployed\"))\r\n\r\n        return(_1, datasize(\"Dummy_31_deployed\"))\r\n\r\n        function allocate_unbounded() -> memPtr {\r\n            memPtr := mload(64)\r\n        }\r\n\r\n        function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n            revert(0, 0)\r\n        }\r\n\r\n        /// @src 0:34:309  \"contract Dummy {...\"\r\n        function constructor_Dummy_31() {\r\n\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n        }\r\n        /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n    }\r\n    /// @use-src 0:\"test.sol\"\r\n    object \"Dummy_31_deployed\" {\r\n        code {\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n            mstore(64, memoryguard(128))\r\n\r\n            if iszero(lt(calldatasize(), 4))\r\n            {\r\n                let selector := shift_right_224_unsigned(calldataload(0))\r\n                switch selector\r\n\r\n                case 0x6a3273b7\r\n                {\r\n                    // test1(uint256[])\r\n\r\n                    external_fun_test1_19()\r\n                }\r\n\r\n                case 0x6f1f05ed\r\n                {\r\n                    // test2(uint256[])\r\n\r\n                    external_fun_test2_30()\r\n                }\r\n\r\n                default {}\r\n            }\r\n\r\n            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()\r\n\r\n            function shift_right_224_unsigned(value) -> newValue {\r\n                newValue :=\r\n\r\n                shr(224, value)\r\n\r\n            }\r\n\r\n            function allocate_unbounded() -> memPtr {\r\n                memPtr := mload(64)\r\n            }\r\n\r\n            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function round_up_to_mul_of_32(value) -> result {\r\n                result := and(add(value, 31), not(31))\r\n            }\r\n\r\n            function panic_error_0x41() {\r\n                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\r\n                mstore(4, 0x41)\r\n                revert(0, 0x24)\r\n            }\r\n\r\n            function finalize_allocation(memPtr, size) {\r\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\r\n                // protect against overflow\r\n                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }\r\n                mstore(64, newFreePtr)\r\n            }\r\n\r\n            function allocate_memory(size) -> memPtr {\r\n                memPtr := allocate_unbounded()\r\n                finalize_allocation(memPtr, size)\r\n            }\r\n\r\n            function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {\r\n                // Make sure we can allocate memory without overflow\r\n                if gt(length, 0xffffffffffffffff) { panic_error_0x41() }\r\n\r\n                size := mul(length, 0x20)\r\n\r\n                // add length slot\r\n                size := add(size, 0x20)\r\n\r\n            }\r\n\r\n            function revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function cleanup_t_uint256(value) -> cleaned {\r\n                cleaned := value\r\n            }\r\n\r\n            function validator_revert_t_uint256(value) {\r\n                if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }\r\n            }\r\n\r\n            function abi_decode_t_uint256(offset, end) -> value {\r\n                value := calldataload(offset)\r\n                validator_revert_t_uint256(value)\r\n            }\r\n\r\n            // uint256[]\r\n            function abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(offset, length, end) -> array {\r\n                array := allocate_memory(array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length))\r\n                let dst := array\r\n\r\n                mstore(array, length)\r\n                dst := add(array, 0x20)\r\n\r\n                let srcEnd := add(offset, mul(length, 0x20))\r\n                if gt(srcEnd, end) {\r\n                    revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef()\r\n                }\r\n                for { let src := offset } lt(src, srcEnd) { src := add(src, 0x20) }\r\n                {\r\n\r\n                    let elementPos := src\r\n\r\n                    mstore(dst, abi_decode_t_uint256(elementPos, end))\r\n                    dst := add(dst, 0x20)\r\n                }\r\n            }\r\n\r\n            // uint256[]\r\n            function abi_decode_t_array$_t_uint256_$dyn_memory_ptr(offset, end) -> array {\r\n                if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }\r\n                let length := calldataload(offset)\r\n                array := abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(add(offset, 0x20), length, end)\r\n            }\r\n\r\n            function abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(headStart, dataEnd) -> value0 {\r\n                if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n                {\r\n\r\n                    let offset := calldataload(add(headStart, 0))\r\n                    if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }\r\n\r\n                    value0 := abi_decode_t_array$_t_uint256_$dyn_memory_ptr(add(headStart, offset), dataEnd)\r\n                }\r\n\r\n            }\r\n\r\n            function abi_encode_tuple__to__fromStack(headStart ) -> tail {\r\n                tail := add(headStart, 0)\r\n\r\n            }\r\n\r\n            function external_fun_test1_19() {\r\n\r\n                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                let param_0 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(4, calldatasize())\r\n                fun_test1_19(param_0)\r\n                let memPos := allocate_unbounded()\r\n                let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                return(memPos, sub(memEnd, memPos))\r\n\r\n            }\r\n\r\n            function revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // uint256[]\r\n            function abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(offset, end) -> arrayPos, length {\r\n                if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }\r\n                length := calldataload(offset)\r\n                if gt(length, 0xffffffffffffffff) { revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() }\r\n                arrayPos := add(offset, 0x20)\r\n                if gt(add(arrayPos, mul(length, 0x20)), end) { revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() }\r\n            }\r\n\r\n            function abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(headStart, dataEnd) -> value0, value1 {\r\n                if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n                {\r\n\r\n                    let offset := calldataload(add(headStart, 0))\r\n                    if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }\r\n\r\n                    value0, value1 := abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(add(headStart, offset), dataEnd)\r\n                }\r\n\r\n            }\r\n\r\n            function external_fun_test2_30() {\r\n\r\n                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                let param_0, param_1 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(4, calldatasize())\r\n                fun_test2_30(param_0, param_1)\r\n                let memPos := allocate_unbounded()\r\n                let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                return(memPos, sub(memEnd, memPos))\r\n\r\n            }\r\n\r\n            function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            /// @ast-id 19\r\n            /// @src 0:126:212  \"function test1(uint256[] memory amounts) external {...\"\r\n            function fun_test1_19(var_amounts_11_mpos) {\r\n\r\n                /// @src 0:197:204  \"amounts\"\r\n                let _1_mpos := var_amounts_11_mpos\r\n                let expr_15_mpos := _1_mpos\r\n                fun_iacceptmem_8(expr_15_mpos)\r\n\r\n            }\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n            /// @ast-id 8\r\n            /// @src 0:55:117  \"function iacceptmem(uint256[] memory amounts) internal {...\"\r\n            function fun_iacceptmem_8(var_amounts_4_mpos) {\r\n\r\n            }\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n            function convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(value, length) -> converted  {\r\n\r\n                // Copy the array to a free position in memory\r\n                converted :=\r\n\r\n                abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(value, length, calldatasize())\r\n\r\n            }\r\n\r\n            /// @ast-id 30\r\n            /// @src 0:218:306  \"function test2(uint256[] calldata amounts) external {...\"\r\n            function fun_test2_30(var_amounts_22_offset, var_amounts_22_length) {\r\n\r\n                /// @src 0:291:298  \"amounts\"\r\n                let _2_offset := var_amounts_22_offset\r\n                let _2_length := var_amounts_22_length\r\n                let expr_26_offset := _2_offset\r\n                let expr_26_length := _2_length\r\n                /// @src 0:280:299  \"iacceptmem(amounts)\"\r\n                let _3_mpos := convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(expr_26_offset, expr_26_length)\r\n                fun_iacceptmem_8(_3_mpos)\r\n\r\n            }\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n        }\r\n\r\n        data \".metadata\" hex\"a264697066735822122091a53881f8929bec21fa931e3080f22f8cb7c482302a60077aa702ca84fa110e64736f6c63430008140033\"\r\n    }\r\n\r\n}\r\n\r\n\r\nIR:\r\n\r\n/// @use-src 0:\"test.sol\"\r\nobject \"Tester_81\" {\r\n    code {\r\n        /// @src 0:312:598  \"contract Tester {...\"\r\n        mstore(64, memoryguard(128))\r\n        if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n\r\n        constructor_Tester_81()\r\n\r\n        let _1 := allocate_unbounded()\r\n        codecopy(_1, dataoffset(\"Tester_81_deployed\"), datasize(\"Tester_81_deployed\"))\r\n\r\n        return(_1, datasize(\"Tester_81_deployed\"))\r\n\r\n        function allocate_unbounded() -> memPtr {\r\n            memPtr := mload(64)\r\n        }\r\n\r\n        function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n            revert(0, 0)\r\n        }\r\n\r\n        function panic_error_0x41() {\r\n            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\r\n            mstore(4, 0x41)\r\n            revert(0, 0x24)\r\n        }\r\n\r\n        function abi_encode_tuple__to__fromStack(headStart ) -> tail {\r\n            tail := add(headStart, 0)\r\n\r\n        }\r\n\r\n        function revert_forward_1() {\r\n            let pos := allocate_unbounded()\r\n            returndatacopy(pos, 0, returndatasize())\r\n            revert(pos, returndatasize())\r\n        }\r\n\r\n        function shift_left_0(value) -> newValue {\r\n            newValue :=\r\n\r\n            shl(0, value)\r\n\r\n        }\r\n\r\n        function update_byte_slice_20_shift_0(value, toInsert) -> result {\r\n            let mask := 0xffffffffffffffffffffffffffffffffffffffff\r\n            toInsert := shift_left_0(toInsert)\r\n            value := and(value, not(mask))\r\n            result := or(value, and(toInsert, mask))\r\n        }\r\n\r\n        function cleanup_t_uint160(value) -> cleaned {\r\n            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n\r\n        function identity(value) -> ret {\r\n            ret := value\r\n        }\r\n\r\n        function convert_t_uint160_to_t_uint160(value) -> converted {\r\n            converted := cleanup_t_uint160(identity(cleanup_t_uint160(value)))\r\n        }\r\n\r\n        function convert_t_uint160_to_t_contract$_Dummy_$31(value) -> converted {\r\n            converted := convert_t_uint160_to_t_uint160(value)\r\n        }\r\n\r\n        function convert_t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(value) -> converted {\r\n            converted := convert_t_uint160_to_t_contract$_Dummy_$31(value)\r\n        }\r\n\r\n        function prepare_store_t_contract$_Dummy_$31(value) -> ret {\r\n            ret := value\r\n        }\r\n\r\n        function update_storage_value_offset_0t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(slot, value_0) {\r\n            let convertedValue_0 := convert_t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(value_0)\r\n            sstore(slot, update_byte_slice_20_shift_0(sload(slot), prepare_store_t_contract$_Dummy_$31(convertedValue_0)))\r\n        }\r\n\r\n        /// @src 0:312:598  \"contract Tester {...\"\r\n        function constructor_Tester_81() {\r\n\r\n            /// @src 0:312:598  \"contract Tester {...\"\r\n\r\n            /// @src 0:344:355  \"new Dummy()\"\r\n            let _2 := allocate_unbounded()\r\n            let _3 := add(_2, datasize(\"Dummy_31\"))\r\n            if or(gt(_3, 0xffffffffffffffff), lt(_3, _2)) { panic_error_0x41() }\r\n            datacopy(_2, dataoffset(\"Dummy_31\"), datasize(\"Dummy_31\"))\r\n            _3 := abi_encode_tuple__to__fromStack(_3)\r\n\r\n            let expr_37_address := create(0, _2, sub(_3, _2))\r\n\r\n            if iszero(expr_37_address) { revert_forward_1() }\r\n\r\n            update_storage_value_offset_0t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(0x00, expr_37_address)\r\n\r\n        }\r\n        /// @src 0:312:598  \"contract Tester {...\"\r\n\r\n    }\r\n    /// @use-src 0:\"test.sol\"\r\n    object \"Tester_81_deployed\" {\r\n        code {\r\n            /// @src 0:312:598  \"contract Tester {...\"\r\n            mstore(64, memoryguard(128))\r\n\r\n            if iszero(lt(calldatasize(), 4))\r\n            {\r\n                let selector := shift_right_224_unsigned(calldataload(0))\r\n                switch selector\r\n\r\n                case 0x5b364e45\r\n                {\r\n                    // call_test1()\r\n\r\n                    external_fun_call_test1_59()\r\n                }\r\n\r\n                case 0xe948a22b\r\n                {\r\n                    // call_test2()\r\n\r\n                    external_fun_call_test2_80()\r\n                }\r\n\r\n                default {}\r\n            }\r\n\r\n            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()\r\n\r\n            function shift_right_224_unsigned(value) -> newValue {\r\n                newValue :=\r\n\r\n                shr(224, value)\r\n\r\n            }\r\n\r\n            function allocate_unbounded() -> memPtr {\r\n                memPtr := mload(64)\r\n            }\r\n\r\n            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function abi_decode_tuple_(headStart, dataEnd)   {\r\n                if slt(sub(dataEnd, headStart), 0) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n            }\r\n\r\n            function abi_encode_tuple__to__fromStack(headStart ) -> tail {\r\n                tail := add(headStart, 0)\r\n\r\n            }\r\n\r\n            function external_fun_call_test1_59() {\r\n\r\n                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                abi_decode_tuple_(4, calldatasize())\r\n                fun_call_test1_59()\r\n                let memPos := allocate_unbounded()\r\n                let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                return(memPos, sub(memEnd, memPos))\r\n\r\n            }\r\n\r\n            function external_fun_call_test2_80() {\r\n\r\n                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                abi_decode_tuple_(4, calldatasize())\r\n                fun_call_test2_80()\r\n                let memPos := allocate_unbounded()\r\n                let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                return(memPos, sub(memEnd, memPos))\r\n\r\n            }\r\n\r\n            function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function cleanup_t_rational_1000_by_1(value) -> cleaned {\r\n                cleaned := value\r\n            }\r\n\r\n            function cleanup_t_uint256(value) -> cleaned {\r\n                cleaned := value\r\n            }\r\n\r\n            function identity(value) -> ret {\r\n                ret := value\r\n            }\r\n\r\n            function convert_t_rational_1000_by_1_to_t_uint256(value) -> converted {\r\n                converted := cleanup_t_uint256(identity(cleanup_t_rational_1000_by_1(value)))\r\n            }\r\n\r\n            function round_up_to_mul_of_32(value) -> result {\r\n                result := and(add(value, 31), not(31))\r\n            }\r\n\r\n            function panic_error_0x41() {\r\n                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\r\n                mstore(4, 0x41)\r\n                revert(0, 0x24)\r\n            }\r\n\r\n            function finalize_allocation(memPtr, size) {\r\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\r\n                // protect against overflow\r\n                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }\r\n                mstore(64, newFreePtr)\r\n            }\r\n\r\n            function allocate_memory(size) -> memPtr {\r\n                memPtr := allocate_unbounded()\r\n                finalize_allocation(memPtr, size)\r\n            }\r\n\r\n            function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {\r\n                // Make sure we can allocate memory without overflow\r\n                if gt(length, 0xffffffffffffffff) { panic_error_0x41() }\r\n\r\n                size := mul(length, 0x20)\r\n\r\n                // add length slot\r\n                size := add(size, 0x20)\r\n\r\n            }\r\n\r\n            function allocate_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length) -> memPtr {\r\n                let allocSize := array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length)\r\n                memPtr := allocate_memory(allocSize)\r\n\r\n                mstore(memPtr, length)\r\n\r\n            }\r\n\r\n            function zero_memory_chunk_t_uint256(dataStart, dataSizeInBytes) {\r\n                calldatacopy(dataStart, calldatasize(), dataSizeInBytes)\r\n            }\r\n\r\n            function allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length) -> memPtr {\r\n                memPtr := allocate_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length)\r\n                let dataStart := memPtr\r\n                let dataSize := array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length)\r\n\r\n                dataStart := add(dataStart, 32)\r\n                dataSize := sub(dataSize, 32)\r\n\r\n                zero_memory_chunk_t_uint256(dataStart, dataSize)\r\n            }\r\n\r\n            function shift_right_0_unsigned(value) -> newValue {\r\n                newValue :=\r\n\r\n                shr(0, value)\r\n\r\n            }\r\n\r\n            function cleanup_from_storage_t_contract$_Dummy_$31(value) -> cleaned {\r\n                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n\r\n            function extract_from_storage_value_offset_0t_contract$_Dummy_$31(slot_value) -> value {\r\n                value := cleanup_from_storage_t_contract$_Dummy_$31(shift_right_0_unsigned(slot_value))\r\n            }\r\n\r\n            function read_from_storage_split_offset_0_t_contract$_Dummy_$31(slot) -> value {\r\n                value := extract_from_storage_value_offset_0t_contract$_Dummy_$31(sload(slot))\r\n\r\n            }\r\n\r\n            function cleanup_t_uint160(value) -> cleaned {\r\n                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n\r\n            function convert_t_uint160_to_t_uint160(value) -> converted {\r\n                converted := cleanup_t_uint160(identity(cleanup_t_uint160(value)))\r\n            }\r\n\r\n            function convert_t_uint160_to_t_address(value) -> converted {\r\n                converted := convert_t_uint160_to_t_uint160(value)\r\n            }\r\n\r\n            function convert_t_contract$_Dummy_$31_to_t_address(value) -> converted {\r\n                converted := convert_t_uint160_to_t_address(value)\r\n            }\r\n\r\n            function revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            function shift_left_224(value) -> newValue {\r\n                newValue :=\r\n\r\n                shl(224, value)\r\n\r\n            }\r\n\r\n            function abi_decode_tuple__fromMemory(headStart, dataEnd)   {\r\n                if slt(sub(dataEnd, headStart), 0) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n            }\r\n\r\n            function array_length_t_array$_t_uint256_$dyn_memory_ptr(value) -> length {\r\n\r\n                length := mload(value)\r\n\r\n            }\r\n\r\n            function array_storeLengthForEncoding_t_array$_t_uint256_$dyn_memory_ptr_fromStack(pos, length) -> updated_pos {\r\n                mstore(pos, length)\r\n                updated_pos := add(pos, 0x20)\r\n            }\r\n\r\n            function array_dataslot_t_array$_t_uint256_$dyn_memory_ptr(ptr) -> data {\r\n                data := ptr\r\n\r\n                data := add(ptr, 0x20)\r\n\r\n            }\r\n\r\n            function abi_encode_t_uint256_to_t_uint256(value, pos) {\r\n                mstore(pos, cleanup_t_uint256(value))\r\n            }\r\n\r\n            function abi_encodeUpdatedPos_t_uint256_to_t_uint256(value0, pos) -> updatedPos {\r\n                abi_encode_t_uint256_to_t_uint256(value0, pos)\r\n                updatedPos := add(pos, 0x20)\r\n            }\r\n\r\n            function array_nextElement_t_array$_t_uint256_$dyn_memory_ptr(ptr) -> next {\r\n                next := add(ptr, 0x20)\r\n            }\r\n\r\n            // uint256[] -> uint256[]\r\n            function abi_encode_t_array$_t_uint256_$dyn_memory_ptr_to_t_array$_t_uint256_$dyn_memory_ptr_fromStack(value, pos)  -> end  {\r\n                let length := array_length_t_array$_t_uint256_$dyn_memory_ptr(value)\r\n                pos := array_storeLengthForEncoding_t_array$_t_uint256_$dyn_memory_ptr_fromStack(pos, length)\r\n                let baseRef := array_dataslot_t_array$_t_uint256_$dyn_memory_ptr(value)\r\n                let srcPtr := baseRef\r\n                for { let i := 0 } lt(i, length) { i := add(i, 1) }\r\n                {\r\n                    let elementValue0 := mload(srcPtr)\r\n                    pos := abi_encodeUpdatedPos_t_uint256_to_t_uint256(elementValue0, pos)\r\n                    srcPtr := array_nextElement_t_array$_t_uint256_$dyn_memory_ptr(srcPtr)\r\n                }\r\n                end := pos\r\n            }\r\n\r\n            function abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(headStart , value0) -> tail {\r\n                tail := add(headStart, 32)\r\n\r\n                mstore(add(headStart, 0), sub(tail, headStart))\r\n                tail := abi_encode_t_array$_t_uint256_$dyn_memory_ptr_to_t_array$_t_uint256_$dyn_memory_ptr_fromStack(value0,  tail)\r\n\r\n            }\r\n\r\n            function revert_forward_1() {\r\n                let pos := allocate_unbounded()\r\n                returndatacopy(pos, 0, returndatasize())\r\n                revert(pos, returndatasize())\r\n            }\r\n\r\n            /// @ast-id 59\r\n            /// @src 0:362:476  \"function call_test1() external {...\"\r\n            function fun_call_test1_59() {\r\n\r\n                /// @src 0:441:445  \"1000\"\r\n                let expr_49 := 0x03e8\r\n                /// @src 0:427:446  \"new uint256[](1000)\"\r\n                let _1 := convert_t_rational_1000_by_1_to_t_uint256(expr_49)\r\n                let expr_50_mpos := allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(_1)\r\n                /// @src 0:403:446  \"uint256[] memory data = new uint256[](1000)\"\r\n                let var_data_45_mpos := expr_50_mpos\r\n                /// @src 0:456:457  \"d\"\r\n                let _2_address := read_from_storage_split_offset_0_t_contract$_Dummy_$31(0x00)\r\n                let expr_52_address := _2_address\r\n                /// @src 0:456:463  \"d.test1\"\r\n                let expr_54_address := convert_t_contract$_Dummy_$31_to_t_address(expr_52_address)\r\n                let expr_54_functionSelector := 0x6a3273b7\r\n                /// @src 0:464:468  \"data\"\r\n                let _3_mpos := var_data_45_mpos\r\n                let expr_55_mpos := _3_mpos\r\n                /// @src 0:456:469  \"d.test1(data)\"\r\n\r\n                if iszero(extcodesize(expr_54_address)) { revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() }\r\n\r\n                // storage for arguments and returned data\r\n                let _4 := allocate_unbounded()\r\n                mstore(_4, shift_left_224(expr_54_functionSelector))\r\n                let _5 := abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(add(_4, 4) , expr_55_mpos)\r\n\r\n                let _6 := call(gas(), expr_54_address,  0,  _4, sub(_5, _4), _4, 0)\r\n\r\n                if iszero(_6) { revert_forward_1() }\r\n\r\n                if _6 {\r\n\r\n                    let _7 := 0\r\n\r\n                    if gt(_7, returndatasize()) {\r\n                        _7 := returndatasize()\r\n                    }\r\n\r\n                    // update freeMemoryPointer according to dynamic return size\r\n                    finalize_allocation(_4, _7)\r\n\r\n                    // decode return parameters from external try-call into retVars\r\n                    abi_decode_tuple__fromMemory(_4, add(_4, _7))\r\n                }\r\n\r\n            }\r\n            /// @src 0:312:598  \"contract Tester {...\"\r\n\r\n            /// @ast-id 80\r\n            /// @src 0:482:596  \"function call_test2() external {...\"\r\n            function fun_call_test2_80() {\r\n\r\n                /// @src 0:561:565  \"1000\"\r\n                let expr_70 := 0x03e8\r\n                /// @src 0:547:566  \"new uint256[](1000)\"\r\n                let _8 := convert_t_rational_1000_by_1_to_t_uint256(expr_70)\r\n                let expr_71_mpos := allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(_8)\r\n                /// @src 0:523:566  \"uint256[] memory data = new uint256[](1000)\"\r\n                let var_data_66_mpos := expr_71_mpos\r\n                /// @src 0:576:577  \"d\"\r\n                let _9_address := read_from_storage_split_offset_0_t_contract$_Dummy_$31(0x00)\r\n                let expr_73_address := _9_address\r\n                /// @src 0:576:583  \"d.test2\"\r\n                let expr_75_address := convert_t_contract$_Dummy_$31_to_t_address(expr_73_address)\r\n                let expr_75_functionSelector := 0x6f1f05ed\r\n                /// @src 0:584:588  \"data\"\r\n                let _10_mpos := var_data_66_mpos\r\n                let expr_76_mpos := _10_mpos\r\n                /// @src 0:576:589  \"d.test2(data)\"\r\n\r\n                if iszero(extcodesize(expr_75_address)) { revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() }\r\n\r\n                // storage for arguments and returned data\r\n                let _11 := allocate_unbounded()\r\n                mstore(_11, shift_left_224(expr_75_functionSelector))\r\n                let _12 := abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(add(_11, 4) , expr_76_mpos)\r\n\r\n                let _13 := call(gas(), expr_75_address,  0,  _11, sub(_12, _11), _11, 0)\r\n\r\n                if iszero(_13) { revert_forward_1() }\r\n\r\n                if _13 {\r\n\r\n                    let _14 := 0\r\n\r\n                    if gt(_14, returndatasize()) {\r\n                        _14 := returndatasize()\r\n                    }\r\n\r\n                    // update freeMemoryPointer according to dynamic return size\r\n                    finalize_allocation(_11, _14)\r\n\r\n                    // decode return parameters from external try-call into retVars\r\n                    abi_decode_tuple__fromMemory(_11, add(_11, _14))\r\n                }\r\n\r\n            }\r\n            /// @src 0:312:598  \"contract Tester {...\"\r\n\r\n        }\r\n\r\n        data \".metadata\" hex\"a26469706673582212206b8eddd409c79e922dd0f0a51e1bc0de144b9cddce7abf43674cb1645c19260c64736f6c63430008140033\"\r\n    }\r\n\r\n    /// @use-src 0:\"test.sol\"\r\n    object \"Dummy_31\" {\r\n        code {\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n            mstore(64, memoryguard(128))\r\n            if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n\r\n            constructor_Dummy_31()\r\n\r\n            let _1 := allocate_unbounded()\r\n            codecopy(_1, dataoffset(\"Dummy_31_deployed\"), datasize(\"Dummy_31_deployed\"))\r\n\r\n            return(_1, datasize(\"Dummy_31_deployed\"))\r\n\r\n            function allocate_unbounded() -> memPtr {\r\n                memPtr := mload(64)\r\n            }\r\n\r\n            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n                revert(0, 0)\r\n            }\r\n\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n            function constructor_Dummy_31() {\r\n\r\n                /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n            }\r\n            /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n        }\r\n        /// @use-src 0:\"test.sol\"\r\n        object \"Dummy_31_deployed\" {\r\n            code {\r\n                /// @src 0:34:309  \"contract Dummy {...\"\r\n                mstore(64, memoryguard(128))\r\n\r\n                if iszero(lt(calldatasize(), 4))\r\n                {\r\n                    let selector := shift_right_224_unsigned(calldataload(0))\r\n                    switch selector\r\n\r\n                    case 0x6a3273b7\r\n                    {\r\n                        // test1(uint256[])\r\n\r\n                        external_fun_test1_19()\r\n                    }\r\n\r\n                    case 0x6f1f05ed\r\n                    {\r\n                        // test2(uint256[])\r\n\r\n                        external_fun_test2_30()\r\n                    }\r\n\r\n                    default {}\r\n                }\r\n\r\n                revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()\r\n\r\n                function shift_right_224_unsigned(value) -> newValue {\r\n                    newValue :=\r\n\r\n                    shr(224, value)\r\n\r\n                }\r\n\r\n                function allocate_unbounded() -> memPtr {\r\n                    memPtr := mload(64)\r\n                }\r\n\r\n                function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                function revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                function round_up_to_mul_of_32(value) -> result {\r\n                    result := and(add(value, 31), not(31))\r\n                }\r\n\r\n                function panic_error_0x41() {\r\n                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\r\n                    mstore(4, 0x41)\r\n                    revert(0, 0x24)\r\n                }\r\n\r\n                function finalize_allocation(memPtr, size) {\r\n                    let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\r\n                    // protect against overflow\r\n                    if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }\r\n                    mstore(64, newFreePtr)\r\n                }\r\n\r\n                function allocate_memory(size) -> memPtr {\r\n                    memPtr := allocate_unbounded()\r\n                    finalize_allocation(memPtr, size)\r\n                }\r\n\r\n                function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {\r\n                    // Make sure we can allocate memory without overflow\r\n                    if gt(length, 0xffffffffffffffff) { panic_error_0x41() }\r\n\r\n                    size := mul(length, 0x20)\r\n\r\n                    // add length slot\r\n                    size := add(size, 0x20)\r\n\r\n                }\r\n\r\n                function revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                function cleanup_t_uint256(value) -> cleaned {\r\n                    cleaned := value\r\n                }\r\n\r\n                function validator_revert_t_uint256(value) {\r\n                    if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }\r\n                }\r\n\r\n                function abi_decode_t_uint256(offset, end) -> value {\r\n                    value := calldataload(offset)\r\n                    validator_revert_t_uint256(value)\r\n                }\r\n\r\n                // uint256[]\r\n                function abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(offset, length, end) -> array {\r\n                    array := allocate_memory(array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length))\r\n                    let dst := array\r\n\r\n                    mstore(array, length)\r\n                    dst := add(array, 0x20)\r\n\r\n                    let srcEnd := add(offset, mul(length, 0x20))\r\n                    if gt(srcEnd, end) {\r\n                        revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef()\r\n                    }\r\n                    for { let src := offset } lt(src, srcEnd) { src := add(src, 0x20) }\r\n                    {\r\n\r\n                        let elementPos := src\r\n\r\n                        mstore(dst, abi_decode_t_uint256(elementPos, end))\r\n                        dst := add(dst, 0x20)\r\n                    }\r\n                }\r\n\r\n                // uint256[]\r\n                function abi_decode_t_array$_t_uint256_$dyn_memory_ptr(offset, end) -> array {\r\n                    if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }\r\n                    let length := calldataload(offset)\r\n                    array := abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(add(offset, 0x20), length, end)\r\n                }\r\n\r\n                function abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(headStart, dataEnd) -> value0 {\r\n                    if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n                    {\r\n\r\n                        let offset := calldataload(add(headStart, 0))\r\n                        if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }\r\n\r\n                        value0 := abi_decode_t_array$_t_uint256_$dyn_memory_ptr(add(headStart, offset), dataEnd)\r\n                    }\r\n\r\n                }\r\n\r\n                function abi_encode_tuple__to__fromStack(headStart ) -> tail {\r\n                    tail := add(headStart, 0)\r\n\r\n                }\r\n\r\n                function external_fun_test1_19() {\r\n\r\n                    if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                    let param_0 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(4, calldatasize())\r\n                    fun_test1_19(param_0)\r\n                    let memPos := allocate_unbounded()\r\n                    let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                    return(memPos, sub(memEnd, memPos))\r\n\r\n                }\r\n\r\n                function revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                // uint256[]\r\n                function abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(offset, end) -> arrayPos, length {\r\n                    if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }\r\n                    length := calldataload(offset)\r\n                    if gt(length, 0xffffffffffffffff) { revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() }\r\n                    arrayPos := add(offset, 0x20)\r\n                    if gt(add(arrayPos, mul(length, 0x20)), end) { revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() }\r\n                }\r\n\r\n                function abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(headStart, dataEnd) -> value0, value1 {\r\n                    if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\r\n\r\n                    {\r\n\r\n                        let offset := calldataload(add(headStart, 0))\r\n                        if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }\r\n\r\n                        value0, value1 := abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(add(headStart, offset), dataEnd)\r\n                    }\r\n\r\n                }\r\n\r\n                function external_fun_test2_30() {\r\n\r\n                    if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\r\n                    let param_0, param_1 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(4, calldatasize())\r\n                    fun_test2_30(param_0, param_1)\r\n                    let memPos := allocate_unbounded()\r\n                    let memEnd := abi_encode_tuple__to__fromStack(memPos  )\r\n                    return(memPos, sub(memEnd, memPos))\r\n\r\n                }\r\n\r\n                function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                /// @ast-id 19\r\n                /// @src 0:126:212  \"function test1(uint256[] memory amounts) external {...\"\r\n                function fun_test1_19(var_amounts_11_mpos) {\r\n\r\n                    /// @src 0:197:204  \"amounts\"\r\n                    let _1_mpos := var_amounts_11_mpos\r\n                    let expr_15_mpos := _1_mpos\r\n                    fun_iacceptmem_8(expr_15_mpos)\r\n\r\n                }\r\n                /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n                /// @ast-id 8\r\n                /// @src 0:55:117  \"function iacceptmem(uint256[] memory amounts) internal {...\"\r\n                function fun_iacceptmem_8(var_amounts_4_mpos) {\r\n\r\n                }\r\n                /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n                function convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(value, length) -> converted  {\r\n\r\n                    // Copy the array to a free position in memory\r\n                    converted :=\r\n\r\n                    abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(value, length, calldatasize())\r\n\r\n                }\r\n\r\n                /// @ast-id 30\r\n                /// @src 0:218:306  \"function test2(uint256[] calldata amounts) external {...\"\r\n                function fun_test2_30(var_amounts_22_offset, var_amounts_22_length) {\r\n\r\n                    /// @src 0:291:298  \"amounts\"\r\n                    let _2_offset := var_amounts_22_offset\r\n                    let _2_length := var_amounts_22_length\r\n                    let expr_26_offset := _2_offset\r\n                    let expr_26_length := _2_length\r\n                    /// @src 0:280:299  \"iacceptmem(amounts)\"\r\n                    let _3_mpos := convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(expr_26_offset, expr_26_length)\r\n                    fun_iacceptmem_8(_3_mpos)\r\n\r\n                }\r\n                /// @src 0:34:309  \"contract Dummy {...\"\r\n\r\n            }\r\n\r\n            data \".metadata\" hex\"a264697066735822122091a53881f8929bec21fa931e3080f22f8cb7c482302a60077aa702ca84fa110e64736f6c63430008140033\"\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1650036715/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1651813780",
    "html_url": "https://github.com/ethereum/solidity/issues/14444#issuecomment-1651813780",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
    "id": 1651813780,
    "node_id": "IC_kwDOAm_5kc5idK2U",
    "user": {
      "login": "r0qs",
      "id": 457348,
      "node_id": "MDQ6VXNlcjQ1NzM0OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/457348?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/r0qs",
      "html_url": "https://github.com/r0qs",
      "followers_url": "https://api.github.com/users/r0qs/followers",
      "following_url": "https://api.github.com/users/r0qs/following{/other_user}",
      "gists_url": "https://api.github.com/users/r0qs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/r0qs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/r0qs/subscriptions",
      "organizations_url": "https://api.github.com/users/r0qs/orgs",
      "repos_url": "https://api.github.com/users/r0qs/repos",
      "events_url": "https://api.github.com/users/r0qs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/r0qs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-26T13:30:59Z",
    "updated_at": "2023-07-26T15:24:48Z",
    "author_association": "MEMBER",
    "body": "> Hi there, thanks for replying! However, I am not sure I fully understand the point here. I believe they should have similar gas consumption because they both convert from `calldata` to `memory` once. The only difference is the happening order. From yul file, it also proves that the most heavy function `abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr` is called:\r\n> \r\n>     1. For `Dummy.test1 `, it is called in the wrapper before actually calling `Dummy.test\r\n> \r\n>     2. For `Dummy.test2`, it is called before calling `iacceptmem`\r\n> \r\n> \r\n> In Remix IDE, the gas consumption for `Tester.call_test1` and `Tester.call_test2` is **552455** and **316317**. Not sure I understand correctly, it seems like you both think the second one should consume more. From yul file, they indeed have some small differences on CALLDATALOAD and other opcode, but that cannot explain the huge gas difference here. Would you elaborate more about why they have such huge gas consumption?\r\n\r\nHi @charlesxsh, are you using the legacy code generation pipeline or compiling via IR? I suspect that is the former, and if so, I would recommend that you switch to the [via IR pipeline](https://docs.soliditylang.org/en/v0.8.21/ir-breaking-changes.html).\r\n\r\nIf you compile your code using Solidity version `0.7.6+commit.7338295f`, the legacy codegen (i.e. the current default in remix) and `pragma experimental ABIEncoderV2;` it will result in similar gas consumption of the one you posted using Solidity version `0.8.+`, which corroborates what I mentioned before that the gas increase is probably due to the use of [ABIEncoderV2](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics) in legacy codegen. And this is because the `ABIEconderV2` is written in Yul and calling it from legacy code generation has an inherit overhead.\r\n\r\nHowever, if you enable `viaIR` in the compiler settings you will get \"similar\" gas cost for both functions (e.g. around `268524`), but the second function will be slightly more expensive due to the validations that I mentioned previously. Regardless, you should keep in mind that they are not supposed to have equal gas costs and that it is recommended to use the via IR pipeline whenever possible since it will eventually become the default.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1651813780/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1652069961",
    "html_url": "https://github.com/ethereum/solidity/issues/14444#issuecomment-1652069961",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14444",
    "id": 1652069961,
    "node_id": "IC_kwDOAm_5kc5ieJZJ",
    "user": {
      "login": "charlesxsh",
      "id": 8362565,
      "node_id": "MDQ6VXNlcjgzNjI1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8362565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charlesxsh",
      "html_url": "https://github.com/charlesxsh",
      "followers_url": "https://api.github.com/users/charlesxsh/followers",
      "following_url": "https://api.github.com/users/charlesxsh/following{/other_user}",
      "gists_url": "https://api.github.com/users/charlesxsh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charlesxsh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charlesxsh/subscriptions",
      "organizations_url": "https://api.github.com/users/charlesxsh/orgs",
      "repos_url": "https://api.github.com/users/charlesxsh/repos",
      "events_url": "https://api.github.com/users/charlesxsh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charlesxsh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-26T15:39:42Z",
    "updated_at": "2023-07-26T15:39:42Z",
    "author_association": "NONE",
    "body": "Hi @r0qs , thanks for such detail response. Indeed I used the legacy code generation pipeline. And I tried enabling `viaIR` and both functions achieved the similar gas cost! That is amazing. The only question I left is the root cause for why legacy codegen + ABIEncoderV2 will make a huge gas difference for these two functions. Would you point out where is the related code for handling calldata -> memory conversion at the function parameter and at the function body in the compiler? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1652069961/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
