{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/5107/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/5107/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/5107/events",
  "html_url": "https://github.com/ethereum/solidity/issues/5107",
  "id": 364369139,
  "node_id": "MDU6SXNzdWUzNjQzNjkxMzk=",
  "number": 5107,
  "title": "Yul: Investigate potential memory-management optimizations and types",
  "user": {
    "login": "chriseth",
    "id": 9073706,
    "node_id": "MDQ6VXNlcjkwNzM3MDY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/chriseth",
    "html_url": "https://github.com/chriseth",
    "followers_url": "https://api.github.com/users/chriseth/followers",
    "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
    "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
    "organizations_url": "https://api.github.com/users/chriseth/orgs",
    "repos_url": "https://api.github.com/users/chriseth/repos",
    "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/chriseth/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1282209978,
      "node_id": "MDU6TGFiZWwxMjgyMjA5OTc4",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/optimizer",
      "name": "optimizer",
      "color": "d4c5f9",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2018-09-27T08:53:09Z",
  "updated_at": "2022-08-17T13:48:52Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Related: https://github.com/ethereum/solidity/issues/4033\r\n\r\n@Arachnid recently observed that in `function f(bytes32 a)`, the expression `keccak256(abi.encode(a, a))` is much more expensive than the old `keccak256(a, a)`. We should improve the optimizer to reduce both cases to the same code, which should roughly be `mstore(0, a) mstore(0x20, a) let result := keccak256(0, 0x40)`.\r\n\r\nThe problem is that `abi.encode` always returns a `bytes`, which has an address in memory and a stored length.  The optimizer should be able to reason about the lifetime of memory objects and all memory operations should be relative to memory ranges which can be moved around by the optimizer.\r\n\r\nFor that to work, there needs to be an IR-level `allocate` function and every memory access needs to provide the \"handle\" of the memory object it wants to access. So `abi.encode`, `keccak256` and the function `f` itself should be implemented roughly as follows:\r\n\r\n```\r\nfunction abi_encode_bytes32_bytes32(a, b) -> v {\r\n  v := allocate(0x60)\r\n  mobj_store(v, 0x00, 0x60)\r\n  mobj_store(v, 0x20, a)\r\n  mobj_store(v, 0x40, b)\r\n}\r\nfunction keccak256_bytes(v) -> h {\r\n  let len := mobj_load(v, 0x00)\r\n  h := mobj_keccak256(v, 0x20, len)\r\n}\r\nfunction f(a) -> h {\r\n  h := keccak256_bytes(abi_encode_bytes32_bytes32(a, a))\r\n}\r\n```\r\n\r\nSince the memory object is passed around in functions, we currently cannot improve that, but of course the optimizer would inline the two function calls as follows:\r\n```\r\nfunction f(a) -> h {\r\n  let v := allocate(0x60)\r\n  mobj_store(v, 0x00, 0x60)\r\n  mobj_store(v, 0x20, a)\r\n  mobj_store(v, 0x40, b)\r\n  let len := mobj_load(v, 0x00)\r\n  h := mobj_keccak256(v, 0x20, len)\r\n}\r\n```\r\n\r\nThe combination of `mobj_store(v, 0x00, 0x60)` and `let len := mobj_load(v, 0x00)` can of course be optimized to replace `len` by `0x60`:\r\n\r\n```\r\nfunction f(a) -> h {\r\n  let v := allocate(0x60)\r\n  mobj_store(v, 0x00, 0x60)\r\n  mobj_store(v, 0x20, a)\r\n  mobj_store(v, 0x40, b)\r\n  h := mobj_keccak256(v, 0x20, 0x60)\r\n}\r\n```\r\n\r\nAnd in this code snippet, we can now derive the following facts:\r\n\r\n - `v` is allocated only temporarily, so the \"free memory pointer\" can be reset at the end of the function\r\n - since the value written at `v[0]` is never read, and the allocation of `v` is temporary, it does not have to be written\r\n - this reduces the size of the allocated area and thus the code can be simplified to the following:\r\n\r\n```\r\nfunction f(a) -> h {\r\n  let v := allocate(0x40)\r\n  mobj_store(v, 0x00, a)\r\n  mobj_store(v, 0x20, b)\r\n  h := mobj_keccak256(v, 0x00, 0x40)\r\n}\r\n```\r\n\r\nFurthermore:\r\n\r\n - a temporary allocation of 64 bytes can be moved to the scratch space (we might also think about providing additional fixed-size scratch space at other places in the future)\r\n\r\nand thus:\r\n```\r\nfunction f(a) -> h {\r\n  let v := scratch(0x40)\r\n  mobj_store(v, 0x00, a)\r\n  mobj_store(v, 0x20, b)\r\n  h := mobj_keccak256(v, 0x00, 0x40)\r\n}\r\n```\r\n\r\nIf after memory management optimizations, the `mobj_store` and `allocate` calls are resolved, we end up with the following:\r\n```\r\nfunction f(a) -> h {\r\n  mstore(0x00, a)\r\n  mstore(0x20, b)\r\n  h := keccak256(0x00, 0x40)\r\n}\r\n```\r\n\r\n---\r\n\r\nSome routines need memory but cannot provide an upper bound at the point of allocation. The dynamic abi encoding functions are examples. For these, there could be the function `allocateUnbounded()`, which returns a memory object (a first implementation could just return the free memory pointer). There is a corresponding `releaseUnbounded()` function and the following property has to be fulfilled for all valid programs: Any control flow that starts from a point that calls `allocateUnbounded()` will first encounter a terminating builtin or a call to `releaseUnbounded()` before it encounters any other allocation call.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/5107/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/5107/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425012831",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-425012831",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 425012831,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTAxMjgzMQ==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T08:54:18Z",
    "updated_at": "2018-09-27T08:54:18Z",
    "author_association": "MEMBER",
    "body": "Tasks: formalize this :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425012831/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425015851",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-425015851",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 425015851,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTAxNTg1MQ==",
    "user": {
      "login": "liangdzou",
      "id": 1409883,
      "node_id": "MDQ6VXNlcjE0MDk4ODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1409883?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/liangdzou",
      "html_url": "https://github.com/liangdzou",
      "followers_url": "https://api.github.com/users/liangdzou/followers",
      "following_url": "https://api.github.com/users/liangdzou/following{/other_user}",
      "gists_url": "https://api.github.com/users/liangdzou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/liangdzou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/liangdzou/subscriptions",
      "organizations_url": "https://api.github.com/users/liangdzou/orgs",
      "repos_url": "https://api.github.com/users/liangdzou/repos",
      "events_url": "https://api.github.com/users/liangdzou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/liangdzou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T09:03:32Z",
    "updated_at": "2018-10-01T10:28:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "Sounds interesting, will have a try :-)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425015851/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425150747",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-425150747",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 425150747,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTE1MDc0Nw==",
    "user": {
      "login": "liangdzou",
      "id": 1409883,
      "node_id": "MDQ6VXNlcjE0MDk4ODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1409883?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/liangdzou",
      "html_url": "https://github.com/liangdzou",
      "followers_url": "https://api.github.com/users/liangdzou/followers",
      "following_url": "https://api.github.com/users/liangdzou/following{/other_user}",
      "gists_url": "https://api.github.com/users/liangdzou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/liangdzou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/liangdzou/subscriptions",
      "organizations_url": "https://api.github.com/users/liangdzou/orgs",
      "repos_url": "https://api.github.com/users/liangdzou/repos",
      "events_url": "https://api.github.com/users/liangdzou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/liangdzou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T16:07:49Z",
    "updated_at": "2018-10-01T10:29:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "Example:\r\n```\r\n  1 contract C {                                                                                                                                                                                              \r\n  2   function f(bytes32 a) public pure {                                           \r\n  3     keccak256(abi.encode(a, a));                                                \r\n  4   }                                                                             \r\n  5 }\r\n```\r\n\r\nGenerated code:\r\n```\r\n110     tag_6:                                                                                                                                                                                                \r\n111         /* \"t.sol\":74:75  a */                                                  \r\n112       dup1                                                                      \r\n113         /* \"t.sol\":77:78  a */                                                  \r\n114       dup2                                                                      \r\n115         /* \"t.sol\":63:79  abi.encode(a, a) */                                   \r\n116       add(0x20, mload(0x40))                                                    \r\n117       dup1                                                                      \r\n118       dup4                                                                      \r\n119       dup2                                                                      \r\n120       mstore                                                                    \r\n121       0x20                                                                      \r\n122       add                                                                       \r\n123       dup3                                                                      \r\n124       dup2                                                                      \r\n125       mstore                                                                    \r\n126       0x20                                                                      \r\n127       add                                                                       \r\n128       swap3                                                                     \r\n129       pop                                                                       \r\n130       pop                                                                       \r\n131       pop                                                                       \r\n132       mload(0x40)                                                               \r\n133         /* \"--CODEGEN--\":49:53   */                                             \r\n134       0x20                                                                      \r\n135         /* \"--CODEGEN--\":39:46   */                                             \r\n136       dup2                                                                      \r\n137         /* \"--CODEGEN--\":30:37   */                                             \r\n138       dup4                                                                      \r\n139         /* \"--CODEGEN--\":26:47   */                                             \r\n140       sub                                                                       \r\n141         /* \"--CODEGEN--\":22:54   */                                             \r\n142       sub                                                                       \r\n143         /* \"--CODEGEN--\":13:20   */                                             \r\n144       dup2                                                                      \r\n145         /* \"--CODEGEN--\":6:55   */                                              \r\n146       mstore                                                                    \r\n147         /* \"t.sol\":63:79  abi.encode(a, a) */                                   \r\n148       swap1                                                                     \r\n149       0x40                                                                      \r\n150       mstore                                                                    \r\n151         /* \"t.sol\":53:80  keccak256(abi.encode(a, a)) */                        \r\n152       dup1                                                                      \r\n153       mload                                                                     \r\n154       swap1                                                                     \r\n155       0x20                                                                      \r\n156       add                                                                       \r\n157       keccak256                                                                 \r\n158       pop                                                                       \r\n159         /* \"t.sol\":15:84  function f(bytes32 a) public pure {... */             \r\n160       pop                                                                       \r\n161       jump  // out\r\n```\r\n\r\nThe lines 111-150 calcuate abi.encode(a, a) and store it to memory, where the stack changed from \"..., a\" to \"..., a, encode_loc\".\r\nThe encoded result in memory has 0x60 bytes, and the content is \"0x40, a, a\".\r\n\r\nThe lines 152-157 calcualtes the keccak256(encode_loc + 0x20, 0x40)\r\n\r\nObservations:\r\n1. the encoded result is only used in function keccak256, therefore, we do not actually need to generate its presentation in memory.\r\n2. the size for the encoded result 0x40 <= scratch size, therefore, we can directly use the scratch size without allocating memory and set the free memory pointer.\r\n\r\nQuestion:\r\n1. Can we do something specifically for the situation when encode appears as an argument of a low-level function (not only for keccak256)?\r\n2. Is it better to avoid mstore at all for this case to operate directly in stack?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/425150747/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/455784884",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-455784884",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 455784884,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTc4NDg4NA==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-19T14:26:14Z",
    "updated_at": "2019-01-19T14:26:14Z",
    "author_association": "MEMBER",
    "body": "I vote for doing this and for prioritizing this!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/455784884/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/470718646",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-470718646",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 470718646,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDcxODY0Ng==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-07T22:16:53Z",
    "updated_at": "2019-03-11T14:19:06Z",
    "author_association": "MEMBER",
    "body": "@chriseth You mentioned that we might want to already use memory management functions e.g. in ``abi.encode`` and considered ``allocate_unknown`` and ``resize``, since the encoder doesn't know the length of the encoding in advance. However, I'm not sure whether it has to be more expensive to rewrite the encoder to first determine the length and to only write afterwards. Consider the following:\r\n\r\n```\r\nuint256 a = 42;\r\nuint256[] memory b = new uint256[](32);\r\nuint256[] memory c = new uint256[](16);\r\nuint256 d = 23;\r\nabi.encode(a,b,c,d);\r\n```\r\n\r\nNow the current encoder would implement ``abi.encode`` here (conceptually and very roughly) like:\r\n```\r\nfunction encode_now(headStart, a, b_ptr, c_ptr, d) -> tail {\r\n    let sizeofHead := mul(4, 32)\r\n    tail := add(headStart, size_of_current_head)\r\n\r\n    mstore(headStart, a)\r\n\r\n    mstore(add(headStart, 32), sub(tail, headStart))\r\n    tail := encode_dyn_now(b_ptr, tail)\r\n\r\n    mstore(add(headStart, 64), sub(tail, headStart))\r\n    tail := encode_dyn_now(c_ptr, tail)\r\n\r\n    mstore(headStart, d)\r\n}\r\nfunction encode_dyn_now(ptr, tail) -> newTail {\r\n    let length := read_length(ptr)\r\n    newTail := add(tail, add(length, 0x20))\r\n    mstore(tail, length)\r\n    copy(ptr, add(tail, 0x20), length)\r\n}\r\n```\r\n\r\nHowever, we could also do the following instead:\r\n```\r\nfunction encode_new(a, b_ptr, c_ptr, d) -> result {\r\n  let offset_a := 0\r\n  let length_a := 32\r\n  {\r\n    let offset_b := add(offset_a, length_a)\r\n    let length_b := add(read_length(b_ptr), 32)\r\n\r\n    {\r\n      let offset_c := add(offset_b, length_b)\r\n      let num_elems_c := read_length(c_ptr)\r\n      let length_c := add(num_elems_c, 32)\r\n\r\n      {\r\n        let offset_d := add(offset_c, length_c)\r\n        let length_d := 32\r\n\r\n        {\r\n          let length := add(offset_d, length_d)\r\n          result := allocate(length)\r\n          // actually, not sure how result would be handled stack-wise\r\n          // but theoretically it's no problem at the end of every scope\r\n          // to swap it behind every slot that's no longer used and\r\n          // then pop all those slots and still have result reachable in the end\r\n        }\r\n\r\n        // problem: stack is getting deep - d might not be accessible here\r\n        mobj_store(result, offset_d, d)\r\n      }\r\n\r\n      mobj_store(result, offset_c, num_elems_c)\r\n      encode_dyn_new(result, add(offset_c, 32), add(c_ptr, 32), num_elems_c)\r\n    }\r\n    mobj_store(result, offset_b, num_elems_b)\r\n    encode_dyn_new(result, add(offset_b, 32), add(b_ptr, 32), num_elems_b)\r\n  }\r\n}\r\nfunction encode_dyn_new(result, offset, ptr, length)\r\n{\r\n  copy_mobj(ptr, result, offset, length)\r\n}\r\n```\r\nI haven't yet written a complete example with the two different modes and checked what the optimizer would make of it, but my guess is that the latter way of doing things is not inherently more expensive than the former - the main issue is again stack depth (the large number of locals is not necessarily a problem, since they have good lifetime and access behaviour as indicated by the scopes, but the last argument needs to be accessible at the place with the comment above). The number of locals can be further reduced in the example case above and there might be a way to tweak it to be equally good as the current version.\r\n\r\nWhen I get around to, I'll write up compilable versions of the above and compare how the current optimizer deals with them.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/470718646/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/471557242",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-471557242",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 471557242,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MTU1NzI0Mg==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-11T14:18:57Z",
    "updated_at": "2019-03-11T14:18:57Z",
    "author_association": "MEMBER",
    "body": "@chriseth noted that my suggestion probably won't work for dynamically sized arrays with dynamically sized base pointers and I tend to agree now (so I'm minimizing above comment).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/471557242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/550420217",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-550420217",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 550420217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MDQyMDIxNw==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-06T17:39:30Z",
    "updated_at": "2020-04-03T13:37:03Z",
    "author_association": "MEMBER",
    "body": "In a global analysis step, the line `let v := allocate(x)` can be changed to `let v := 0x40` (the free memory pointer) if\r\n - `v` is not passed to any function except the builtin memory read/write functions and only as the memory object\r\n - `v` is not used anywhere else (not assigned to, not assigned from, etc).\r\n - `v` is not a return variable.\r\n - The function `allocate` nor any user-defined function that calls it is called after `let v := allocate(x)` until `v` goes out of scope.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/550420217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/550421698",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-550421698",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 550421698,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MDQyMTY5OA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-06T17:42:58Z",
    "updated_at": "2019-11-06T17:42:58Z",
    "author_association": "MEMBER",
    "body": "In a global analysis step, a function `function f(...) -> ... { ... }` can be changed to `function f(...) -> ... { let t := mload(0x40) ... mstore(0x40, t) }` if the following conditions are met:\r\n - all functions called from `f` meet these conditions\r\n - the return values of the `allocate` function called in `f`'s body are not stored in memory or storage and are not returned.\r\n\r\n(this might be relaxed a little)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/550421698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/638186410",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-638186410",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 638186410,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzODE4NjQxMA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-03T13:10:31Z",
    "updated_at": "2020-06-03T13:10:31Z",
    "author_association": "MEMBER",
    "body": "Let's start with by adding and using the functions in the yul code generator, ignoring range checks for now.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/638186410/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/638890232",
    "html_url": "https://github.com/ethereum/solidity/issues/5107#issuecomment-638890232",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/5107",
    "id": 638890232,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzODg5MDIzMg==",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-04T14:37:22Z",
    "updated_at": "2020-06-04T14:37:48Z",
    "author_association": "MEMBER",
    "body": "More details for the proposed first steps:\r\n\r\nStep 1:\r\n---------\r\nIntroduce the following Yul util functions, use them in Yul IR generation and the ABI encoder code, and eliminate all acesses of the free memory pointer this way:\r\n  - ``mobj_allocate(size) -> mobj`` - allocates ``size`` bytes by reading from and updating the free memory pointer\r\n  - ``mobj_allocate_unbounded() -> mobj_unbounded`` - just returns the current position of the free memory pointer\r\n  - ``mobj_finalize(mobj_unbounded, size) -> mobj`` - makes a previously unbounded memory object persistent, i.e. write ``add(mobj_unbounded, size)`` (rounded up) to the free memory pointer\r\n  - ``mobj_discard(mobj_unbounded)`` - discards a previously allocated memory object; does nothing (mainly to be used after ``mobj_allocate_unbounded()``, in case the unbounded memory was temporary and is discarded - but we should also try to use it after all allocations; later we can decide, if we really need it or remove it again and rely on static analysis instead; doesn't hurt to have it, the optimizer will remove it anyways).\r\n\r\nStep 2:\r\n----------\r\nIntroduce the following further Yul util functions:\r\n  - ``mobj_load(mobj, offset) -> value`` - load from memory object. Initially without bounds checks.\r\n  - ``mobj_store(mobj, offset, value)`` - store to memory object. Initially without bounds checks.\r\n  - ``get_scratch_space() -> mobj`` - returns ``0``, used whenever we write to memory offset 0 as scratch space\r\n\r\nTry to replace all ``mload``s and ``mstore``s with ``mobj_load`` and ``mobj_store``.\r\nCheck how we pass memory offsets to builtins. Potentially define functions like ``keccak_mobj(mobj, offset, size)`` and use them.\r\n\r\nAt that point we can re-evaluate where we stand and what our usage requirements look like. Next step would be to make memory objects a proper type and promote the functions to builtins - but we need to check how we will be dealing with the length of the object and how we pass memory to things like ``keccak`` or ``call``.\r\nThere were some random further notes here: https://hackmd.io/qFJ9LOweQf6QS1_BjIr0rQ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/638890232/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
