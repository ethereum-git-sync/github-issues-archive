{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/8160/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/8160/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/8160/events",
  "html_url": "https://github.com/ethereum/solidity/issues/8160",
  "id": 550952830,
  "node_id": "MDU6SXNzdWU1NTA5NTI4MzA=",
  "number": 8160,
  "title": "[Doc] Mention various signature formats",
  "user": {
    "login": "3esmit",
    "id": 224810,
    "node_id": "MDQ6VXNlcjIyNDgxMA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/3esmit",
    "html_url": "https://github.com/3esmit",
    "followers_url": "https://api.github.com/users/3esmit/followers",
    "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
    "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
    "organizations_url": "https://api.github.com/users/3esmit/orgs",
    "repos_url": "https://api.github.com/users/3esmit/repos",
    "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
    "received_events_url": "https://api.github.com/users/3esmit/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 275027668,
      "node_id": "MDU6TGFiZWwyNzUwMjc2Njg=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/documentation%20:book:",
      "name": "documentation :book:",
      "color": "006b75",
      "default": false,
      "description": ""
    },
    {
      "id": 4438006499,
      "node_id": "LA_kwDOAm_5kc8AAAABCIaa4w",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/low%20effort",
      "name": "low effort",
      "color": "ffb1fa",
      "default": false,
      "description": "There is not much implementation work to be done. The task is very easy or tiny."
    },
    {
      "id": 4438157609,
      "node_id": "LA_kwDOAm_5kc8AAAABCIjpKQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/low%20impact",
      "name": "low impact",
      "color": "5d71ff",
      "default": false,
      "description": "Changes are not very noticeable or potential benefits are limited."
    },
    {
      "id": 4438492402,
      "node_id": "LA_kwDOAm_5kc8AAAABCI4E8g",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/nice%20to%20have",
      "name": "nice to have",
      "color": "ffdeb3",
      "default": false,
      "description": "We don’t see a good reason not to have it but won’t go out of our way to implement it."
    },
    {
      "id": 4699440809,
      "node_id": "LA_kwDOAm_5kc8AAAABGBvGqQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/closed%20due%20inactivity",
      "name": "closed due inactivity",
      "color": "91535E",
      "default": false,
      "description": "The issue/PR was automatically closed due to inactivity."
    },
    {
      "id": 4699444681,
      "node_id": "LA_kwDOAm_5kc8AAAABGBvVyQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/stale",
      "name": "stale",
      "color": "BF4801",
      "default": false,
      "description": "The issue/PR was marked as stale because it has been open for too long."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 14,
  "created_at": "2020-01-16T17:31:43Z",
  "updated_at": "2023-03-07T12:04:49Z",
  "closed_at": "2023-03-07T12:04:49Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nHey, I am trying to  standardize `appended compact signatures` in top of what GnosisSafe did (https://github.com/gnosis/safe-contracts/blob/892448e93f6203b530630f20de45d8a55fde7463/contracts/GnosisSafe.sol#L189).\r\n\r\nThere is interesting things happening in https://github.com/ethereum/EIPs/pull/2126, but it also seems to lack to standardize the signature format.\r\n\r\nWe have 4 formats I know:\r\n- Contract (EIP1271): dynamic syze;  \r\n- Canonical: 68 bytes size;\r\n- Compact 65 bytes size (v is padded to a single byte); \r\n- Super compact 64 size (v is embedded in r bitwise https://eips.ethereum.org/EIPS/eip-2098)... \r\n I think that maybe would be interesting to solidity have a type `signature` to create a new standard out of all, and we could use something like `function checkSig(signature memory signatures)` \r\n\r\nI think that if anything is done, it should be looked into what GnosisSafe done and how we could improve in solidity for this implementation be more \"elegant\". \r\n\r\n\r\n## Motivation\r\n\r\nHowever I think that this is such common thing that solidity should have it embedded, so it becomes easier for all wallets understand the format of signature (and that is a signature, or multiple supported).\r\n\r\nI know ya going to say to use Struct and Libraries, and yes, that's what I would have to use if this don't gets approved.\r\n\r\n## Specification\r\n\r\nWIP / Brainstorm\r\n\r\nSignatures should:\r\n- Dynamic Size;\r\n- Depending on the type, Can be nested, a signature can contain other signatures that themselves can contain other signatures,\r\n- Have type accessible to contracts know what to do;\r\n- Can check against msg.sender\r\n- Can be null (check against application logic) \r\n\r\n## Backwards Compatibility\r\n\r\nCould be part of ABIV2Encoder, so its under experimental features. ",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/8160/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/8160/timeline",
  "performed_via_github_app": null,
  "state_reason": "not_planned"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/575261819",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-575261819",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 575261819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NTI2MTgxOQ==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-16T17:34:55Z",
    "updated_at": "2020-01-16T17:34:55Z",
    "author_association": "MEMBER",
    "body": "Damn, you got me on that (\"I know ya going to say to use Struct and Libraries, and yes, that's what I would have to use if this don't gets approved.\") :)\r\n\r\nBut to be honest, this just sounds like forcing an ERC by adding a feature to Solidity.\r\n\r\nIs there some more complex thing that can rather be done with Solidity than just adding a signature type?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/575261819/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/575966343",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-575966343",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 575966343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NTk2NjM0Mw==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-19T04:32:48Z",
    "updated_at": "2020-01-19T04:32:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "I tried to solve the problem with library and struct, however its really hard to came with a better solution. \r\n\r\nThe problem is that EIP 1271 is a contract call and can have an arbitrary lenght signature, and needs to know the message being signed to be validated.\r\n\r\nThe best design would be less efficient then what GnosisSafe have because GnosisSafe decodes and verifies in the same loop, while using a library it would first loop to decode, then after loop around to verify.\r\n\r\nI found out in Solidity it would be possible a library that:\r\n- contains method to decode signatures into ` struct GenericSignature { SigType sigType; bytes sig; }` \r\n- which depending on the SigType could be then decoded into `struct ContractSignature { address validator, GenericSigature[] sigs }`\r\n\r\nI tried doing with only one struct, but nasting structs is only supported for storage. \r\n\r\n@chriseth I think that now that signatures are maturing as EIP:\r\n- consider pick up into the discussion to embrace a pattern of packed appended signatures natively in solidity; \r\n- or in case thats too specific, improve libraries to, similar how is done in js, callback for, in this case, validation to happen inside the same decode loop, so we can implement this as library without being a significant waste of gas.\r\n- or, in case I am not seeing the obvious, enlighten me to the right path.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/575966343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577937170",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-577937170",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 577937170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NzkzNzE3MA==",
    "user": {
      "login": "ethernian",
      "id": 4574735,
      "node_id": "MDQ6VXNlcjQ1NzQ3MzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4574735?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ethernian",
      "html_url": "https://github.com/ethernian",
      "followers_url": "https://api.github.com/users/ethernian/followers",
      "following_url": "https://api.github.com/users/ethernian/following{/other_user}",
      "gists_url": "https://api.github.com/users/ethernian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ethernian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ethernian/subscriptions",
      "organizations_url": "https://api.github.com/users/ethernian/orgs",
      "repos_url": "https://api.github.com/users/ethernian/repos",
      "events_url": "https://api.github.com/users/ethernian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ethernian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-24T00:10:50Z",
    "updated_at": "2020-01-24T00:10:50Z",
    "author_association": "NONE",
    "body": "Personally, I would like to see the `appended signatures` natively supported in solidity, because it could be really convenient for generalized Meta-Tx support (which is damn important!).\r\n\r\nNevertheless, I do also understand @chriseth who is reasonably cautious implementing on solidity level (I hope understood him correctly) any ERC which is not widely used, probably incomplete and can change later.\r\n\r\nWhen we later achieve stability and usage numbers for the ERC, then we will surely have a better chance for 'native solidity support'. But now the ERC is expected to provide the proof of stability and completeness, even if made with existing tools and not at the best performance and efficiency.\r\n\r\nDoes anyone knows a better plan?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577937170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577971797",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-577971797",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 577971797,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3Nzk3MTc5Nw==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-24T02:59:53Z",
    "updated_at": "2020-01-24T02:59:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think would be good for Solidity adopt a signature type, because we have a lot of fragmentation on how signature are dealt with.  \r\n\r\nBy introducing a signature native type, Solidity won't loose flexibility, because all what is currently being done would be still possible. \r\nHowever, this \"Signature\" type would unify the developers into this solution, as it would support all that is needed for Ethereum Signed Messages, and that are complicated to develop as library, such as nested lookup into the data, as GnosisSafe implemented.\r\n\r\nI think is important to repeat that what GnosisSafe did with the `bytes signature` is implemented their own type \"Signature\", so the suggestion here is to bring something similar of that into Solidity itself. \r\n\r\nOther option would be to support another dynamic type we could use nested lookups in a compact format, I am not updated on ABIv2 Encoder, and that something for this pragma. \r\n\r\nI am looking forward the use of a Library and Struct for Signature aswell @ethernian , so we could use it with ABIv2 Encoder and have what we are asking here. I tried that based on gnosis safe, but no success. Maybe you can try it?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577971797/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577984966",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-577984966",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 577984966,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3Nzk4NDk2Ng==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-01-24T04:20:12Z",
    "updated_at": "2020-01-24T04:20:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "@ethernian This is where I stopped, this is far from ideal design, but I am trying to abstract things in solidity capabilities...  Also, I am experimenting with differnt things, like using Signature datatype in EIP1271, but maybe you have a better idea... \r\n\r\nI will keep looking around this issue but enough is enough, for now :)...\r\n\r\n```solidity\r\npragma solidity >=0.5.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract EIP1271 {\r\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        SignatureLib.Signature[] memory _signature)\r\n        public\r\n        view\r\n        returns (bytes4);\r\n}\r\n\r\n\r\n\r\ncontract SignatureLib {\r\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n    enum SigType { EIP1271, Canonical, Compact, EIP2098 }\r\n\r\n    struct Signature {\r\n        SigType sigType;\r\n        bytes data;\r\n    }\r\n\r\n    struct SigEIP1271 {\r\n        EIP1271 signer;\r\n        Signature[] signatures;\r\n    }\r\n\r\n    struct SigCanonical {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    struct SigCompact {\r\n        bytes data;\r\n    }\r\n\r\n    struct SigEIP2098 {\r\n        bytes32 r;\r\n        bytes32 vs;\r\n    }\r\n\r\n    function newSigCompact(bytes memory data) internal pure returns (SigCompact memory) {\r\n        require(data.length == 65);\r\n        return SigCompact(data);\r\n    }\r\n\r\n    function newSigEIP1271(bytes memory data) internal pure returns (SigEIP1271 memory) {\r\n        //TODO: conversion\r\n    }\r\n    function newSigCanonical(bytes memory data) internal pure returns (SigCanonical memory) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(data, 0x20))\r\n            s := mload(add(data, 0x40))\r\n            v := mload(add(data, 0x60))\r\n        }\r\n        return SigCanonical(r,s,v);\r\n    }\r\n\r\n    function newSigEIP2098(bytes memory data) internal pure returns (SigEIP2098 memory) {\r\n        require(data.length == 64);\r\n        bytes32 r;\r\n        bytes32 vs;\r\n        assembly {\r\n            r := mload(add(data, 0x20))\r\n            vs := mload(add(data, 0x40))\r\n        }\r\n        return SigEIP2098(r,vs);\r\n    }\r\n    \r\n\r\n    function recover(bytes memory message, Signature memory signature) internal pure returns (address) {\r\n        if(signature.sigType == SigType.EIP1271){\r\n            return recover(message, newSigEIP1271(signature.data));\r\n        } else if(signature.sigType == SigType.Canonical){\r\n            return recover(message, newSigCanonical(signature.data));\r\n        } else if(signature.sigType == SigType.Compact){\r\n            return recover(message, newSigCompact(signature.data));\r\n        } else if(signature.sigType == SigType.EIP2098){\r\n            return recover(message, newSigEIP2098(signature.data));\r\n        }\r\n    }\r\n\r\n    function recover(bytes memory message, SigEIP1271 memory signature) internal pure returns (address) {\r\n        return EIP1271(signature.signer).isValidSignature(message, signature.signatures) == EIP1271_MAGIC_VALUE ? address(signature.signer) : address(0);\r\n    }\r\n\r\n    function recover(bytes memory message, SigEIP2098 memory signature) internal pure returns (address) {\r\n        bytes32 s = signature.vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n        uint8 v = 27 + uint8(uint256(signature.vs) >> 255);\r\n        return ecrecover(keccak256(message), v, signature.r, s);\r\n    }\r\n\r\n    function recover(bytes memory message, SigCompact memory signature) internal pure returns (address) {\r\n        if (signature.data.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(keccak256(message), v, r, s);\r\n    }\r\n\r\n    function recover(bytes memory message, SigCanonical memory signature) internal pure returns (address) {\r\n        if (uint256(signature.s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (signature.v != 27 && signature.v != 28) {\r\n            return address(0);\r\n        }\r\n        return ecrecover(keccak256(message), signature.v, signature.r, signature.s);\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract MessageLib {\r\n    enum MsgType { EIP191 }\r\n    struct Message {\r\n        bytes data;\r\n        MsgType msgType;\r\n    }\r\n\r\n    function getMessageHash(Message memory message) internal view returns (address) {\r\n        return keccak256(message.data);\r\n    }\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/577984966/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590292228",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590292228",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590292228,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDI5MjIyOA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T12:14:19Z",
    "updated_at": "2020-02-24T12:14:19Z",
    "author_association": "MEMBER",
    "body": "Solidity does not want to impose standards by means of adding language features. Also, it should only add features if it cannot be solved with libraries and inline assembly or if that is really cumbersome and error-prone.\r\n\r\nCan you solve this with a library?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590292228/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590323734",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590323734",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590323734,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDMyMzczNA==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T13:38:35Z",
    "updated_at": "2020-02-24T13:38:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "@chriseth It hard to solve that, we basically need to create a custom ABI decoder inside the contract for this types of signature.  \r\n\r\nWe need to do that in the contract level because Solidity don't have it natively. This issue is a suggestion/feature request for having a Signature datatype which, 1. have a dynamic type; 2. can be nested indef.... ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590323734/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590338546",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590338546",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590338546,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDMzODU0Ng==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T14:13:55Z",
    "updated_at": "2020-02-24T14:13:55Z",
    "author_association": "MEMBER",
    "body": "Can you please explain again why a struct with `bytes` and `abi.decode` would not work?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590338546/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590349324",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590349324",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590349324,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDM0OTMyNA==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T14:34:22Z",
    "updated_at": "2020-02-24T14:34:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Can you please explain again why a struct with `bytes` and `abi.decode` would not work?\r\n\r\nIt can't deal with dynamic type.. So I can have decode into a fixed set, but not into a dynamic set.\r\nWe need a \r\n\r\n\r\nFor example, see the code snipped I shared above, to be able to achieve something similar to a dynamic type, this is the best I managed to do in Solidity:\r\n```solidity\r\n    function recover(bytes memory message, Signature memory signature) internal pure returns (address) {\r\n        if(signature.sigType == SigType.EIP1271){\r\n            return recover(message, newSigEIP1271(signature.data));\r\n        } else if(signature.sigType == SigType.Canonical){\r\n            return recover(message, newSigCanonical(signature.data));\r\n        } else if(signature.sigType == SigType.Compact){\r\n            return recover(message, newSigCompact(signature.data));\r\n        } else if(signature.sigType == SigType.EIP2098){\r\n            return recover(message, newSigEIP2098(signature.data));\r\n        }\r\n    }\r\n``` \r\n\r\nwhere each of sub function would have its own way of initializing. This is a load of work for something that should be a standard, so any wallet can sign to any contract, and any contract that uses this can accept singatures of any other contract.\r\n\r\nIf this all is left to the developers to decide, we are going to have a bad time on interoperability. \r\n**I agree with you that Solidity team should not enforce standards**, but maybe we can have at least a suggestion or better tooling for solving this problem? \r\nMaybe you see an easy fix to this, so perhaps you could give us a tip on how to solve this problem of Multiple Types of Signature (Signatures, Contract Signatures, types of escaping message, etc) and Interoperability. \r\n\r\nSignatures: Can only be from one externally owned account, can have different formats.\r\nContract Signature: Is composed of multiple Signatures, each signature can be in its own format or be another contract signature with many other signatures.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590349324/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590357776",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590357776",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590357776,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDM1Nzc3Ng==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T14:49:50Z",
    "updated_at": "2020-02-24T14:49:50Z",
    "author_association": "MEMBER",
    "body": "In my opinion, the community should agree on a standard. I'm neither in favour of enforcing a standard through the compiler nor with hiding complexity inside the compiler.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590357776/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590367926",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-590367926",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 590367926,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5MDM2NzkyNg==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-24T15:07:40Z",
    "updated_at": "2020-02-24T15:07:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think your points are reasonable, and maybe this is a documentation issue then? \r\n\r\nWhere documentation says about ecrecover and signatures in general, it should perhaps mention about ERC-1271 (contract signatures) and how the signatures are being handled (compact representations, canonical format, etc) by web3 developers;\r\n\r\nThe documentation would not be forcing an standard. but would point out that contracts can't ecrecover, but there is EIP1271 for that, and that signatures can be represented in canonical format (bytes32 r, bytes32  s,  uint8 v) or in a compact format (bytes32, bytes32, byte v), or in EIP2098 compact format (bytes32, bytes32), and link to a forum. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/590367926/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/597775632",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-597775632",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 597775632,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5Nzc3NTYzMg==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-11T17:47:47Z",
    "updated_at": "2020-03-11T17:47:47Z",
    "author_association": "MEMBER",
    "body": "That sounds like a good idea. I think we should also link implementations of that, e.g. the Zeppelin one.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/597775632/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1446210212",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-1446210212",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 1446210212,
    "node_id": "IC_kwDOAm_5kc5WM2qk",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2023-02-27T12:04:56Z",
    "updated_at": "2023-02-27T12:04:56Z",
    "author_association": "NONE",
    "body": "This issue has been marked as stale due to inactivity for the last 90 days.\nIt will be automatically closed in 7 days.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1446210212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1458050400",
    "html_url": "https://github.com/ethereum/solidity/issues/8160#issuecomment-1458050400",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/8160",
    "id": 1458050400,
    "node_id": "IC_kwDOAm_5kc5W6BVg",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2023-03-07T12:04:47Z",
    "updated_at": "2023-03-07T12:04:47Z",
    "author_association": "NONE",
    "body": "Hi everyone! This issue has been automatically closed due to inactivity.\nIf you think this issue is still relevant in the latest Solidity version and you have something to [contribute](https://docs.soliditylang.org/en/latest/contributing.html), feel free to reopen.\nHowever, unless the issue is a concrete proposal that can be implemented, we recommend starting a language discussion on the [forum](https://forum.soliditylang.org) instead.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1458050400/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
