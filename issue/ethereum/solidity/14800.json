{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/14800",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/14800/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/14800/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/14800/events",
  "html_url": "https://github.com/ethereum/solidity/issues/14800",
  "id": 2096471045,
  "node_id": "I_kwDOAm_5kc589ZwF",
  "number": 14800,
  "title": "solc produce Different Bytcode in multiple contracts after an equivalent expression change",
  "user": {
    "login": "chamitro",
    "id": 36297330,
    "node_id": "MDQ6VXNlcjM2Mjk3MzMw",
    "avatar_url": "https://avatars.githubusercontent.com/u/36297330?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/chamitro",
    "html_url": "https://github.com/chamitro",
    "followers_url": "https://api.github.com/users/chamitro/followers",
    "following_url": "https://api.github.com/users/chamitro/following{/other_user}",
    "gists_url": "https://api.github.com/users/chamitro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/chamitro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/chamitro/subscriptions",
    "organizations_url": "https://api.github.com/users/chamitro/orgs",
    "repos_url": "https://api.github.com/users/chamitro/repos",
    "events_url": "https://api.github.com/users/chamitro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/chamitro/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 249074435,
      "node_id": "MDU6TGFiZWwyNDkwNzQ0MzU=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/bug%20:bug:",
      "name": "bug :bug:",
      "color": "fc1313",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2024-01-23T16:26:12Z",
  "updated_at": "2024-01-24T16:30:35Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "<!--## Prerequisites\r\n\r\n- First, many thanks for taking part in the community. We really appreciate that.\r\n- We realize there is a lot of information requested here. We ask only that you do your best to provide as much information as possible so we can better help you.\r\n- Support questions are better asked in one of the following locations:\r\n    - [Solidity chat](https://gitter.im/ethereum/solidity)\r\n    - [Stack Overflow](https://ethereum.stackexchange.com/)\r\n- Ensure the issue isn't already reported.\r\n- The issue should be reproducible with the latest solidity version; however, this isn't a hard requirement and being reproducible with an older version is sufficient.\r\n\r\n*Delete the above section and the instructions in the sections below before submitting*\r\n-->\r\n\r\n## Description\r\n\r\nI have 2 versions of the smart contract below. The only difference is in line: \r\n ```solidity\r\n string private _name = \"ManofDevelopingIndia\";\r\n ```\r\n which changes to :\r\n```solidity\r\nstring private _name = \"Man\" \"of\" \"Developing\" \"India\";\r\n```\r\nThese 2 expressions are equivalent according to the solidity documentation (https://docs.soliditylang.org/en/latest/types.html#integers).\r\n\r\nSo, when I compile to bytecode the 2 contracts (using the command solc --bin standard.sol and solc --bin standard2.sol), there are many differences in the produced bytecode. Not only in the ManofDevelopingIndia Contract but in other libraries like SafeMath and Utils.\r\nWhile the IERC20, IDexRouter, IDexFactory and Context bytecode is the same. \r\n\r\nMy question is that. Should the bytecode be the same as long the two expressions are equivalent and there are no optimizations? And if not why there are changes in SafeMath and Utils bytecode apart from the MAnOdDevelopingIndia, while the \r\n```solidity\r\nstring private _name\r\n```\r\nhas no correlation to them.\r\n\r\nThe contract is the one below:\r\n\r\n```solidity\r\n\r\n// SPDX-License-Identifier:MIT\r\npragma solidity ^0.8.23;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// Dex Factory contract interface\r\ninterface IDexFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\n// Dex Router contract interface\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = payable(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ManofDevelopingIndia is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    mapping(address => bool) public isExcludedFromFee;\r\n    mapping(address => bool) public isExcludedFromMaxTxn;\r\n    mapping(address => bool) public isExcludedFromMaxHolding;\r\n    mapping(address => bool) public isBot;\r\n\r\n    string private _name = \"ManofDevelopingIndia\";\r\n    string private _symbol = \"MODI\";\r\n    uint8 private _decimals = 9;\r\n    uint256 private _totalSupply = 1_400_000_000 * 1e9;\r\n\r\n    address private constant DEAD = address(0xdead);\r\n    address private constant ZERO = address(0);\r\n    IDexRouter public dexRouter;\r\n    address public dexPair;\r\n    address public marketingWallet;\r\n    address public DevelopmentWallet;\r\n    address public liquidityReceiverWallet;\r\n\r\n    uint256 public minTokenToSwap = _totalSupply.div(1e5); // this amount will trigger swap and distribute\r\n    uint256 public maxHoldLimit = _totalSupply.mul(30).div(1000); // this is the max wallet holding limit\r\n    uint256 public maxTxnLimit = _totalSupply.mul(20).div(1000); // this is the max transaction limit\r\n    uint256 public percentDivider = 1000;\r\n    uint256 public snipingTime = 30 seconds;\r\n    uint256 public launchedAt;\r\n\r\n    bool public distributeAndLiquifyStatus; // should be true to turn on to liquidate the pool\r\n    bool public feesStatus = true; // enable by default\r\n    bool public trading; // once enable can't be disable afterwards\r\n\r\n    uint256 public liquidityFeeOnBuying = 10; // 1% will be added to the liquidity\r\n    uint256 public marketingFeeOnBuying = 10; // 1% will be added to the marketing address\r\n    uint256 public DevelopmentFeeOnBuying = 10; // 1% will be added to the Development address\r\n\r\n    uint256 public liquidityFeeOnSelling = 10; // 1% will be added to the liquidity\r\n    uint256 public marketingFeeOnSelling = 10; // 1% will be added to the marketing address\r\n    uint256 public DevelopmentFeeOnSelling = 10; // 1% will be added to the Development address\r\n\r\n    uint256 liquidityFeeCounter = 0;\r\n    uint256 marketingFeeCounter = 0;\r\n    uint256 DevelopmentFeeCounter = 0;\r\n\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n    );\r\n\r\n    constructor() {\r\n        _balances[owner()] = _totalSupply;\r\n        liquidityReceiverWallet = msg.sender;\r\n        marketingWallet = address(0x8c1eFacD4690dA48A6918b648A7CA22d7c86FaB2);\r\n        DevelopmentWallet = address(0x3a3ddd1C3d4AF0b7D69BFc965DD149dfA93Ec806);\r\n\r\n        IDexRouter _dexRouter = IDexRouter(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n        // Create a dex pair for this new ERC20\r\n        address _dexPair = IDexFactory(_dexRouter.factory()).createPair(\r\n            address(this),\r\n            _dexRouter.WETH()\r\n        );\r\n        dexPair = _dexPair;\r\n\r\n        // set the rest of the contract variables\r\n        dexRouter = _dexRouter;\r\n\r\n        //exclude owner and this contract from fee\r\n        isExcludedFromFee[owner()] = true;\r\n        isExcludedFromFee[address(this)] = true;\r\n\r\n        //exclude owner and this contract from max Txn\r\n        isExcludedFromMaxTxn[owner()] = true;\r\n        isExcludedFromMaxTxn[address(this)] = true;\r\n\r\n        //exclude owner and this contract from max hold limit\r\n        isExcludedFromMaxHolding[owner()] = true;\r\n        isExcludedFromMaxHolding[address(this)] = true;\r\n        isExcludedFromMaxHolding[dexPair] = true;\r\n        isExcludedFromMaxHolding[marketingWallet] = true;\r\n        isExcludedFromMaxHolding[DevelopmentWallet] = true;\r\n\r\n        emit Transfer(address(0), owner(), _totalSupply);\r\n    }\r\n\r\n    //to receive ETH from dexRouter when swapping\r\n    receive() external payable {}\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"MODI: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"MODI: decreased allowance or below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function includeOrExcludeFromFee(address account, bool value)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isExcludedFromFee[account] = value;\r\n    }\r\n\r\n    function includeOrExcludeFromMaxTxn(address account, bool value)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isExcludedFromMaxTxn[account] = value;\r\n    }\r\n\r\n    function includeOrExcludeFromMaxHolding(address account, bool value)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isExcludedFromMaxHolding[account] = value;\r\n    }\r\n\r\n    function removeBots(address account)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isBot[account] = false;\r\n    }\r\n\r\n    function setMinTokenToSwap(uint256 _amount) external onlyOwner {\r\n        require(_amount > 0,\"MODI: cant be 0\");\r\n        minTokenToSwap = _amount;\r\n    }\r\n\r\n    function setMaxHoldLimit(uint256 _amount) external onlyOwner {\r\n        require(_amount >= _totalSupply.mul(5).div(percentDivider), \"MODI: should be greater than 0.5%\");\r\n        maxHoldLimit = _amount;\r\n    }\r\n\r\n    function setMaxTxnLimit(uint256 _amount) external onlyOwner {\r\n        require(_amount >= _totalSupply/percentDivider, \"MODI: should be greater than 0.1%\");\r\n        maxTxnLimit = _amount;\r\n    }\r\n\r\n    function setBuyFeePercent(uint256 _lwFee, uint256 _marketingFee, uint256 _DevelopmentFee)\r\n        external\r\n        onlyOwner\r\n    {\r\n        marketingFeeOnBuying = _lwFee;\r\n        DevelopmentFeeOnBuying = _DevelopmentFee;\r\n        liquidityFeeOnBuying = _marketingFee;\r\n        require(\r\n            _lwFee.add(_marketingFee).add(_DevelopmentFee) <= percentDivider.div(10),\r\n            \"MODI: cant be more than 10%\"\r\n        );\r\n    }\r\n\r\n    function setSellFeePercent(uint256 _lwFee, uint256 _marketingFee, uint256 _DevelopmentFee)\r\n        external\r\n        onlyOwner\r\n    {\r\n        marketingFeeOnSelling = _lwFee;\r\n        DevelopmentFeeOnSelling = _DevelopmentFee;\r\n        liquidityFeeOnSelling = _marketingFee;\r\n        require(\r\n            _lwFee.add(_marketingFee).add(_DevelopmentFee) <= percentDivider.div(10),\r\n            \"MODI: cant be more than 10%\"\r\n        );\r\n    }\r\n\r\n    function setDistributionStatus(bool _value) public onlyOwner {\r\n        distributeAndLiquifyStatus = _value;\r\n    }\r\n\r\n    function enableOrDisableFees(bool _value) external onlyOwner {\r\n        feesStatus = _value;\r\n    }\r\n\r\n    function removeStuckEth(address _receiver) public onlyOwner {\r\n        payable(_receiver).transfer(address(this).balance);\r\n    }\r\n\r\n    function updateAddresses(address _marketingWallet, address _DevelopmentWallet, address _liquidityReceiverWallet) external onlyOwner {\r\n        marketingWallet = _marketingWallet;\r\n        DevelopmentWallet = _DevelopmentWallet;\r\n        liquidityReceiverWallet = _liquidityReceiverWallet;\r\n    }\r\n\r\n    function enableTrading() external onlyOwner {\r\n        require(!trading, \"MODI: already enabled\");\r\n        trading = true;\r\n        feesStatus = true;\r\n        distributeAndLiquifyStatus = true;\r\n        launchedAt = block.timestamp;\r\n    }\r\n\r\n    function totalBuyFeePerTx(uint256 amount) public view returns (uint256) {\r\n        uint256 fee = amount.mul(marketingFeeOnBuying.add(liquidityFeeOnBuying).add(DevelopmentFeeOnBuying)).div(\r\n            percentDivider\r\n        );\r\n        return fee;\r\n    }\r\n\r\n    function totalSellFeePerTx(uint256 amount) public view returns (uint256) {\r\n        uint256 fee = amount\r\n            .mul(marketingFeeOnSelling.add(liquidityFeeOnSelling).add(DevelopmentFeeOnSelling))\r\n            .div(percentDivider);\r\n        return fee;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"MODI: approve from the zero address\");\r\n        require(spender != address(0), \"MODI: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"MODI: transfer from the zero address\");\r\n        require(to != address(0), \"MODI: transfer to the zero address\");\r\n        require(amount > 0, \"MODI: Amount must be greater than zero\");\r\n        require(!isBot[from], \"MODI: Bot detected\");\r\n\r\n        if (!isExcludedFromMaxTxn[from] && !isExcludedFromMaxTxn[to]) {\r\n            require(amount <= maxTxnLimit, \"MODI: max txn limit exceeds\");\r\n\r\n            // trading disable till launch\r\n            if (!trading) {\r\n                require(\r\n                    dexPair != from && dexPair != to,\r\n                    \"MODI: trading is disable\"\r\n                );\r\n            }\r\n            // antibot\r\n            if (\r\n                block.timestamp < launchedAt + snipingTime &&\r\n                from != address(dexRouter)\r\n            ) {\r\n                if (dexPair == from) {\r\n                    isBot[to] = true;\r\n                } else if (dexPair == to) {\r\n                    isBot[from] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isExcludedFromMaxHolding[to]) {\r\n            require(\r\n                balanceOf(to).add(amount) <= maxHoldLimit,\r\n                \"MODI: max hold limit exceeds\"\r\n            );\r\n        }\r\n\r\n        // swap and liquify\r\n        distributeAndLiquify(from, to);\r\n\r\n        //indicates if fee should be deducted from transfer\r\n        bool takeFee = true;\r\n\r\n        //if any account belongs to isExcludedFromFee account then remove the fee\r\n        if (isExcludedFromFee[from] || isExcludedFromFee[to] || !feesStatus) {\r\n            takeFee = false;\r\n        }\r\n\r\n        //transfer amount, it will take tax, burn, liquidity fee\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n    }\r\n\r\n    //this method is responsible for taking all fee, if takeFee is true\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bool takeFee\r\n    ) private {\r\n        if (dexPair == sender && takeFee) {\r\n            uint256 allFee = totalBuyFeePerTx(amount);\r\n            uint256 tTransferAmount = amount.sub(allFee);\r\n            _balances[sender] = _balances[sender].sub(amount,\"MODI: insufficient balance\");\r\n            _balances[recipient] = _balances[recipient].add(tTransferAmount);\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n            takeTokenFee(sender, allFee);\r\n            setFeeCountersOnBuying(amount);\r\n        } else if (dexPair == recipient && takeFee) {\r\n            uint256 allFee = totalSellFeePerTx(amount);\r\n            uint256 tTransferAmount = amount.sub(allFee);\r\n            _balances[sender] = _balances[sender].sub(amount,\"MODI: insufficient balance\");\r\n            _balances[recipient] = _balances[recipient].add(tTransferAmount);\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n            takeTokenFee(sender, allFee);\r\n            setFeeCountersOnSelling(amount);\r\n        } else {\r\n            _balances[sender] = _balances[sender].sub(amount,\"MODI: insufficient balance\");\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function takeTokenFee(address sender, uint256 amount) private {\r\n        _balances[address(this)] = _balances[address(this)].add(amount);\r\n\r\n        emit Transfer(sender, address(this), amount);\r\n    }\r\n\r\n    function setFeeCountersOnBuying(uint256 amount) private {\r\n        liquidityFeeCounter += amount.mul(liquidityFeeOnBuying).div(\r\n            percentDivider\r\n        );\r\n        marketingFeeCounter += amount.mul(marketingFeeOnBuying).div(percentDivider);\r\n        DevelopmentFeeCounter += amount.mul(DevelopmentFeeOnBuying).div(percentDivider);\r\n    }\r\n\r\n    function setFeeCountersOnSelling(uint256 amount) private {\r\n        liquidityFeeCounter += amount.mul(liquidityFeeOnSelling).div(\r\n            percentDivider\r\n        );\r\n        marketingFeeCounter += amount.mul(marketingFeeOnSelling).div(percentDivider);\r\n        DevelopmentFeeCounter += amount.mul(DevelopmentFeeOnSelling).div(percentDivider);\r\n    }\r\n\r\n    function distributeAndLiquify(address from, address to) private {\r\n        // is the token balance of this contract address over the min number of\r\n        // tokens that we need to initiate a swap + liquidity lock?\r\n        // also, don't get caught in a circular liquidity event.\r\n        // also, don't swap & liquify if sender is Dex pair.\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        bool shouldSell = contractTokenBalance >= minTokenToSwap;\r\n\r\n        if (\r\n            shouldSell &&\r\n            from != dexPair &&\r\n            distributeAndLiquifyStatus &&\r\n            !(from == address(this) && to == address(dexPair)) // swap 1 time\r\n        ) {\r\n            // approve contract\r\n            _approve(address(this), address(dexRouter), contractTokenBalance);\r\n\r\n            uint256 halfLiquidity = liquidityFeeCounter.div(2);\r\n            uint256 otherHalfLiquidity = liquidityFeeCounter.sub(halfLiquidity);\r\n\r\n            uint256 tokenAmountToBeSwapped = contractTokenBalance.sub(\r\n                otherHalfLiquidity\r\n            );\r\n\r\n            uint256 balanceBefore = address(this).balance;\r\n\r\n            // now is to lock into liquidty pool\r\n            Utils.swapTokensForEth(address(dexRouter), tokenAmountToBeSwapped);\r\n\r\n            uint256 deltaBalance = address(this).balance.sub(balanceBefore);\r\n            uint256 ethToBeAddedToLiquidity = deltaBalance\r\n                .mul(halfLiquidity)\r\n                .div(tokenAmountToBeSwapped);\r\n            uint256 ethFormarketing = deltaBalance.mul(marketingFeeCounter).div(\r\n                tokenAmountToBeSwapped\r\n            );\r\n            uint256 ethForDevelopment = deltaBalance.sub(ethToBeAddedToLiquidity).sub(\r\n                ethFormarketing\r\n            );\r\n\r\n            // add liquidity to Dex\r\n            if (ethToBeAddedToLiquidity > 0) {\r\n                Utils.addLiquidity(\r\n                    address(dexRouter),\r\n                    liquidityReceiverWallet,\r\n                    otherHalfLiquidity,\r\n                    ethToBeAddedToLiquidity\r\n                );\r\n\r\n                emit SwapAndLiquify(\r\n                    halfLiquidity,\r\n                    ethToBeAddedToLiquidity,\r\n                    otherHalfLiquidity\r\n                );\r\n            }\r\n\r\n            // sending eth to marketing wallet\r\n            if (ethFormarketing > 0) payable(marketingWallet).transfer(ethFormarketing);\r\n\r\n            // sending eth to development wallet\r\n            if (ethForDevelopment > 0) payable(DevelopmentWallet).transfer(ethForDevelopment);\r\n\r\n            // Reset all fee counters\r\n            liquidityFeeCounter = 0;\r\n            marketingFeeCounter = 0;\r\n            DevelopmentFeeCounter = 0;\r\n        }\r\n    }\r\n}\r\n\r\n// Library for doing a swap on Dex\r\nlibrary Utils {\r\n    using SafeMath for uint256;\r\n\r\n    function swapTokensForEth(address routerAddress, uint256 tokenAmount)\r\n        internal\r\n    {\r\n        IDexRouter dexRouter = IDexRouter(routerAddress);\r\n\r\n        // generate the Dex pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = dexRouter.WETH();\r\n\r\n        // make the swap\r\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp + 300\r\n        );\r\n    }\r\n\r\n    function addLiquidity(\r\n        address routerAddress,\r\n        address owner,\r\n        uint256 tokenAmount,\r\n        uint256 ethAmount\r\n    ) internal {\r\n        IDexRouter dexRouter = IDexRouter(routerAddress);\r\n\r\n        // add the liquidity\r\n        dexRouter.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            owner,\r\n            block.timestamp + 300\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n```\r\n\r\n<!--Please shortly describe the bug you have found, and what you expect instead.-->\r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.23\r\n- Target EVM version (as per compiler settings):\r\n- Framework/IDE (e.g. Truffle or Remix): \r\n- EVM execution environment / backend / blockchain client:\r\n- Operating system: ubuntu 22.04\r\n\r\n## Steps to Reproduce\r\n```\r\nsolc --bin standard.sol > 1.txt\r\nsolc --bin standard2.sol > 2.txt\r\ndiff 1.txt 2.txt | colordiff\r\n```\r\n<!--\r\nPlease provide a *minimal* source code example to trigger the bug you have found.\r\nPlease also mention any command-line flags that are necessary for triggering the bug.\r\nProvide as much information as necessary to reproduce the bug.\r\n\r\n```solidity\r\n// Some *minimal* Solidity source code to reproduce the bug.\r\n// ...\r\n```\r\n-->\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/14800/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/14800/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1907287685",
    "html_url": "https://github.com/ethereum/solidity/issues/14800#issuecomment-1907287685",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14800",
    "id": 1907287685,
    "node_id": "IC_kwDOAm_5kc5xruaF",
    "user": {
      "login": "r0qs",
      "id": 457348,
      "node_id": "MDQ6VXNlcjQ1NzM0OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/457348?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/r0qs",
      "html_url": "https://github.com/r0qs",
      "followers_url": "https://api.github.com/users/r0qs/followers",
      "following_url": "https://api.github.com/users/r0qs/following{/other_user}",
      "gists_url": "https://api.github.com/users/r0qs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/r0qs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/r0qs/subscriptions",
      "organizations_url": "https://api.github.com/users/r0qs/orgs",
      "repos_url": "https://api.github.com/users/r0qs/repos",
      "events_url": "https://api.github.com/users/r0qs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/r0qs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T03:18:27Z",
    "updated_at": "2024-01-24T03:18:27Z",
    "author_association": "MEMBER",
    "body": "Thanks for reporting, @chamitro, but I believe this is not a bug. The string expressions are indeed equivalent; the difference in the bytecode is due to metadata. If you compare the Yul code generated by both, they should be equal.\r\n\r\nPlease see the following warning in [our documentation about contract metadata](https://docs.soliditylang.org/en/v0.8.23/metadata.html):\r\n```\r\nSince the bytecode of the resulting contract contains the metadata hash by default, any change to the metadata\r\nmight result in a change of the bytecode. This includes changes to a filename or path, and \r\nsince the metadata includes a hash of all the sources used, a single whitespace change results \r\nin different metadata, and different bytecode.\r\n```\r\n\r\nFor instance, the contracts below will generate different bytecode due to metadata divergence, although `f()` will produce the same output for both (i.e., `ManofDevelopingIndia`):\r\n\r\n- a.sol:\r\n```solidity\r\ncontract A {\r\n    string private _name = \"ManofDevelopingIndia\";\r\n    function f() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n}\r\n```\r\n- b.sol\r\n```solidity\r\ncontract A {\r\n    string private _name = \"Man\" \"of\" \"Developing\" \"India\";\r\n    function f() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n}\r\n```\r\n\r\nYou can check the generated Yul by doing\r\n```sh\r\nsolc --ir a.sol > a.yul\r\nsolc --ir b.sol > b.yul\r\ndiff a.yul b.yul\r\n```\r\n\r\nYou will see that only the metadata hash and some source locations will be different, like:\r\n```diff\r\n<         data \".metadata\" hex\"a2646970667358221220fef6372fd6d9f1584086e88f921cc5f73d7c76d9ff3f0f3913e4fb9b6805dad164736f6c63430008170033\"\r\n---\r\n>         data \".metadata\" hex\"a2646970667358221220ee7e0fb2c94e6b02415895ae48c4229bfae8191cff9bf875a305caccc0d6116664736f6c63430008170033\"\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1907287685/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1907778127",
    "html_url": "https://github.com/ethereum/solidity/issues/14800#issuecomment-1907778127",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14800",
    "id": 1907778127,
    "node_id": "IC_kwDOAm_5kc5xtmJP",
    "user": {
      "login": "chamitro",
      "id": 36297330,
      "node_id": "MDQ6VXNlcjM2Mjk3MzMw",
      "avatar_url": "https://avatars.githubusercontent.com/u/36297330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chamitro",
      "html_url": "https://github.com/chamitro",
      "followers_url": "https://api.github.com/users/chamitro/followers",
      "following_url": "https://api.github.com/users/chamitro/following{/other_user}",
      "gists_url": "https://api.github.com/users/chamitro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chamitro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chamitro/subscriptions",
      "organizations_url": "https://api.github.com/users/chamitro/orgs",
      "repos_url": "https://api.github.com/users/chamitro/repos",
      "events_url": "https://api.github.com/users/chamitro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chamitro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T09:51:16Z",
    "updated_at": "2024-01-24T09:51:16Z",
    "author_association": "NONE",
    "body": "Thank you for the information! My question is that while the change is in the ManOfDevelopingIndia contract's source code, the bytecode of  : IERC20, IDexRouter, IDexFactory and Context contracts is not changing, while the bytecode of Utils and SafeMath is changing. I was expecting that there wouldl be changes only in the ManOfDevelopingIndia contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1907778127/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908263108",
    "html_url": "https://github.com/ethereum/solidity/issues/14800#issuecomment-1908263108",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14800",
    "id": 1908263108,
    "node_id": "IC_kwDOAm_5kc5xvcjE",
    "user": {
      "login": "max-clinch",
      "id": 74224236,
      "node_id": "MDQ6VXNlcjc0MjI0MjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/74224236?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/max-clinch",
      "html_url": "https://github.com/max-clinch",
      "followers_url": "https://api.github.com/users/max-clinch/followers",
      "following_url": "https://api.github.com/users/max-clinch/following{/other_user}",
      "gists_url": "https://api.github.com/users/max-clinch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/max-clinch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/max-clinch/subscriptions",
      "organizations_url": "https://api.github.com/users/max-clinch/orgs",
      "repos_url": "https://api.github.com/users/max-clinch/repos",
      "events_url": "https://api.github.com/users/max-clinch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/max-clinch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T14:38:56Z",
    "updated_at": "2024-01-24T14:38:56Z",
    "author_association": "NONE",
    "body": "> Thank you for the information! My question is that while the change is in the ManOfDevelopingIndia contract's source code, the bytecode of : IERC20, IDexRouter, IDexFactory and Context contracts is not changing, while the bytecode of Utils and SafeMath is changing. I was expecting that there wouldl be changes only in the ManOfDevelopingIndia contract.\r\n\r\nthe behavior you're observing is a result of how Solidity handles metadata and bytecode generation. While the logical functionality of certain contracts remains unchanged, metadata changes can propagate to affect other parts of the bytecode. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908263108/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908490070",
    "html_url": "https://github.com/ethereum/solidity/issues/14800#issuecomment-1908490070",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14800",
    "id": 1908490070,
    "node_id": "IC_kwDOAm_5kc5xwT9W",
    "user": {
      "login": "chamitro",
      "id": 36297330,
      "node_id": "MDQ6VXNlcjM2Mjk3MzMw",
      "avatar_url": "https://avatars.githubusercontent.com/u/36297330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chamitro",
      "html_url": "https://github.com/chamitro",
      "followers_url": "https://api.github.com/users/chamitro/followers",
      "following_url": "https://api.github.com/users/chamitro/following{/other_user}",
      "gists_url": "https://api.github.com/users/chamitro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chamitro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chamitro/subscriptions",
      "organizations_url": "https://api.github.com/users/chamitro/orgs",
      "repos_url": "https://api.github.com/users/chamitro/repos",
      "events_url": "https://api.github.com/users/chamitro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chamitro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T16:30:34Z",
    "updated_at": "2024-01-24T16:30:34Z",
    "author_association": "NONE",
    "body": "Ok thank you for the informations!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908490070/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
