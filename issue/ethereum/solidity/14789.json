{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/14789",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/events",
  "html_url": "https://github.com/ethereum/solidity/issues/14789",
  "id": 2090987369,
  "node_id": "I_kwDOAm_5kc58oe9p",
  "number": 14789,
  "title": "Selective function inlining and optimisation",
  "user": {
    "login": "PetarMax",
    "id": 8540490,
    "node_id": "MDQ6VXNlcjg1NDA0OTA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8540490?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/PetarMax",
    "html_url": "https://github.com/PetarMax",
    "followers_url": "https://api.github.com/users/PetarMax/followers",
    "following_url": "https://api.github.com/users/PetarMax/following{/other_user}",
    "gists_url": "https://api.github.com/users/PetarMax/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/PetarMax/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/PetarMax/subscriptions",
    "organizations_url": "https://api.github.com/users/PetarMax/orgs",
    "repos_url": "https://api.github.com/users/PetarMax/repos",
    "events_url": "https://api.github.com/users/PetarMax/events{/privacy}",
    "received_events_url": "https://api.github.com/users/PetarMax/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4726043980,
      "node_id": "LA_kwDOAm_5kc8AAAABGbG1TA",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/feature",
      "name": "feature",
      "color": "fbca02",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2024-01-19T17:33:59Z",
  "updated_at": "2024-01-19T17:33:59Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nAt Runtime Verification (RV), we are developing tooling based on symbolic execution that allows us to verify properties of Solidity programs by analysing the corresponding compiled EVM bytecode. An important aspect of our analysis is reasoning about symbolic dynamically-sized data structures in memory, such as byte arrays and arrays of byte arrays. These data structures often get copied to memory in chunks of 32 bytes with the help of auto-generated auxiliary functions, such as the ones generated by the [`copyToMemoryFunction`](https://github.com/ethereum/solidity/blob/ec563a12cb9247d985df1e52cfacd9d03520fa2c/libsolidity/codegen/YulUtilFunctions.cpp#L83) function of the codebase. We reason about these function by writing, proving, and then reusing summaries of their behaviour. This is a standard approach that allows us to jump over the 32-byte-copying loops. These summaries would ideally be written once-and-for-all, and could be made reusable by any symbolic analysis of EVM bytecode.\r\n\r\nThe issue that we are faced with is that the EVM bytecode corresponding to these functions is often inlined and heavily optimised in ways that rely on the structure of the rest of the program, which we are not able to predict. We are therefore unable to provide a universal summary per function, but have to recreate the summaries every time the compiler chooses to do a different optimisation. This makes the verification effort brittle, severely negatively impacting the resilience and maintainability of the obtained proofs.\r\n\r\nImportantly, this issue is not limited to our verification efforts alone, and is very likely to appear in any symbolic analysis of EVM bytecode that attempts to reason about symbolic dynamically-sized data structures.\r\n\r\n## Motivation\r\n\r\nThe above-described issue could be addressed by extending the Solidity compiler with a mechanism that would allow the user to choose the functions that are not to be inlined and/or optimised during the compilation process. This would ensure the stability of the associated bytecode. \r\n\r\nThis solution came up as a result of a recent discussion between RV and @ekpyron.\r\n\r\nNota bene: this feature request could be rendered obsolete when #14741 is implemented, if `MCOPY` was to be used instead of the 32-byte-copying loops.\r\n\r\n## Specification\r\n\r\nI am not sufficiently familiar with the codebase to give a precise specification. At the UI level, I presume it would involve a flag to the compiler (for example, `--dont-inline` or `--dont-optimise`) followed by a list of function identifiers to not be inlined/optimised. \r\n\r\n## Backwards Compatibility\r\n\r\nAs this feature would be optional, there should be no issues with backwards compatibility.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/14789/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
