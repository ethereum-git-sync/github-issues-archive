{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/14789",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/events",
  "html_url": "https://github.com/ethereum/solidity/issues/14789",
  "id": 2090987369,
  "node_id": "I_kwDOAm_5kc58oe9p",
  "number": 14789,
  "title": "Selective function inlining and optimisation",
  "user": {
    "login": "PetarMax",
    "id": 8540490,
    "node_id": "MDQ6VXNlcjg1NDA0OTA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8540490?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/PetarMax",
    "html_url": "https://github.com/PetarMax",
    "followers_url": "https://api.github.com/users/PetarMax/followers",
    "following_url": "https://api.github.com/users/PetarMax/following{/other_user}",
    "gists_url": "https://api.github.com/users/PetarMax/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/PetarMax/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/PetarMax/subscriptions",
    "organizations_url": "https://api.github.com/users/PetarMax/orgs",
    "repos_url": "https://api.github.com/users/PetarMax/repos",
    "events_url": "https://api.github.com/users/PetarMax/events{/privacy}",
    "received_events_url": "https://api.github.com/users/PetarMax/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4438481746,
      "node_id": "LA_kwDOAm_5kc8AAAABCI3bUg",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/must%20have%20eventually",
      "name": "must have eventually",
      "color": "ffb04d",
      "default": false,
      "description": "Something we consider essential but not enough to prevent us from releasing Solidity 1.0 without it."
    },
    {
      "id": 4726043980,
      "node_id": "LA_kwDOAm_5kc8AAAABGbG1TA",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/feature",
      "name": "feature",
      "color": "fbca02",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2024-01-19T17:33:59Z",
  "updated_at": "2024-01-29T12:41:46Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nAt Runtime Verification (RV), we are developing tooling based on symbolic execution that allows us to verify properties of Solidity programs by analysing the corresponding compiled EVM bytecode. An important aspect of our analysis is reasoning about symbolic dynamically-sized data structures in memory, such as byte arrays and arrays of byte arrays. These data structures often get copied to memory in chunks of 32 bytes with the help of auto-generated auxiliary functions, such as the ones generated by the [`copyToMemoryFunction`](https://github.com/ethereum/solidity/blob/ec563a12cb9247d985df1e52cfacd9d03520fa2c/libsolidity/codegen/YulUtilFunctions.cpp#L83) function of the codebase. We reason about these function by writing, proving, and then reusing summaries of their behaviour. This is a standard approach that allows us to jump over the 32-byte-copying loops. These summaries would ideally be written once-and-for-all, and could be made reusable by any symbolic analysis of EVM bytecode.\r\n\r\nThe issue that we are faced with is that the EVM bytecode corresponding to these functions is often inlined and heavily optimised in ways that rely on the structure of the rest of the program, which we are not able to predict. We are therefore unable to provide a universal summary per function, but have to recreate the summaries every time the compiler chooses to do a different optimisation. This makes the verification effort brittle, severely negatively impacting the resilience and maintainability of the obtained proofs.\r\n\r\nImportantly, this issue is not limited to our verification efforts alone, and is very likely to appear in any symbolic analysis of EVM bytecode that attempts to reason about symbolic dynamically-sized data structures.\r\n\r\n## Motivation\r\n\r\nThe above-described issue could be addressed by extending the Solidity compiler with a mechanism that would allow the user to choose the functions that are not to be inlined and/or optimised during the compilation process. This would ensure the stability of the associated bytecode. \r\n\r\nThis solution came up as a result of a recent discussion between RV and @ekpyron.\r\n\r\nNota bene: this feature request could be rendered obsolete when #14741 is implemented, if `MCOPY` was to be used instead of the 32-byte-copying loops.\r\n\r\n## Specification\r\n\r\nI am not sufficiently familiar with the codebase to give a precise specification. At the UI level, I presume it would involve a flag to the compiler (for example, `--dont-inline` or `--dont-optimise`) followed by a list of function identifiers to not be inlined/optimised. \r\n\r\n## Backwards Compatibility\r\n\r\nAs this feature would be optional, there should be no issues with backwards compatibility.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/14789/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/14789/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1902255603",
    "html_url": "https://github.com/ethereum/solidity/issues/14789#issuecomment-1902255603",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14789",
    "id": 1902255603,
    "node_id": "IC_kwDOAm_5kc5xYh3z",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-20T20:14:49Z",
    "updated_at": "2024-01-20T20:14:49Z",
    "author_association": "MEMBER",
    "body": "Well, we had an idea for a similar feature for a slightly different use case in the past: #9628. It was actually @ekpyron's idea, though I'm not sure if his opinion on that didn't actually change over time. It had downsides too (see the discussion in the issue).\r\n\r\n> At the UI level, I presume it would involve a flag to the compiler (for example, `--dont-inline` or `--dont-optimise`) followed by a list of function identifiers to not be inlined/optimised.\r\n\r\nControlling it like this seems a bit too brittle to me. If you want to target specific functions Yul by name, you'd definitely want their names to be stable, and currently we don't really guarantee that. You'd have to check every release to make sure you're still using the right name.\r\n\r\nAnother thing is that, as soon a the new (experimental) type system is stable and powerful enough, these helpers will be moved to the standard library and written in Solidity rather than Yul. Then you'll have to worry about the way the compiler names Yul functions based on the Solidity source and that's even more brittle.\r\n\r\nIf we do go with the idea for marking specific functions for inlining/no inlining, I think this will have to be by marking them as such in the Yul sources. The compiler supports two-step compilation, where you first compile your Solidity source to Yul and then you invoke it separately on the Yul source to produce bytecode. You can edit the Yul source in between those steps and add the annotations you need.\r\n\r\n> Nota bene: this feature request could be rendered obsolete when #14741 is implemented, if MCOPY was to be used instead of the 32-byte-copying loops.\r\n\r\nWe're going to do just that very soon. It won't make it to the very next release next week, but it will definitely ship in the one right after that. It's very high on our priority list, because we also expect nice gas savings from it.\r\n\r\nNote that the compiler will fall back to the old version of the copying routine if you select an EVM version that has no `MCOPY` so you'd have to make sure you always compile for `cancun` or newer.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1902255603/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908221913",
    "html_url": "https://github.com/ethereum/solidity/issues/14789#issuecomment-1908221913",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14789",
    "id": 1908221913,
    "node_id": "IC_kwDOAm_5kc5xvSfZ",
    "user": {
      "login": "PetarMax",
      "id": 8540490,
      "node_id": "MDQ6VXNlcjg1NDA0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8540490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PetarMax",
      "html_url": "https://github.com/PetarMax",
      "followers_url": "https://api.github.com/users/PetarMax/followers",
      "following_url": "https://api.github.com/users/PetarMax/following{/other_user}",
      "gists_url": "https://api.github.com/users/PetarMax/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PetarMax/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PetarMax/subscriptions",
      "organizations_url": "https://api.github.com/users/PetarMax/orgs",
      "repos_url": "https://api.github.com/users/PetarMax/repos",
      "events_url": "https://api.github.com/users/PetarMax/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PetarMax/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T14:17:59Z",
    "updated_at": "2024-01-24T14:17:59Z",
    "author_association": "NONE",
    "body": "Thank you very much, @cameel! \r\n\r\nUnderstood re #9628. I think we will likely wait for a version with `MCOPY` to be there and see how we fare with verification, and also whether or not that version would be applicable to our current engagements.\r\n\r\nIf it does not, then I will come back to you on inlining/no inlining annotations directly in Yul code.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1908221913/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1914618796",
    "html_url": "https://github.com/ethereum/solidity/issues/14789#issuecomment-1914618796",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/14789",
    "id": 1914618796,
    "node_id": "IC_kwDOAm_5kc5yHsOs",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-29T12:41:25Z",
    "updated_at": "2024-01-29T12:41:25Z",
    "author_association": "MEMBER",
    "body": "Just as an additional piece of information here: the optimizer is already quite configurable via the StandardJSON interface (https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html#compiler-input-and-output-json-description) - we perform inlining at two stages, on the Yul level and on the level of EVM assembly (although the latter inliner is more limited than the former and will only inline very small functions with non-complex control flow). The low-level inliner on the EVM assembly level can be disabled by setting ``\"inliner\": false`` in ``settings.optimizer.details``. The Yul-level inliner can be disabled by adjusting the ``settings.optimizer.details.yulDetails.optimizerSteps``:\r\n\r\nThe default Yul optimizer step sequence is ``\"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul]VcTOculjmul\"`` - the individual letters are documented at https://docs.soliditylang.org/en/v0.8.20/internals/optimizer.html#optimizer-steps. The Yul-level-inliner is ``i`` in the sequence, so ``\"\"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvfCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul]VcTOculjmul\"`` would run the Yul optimizer in its default settings but without inlining. It may also be interesting which other transformations cause issues for you in verification (``F``, the \"FunctionSpecializer\", is a candidate, for example - when a function is called with a constant as one of its arguments, it can create a new copy of that function with that constant inlined into the function).\r\n\r\nHowever, this doesn't allow to selectively prevent inlining on specific functions only, but disables it entirely. But it would be an interesting data point if disabling inlining (and/or other steps) like that solves your issues!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1914618796/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
