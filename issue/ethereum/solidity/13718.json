{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/events",
  "html_url": "https://github.com/ethereum/solidity/issues/13718",
  "id": 1453393910,
  "node_id": "I_kwDOAm_5kc5WoQf2",
  "number": 13718,
  "title": "User defined operators/literals",
  "user": {
    "login": "NunoFilipeSantos",
    "id": 2582498,
    "node_id": "MDQ6VXNlcjI1ODI0OTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2582498?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/NunoFilipeSantos",
    "html_url": "https://github.com/NunoFilipeSantos",
    "followers_url": "https://api.github.com/users/NunoFilipeSantos/followers",
    "following_url": "https://api.github.com/users/NunoFilipeSantos/following{/other_user}",
    "gists_url": "https://api.github.com/users/NunoFilipeSantos/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/NunoFilipeSantos/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/NunoFilipeSantos/subscriptions",
    "organizations_url": "https://api.github.com/users/NunoFilipeSantos/orgs",
    "repos_url": "https://api.github.com/users/NunoFilipeSantos/repos",
    "events_url": "https://api.github.com/users/NunoFilipeSantos/events{/privacy}",
    "received_events_url": "https://api.github.com/users/NunoFilipeSantos/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4806670945,
      "node_id": "LA_kwDOAm_5kc8AAAABHn_6YQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/roadmap",
      "name": "roadmap",
      "color": "15B732",
      "default": false,
      "description": ""
    },
    {
      "id": 4867045645,
      "node_id": "LA_kwDOAm_5kc8AAAABIhk5DQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/epic",
      "name": "epic",
      "color": "BE24FA",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [
    {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    {
      "login": "matheusaaguiar",
      "id": 95899911,
      "node_id": "U_kgDOBbdRBw",
      "avatar_url": "https://avatars.githubusercontent.com/u/95899911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/matheusaaguiar",
      "html_url": "https://github.com/matheusaaguiar",
      "followers_url": "https://api.github.com/users/matheusaaguiar/followers",
      "following_url": "https://api.github.com/users/matheusaaguiar/following{/other_user}",
      "gists_url": "https://api.github.com/users/matheusaaguiar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/matheusaaguiar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/matheusaaguiar/subscriptions",
      "organizations_url": "https://api.github.com/users/matheusaaguiar/orgs",
      "repos_url": "https://api.github.com/users/matheusaaguiar/repos",
      "events_url": "https://api.github.com/users/matheusaaguiar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/matheusaaguiar/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": {
    "url": "https://api.github.com/repos/ethereum/solidity/milestones/55",
    "html_url": "https://github.com/ethereum/solidity/milestone/55",
    "labels_url": "https://api.github.com/repos/ethereum/solidity/milestones/55/labels",
    "id": 9037873,
    "node_id": "MI_kwDOAm_5kc4Aiegx",
    "number": 55,
    "title": "0.8.20",
    "description": "",
    "creator": {
      "login": "NunoFilipeSantos",
      "id": 2582498,
      "node_id": "MDQ6VXNlcjI1ODI0OTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582498?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NunoFilipeSantos",
      "html_url": "https://github.com/NunoFilipeSantos",
      "followers_url": "https://api.github.com/users/NunoFilipeSantos/followers",
      "following_url": "https://api.github.com/users/NunoFilipeSantos/following{/other_user}",
      "gists_url": "https://api.github.com/users/NunoFilipeSantos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NunoFilipeSantos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NunoFilipeSantos/subscriptions",
      "organizations_url": "https://api.github.com/users/NunoFilipeSantos/orgs",
      "repos_url": "https://api.github.com/users/NunoFilipeSantos/repos",
      "events_url": "https://api.github.com/users/NunoFilipeSantos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NunoFilipeSantos/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 17,
    "closed_issues": 3,
    "state": "open",
    "created_at": "2023-02-13T14:11:41Z",
    "updated_at": "2023-04-12T12:11:42Z",
    "due_on": "2023-04-05T07:00:00Z",
    "closed_at": null
  },
  "comments": 5,
  "created_at": "2022-11-17T13:55:39Z",
  "updated_at": "2023-04-13T13:30:01Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### What\r\n\r\nAllow users to define custom operators for user-defined types and suffixes for converting literals to user-defined types.\r\n\r\n### Why\r\n\r\nTo make the use of user-defined value types more ergonomic to solidity language users. This includes use cases like fixed-point numbers or special types for performing unchecked operations by default.\r\n\r\n### How\r\n#### Operators\r\n- [x] Main implementation\r\n    - #12362 (the original PR by @wechman)\r\n    - #13790\r\n        - #13660\r\n        - #13685\r\n        - #13693\r\n        - #13739\r\n        - #13741\r\n    - https://github.com/ethereum/solidity-blog/pull/202\r\n- [x] Bugs affecting/blocking the implementation\r\n    - #13764\r\n    - #13765\r\n    - #13908\r\n- [ ] Bugs in the implementation\r\n    - #14016\r\n    - #14001\r\n\r\n#### Literal suffixes\r\n- [ ] #12656\r\n    - #13415 \r\n    - #14015\r\n    - #14036\r\n    - #14054\r\n    - #14066\r\n    - #14078\r\n    - #14087\r\n    - #14103\r\n    - #14104\r\n- #14105\r\n- [ ] Documentation.\r\n- [ ] SMTChecker warning + tests.\r\n\r\n#### Extras\r\n- [ ] #13893\r\n    - #13900\r\n- [ ] Documentation updates\r\n    - [ ] Rewrite documentation on `using for` to make it easier to understand and more coherent.\r\n    - [ ] Add a canonical example of proper use of operators to introduction to smart contracts.\r\n- [ ] Refactors\r\n    - [ ] `+` is internally recognized as both unary and binary even though the language has only binary `+` (https://github.com/ethereum/solidity/pull/13790#discussion_r1113063168).\r\n    - [ ] Store operator definitions in an annotation to avoid having to rescan the whole source unit on each check.\r\n\r\n### Notes\r\n\r\n### Out of scope\r\n\r\n- Generalized AST annotation for function calls.\r\n- Support for `!`, `<<`, `>>` and `**`.\r\n- Support for increment, decrement and assignments.\r\n- Automatically derived comparison operators (or spaceship operator).\r\n- Operators on mixed types.\r\n- Operators on structs and reference types.\r\n\r\n---\r\n### Resources\r\n\r\n1. [User Defined Value Types in Solidity](https://blog.soliditylang.org/2021/09/27/user-defined-value-types/) (blog post introducing the original design)\r\n1. [The Future of Using For](https://notes.ethereum.org/Quug7DmAQ3akyYIsdGH8FQ) (design notes)\r\n1. [Literal suffixes - design decisions](https://notes.ethereum.org/62ZGU8OHQw-KimH7inZ-4w) (design notes)\r\n1. #11969 (original issue+discussion)\r\n1. [Units](https://notes.ethereum.org/XQGJdzHhSEeg6u2Ri-oEeQ) (design notes)\r\n1. [Fixed-point math example](https://gist.github.com/chriseth/cd6d825df5a13055b1c5d7bcf1e614a7)\r\n1. Older related issues:\r\n    - #9211\r\n    - #11531\r\n    - #12273\r\n1. Forum: https://forum.soliditylang.org/t/user-defined-types-and-operators/456\r\n1. Forum: [[feature preview] User-defined operators](https://forum.soliditylang.org/t/feature-preview-user-defined-operators/1435)\r\n1. [Feature Deep-Dive: User-Defined Operators](https://blog.soliditylang.org/2023/02/22/user-defined-operators/) (release blog post)",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/13718/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341058649",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341058649",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341058649,
    "node_id": "IC_kwDOAm_5kc5P7u5Z",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T14:36:03Z",
    "updated_at": "2023-01-25T04:37:45Z",
    "author_association": "MEMBER",
    "body": "Here's a summary of the current state of the operator implementation, in the form suitable for a short presentation:\r\n\r\n### Operators currently\r\n- Solidity supports the following operators:\r\n    1. Bitwise: `&`, `|`, `^`, `<<`, `>>`, `~`\r\n    2. Arithmetic: `+`, `-`, `*`, `/`, `%`, `**`\r\n    3. Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\r\n    4. Boolean: `!`, `&&`, `||`\r\n    5. Assignment: `=`, `+=`, `-=`, `^=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\r\n    6. Increment/decrement: `++`, `--`\r\n    7. Ternary: `?:`\r\n    8. Other: `delete`, `new`\r\n- Operators are built-in and cannot be redefined.\r\n- There are no built-in operators that work on user-defined value types.\r\n\r\n### Refresher on `using for`\r\n#### Example\r\n```solidity\r\ntype Int is int;\r\n\r\nlibrary L {\r\n    function add(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n    function sub(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) - Int.unwrap(b));\r\n    }\r\n}\r\n\r\nfunction unsub(Int a) pure returns (Int) {\r\n    return Int.wrap(-Int.unwrap(a));\r\n}\r\nfunction equals(Int a, Int b) pure returns (bool) {\r\n    return Int.unwrap(a) == Int.unwrap(b);\r\n}\r\n\r\nusing L for Int;\r\nusing {unsub} for Int;\r\nusing {equals} for Int global;\r\n\r\nfunction test(Int a, Int b) pure returns (Int) {\r\n    return a.equals(b) ? a.add(b) : a.unsub().sub(b);\r\n}\r\n```\r\n\r\n#### Rules\r\n- `using for` can attach a function to any type.\r\n- Currently has 3 forms:\r\n    1. `using L for T`\r\n    2. `using L for *`\r\n    3. `using {f, g, h} for T`.\r\n- Can be used at file level and contract level (including libraries but not interfaces).\r\n- The wildcard type can only be used with libraries.\r\n    - It's not allowed for individual functions\r\n    - Attaches all non-private functions of a library.\r\n- The wildcard type allows attaching functions to types that cannot be named.\r\n    - We're considering deprecating it but not before we find alternative solution for such types.\r\n- The directive can be marked as `global`.\r\n    - `global` can only be used at file level, with user-defined value types, structs and enums that are defined in the current source unit.\r\n    - Global `using for` has effect on all source units where the user-defined value type is visible.\r\n\r\n### User-defined operators\r\n#### Example 1\r\n```solidity\r\ntype Int is int;\r\n\r\nlibrary L {\r\n    function add(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n    function sub(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n}\r\n\r\nfunction unsub(Int a) pure returns (Int) {\r\n    return Int.wrap(-Int.unwrap(a));\r\n}\r\nfunction equals(Int a, Int b) pure returns (bool) {\r\n    return Int.unwrap(a) == Int.unwrap(b);\r\n}\r\n\r\nusing {L.add as +, L.sub as -, unsub as -} for Int;\r\nusing {equals as ==} for Int global;\r\n\r\nfunction test(Int a, Int b) pure returns (Int) {\r\n    return a == b ? a + b : -a - b;\r\n}\r\n```\r\n\r\n#### Example 2\r\n```solidity\r\ntype UncheckedCounter is uint;\r\n\r\nusing {\r\n    add as +,\r\n    lt as <\r\n} for UncheckedCounter;\r\n\r\nUncheckedCounter constant ONE = UncheckedCounter.wrap(1);\r\n\r\nfunction add(UncheckedCounter x, UncheckedCounter y) pure returns (UncheckedCounter) {\r\n    unchecked {\r\n        return UncheckedCounter.wrap(UncheckedCounter.unwrap(x) + UncheckedCounter.unwrap(y));\r\n    }\r\n}\r\n\r\nfunction lt(UncheckedCounter x, UncheckedCounter y) pure returns (bool) {\r\n    return UncheckedCounter.unwrap(x) < UncheckedCounter.unwrap(y);\r\n}\r\n\r\ncontract C {\r\n    uint internalCounter = 12;\r\n\r\n    function testCounter() public returns (uint) {\r\n        for (UncheckedCounter i = UncheckedCounter.wrap(12); i < UncheckedCounter.wrap(20); i = i + ONE) {\r\n            ++internalCounter;\r\n        }\r\n        return internalCounter;\r\n    }\r\n}\r\n```\r\n\r\n#### User-definable operators\r\n- The following operators can now be user-defined\r\n    1. Bitwise: `&`, `|`, `^`, `<<`, `>>`, `~`\r\n    2. Arithmetic: `+`, `-`, `*`, `/`, `%`, `**`\r\n    3. Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\r\n    4. Boolean: `!`\r\n- `&&` and `||` are not allowed for now due to their short-circuiting behavior.\r\n- `++` and `--` would be useful but are even more complicated: both have prefix and postfix variants with different semantics and modify their argument.\r\n\r\n#### Unary and binary operators\r\n- Unary operators: `!`, `~`, `-`\r\n- `-` is the only operator that's both unary and binary.\r\n    - Note that unary `+` is not available in Solidity.\r\n- All other operators are binary.\r\n\r\n#### Supported types\r\n- Operators can only be defined for user-defined value types for now.\r\n    - All other built-in and user-defined types are disallowed, including structs and enums.\r\n- Wildcard type is not allowed for operators.\r\n\r\n#### Operator parameters and return values\r\n- All parameters must be of the same type and this must be the type specified in `using for`.\r\n- The return value must be of the same type as well, except for comparison operators, where it must be `bool`.\r\n- There are no implicit conversions allowed.\r\n\r\n#### Global operators\r\nThe rules for `using for global` with operators are the same as for bound functions:\r\n- Only allowed at file level\r\n- The type must be defined in the current source unit\r\n- Effects extend to wherever the type is visible, not just current source unit.\r\n\r\n#### Mutability\r\n- Operators do not have to be `pure`. They can have side-effects, including making external calls.\r\n    - NOTE: We're still considering changing this to disallow operators with side-effects.\r\n\r\n#### What can be used as operator definition\r\n##### Free functions and library functions can be used\r\n- An operator definition can be a file-level function or a library function.\r\n- Private library functions can only be used in `using for` within a library (but note bug #13764).\r\n- External and public library functions can be used (but note bug #13765).\r\n- Contract and interface functions are not allowed.\r\n    - By extension, operator definition cannot be virtual and must have a body.\r\n\r\n##### Overloaded functions cannot be used\r\n```solidity\r\ntype A is address;\r\ntype AP is address payable;\r\n\r\nfunction add(A, A) pure returns (A) {}\r\nfunction add(AP, AP) pure returns (AP) {}\r\n\r\nusing {add as +} for A;  // Error: Identifier not found or not unique.\r\nusing {add as +} for AP;\r\n```\r\n\r\nThis mostly due to the current language limitations (it's not possible to refer to a specific overload of a function).\r\nThe restriction may be lifted in the future.\r\n\r\n##### Built-in functions cannot be used\r\n- Operator definition cannot be a built-in function like `keccak256`, `revert`, `abi.encode()`.\r\n- But a function shadowing a built-in is fine.\r\n\r\n#### Operator definitions are not attached automatically\r\nUsing a function to define an operator does not automatically make it available as an attached function.\r\nFor that the funtion needs to be attached explicitly.\r\n\r\n```solidity\r\ntype A is address;\r\n\r\nusing {add as +} for A;\r\nusing {sub as -, sub} for A;\r\n\r\nfunction add(A a, A b) pure returns (A) { /* ... */ }\r\nfunction sub(A a, A b) pure returns (A) { /* ... */ }\r\n\r\nfunction test(A a) pure {\r\n    a + a;\r\n    a.add(a); // Error: Member \"add\" not found or not visible after argument-dependent lookup in A.\r\n\r\n    a - a;\r\n    a.sub(a); // OK\r\n}\r\n```\r\n\r\n#### Multiple operator definitions\r\n- It is not possible to redefine any built-in operators. All valid cases are the ones where previously there was no built-in operator.\r\n- Only one definition is allowed\r\n    - Exception: the binary and unary variant are considered two different operators so `-` can have two definitions.\r\n- It's allowed to repeat the definition multiple times. Even in the same `using for` directive.\r\n- Operators cannot be shadowed. If one is defined at file level, it cannot have a different definition inside a contract.\r\n- `using for` is not inherited by derived contracts and this applies to operators as well.\r\n\r\n### Operators on structs\r\nWe decided to limit the initial implementation to user-defined value types due to the planned future changes to reference types that may complicate design and require a breaking change to fix. In particular, location is going to become a part of the type itself in the future.\r\n\r\nIf enabled, operators on structs would work as described below.\r\n\r\n#### Overloading on location\r\n- Structs are reference types and have a location but `using for` does not include location.\r\n- It's allowed to have multiple definitions with different locations as long as parameters and returns values in each one are identical.\r\n- Storage and calldata arguments are probably not very useful but allowed.\r\n\r\n##### Example\r\n```solidity\r\nusing {\r\n    addC as +,\r\n    addM as +,\r\n    addS as +\r\n} for S;\r\n\r\nstruct S {\r\n    uint v;\r\n}\r\n\r\nfunction addC(S calldata, S calldata) pure returns (S calldata) { /* ... */ }\r\nfunction addM(S memory, S memory) pure returns (S memory) { /* ... */ }\r\nfunction addS(S storage, S storage) returns (S storage) { /* ... */ }\r\n```\r\n\r\n#### No implicit conversions between location\r\n- When calling the operator, the location of each operand must match one of the definitions. There is no implicit conversion.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341058649/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341585718",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341585718",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341585718,
    "node_id": "IC_kwDOAm_5kc5P9vk2",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T20:56:19Z",
    "updated_at": "2022-12-07T20:56:19Z",
    "author_association": "MEMBER",
    "body": "@paulrberg @frangio Since the PR implementing user-defined operators is pretty much ready, this might be a good moment to get some early feedback about the implementation. Want to take a look? The comment above contains a high-level description of how they're going to work in practice, including current limitations.\r\n\r\nYou can also get a binary with support for operators from CI artifacts for [jobs on `user-defined-operators-for-udvt` branch](https://app.circleci.com/pipelines/github/ethereum/solidity?branch=user-defined-operators-for-udvt) (`b_ubu_static` for Linux, `b_win` for Windows, `b_osx` for macOS, `b_ems` for wasm). Not linking directly since the link would change whenever new code is pushed to the PR.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341585718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341642838",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341642838",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341642838,
    "node_id": "IC_kwDOAm_5kc5P99hW",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T21:53:43Z",
    "updated_at": "2022-12-07T21:53:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "Some early thoughts after just reading your description, which was great.\r\n\r\nMutability: I'm curious how others feel, but I think operators that are not `view` or `pure` should be disallowed. Having to look out for side effects on operators is scary. Static calls could be risky too, but `pure` may be too much of a restriction.\r\n\r\nIncrement/Decrement: Seeing `i + ONE` in your example made me miss these operators. I think the difficulties that you mentioned can be managed. For example, the `++` operator could be defined as a \"pure\" function that returns the increment of the input value, and the compiler can take care of assigning the result to the input _variable_ at the appropriate time depending on whether the operator is used prefix or postfix. Have you considered this?\r\n\r\nStructs: I'm not sure that operators for structs will be useful with the limitations around data location and the lack of automatic casting (which does make sense). I feel it may be better to drop support for struct operators entirely, until there are location-generic functions (#13207) and the operator could be defined in that way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341642838/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1342926337",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1342926337",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1342926337,
    "node_id": "IC_kwDOAm_5kc5QC24B",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-08T15:44:47Z",
    "updated_at": "2022-12-08T15:45:15Z",
    "author_association": "MEMBER",
    "body": " @frangio Thanks, that's very useful feedback!\r\n\r\n> I think operators that are not `view` or `pure` should be disallowed.\r\n\r\nI'm with you on that and @ekpyron was leaning that way too when I brought that up yesterday. We're seriously considering forcing `view` or `pure` and requiring the definition to be non-external. Restricting it initially and relaxing later is easier because the later change would not be breaking.\r\n\r\nAs for me personally, I'd be completely fine with `pure` because anything else will be hell for auditing and reading code in general. I usually don't expect side-effects from operators when I'm reading code myself.\r\n\r\n> Increment/Decrement: Seeing `i + ONE` in your example made me miss these operators.\r\n\r\nYeah, exactly why I included that example. But note that the literal suffixes will somewhat improve this. With them it would look like this:\r\n```solidity\r\nfunction cycles(uint c) pure suffix returns (UncheckedCounter) {\r\n    return UncheckedCounter.wrap(c);\r\n}\r\n```\r\n```solidity\r\nfor (UncheckedCounter i = 12 cycles; i < 20 cycles; i = i + 1 cycles)\r\n    ++internalCounter;\r\n```\r\n\r\nStill more verbose than `++` but may be good enough for the initial implementation.\r\n\r\n> I think the difficulties that you mentioned can be managed. For example, the `++` operator could be defined as a \"pure\" function that returns the increment of the input value, and the compiler can take care of assigning the result to the input _variable_ at the appropriate time depending on whether the operator is used prefix or postfix. Have you considered this?\r\n\r\nYeah, this sounds reasonable and we might do it like this. I don't see technical obstacles. It's really not as much about design issues as about keeping the implementation manageable. We wanted to start with something good enough and will be open to improving it after we get the main PR merged.\r\n\r\n> Structs: I'm not sure that operators for structs will be useful with the limitations around data location and the lack of automatic casting (which does make sense). I feel it may be better to drop support for struct operators entirely, until there are location-generic functions (#13207) and the operator could be defined in that way.\r\n\r\nOk, that's a useful piece of feedback on their usefulness. We're leaning towards dropping them too. It's just that we have them already implemented and working so we can still decide to keep them if we hear good reasons for that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1342926337/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1503203213",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1503203213",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1503203213,
    "node_id": "IC_kwDOAm_5kc5ZmQ-N",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-11T12:01:46Z",
    "updated_at": "2023-04-13T13:30:01Z",
    "author_association": "MEMBER",
    "body": "Here's a summary of the current state of the literal suffix implementation:\r\n\r\n### Denominations\r\nCurrently Solidity supports *denominations*, which superficially resemble the new feature:\r\n- The following denomination suffixes are available:\r\n    - [Ether units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#ether-units): `wei`, `gwei`, `ether`.\r\n    - [Time units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units): `seconds`, `minutes`, `hours`, `days`, `weeks`\r\n- The following denominations used to be available, but have been deprecated:\r\n    - `finney`, `szabo` (now usable as identifiers)\r\n    - `years` (forbidden as identifier)\r\n- Denomination suffixes are allowed only on rational number literals.\r\n    - This includes fractional literals (`1.1 gwei` is valid).\r\n    - This includes rational literals in scientific notation (`1e2 wei` is valid).\r\n    - Note: Hexadecimal numbers in Solidity represent fixed-bytes literals or addresses (`0x01 wei` is invalid).\r\n- Denominations do not affect the type.\r\n    - Literal with a denomination is still the same kind of literal.\r\n    - Operations on numbers with denominations are performed in unlimited precision, just as on bare literals.\r\n\r\n### User-defined literal suffixes\r\n#### Example\r\n```solidity\r\ntype Length is uint;\r\n\r\nfunction km(uint meters) pure suffix returns (Length) {\r\n    return Length.wrap(meters * 1000);\r\n}\r\n\r\nstruct Float {\r\n    uint mantissa;\r\n    uint exponent;\r\n}\r\n\r\nfunction f(uint mantissa, uint exponent) pure suffix returns (Float memory) {\r\n    return Float(mantissa, exponent);\r\n}\r\n\r\ncontract C {\r\n    Length public length = 5000 km;\r\n    Float public factor = 1.23 f;\r\n}\r\n```\r\n\r\n#### Suffix definitions\r\n- Must have the `suffix` modifier.\r\n- Must be free functions.\r\n- Must be pure.\r\n    - Like all other pure functions, can perform pure external calls.\r\n- Suffix names have the same restrictions as function names.\r\n    - A suffix cannot have the same name as an existing denomination.\r\n    - The deprecated `finney` and `szabo` are allowed as names. `years` is not.\r\n\r\n#### Suffix call syntax\r\n- Suffixes can be called in two ways:\r\n    - Suffix call syntax (`123 suffix`).\r\n    - Function call syntax (`suffix(123)`) - they're still functions.\r\n- Suffix calls use the same syntax as numbers with denominations: literal followed by the name of the suffix.\r\n- Suffix must be separated from the literal by whitespace.\r\n    - The only exception are string literals, where whitespace is optional.\r\n- The input of the suffix must be just a bare literal. Expressions are not allowed (e.g. `(123) suffix` is not valid).\r\n    - String concatenation is not considered an expression. E.g. `\"a\" \"b\" unicode\"c\" suffix` is equivalent to `\"abc\" suffix` and allowed.\r\n    - Note that there are no negative literals in Solidity. A number preceded by a minus is considered an expression.\r\n        - The minus is applied to the result of the suffix call. `-123 suffix` is equivalent to `-(123 suffix)`.\r\n        - A suffix definition will only ever receive positive numbers as input.\r\n- Applying a suffix to a literal with a denomination is not allowed. `123 wei suffix` is invalid.\r\n- The suffix itself is considered an expression but can have only two forms: identifier (`suffix`) or member access (`m.suffix`).\r\n    - Note that currently the only situation where member access is possible is when `m` is a module.\r\n    - Function pointers cannot be used as suffixes.\r\n    - Builtin functions cannot be used as suffixes, even if the parameters and return values happen to match.\r\n\r\n#### Suffix call semantics\r\n- Application of a suffix is equivalent to a free function call.\r\n    - The result is **not** considered a literal and further operations on it are **not** performed in unlimited precision.\r\n- Semantics may change in future versions, when we introduce compile-time constant evaluation or nameable types for literals.\r\n\r\n#### Parameters of a suffix function\r\n- Only types that some literal can be implicitly converted to are allowed:\r\n    - Unsigned integer types (`uint8`, ..., `uint256`, `uint`).\r\n    - Signed integer types (`int8`, ..., `int256`, `int`).\r\n    - Fixed bytes types (`bytes1`, ..., `bytes32`).\r\n    - `address` (but not `address payable`).\r\n    - `bool`.\r\n    - `string` and `bytes`.\r\n- Reference types stored in `calldata` or `storage` are not allowed.\r\n- Must have one or two parameters.\r\n\r\n##### Fractional decomposition\r\nDefinitions with two parameters are a special case:\r\n- Can be used with any rational number literal, including fractional numbers.\r\n- The compiler decomposes the number into the `mantissa * 10**-exponent` form, where\r\n    - *mantissa* is an integer.\r\n    - *exponent* is the smallest non-negative integer fitting the equation.\r\n- The rules above make the decomposition unambiguous:\r\n    - `123000` will always be decomposed into `123000 * 10**-0` never `123 * 10**3` or `123000000 * 10**-3`.\r\n    - `1.23` will be decomposed into `123 * 10**-2` never `1.23 * 10**-0` or `123000 * 10**-5`.\r\n- The compiler imposes the following restrictions on the suffix definition taking two arguments:\r\n   - The first parameter receives the mantissa and can be of any integer type.\r\n       - Note that in `-123` the sign is not considered a part of the literal. Therefore mantissa will never be negative in practice.\r\n       - Signed types are still allowed as a way to limit the range of input or avoid explicit conversions.\r\n   - The second parameter receives the exponent and can be of any unsigned integer type.\r\n- Decomposition is performed only for suffix call syntax. In the standard call syntax two-parameter suffixes work like any other two-parameter function.\r\n\r\n#### Return values of a suffix function\r\n- Types with `calldata` or `storage` locations are not allowed.\r\n- All other types are allowed.\r\n- A suffix must return exactly one value.\r\n\r\n#### Overloading\r\n- Suffix functions can be overloaded.\r\n- It is not possible to define two functions that differ only by presence of the `suffix` modifier.\r\n- Overload resolution rules are the same as for normal functions with a single modification:\r\n    - A two-argument suffix definition is considered a match for any rational number literal that fits its arguments after decomposition.\r\n- As per usual overloading rules, if a suffix call matches multiple definitions, it is considered ambiguous and triggers a compilation error. For example:\r\n    - `1 suffix` is considered ambiguous when both `suffix(uint)` and `suffix(uint, uint)` are defined.\r\n    - `1024 suffix` is unambiguous when only `suffix(uint8)` and `suffix(uint, uint)` are defined. It only matches argument types of the second definition.\r\n\r\n**NOTE: It is very likely that we'll decide to disallow overloading for suffix calls.** This would mean that:\r\n- Defining overloaded suffixes would be allowed.\r\n- Calling such suffixes via normal call syntax would be allowed.\r\n- Calling such suffixes via suffix call syntax would **not** be allowed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1503203213/reactions",
      "total_count": 3,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 2,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
