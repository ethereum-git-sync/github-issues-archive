{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/events",
  "html_url": "https://github.com/ethereum/solidity/issues/13718",
  "id": 1453393910,
  "node_id": "I_kwDOAm_5kc5WoQf2",
  "number": 13718,
  "title": "User defined operators/literals",
  "user": {
    "login": "NunoFilipeSantos",
    "id": 2582498,
    "node_id": "MDQ6VXNlcjI1ODI0OTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2582498?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/NunoFilipeSantos",
    "html_url": "https://github.com/NunoFilipeSantos",
    "followers_url": "https://api.github.com/users/NunoFilipeSantos/followers",
    "following_url": "https://api.github.com/users/NunoFilipeSantos/following{/other_user}",
    "gists_url": "https://api.github.com/users/NunoFilipeSantos/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/NunoFilipeSantos/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/NunoFilipeSantos/subscriptions",
    "organizations_url": "https://api.github.com/users/NunoFilipeSantos/orgs",
    "repos_url": "https://api.github.com/users/NunoFilipeSantos/repos",
    "events_url": "https://api.github.com/users/NunoFilipeSantos/events{/privacy}",
    "received_events_url": "https://api.github.com/users/NunoFilipeSantos/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4806670945,
      "node_id": "LA_kwDOAm_5kc8AAAABHn_6YQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/roadmap",
      "name": "roadmap",
      "color": "15B732",
      "default": false,
      "description": ""
    },
    {
      "id": 4867045645,
      "node_id": "LA_kwDOAm_5kc8AAAABIhk5DQ",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/epic",
      "name": "epic",
      "color": "BE24FA",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [
    {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    {
      "login": "matheusaaguiar",
      "id": 95899911,
      "node_id": "U_kgDOBbdRBw",
      "avatar_url": "https://avatars.githubusercontent.com/u/95899911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/matheusaaguiar",
      "html_url": "https://github.com/matheusaaguiar",
      "followers_url": "https://api.github.com/users/matheusaaguiar/followers",
      "following_url": "https://api.github.com/users/matheusaaguiar/following{/other_user}",
      "gists_url": "https://api.github.com/users/matheusaaguiar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/matheusaaguiar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/matheusaaguiar/subscriptions",
      "organizations_url": "https://api.github.com/users/matheusaaguiar/orgs",
      "repos_url": "https://api.github.com/users/matheusaaguiar/repos",
      "events_url": "https://api.github.com/users/matheusaaguiar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/matheusaaguiar/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2022-11-17T13:55:39Z",
  "updated_at": "2022-12-16T15:14:11Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### What\r\n\r\nAllow users to define custom operators for user-defined types and suffixes for converting literals to user-defined types.\r\n\r\n### Why\r\n\r\nTo make the use of user-defined value types more ergonomic to solidity language users. This includes use cases like fixed-point numbers or special types for performing unchecked operations by default.\r\n\r\n### How\r\n\r\n- [ ] #13790\r\n    - [x] #12362 (the original PR by @wechman)\r\n    - [x] #13660\r\n    - [x] #13685\r\n    - [x] #13693\r\n    - [x] #13739\r\n    - [x] #13741\r\n- [ ] #12656\r\n    - [ ] #13415 \r\n\r\n### Notes\r\n\r\n\r\n### Out of scope\r\n\r\n- Mixed-signature operators.\r\n- Generalized AST annotation for function calls.\r\n\r\n---\r\n### Resources\r\n\r\n1. [User Defined Value Types in Solidity](https://blog.soliditylang.org/2021/09/27/user-defined-value-types/) (blog post introducing the original design)\r\n2. [The Future of Using For](https://notes.ethereum.org/Quug7DmAQ3akyYIsdGH8FQ) (design notes)\r\n3. [Literal suffixes - design decisions](https://notes.ethereum.org/62ZGU8OHQw-KimH7inZ-4w) (design notes)\r\n4. #11969 (original issue+discussion)\r\n5. [Units](https://notes.ethereum.org/XQGJdzHhSEeg6u2Ri-oEeQ) (design notes)\r\n6. [Fixed-point math example](https://gist.github.com/chriseth/cd6d825df5a13055b1c5d7bcf1e614a7)\r\n7. Older related issues:\r\n    - #9211\r\n    - #11531\r\n    - #12273",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/13718/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/13718/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341058649",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341058649",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341058649,
    "node_id": "IC_kwDOAm_5kc5P7u5Z",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T14:36:03Z",
    "updated_at": "2022-12-07T21:58:41Z",
    "author_association": "MEMBER",
    "body": "Here's a summary of the current state of the operator implementation, in the form suitable for a short presentation:\r\n\r\n### Operators currently\r\n- Solidity supports the following operators:\r\n    1. Bitwise: `&`, `|`, `^`, `<<`, `>>`, `~`\r\n    2. Arithmetic: `+`, `-`, `*`, `/`, `%`, `**`\r\n    3. Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\r\n    4. Boolean: `!`, `&&`, `||`\r\n    5. Assignment: `=`, `+=`, `-=`, `>=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\r\n    6. Increment/decrement: `++`, `--`\r\n    7. Ternary: `?:`\r\n    8. Other: `delete`, `new`\r\n- Operators are built-in and cannot be redefined.\r\n- There are no built-in operators that work on user-defined value types.\r\n\r\n### Refresher on `using for`\r\n#### Example\r\n```solidity\r\ntype Int is int;\r\n\r\nlibrary L {\r\n    function add(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n    function sub(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) - Int.unwrap(b));\r\n    }\r\n}\r\n\r\nfunction unsub(Int a) pure returns (Int) {\r\n    return Int.wrap(-Int.unwrap(a));\r\n}\r\nfunction equals(Int a, Int b) pure returns (bool) {\r\n    return Int.unwrap(a) == Int.unwrap(b);\r\n}\r\n\r\nusing L for Int;\r\nusing {unsub} for Int;\r\nusing {equals} for Int global;\r\n\r\nfunction test(Int a, Int b) pure returns (Int) {\r\n    return a.equals(b) ? a.add(b) : a.unsub().sub(b);\r\n}\r\n```\r\n\r\n#### Rules\r\n- `using for` can attach a function to any type.\r\n- Currently has 3 forms:\r\n    1. `using L for T`\r\n    2. `using L for *`\r\n    3. `using {f, g, h} for T`.\r\n- Can be used at file level and contract level (including libraries but not interfaces).\r\n- The wildcard type can only be used with libraries.\r\n    - It's not allowed for individual functions\r\n    - Attaches all non-private functions of a library.\r\n- The wildcard type allows attaching functions to types that cannot be named.\r\n    - We're considering deprecating it but not before we find alternative solution for such types.\r\n- The directive can be marked as `global`.\r\n    - `global` can only be used at file level, with user-defined value types, structs and enums that are defined in the current source unit.\r\n    - Global `using for` has effect on all source units where the user-defined value type is visible.\r\n\r\n### User-defined operators\r\n#### Example 1\r\n```solidity\r\ntype Int is int;\r\n\r\nlibrary L {\r\n    function add(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n    function sub(Int a, Int b) internal pure returns (Int) {\r\n        return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\r\n    }\r\n}\r\n\r\nfunction unsub(Int a) pure returns (Int) {\r\n    return Int.wrap(-Int.unwrap(a));\r\n}\r\nfunction equals(Int a, Int b) pure returns (bool) {\r\n    return Int.unwrap(a) == Int.unwrap(b);\r\n}\r\n\r\nusing {L.add as +, L.sub as -, unsub as -} for Int;\r\nusing {equals as ==} for Int global;\r\n\r\nfunction test(Int a, Int b) pure returns (Int) {\r\n    return a == b ? a + b : -a - b;\r\n}\r\n```\r\n\r\n#### Example 2\r\n```solidity\r\ntype UncheckedCounter is uint;\r\n\r\nusing {\r\n    add as +,\r\n    lt as <\r\n} for UncheckedCounter;\r\n\r\nUncheckedCounter constant ONE = UncheckedCounter.wrap(1);\r\n\r\nfunction add(UncheckedCounter x, UncheckedCounter y) pure returns (UncheckedCounter) {\r\n    unchecked {\r\n        return UncheckedCounter.wrap(UncheckedCounter.unwrap(x) + UncheckedCounter.unwrap(y));\r\n    }\r\n}\r\n\r\nfunction lt(UncheckedCounter x, UncheckedCounter y) pure returns (bool) {\r\n    return UncheckedCounter.unwrap(x) < UncheckedCounter.unwrap(y);\r\n}\r\n\r\ncontract C {\r\n    uint internalCounter = 12;\r\n\r\n    function testCounter() public returns (uint) {\r\n        for (UncheckedCounter i = UncheckedCounter.wrap(12); i < UncheckedCounter.wrap(20); i = i + ONE) {\r\n            ++internalCounter;\r\n        }\r\n        return internalCounter;\r\n    }\r\n}\r\n```\r\n\r\n#### User-definable operators\r\n- The following operators can now be user-defined\r\n    1. Bitwise: `&`, `|`, `^`, `<<`, `>>`, `~`\r\n    2. Arithmetic: `+`, `-`, `*`, `/`, `%`, `**`\r\n    3. Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\r\n    4. Boolean: `!`\r\n- `&&` and `||` are not allowed for now due to their short-circuiting behavior.\r\n- `++` and `--` would be useful but are even more complicated: both have prefix and postfix variants with different semantics and modify their argument.\r\n\r\n#### Unary and binary operators\r\n- Unary operators: `!`, `~`, `-`\r\n- `-` is the only operator that's both unary and binary.\r\n    - Note that unary `+` is not available in Solidity.\r\n- All other operators are binary.\r\n\r\n#### Supported types\r\n- Operators can only be defined for user-defined value types for now.\r\n    - All other built-in and user-defined types are disallowed, including structs and enums.\r\n- Wildcard type is not allowed for operators.\r\n\r\n#### Operator parameters and return values\r\n- All parameters must be of the same type and this must be the type specified in `using for`.\r\n- The return value must be of the same type as well, except for comparison operators, where it must be `bool`.\r\n- There are no implicit conversions allowed.\r\n\r\n#### Global operators\r\nThe rules for `using for global` with operators are the same as for bound functions:\r\n- Only allowed at file level\r\n- The type must be defined in the current source unit\r\n- Effects extend to wherever the type is visible, not just current source unit.\r\n\r\n#### Mutability\r\n- Operators do not have to be `pure`. They can have side-effects, including making external calls.\r\n    - NOTE: We're still considering changing this to disallow operators with side-effects.\r\n\r\n#### What can be used as operator definition\r\n##### Free functions and library functions can be used\r\n- An operator definition can be a file-level function or a library function.\r\n- Private library functions can only be used in `using for` within a library (but note bug #13764).\r\n- External and public library functions can be used (but note bug #13765).\r\n- Contract and interface functions are not allowed.\r\n    - By extension, operator definition cannot be virtual and must have a body.\r\n\r\n##### Overloaded functions cannot be used\r\n```solidity\r\ntype A is address;\r\ntype AP is address payable;\r\n\r\nfunction add(A, A) pure returns (A) {}\r\nfunction add(AP, AP) pure returns (AP) {}\r\n\r\nusing {add as +} for A;  // Error: Identifier not found or not unique.\r\nusing {add as +} for AP;\r\n```\r\n\r\nThis mostly due to the current language limitations (it's not possible to refer to a specific overload of a function).\r\nThe restriction may be lifted in the future.\r\n\r\n##### Built-in functions cannot be used\r\n- Operator definition cannot be a built-in function like `keccak256`, `revert`, `abi.encode()`.\r\n- But a function shadowing a built-in is fine.\r\n\r\n#### Operator definitions are not attached automatically\r\nUsing a function to define an operator does not automatically make it available as an attached function.\r\nFor that the funtion needs to be attached explicitly.\r\n\r\n```solidity\r\ntype A is address;\r\n\r\nusing {add as +} for A;\r\nusing {sub as -, sub} for A;\r\n\r\nfunction add(A a, A b) pure returns (A) { /* ... */ }\r\nfunction sub(A a, A b) pure returns (A) { /* ... */ }\r\n\r\nfunction test(A a) pure {\r\n    a + a;\r\n    a.add(a); // Error: Member \"add\" not found or not visible after argument-dependent lookup in A.\r\n\r\n    a - a;\r\n    a.sub(a); // OK\r\n}\r\n```\r\n\r\n#### Multiple operator definitions\r\n- It is not possible to redefine any built-in operators. All valid cases are the ones where previously there was no built-in operator.\r\n- Only one definition is allowed\r\n    - Exception: the binary and unary variant are considered two different operators so `-` can have two definitions.\r\n- It's allowed to repeat the definition multiple times. Even in the same `using for` directive.\r\n- Operators cannot be shadowed. If one is defined at file level, it cannot have a different definition inside a contract.\r\n- `using for` is not inherited by derived contracts and this applies to operators as well.\r\n\r\n### Operators on structs\r\nWe decided to limit the initial implementation to user-defined value types due to the planned future changes to reference types that may complicate design and require a breaking change to fix. In particular, location is going to become a part of the type itself in the future.\r\n\r\nIf enabled, operators on structs would work as described below.\r\n\r\n#### Overloading on location\r\n- Structs are reference types and have a location but `using for` does not include location.\r\n- It's allowed to have multiple definitions with different locations as long as parameters and returns values in each one are identical.\r\n- Storage and calldata arguments are probably not very useful but allowed.\r\n\r\n##### Example\r\n```solidity\r\nusing {\r\n    addC as +,\r\n    addM as +,\r\n    addS as +\r\n} for S;\r\n\r\nstruct S {\r\n    uint v;\r\n}\r\n\r\nfunction addC(S calldata, S calldata) pure returns (S calldata) { /* ... */ }\r\nfunction addM(S memory, S memory) pure returns (S memory) { /* ... */ }\r\nfunction addS(S storage, S storage) returns (S storage) { /* ... */ }\r\n```\r\n\r\n#### No implicit conversions between location\r\n- When calling the operator, the location of each operand must match one of the definitions. There is no implicit conversion.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341058649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341585718",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341585718",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341585718,
    "node_id": "IC_kwDOAm_5kc5P9vk2",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T20:56:19Z",
    "updated_at": "2022-12-07T20:56:19Z",
    "author_association": "MEMBER",
    "body": "@paulrberg @frangio Since the PR implementing user-defined operators is pretty much ready, this might be a good moment to get some early feedback about the implementation. Want to take a look? The comment above contains a high-level description of how they're going to work in practice, including current limitations.\r\n\r\nYou can also get a binary with support for operators from CI artifacts for [jobs on `user-defined-operators-for-udvt` branch](https://app.circleci.com/pipelines/github/ethereum/solidity?branch=user-defined-operators-for-udvt) (`b_ubu_static` for Linux, `b_win` for Windows, `b_osx` for macOS, `b_ems` for wasm). Not linking directly since the link would change whenever new code is pushed to the PR.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341585718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341642838",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1341642838",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1341642838,
    "node_id": "IC_kwDOAm_5kc5P99hW",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-07T21:53:43Z",
    "updated_at": "2022-12-07T21:53:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "Some early thoughts after just reading your description, which was great.\r\n\r\nMutability: I'm curious how others feel, but I think operators that are not `view` or `pure` should be disallowed. Having to look out for side effects on operators is scary. Static calls could be risky too, but `pure` may be too much of a restriction.\r\n\r\nIncrement/Decrement: Seeing `i + ONE` in your example made me miss these operators. I think the difficulties that you mentioned can be managed. For example, the `++` operator could be defined as a \"pure\" function that returns the increment of the input value, and the compiler can take care of assigning the result to the input _variable_ at the appropriate time depending on whether the operator is used prefix or postfix. Have you considered this?\r\n\r\nStructs: I'm not sure that operators for structs will be useful with the limitations around data location and the lack of automatic casting (which does make sense). I feel it may be better to drop support for struct operators entirely, until there are location-generic functions (#13207) and the operator could be defined in that way.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1341642838/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1342926337",
    "html_url": "https://github.com/ethereum/solidity/issues/13718#issuecomment-1342926337",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13718",
    "id": 1342926337,
    "node_id": "IC_kwDOAm_5kc5QC24B",
    "user": {
      "login": "cameel",
      "id": 137030,
      "node_id": "MDQ6VXNlcjEzNzAzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/137030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cameel",
      "html_url": "https://github.com/cameel",
      "followers_url": "https://api.github.com/users/cameel/followers",
      "following_url": "https://api.github.com/users/cameel/following{/other_user}",
      "gists_url": "https://api.github.com/users/cameel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cameel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cameel/subscriptions",
      "organizations_url": "https://api.github.com/users/cameel/orgs",
      "repos_url": "https://api.github.com/users/cameel/repos",
      "events_url": "https://api.github.com/users/cameel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cameel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-08T15:44:47Z",
    "updated_at": "2022-12-08T15:45:15Z",
    "author_association": "MEMBER",
    "body": " @frangio Thanks, that's very useful feedback!\r\n\r\n> I think operators that are not `view` or `pure` should be disallowed.\r\n\r\nI'm with you on that and @ekpyron was leaning that way too when I brought that up yesterday. We're seriously considering forcing `view` or `pure` and requiring the definition to be non-external. Restricting it initially and relaxing later is easier because the later change would not be breaking.\r\n\r\nAs for me personally, I'd be completely fine with `pure` because anything else will be hell for auditing and reading code in general. I usually don't expect side-effects from operators when I'm reading code myself.\r\n\r\n> Increment/Decrement: Seeing `i + ONE` in your example made me miss these operators.\r\n\r\nYeah, exactly why I included that example. But note that the literal suffixes will somewhat improve this. With them it would look like this:\r\n```solidity\r\nfunction cycles(uint c) pure suffix returns (UncheckedCounter) {\r\n    return UncheckedCounter.wrap(c);\r\n}\r\n```\r\n```solidity\r\nfor (UncheckedCounter i = 12 cycles; i < 20 cycles; i = i + 1 cycles)\r\n    ++internalCounter;\r\n```\r\n\r\nStill more verbose than `++` but may be good enough for the initial implementation.\r\n\r\n> I think the difficulties that you mentioned can be managed. For example, the `++` operator could be defined as a \"pure\" function that returns the increment of the input value, and the compiler can take care of assigning the result to the input _variable_ at the appropriate time depending on whether the operator is used prefix or postfix. Have you considered this?\r\n\r\nYeah, this sounds reasonable and we might do it like this. I don't see technical obstacles. It's really not as much about design issues as about keeping the implementation manageable. We wanted to start with something good enough and will be open to improving it after we get the main PR merged.\r\n\r\n> Structs: I'm not sure that operators for structs will be useful with the limitations around data location and the lack of automatic casting (which does make sense). I feel it may be better to drop support for struct operators entirely, until there are location-generic functions (#13207) and the operator could be defined in that way.\r\n\r\nOk, that's a useful piece of feedback on their usefulness. We're leaning towards dropping them too. It's just that we have them already implemented and working so we can still decide to keep them if we hear good reasons for that.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1342926337/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
