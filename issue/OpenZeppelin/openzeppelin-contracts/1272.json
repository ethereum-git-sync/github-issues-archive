{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272",
  "id": 356967217,
  "node_id": "MDU6SXNzdWUzNTY5NjcyMTc=",
  "number": 1272,
  "title": "[spec] Bouncer/SignatureChecker + Contract Signatures ",
  "user": {
    "login": "shrugs",
    "id": 1535001,
    "node_id": "MDQ6VXNlcjE1MzUwMDE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/shrugs",
    "html_url": "https://github.com/shrugs",
    "followers_url": "https://api.github.com/users/shrugs/followers",
    "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
    "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
    "organizations_url": "https://api.github.com/users/shrugs/orgs",
    "repos_url": "https://api.github.com/users/shrugs/repos",
    "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
    "received_events_url": "https://api.github.com/users/shrugs/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 503650860,
      "node_id": "MDU6TGFiZWw1MDM2NTA4NjA=",
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/labels/feature",
      "name": "feature",
      "color": "b9db64",
      "default": false,
      "description": "New contracts, functions, or helpers."
    },
    {
      "id": 805777215,
      "node_id": "MDU6TGFiZWw4MDU3NzcyMTU=",
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/labels/on%20hold",
      "name": "on hold",
      "color": "5319e7",
      "default": false,
      "description": "Put on hold for some reason that must be specified in a comment."
    },
    {
      "id": 1000207718,
      "node_id": "MDU6TGFiZWwxMDAwMjA3NzE4",
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/labels/contracts",
      "name": "contracts",
      "color": "1d76db",
      "default": false,
      "description": "Smart contract code."
    },
    {
      "id": 1309858931,
      "node_id": "MDU6TGFiZWwxMzA5ODU4OTMx",
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/labels/needs%20milestone",
      "name": "needs milestone",
      "color": "c5def5",
      "default": false,
      "description": "Interesting features or improvements that are not yet assigned to a milestone."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "shrugs",
    "id": 1535001,
    "node_id": "MDQ6VXNlcjE1MzUwMDE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/shrugs",
    "html_url": "https://github.com/shrugs",
    "followers_url": "https://api.github.com/users/shrugs/followers",
    "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
    "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
    "organizations_url": "https://api.github.com/users/shrugs/orgs",
    "repos_url": "https://api.github.com/users/shrugs/repos",
    "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
    "received_events_url": "https://api.github.com/users/shrugs/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 14,
  "created_at": "2018-09-04T20:38:09Z",
  "updated_at": "2022-09-16T22:24:45Z",
  "closed_at": "2022-09-16T22:24:45Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## ðŸŽ‰ Description\r\n\r\nWe want to unify the methods by which we check signatures within the OZ contracts. The use-cases are:\r\n\r\n- transparently supporting contract signatures via `isValidSignature` using the same interface as checking EOA signatures\r\n- supporting MetaTx-style transactions\r\n- supporting Bouncer-style off-chain authorization\r\n- supporting signature arrays for collecting multiple off-chain signatures and submitting in a bundle (useful for threshold multisig logic)\r\n- supporting Airdrop contracts ala Crowdsale.sol\r\n\r\nI've done a half-job of building all of this out in a local branch, but I don't have the bandwidth to finish it up before the branch gets stale, so I'm going to document the architecture and get back to this later.\r\n\r\n## Pending Concerns\r\n\r\nWe should replace the `eth_personalSign` with `eth_signedTypedData` like GnosisSafe has done, which means we need to add the same sort of domainSeparator logic they have to the signature checker instead of assuming everything is an `Ethereum Signed Message:`.\r\n\r\n## Contracts\r\n\r\n### `ISignatureValidator`\r\n\r\nhttps://github.com/ethereum/EIPs/issues/1271\r\n\r\n```solidity\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface ISignatureValidator {\r\n  /**\r\n   * @dev Should return whether the signature provided is valid for the provided data\r\n   * @param _data Arbitrary length data signed on the behalf of address(this)\r\n   * @param _signature Signature byte array associated with _data\r\n   *\r\n   * MUST return a bool upon valid or invalid signature with corresponding _data\r\n   * MUST take (bytes, bytes) as arguments\r\n   */\r\n  function isValidSignature(\r\n    bytes _data,\r\n    bytes _signature\r\n  )\r\n    external\r\n    returns (\r\n      bool isValid\r\n    );\r\n}\r\n```\r\n\r\n### `SignatureChecker`\r\n\r\nSignatureChecker is a contract designed to be inherited. It offers pluggable authentication and authorization logic, designed to allow contracts to easily validate a set of signatures that a user submits.\r\n\r\nIt is inspired by logic from https://github.com/gnosis/safe-contracts/blob/development/contracts/GnosisSafe.sol\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./SignaturesSplitter.sol\";\r\nimport \"./ISignatureValidator.sol\";\r\nimport \"./BytesConverter.sol\";\r\nimport \"./ECRecovery.sol\";\r\n\r\n\r\ncontract SignatureChecker {\r\n  using ECRecovery for bytes32;\r\n\r\n  // signature size is 65 bytes (tightly packed v (1) + r (32) + s (32))\r\n  uint256 constant SIGNATURE_SIZE = 65;\r\n\r\n  modifier onlyValidSignatures(bytes _data, bytes _signatures)\r\n  {\r\n    require(validSignatures(_data, _signatures), \"INVALID_SIGNATURES\");\r\n    _;\r\n  }\r\n\r\n  function numSignatures(bytes _signatures)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    return _signatures.length / SIGNATURE_SIZE;\r\n  }\r\n\r\n  function validSignaturesLength(bytes _signatures)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return (_signatures.length % SIGNATURE_SIZE) == 0;\r\n  }\r\n\r\n  function validSignatures(bytes _data, bytes _signatures)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 numSigs = numSignatures(_signatures);\r\n    if (!validSignaturesLength(_signatures)) {\r\n      return false;\r\n    }\r\n\r\n    // There cannot be asigner with address 0\r\n    address lastSigner = address(0);\r\n    address currentSigner;\r\n    bytes memory currentSignerSignature;\r\n\r\n    for (uint256 i = 0; i < numSigs; i++) {\r\n      bytes memory signature = SignaturesSplitter.signatureAt(_signatures, i);\r\n\r\n      // get signer and signature\r\n      (currentSigner, currentSignerSignature) = signerOf(signature, _data);\r\n\r\n      // signer must be authenticated and authorized to sign for this data\r\n      if (!(isAuthenticated(currentSigner) && isAuthorized(currentSigner, _data))) {\r\n        return false;\r\n      }\r\n\r\n      // confirm that they've actually signed this\r\n      if (!isSignedBy(_data, currentSigner, currentSignerSignature)) {\r\n        return false;\r\n      }\r\n\r\n      // duplicated signature or improper order\r\n      if (currentSigner <= lastSigner) {\r\n        return false;\r\n      }\r\n\r\n      lastSigner = currentSigner;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function signerOf(bytes _signature, bytes _data)\r\n    internal\r\n    pure\r\n    returns (\r\n      address signer,\r\n      bytes memory signature\r\n    )\r\n  {\r\n    uint8 v = SignaturesSplitter.getV(_signature);\r\n    // If v is 0 then it is a contract signature\r\n    if (v == 0) {\r\n      // When handling contract signatures the address of the contract is encoded into r\r\n      signer = address(SignaturesSplitter.getR(_signature));\r\n      signature = SignaturesSplitter.getContractSignature(_signature);\r\n    } else {\r\n      // for EOA accounts, signer is encoded in vrs for relevant data hash\r\n      signature = _signature;\r\n      signer = BytesConverter.toBytes32(_data, 0)\r\n        .toEthSignedMessageHash()\r\n        .recover(signature);\r\n    }\r\n  }\r\n\r\n  function isSignedBy(\r\n    bytes _data,\r\n    address _signer,\r\n    bytes _signature\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    if (_signer.supportsInterface(InterfaceId_SignatureValidator)) {\r\n      // contract\r\n      return ISignatureValidator(_signer).isValidSignature(_data, _signature);\r\n    } else {\r\n      // EOA\r\n      return _signer == BytesConverter.toBytes32(_data, 0)\r\n        .toEthSignedMessageHash()\r\n        .recover(_signature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Whether or not `_signer` is authenticated within the context of this SignatureChecker\r\n   * param _signer signer\r\n   */\r\n  function isAuthenticated(address)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(address(this) == 0, \"INHERIT_ME\"); // address(this) removes solc state read warning\r\n  }\r\n\r\n  /**\r\n   * @dev Whether or not `_signer` is authorized to sign for `_data`\r\n   * param _signer signer\r\n   * param _data data\r\n   */\r\n  function isAuthorized(address, bytes)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(address(this) == 0, \"INHERIT_ME\"); // address(this) removes solc state read warning\r\n  }\r\n}\r\n```\r\n\r\n### `Bouncer`\r\n\r\nA Bouncer, then, is just some convenience functions for accepting signatures and assumes that the data being signed is the hash of `msg.data`.\r\n\r\nWe call the signatures \"tickets\" to imply that they're valid for the current transaction.\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./BouncerUtils.sol\";\r\nimport \"../../signatures/SignatureChecker.sol\";\r\nimport \"../../signatures/BytesConverter.sol\";\r\n\r\n\r\ncontract Bouncer is SignatureChecker {\r\n\r\n  modifier onlyValidTickets(bytes _tickets)\r\n  {\r\n    require(validTickets(_tickets), \"INVALID_TICkETS\");\r\n    _;\r\n  }\r\n\r\n  function validTickets(bytes _tickets)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return validSignatures(\r\n      BytesConverter.toBytes(BouncerUtils.messageDataHash(_tickets.length)),\r\n      _tickets\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### `BouncerWithTrustedSigners`\r\n\r\nA Bouncer with trusted signers via Roles.sol. This implements the SignatureChecker functions.\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./Bouncer.sol\";\r\nimport \"../rbac/Roles.sol\";\r\n\r\ncontract BouncerWithTrustedSigners is Bouncer {\r\n  using Roles for Roles.Role;\r\n\r\n  Roles.Role private signers;\r\n\r\n  modifier onlyTrustedSigner() {\r\n    require(signers.has(msg.sender), \"DOES_NOT_HAVE_SIGNER_ROLE\");\r\n    _;\r\n  }\r\n\r\n  constructor(address[] _signers)\r\n    public\r\n  {\r\n    signers.addMany(_signers);\r\n  }\r\n\r\n  /**\r\n   * @dev allows trusted signer to add additional signers\r\n   */\r\n  function addTrustedSigner(address _signer)\r\n    public\r\n    onlyTrustedSigner\r\n  {\r\n    require(_signer != address(0), \"NULL_SIGNER\");\r\n    signers.add(_signer);\r\n  }\r\n\r\n  /**\r\n   * @dev allows trusted signer to remove other signers\r\n   * @param _signer signer\r\n   */\r\n  function removeTrustedSigner(address _signer)\r\n    public\r\n    onlyTrustedSigner\r\n  {\r\n    signers.remove(_signer);\r\n  }\r\n\r\n  function isTrustedSigner(address _signer)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return signers.has(_signer);\r\n  }\r\n\r\n  /**\r\n   * @dev Whether or not `_signer` is authenticated within the context of this SignatureChecker\r\n   * @param _signer signer\r\n   */\r\n  function isAuthenticated(address _signer)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return isTrustedSigner(_signer);\r\n  }\r\n\r\n  /**\r\n   * @dev Whether or not `_signer` is authorized to sign for `_data`\r\n   */\r\n  function isAuthorized(address, bytes)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    // any signer is authorized for any signature\r\n    // replace this function if you want to support stuff like multisig thresholds\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n### BouncerWithNonceTracking\r\n\r\nBouncerWithNonceTracking (name tbd) helps keep track of nonces per-address.\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\ncontract BouncerWithNonceTracking is Bouncer {\r\n  mapping(address => uint256) internal nonces;\r\n\r\n  modifier withNonce(address _actor, uint256 _nonce) {\r\n    require(_nonce > nonces[_actor], \"INVALID_NONCE\");\r\n    _;\r\n    nonces[_actor] = _nonce;\r\n  }\r\n}\r\n```\r\n\r\n### Airdrop\r\n\r\nAnd airdrop, then, would look like\r\n\r\n```solidity\r\npragma solidity ^0.4.24;\r\n\r\ncontract Airdrop is BouncerWithTrustedSigners, BouncerWithNonceTracking {\r\n  function mint(address _beneficiary, IERC20 _token, uint256 _amount, bytes _tickets)\r\n    public\r\n    onlyValidTickets(_tickets)\r\n    withNonce(_beneficiary, 1)\r\n  {\r\n    // trust arguments and can only be called once per beneficiary\r\n    _token.transfer(_beneficiary, _amount);\r\n  }\r\n}\r\n```\r\n\r\n### GnosisSafe\r\n\r\nGnosisSafe could use this pattern as well: they would replace [`checkSignatures`](https://github.com/gnosis/safe-contracts/blob/development/contracts/GnosisSafe.sol#L131) with `validSignatures`. They could implement threshold approvals in two ways:\r\n\r\n1. check that `numSignatures` is gte approval threshold, for off-chain signature aggregation\r\n2. check that the message hash has been approved as part of `SignatureChecker#isAuthorized(...)` for on-chain approvals\r\n",
  "closed_by": {
    "login": "frangio",
    "id": 481465,
    "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/frangio",
    "html_url": "https://github.com/frangio",
    "followers_url": "https://api.github.com/users/frangio/followers",
    "following_url": "https://api.github.com/users/frangio/following{/other_user}",
    "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
    "organizations_url": "https://api.github.com/users/frangio/orgs",
    "repos_url": "https://api.github.com/users/frangio/repos",
    "events_url": "https://api.github.com/users/frangio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/frangio/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272/reactions",
    "total_count": 4,
    "+1": 4,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418510158",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-418510158",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 418510158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODUxMDE1OA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-04T20:39:31Z",
    "updated_at": "2018-09-04T20:39:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm going to close PRs #1024, #812, #1020, #812, and #983 for cleanliness. They are all affected by this change and will be stale by the time we implement it. ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418510158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418896589",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-418896589",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 418896589,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODg5NjU4OQ==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-05T22:04:17Z",
    "updated_at": "2018-09-05T22:04:37Z",
    "author_association": "MEMBER",
    "body": "Can you explain further how threshold signatures fit into this? Would there be a component in OpenZeppelin to specifically support them?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418896589/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418898238",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-418898238",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 418898238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODg5ODIzOA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-05T22:11:15Z",
    "updated_at": "2018-09-05T22:11:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "threshold signatures probably isn't the best term, since that's already a real thing. But I'm referencing \"be able to validate an array of signatures rather than a single signature\" and then make it easy to apply some threshold logic to them. Specifically in the case of multisig schemes where a transaction might require 3 signatures from owners or something.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418898238/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418918412",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-418918412",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 418918412,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODkxODQxMg==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-05T23:56:19Z",
    "updated_at": "2018-09-05T23:56:19Z",
    "author_association": "MEMBER",
    "body": "Right. That's the kind of thing I was expecting to delegate to contract signatures. So we can just say \"we support isValidSignature\" and Gnosis Safe can implement that function with their own threshold logic. Do you see OpenZeppelin having its own multisig validator component? I personally think it's best if we delegate that to actual multisig wallet contracts.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418918412/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418918629",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-418918629",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 418918629,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODkxODYyOQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-05T23:57:35Z",
    "updated_at": "2018-09-05T23:57:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "@frangio I think we have the same opinion here! I'll clarify the text.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/418918629/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468117396",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468117396",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468117396,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODExNzM5Ng==",
    "user": {
      "login": "biocrypto730",
      "id": 38660876,
      "node_id": "MDQ6VXNlcjM4NjYwODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38660876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/biocrypto730",
      "html_url": "https://github.com/biocrypto730",
      "followers_url": "https://api.github.com/users/biocrypto730/followers",
      "following_url": "https://api.github.com/users/biocrypto730/following{/other_user}",
      "gists_url": "https://api.github.com/users/biocrypto730/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/biocrypto730/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/biocrypto730/subscriptions",
      "organizations_url": "https://api.github.com/users/biocrypto730/orgs",
      "repos_url": "https://api.github.com/users/biocrypto730/repos",
      "events_url": "https://api.github.com/users/biocrypto730/events{/privacy}",
      "received_events_url": "https://api.github.com/users/biocrypto730/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T02:56:53Z",
    "updated_at": "2019-02-28T03:13:35Z",
    "author_association": "NONE",
    "body": "?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468117396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468120643",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468120643",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468120643,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODEyMDY0Mw==",
    "user": {
      "login": "biocrypto730",
      "id": 38660876,
      "node_id": "MDQ6VXNlcjM4NjYwODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38660876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/biocrypto730",
      "html_url": "https://github.com/biocrypto730",
      "followers_url": "https://api.github.com/users/biocrypto730/followers",
      "following_url": "https://api.github.com/users/biocrypto730/following{/other_user}",
      "gists_url": "https://api.github.com/users/biocrypto730/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/biocrypto730/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/biocrypto730/subscriptions",
      "organizations_url": "https://api.github.com/users/biocrypto730/orgs",
      "repos_url": "https://api.github.com/users/biocrypto730/repos",
      "events_url": "https://api.github.com/users/biocrypto730/events{/privacy}",
      "received_events_url": "https://api.github.com/users/biocrypto730/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T03:13:29Z",
    "updated_at": "2019-02-28T03:14:32Z",
    "author_association": "NONE",
    "body": "Is there a crowdsale example using this yet? It seems kinda necessary for KYC... And the code above looks great",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468120643/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468339528",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468339528",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468339528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODMzOTUyOA==",
    "user": {
      "login": "nventuro",
      "id": 2530770,
      "node_id": "MDQ6VXNlcjI1MzA3NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nventuro",
      "html_url": "https://github.com/nventuro",
      "followers_url": "https://api.github.com/users/nventuro/followers",
      "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
      "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
      "organizations_url": "https://api.github.com/users/nventuro/orgs",
      "repos_url": "https://api.github.com/users/nventuro/repos",
      "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nventuro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T16:29:06Z",
    "updated_at": "2019-02-28T16:29:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "@projectoblio there are no crowdsales using signatures, but we do have [`WhitelistCrowdsale`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.1.3/contracts/crowdsale/validation/WhitelistCrowdsale.sol), which may suit your needs.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468339528/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468360629",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468360629",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468360629,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODM2MDYyOQ==",
    "user": {
      "login": "biocrypto730",
      "id": 38660876,
      "node_id": "MDQ6VXNlcjM4NjYwODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38660876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/biocrypto730",
      "html_url": "https://github.com/biocrypto730",
      "followers_url": "https://api.github.com/users/biocrypto730/followers",
      "following_url": "https://api.github.com/users/biocrypto730/following{/other_user}",
      "gists_url": "https://api.github.com/users/biocrypto730/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/biocrypto730/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/biocrypto730/subscriptions",
      "organizations_url": "https://api.github.com/users/biocrypto730/orgs",
      "repos_url": "https://api.github.com/users/biocrypto730/repos",
      "events_url": "https://api.github.com/users/biocrypto730/events{/privacy}",
      "received_events_url": "https://api.github.com/users/biocrypto730/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T17:24:14Z",
    "updated_at": "2019-02-28T17:31:15Z",
    "author_association": "NONE",
    "body": "I saw that, and I also read through someone else's argument in a closed issue that said that signature based crowdsales somehow cost the EVM a lot more money that WhitelistCrowdsales. \r\n\r\nI just want to say that (I _think_) this has to be false, in a WhitelistCrowdsale you have a transaction (signature) from the owner to add an address (string), and another transaction from the end-user (signature).  In a Bouncer crowdsale you have only a transaction (signature) from the end-user which contains a signature from the owner (signature).\r\n\r\nSo the WhitelistCrowdsale requires: Transaction + address + Transaction\r\nWhereas the BouncerCrowdsale only requires: Transaction + Signature \r\n--> I assume here that a Transaction is about the same size (or more) as a signature [ typical cryptocurrency transactions are just signatures moving money from one place to another, right?]  then it gets added to an address so it's even bigger\r\n--> BouncerCrowdsale also doesn't need to store long-term data in the chain (can just be a nonce or whatever, instead of a list of addresses that lasts forever) so yea it has to be a lot cheaper long-term, it's mostly computation at the time of the tx\r\n\r\nNot only that, the UX experience is probably about equal. In the WhitelistCrowdsale, users have to wait for an owner transaction to be communicated to the blockchain before donated.  In the BouncerCrowdsale, users can communicate their signature immediately. \r\n\r\nThis is my first time working with OZ so I haven't examined the gas costs of using each of the contracts. But as far as data storage goes I think the BouncerCrowdsale has to be a lot less. \r\n\r\n**Why u write all that, just submit a PR** -- I actually would do this but my solution isn't backwards compatible with the rest of the OZ contracts. It basically requires adding an input parameter to buyTokens .I don't know enough about Solidity to know how to prevent re-entrancy ( although it doesn't seem like my crowdsale can be negatively impacted by it ). So that's what makes the above code so hot and attractive, is because it looks like it can be implemented in OZ really easily. ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468360629/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468391652",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468391652",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468391652,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODM5MTY1Mg==",
    "user": {
      "login": "nventuro",
      "id": 2530770,
      "node_id": "MDQ6VXNlcjI1MzA3NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nventuro",
      "html_url": "https://github.com/nventuro",
      "followers_url": "https://api.github.com/users/nventuro/followers",
      "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
      "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
      "organizations_url": "https://api.github.com/users/nventuro/orgs",
      "repos_url": "https://api.github.com/users/nventuro/repos",
      "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nventuro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T18:51:32Z",
    "updated_at": "2019-02-28T18:51:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It basically requires adding an input parameter to buyTokens\r\n\r\nThis could be implemented by inheriting the original `buyTokens` and disabling it (e.g. by having it always revert). \r\n\r\nI agree with your statements regarding usefulness of a `SignedCrowdsale`, but am unsure as to whether we should first iterate a bit on `SignatureBouncer` itself, which hasn't been worked on in a while. @frangio thoughts?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468391652/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468456739",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468456739",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468456739,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODQ1NjczOQ==",
    "user": {
      "login": "biocrypto730",
      "id": 38660876,
      "node_id": "MDQ6VXNlcjM4NjYwODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38660876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/biocrypto730",
      "html_url": "https://github.com/biocrypto730",
      "followers_url": "https://api.github.com/users/biocrypto730/followers",
      "following_url": "https://api.github.com/users/biocrypto730/following{/other_user}",
      "gists_url": "https://api.github.com/users/biocrypto730/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/biocrypto730/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/biocrypto730/subscriptions",
      "organizations_url": "https://api.github.com/users/biocrypto730/orgs",
      "repos_url": "https://api.github.com/users/biocrypto730/repos",
      "events_url": "https://api.github.com/users/biocrypto730/events{/privacy}",
      "received_events_url": "https://api.github.com/users/biocrypto730/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T22:03:18Z",
    "updated_at": "2019-02-28T22:05:25Z",
    "author_association": "NONE",
    "body": "Thanks yea I might've tried that but there was also this big warning that said \"DO NOT OVERRIDE\" above buyTokens so I wasn't sure i was even doing it right. Rewriting the function inside Crowdsale.sol was easier on my late-night's psyche even though now i realize that's basically the exact same thing. And what am i even saying, is overriding the function the same as inherting it and disabling it? fuck man",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468456739/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468692886",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-468692886",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 468692886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODY5Mjg4Ng==",
    "user": {
      "login": "nventuro",
      "id": 2530770,
      "node_id": "MDQ6VXNlcjI1MzA3NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nventuro",
      "html_url": "https://github.com/nventuro",
      "followers_url": "https://api.github.com/users/nventuro/followers",
      "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
      "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
      "organizations_url": "https://api.github.com/users/nventuro/orgs",
      "repos_url": "https://api.github.com/users/nventuro/repos",
      "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nventuro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-01T14:59:29Z",
    "updated_at": "2019-03-01T14:59:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ah you're right, the strategy I suggested wouldn't work on the `Crowdsale` model. What we should do is have an `internal` `_buyTokens` function, and then just have `buyTokens` call it. In your use case, you'd disable the `public` one, but not the `internal`, which is what the other contracts in the inheritance tree are calling.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/468692886/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/844548943",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-844548943",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 844548943,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0NDU0ODk0Mw==",
    "user": {
      "login": "alfredolopez80",
      "id": 20690133,
      "node_id": "MDQ6VXNlcjIwNjkwMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/20690133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alfredolopez80",
      "html_url": "https://github.com/alfredolopez80",
      "followers_url": "https://api.github.com/users/alfredolopez80/followers",
      "following_url": "https://api.github.com/users/alfredolopez80/following{/other_user}",
      "gists_url": "https://api.github.com/users/alfredolopez80/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alfredolopez80/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alfredolopez80/subscriptions",
      "organizations_url": "https://api.github.com/users/alfredolopez80/orgs",
      "repos_url": "https://api.github.com/users/alfredolopez80/repos",
      "events_url": "https://api.github.com/users/alfredolopez80/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alfredolopez80/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-19T22:49:58Z",
    "updated_at": "2021-05-20T13:42:24Z",
    "author_association": "NONE",
    "body": "@frangio I think for this approach may help the new method in the Open Zeppelin library  in version 4.1 https://docs.openzeppelin.com/contracts/4.x/api/utils#SignatureChecker",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/844548943/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1249910213",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1272#issuecomment-1249910213",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1272",
    "id": 1249910213,
    "node_id": "IC_kwDOA9tCBs5KgB3F",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-09-16T22:24:45Z",
    "updated_at": "2022-09-16T22:24:45Z",
    "author_association": "MEMBER",
    "body": "The different components in this issue have had varying levels of progress over the years. We have SignatureChecker and EIP712 implementations. Meta transactions have been supported in the form of GSN v1 in the past, and currently \"GSN v2\" via ERC2771Context (essentially an implementation of the Bouncer concept). We are not sure the latter is getting much use so we consider deprecating it now, since EIP-4337 is an alternative that seems to have more activity and stronger support, and has the benefit that it is compatible with any contract out of the box.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1249910213/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
