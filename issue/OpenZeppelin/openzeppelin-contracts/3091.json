{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091",
  "id": 1096460476,
  "node_id": "I_kwDOA9tCBs5BWqi8",
  "number": 3091,
  "title": "MerkleProof: Intermediate nodes can be reinterpreted as leaves",
  "user": {
    "login": "hoytech",
    "id": 144548,
    "node_id": "MDQ6VXNlcjE0NDU0OA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/144548?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hoytech",
    "html_url": "https://github.com/hoytech",
    "followers_url": "https://api.github.com/users/hoytech/followers",
    "following_url": "https://api.github.com/users/hoytech/following{/other_user}",
    "gists_url": "https://api.github.com/users/hoytech/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hoytech/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hoytech/subscriptions",
    "organizations_url": "https://api.github.com/users/hoytech/orgs",
    "repos_url": "https://api.github.com/users/hoytech/repos",
    "events_url": "https://api.github.com/users/hoytech/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hoytech/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2022-01-07T16:17:24Z",
  "updated_at": "2022-01-31T15:10:13Z",
  "closed_at": "2022-01-31T15:10:13Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "It is possible to prove the presence of certain values that aren't actually leaves in the tree.\r\n\r\nThis is a very slight variant of a well-known problem sometimes called a \"second preimage attack\" on merkle trees, although in my opinion that is a misleading name. The issue is that you can concatenate the hashes of two internal nodes (resulting in 64 bytes) and provide this as a value to be proved. The smart contract will hash this and attempt to verify it as though it was a normal leaf. If the proof has been shortened appropriately, it will incorrectly be validated.\r\n\r\nThe very slight variation from the typical description is that in the OZ implementation internal nodes are sorted, although this doesn't change the impact of this issue (which is low in most cases).\r\n\r\nI included a test case in https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3090 that demonstrates this issue and adds some documentation warning developers about how to avoid it.\r\n\r\n## Impact\r\n\r\nThe real world impact of this bug is likely small. The first condition for a successful attack is that a contract accepts legitimate leaf values with a length of exactly 64 bytes. For instance, Uniswap's merkle distributor uses the following to hash a leaf:\r\n\r\n      bytes32 node = keccak256(abi.encodePacked(index, account, amount));\r\n\r\nThis is an example of code that is *not* vulnerable. `index` and `amount` are `uint256`s and `account` is an address so the value passed to `keccak256` is `32 + 20 + 32 = 84` bytes long.\r\n\r\nOn the other hand, suppose the code was written like so:\r\n\r\n      bytes32 node = keccak256(abi.encodePacked(index, account, uint96(amount)));\r\n\r\nIn this case, the leaf value is `32 + 20 + 12 = 64` bytes long so it would potentially be vulnerable to a griefing/spamming attack where a large amount of tokens are sent to some random address, effectively burning them. Alternatively, if `index` was packed into some small type (maybe `uint32`) then it might be possible to burn innocent users' tokens by sending them to random addresses. The length condition could also be satisfied if variable-length values are used, for example: `abi.encodePacked(address, bytes(...))`.\r\n\r\nThe second condition of a successful attack is to overcome the fact that the attacker has very little control over the invalid values. This is because they are the output of hash functions over data that presumably the attacker cannot influence. If attackers *do* have some influence over values in the tree (maybe they can sign up for an airdrop using arbitrary addresses) then they may be able to \"grind\" advantageous values to some degree.\r\n\r\nHowever, in the typical case an attacker has to make do with a set of effectively random values. The number of usable inputs scales approximately with the number of leaf values in the tree. An attacker can loop over all possibilities and pick the best one, and there will be more chances of a \"good\" pair of hashes if the tree is larger. However, this is obviously dominated by the large output range of the 256-bit hash function so is not likely a problem in practice.\r\n\r\n## Recommendation\r\n\r\nI originally submitted this to Immunefi but they weren't interested so I'm just posting here. It may be worthwhile determining if any contracts have been deployed that could be impacted by this (probably few, if any).\r\n\r\nAt the very least, users should be warned in the documentation about this issue. Contracts should ensure that there is a \"domain separation\" between hashing leaf values and intermediate nodes. This can be done either by making sure leaf values are never 64 bytes in length, or by using a hash function other than keccak256 when hashing leaves. Also, `abi.encode()` should be encouraged over `abi.encodePacked()` for several reasons.\r\n\r\nMy [pull request](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3090) contains some suggested wording for this. Also feel free to include any part of this description in your documentation, if it helps.\r\n\r\nThere are some API-level changes that could be made to definitively prevent this. For instance, `verify()` could accept a user-defined value type (https://blog.soliditylang.org/2021/09/27/user-defined-value-types/) that wraps `bytes32` and can only be created by a keccak256-wrapper that also checks the input length is not 64-bytes. That said, I think leaving the responsibility of preventing this to the developer is fine, as long as there is appropriate documentation describing how to do so.\r\n\r\n## References\r\n\r\n* https://www.rfc-editor.org/rfc/rfc6962.html#section-2.1\r\n* https://hoytech.github.io/blockchain-storage/lesson2/index.html#/40\r\n",
  "closed_by": {
    "login": "frangio",
    "id": 481465,
    "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/frangio",
    "html_url": "https://github.com/frangio",
    "followers_url": "https://api.github.com/users/frangio/followers",
    "following_url": "https://api.github.com/users/frangio/following{/other_user}",
    "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
    "organizations_url": "https://api.github.com/users/frangio/orgs",
    "repos_url": "https://api.github.com/users/frangio/repos",
    "events_url": "https://api.github.com/users/frangio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/frangio/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091/reactions",
    "total_count": 6,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1007754778",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091#issuecomment-1007754778",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091",
    "id": 1007754778,
    "node_id": "IC_kwDOA9tCBs48ER4a",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-07T21:30:36Z",
    "updated_at": "2022-01-07T21:30:53Z",
    "author_association": "COLLABORATOR",
    "body": "Hello @hoytech,\r\n\r\nWe will come back to you with a longer response next week, but this is something we are aware of, and we already discussed. AFAIK this is not an issue with our implementation but rather a property of merkle trees.\r\n\r\nIt is true that users must be careful with what they use as leaves. IMO it's usually a hash that doesn't match the merkle construction mechanism, but you are right that there is a risk of confusion. We were particularly concerned with this risk when discussing [rebuilding a leaf index during verification](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2841#issuecomment-942654291).\r\n\r\nChanging the `verify()` parameters would be a breaking change, and we want to avoid that whenever possible. That being said, I agree we could definitely mention this potential issue in our documentation.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1007754778/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1007972632",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091#issuecomment-1007972632",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3091",
    "id": 1007972632,
    "node_id": "IC_kwDOA9tCBs48FHEY",
    "user": {
      "login": "hoytech",
      "id": 144548,
      "node_id": "MDQ6VXNlcjE0NDU0OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144548?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hoytech",
      "html_url": "https://github.com/hoytech",
      "followers_url": "https://api.github.com/users/hoytech/followers",
      "following_url": "https://api.github.com/users/hoytech/following{/other_user}",
      "gists_url": "https://api.github.com/users/hoytech/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hoytech/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hoytech/subscriptions",
      "organizations_url": "https://api.github.com/users/hoytech/orgs",
      "repos_url": "https://api.github.com/users/hoytech/repos",
      "events_url": "https://api.github.com/users/hoytech/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hoytech/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-08T12:18:50Z",
    "updated_at": "2022-01-08T12:18:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @Amxx, thanks for the reply.\r\n\r\nI don't believe it's really a property of merkle trees in general. Most merkle tree implementations prevent this by construction, by ensuring the input domains for constructing the leaf and node hashes are disjoint. They do this by prefixing/suffixing node type tags, using keyed hash functions, etc. In this way users can use any values at all for leaves.\r\n\r\nThis is not an issue with the OZ implementation in the sense that the OZ implementation is incomplete and does not itself implement leaf hashing. Instead, it requires the user of the library to take precautions to prevent it. Fortunately it's easy to do by ensuring that the only allowed leaf values are fixed, non-64 byte lengths, and perhaps you're right that usually this is the case, but there are many not-unrealistic scenarios where this could be violated (I wrote a brief analysis of this in the issue description).\r\n\r\nAgain, because most merkle tree implementations do not have this problem, it's especially important to notify library users, and it probably should have been done as soon as OZ was aware of it. [My pull request](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3090) has some basic wording that at least may help as a starting point.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1007972632/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
