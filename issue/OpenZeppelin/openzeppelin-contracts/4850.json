{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4850",
  "id": 2094904089,
  "node_id": "I_kwDOA9tCBs583bMZ",
  "number": 4850,
  "title": "Redundant SSTORE in BeaconProxy constructor",
  "user": {
    "login": "kadenzipfel",
    "id": 30579067,
    "node_id": "MDQ6VXNlcjMwNTc5MDY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/30579067?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kadenzipfel",
    "html_url": "https://github.com/kadenzipfel",
    "followers_url": "https://api.github.com/users/kadenzipfel/followers",
    "following_url": "https://api.github.com/users/kadenzipfel/following{/other_user}",
    "gists_url": "https://api.github.com/users/kadenzipfel/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kadenzipfel/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kadenzipfel/subscriptions",
    "organizations_url": "https://api.github.com/users/kadenzipfel/orgs",
    "repos_url": "https://api.github.com/users/kadenzipfel/repos",
    "events_url": "https://api.github.com/users/kadenzipfel/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kadenzipfel/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2024-01-22T22:44:42Z",
  "updated_at": "2024-01-25T12:37:06Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4435 introduced the usage of an immutable implementation address. However, it still makes use of `ERC1967Utils.upgradeBeaconToAndCall`, which sets the `BEACON_SLOT` to `newBeacon`. \r\n\r\n```solidity\r\nconstructor(address beacon, bytes memory data) payable {\r\n    ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\r\n    _beacon = beacon;\r\n}\r\n```\r\n\r\n```solidity\r\nfunction upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\r\n    _setBeacon(newBeacon);\r\n    emit BeaconUpgraded(newBeacon);\r\n\r\n    if (data.length > 0) {\r\n        Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n    } else {\r\n        _checkNonPayable();\r\n    }\r\n}\r\n```\r\n\r\n```solidity\r\nfunction _setBeacon(address newBeacon) private {\r\n    if (newBeacon.code.length == 0) {\r\n        revert ERC1967InvalidBeacon(newBeacon);\r\n    }\r\n\r\n    StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\r\n\r\n    address beaconImplementation = IBeacon(newBeacon).implementation();\r\n    if (beaconImplementation.code.length == 0) {\r\n        revert ERC1967InvalidImplementation(beaconImplementation);\r\n    }\r\n}\r\n```\r\n\r\nSetting `BEACON_SLOT` here is redundant since we use an immutable implementation address.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1905644220",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4850#issuecomment-1905644220",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850",
    "id": 1905644220,
    "node_id": "IC_kwDOA9tCBs5xldK8",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-23T09:29:15Z",
    "updated_at": "2024-01-23T09:29:15Z",
    "author_association": "COLLABORATOR",
    "body": "Hello @kadenzipfel \r\n\r\nThis sstore was kept on purpose. While it is not necessary for the contract to work, it is used for \"beacon discovery\".\r\n\r\nThe beacon proxy contains no public function, so that it is fully transparent, but that means it also does not (and cannot) include any getter. Now immagine you want to know which beacon a proxy uses. There is no easy way to do so. Our tolling used to rely (and still relies) on ERC-1967 slots for that kind of information.\r\n\r\nWritting the address of the beacon to the `BEACON_SLOT` sets that slot so that tolling suc as OpenZeppelin's upgrade plugin are able to detect which beacon is used.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1905644220/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1906563527",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4850#issuecomment-1906563527",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850",
    "id": 1906563527,
    "node_id": "IC_kwDOA9tCBs5xo9nH",
    "user": {
      "login": "kadenzipfel",
      "id": 30579067,
      "node_id": "MDQ6VXNlcjMwNTc5MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/30579067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kadenzipfel",
      "html_url": "https://github.com/kadenzipfel",
      "followers_url": "https://api.github.com/users/kadenzipfel/followers",
      "following_url": "https://api.github.com/users/kadenzipfel/following{/other_user}",
      "gists_url": "https://api.github.com/users/kadenzipfel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kadenzipfel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kadenzipfel/subscriptions",
      "organizations_url": "https://api.github.com/users/kadenzipfel/orgs",
      "repos_url": "https://api.github.com/users/kadenzipfel/repos",
      "events_url": "https://api.github.com/users/kadenzipfel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kadenzipfel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-23T17:25:25Z",
    "updated_at": "2024-01-23T17:25:25Z",
    "author_association": "NONE",
    "body": "> Hello @kadenzipfel\r\n> \r\n> This sstore was kept on purpose. While it is not necessary for the contract to work, it is used for \"beacon discovery\".\r\n> \r\n> The beacon proxy contains no public function, so that it is fully transparent, but that means it also does not (and cannot) include any getter. Now immagine you want to know which beacon a proxy uses. There is no easy way to do so. Our tolling used to rely (and still relies) on ERC-1967 slots for that kind of information.\r\n> \r\n> Writting the address of the beacon to the `BEACON_SLOT` sets that slot so that tolling suc as OpenZeppelin's upgrade plugin are able to detect which beacon is used.\r\n\r\nFair enough, but fwiw I think a better solution would be to retrieve the immutable from the end of the bytecode or emit an event instead of using storage",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1906563527/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1908184935",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4850#issuecomment-1908184935",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850",
    "id": 1908184935,
    "node_id": "IC_kwDOA9tCBs5xvJdn",
    "user": {
      "login": "max-clinch",
      "id": 74224236,
      "node_id": "MDQ6VXNlcjc0MjI0MjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/74224236?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/max-clinch",
      "html_url": "https://github.com/max-clinch",
      "followers_url": "https://api.github.com/users/max-clinch/followers",
      "following_url": "https://api.github.com/users/max-clinch/following{/other_user}",
      "gists_url": "https://api.github.com/users/max-clinch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/max-clinch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/max-clinch/subscriptions",
      "organizations_url": "https://api.github.com/users/max-clinch/orgs",
      "repos_url": "https://api.github.com/users/max-clinch/repos",
      "events_url": "https://api.github.com/users/max-clinch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/max-clinch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T14:02:53Z",
    "updated_at": "2024-01-24T14:02:53Z",
    "author_association": "NONE",
    "body": "> > Hello @kadenzipfel\r\n> > This sstore was kept on purpose. While it is not necessary for the contract to work, it is used for \"beacon discovery\".\r\n> > The beacon proxy contains no public function, so that it is fully transparent, but that means it also does not (and cannot) include any getter. Now immagine you want to know which beacon a proxy uses. There is no easy way to do so. Our tolling used to rely (and still relies) on ERC-1967 slots for that kind of information.\r\n> > Writting the address of the beacon to the `BEACON_SLOT` sets that slot so that tolling suc as OpenZeppelin's upgrade plugin are able to detect which beacon is used.\r\n> \r\n> Fair enough, but fwiw I think a better solution would be to retrieve the immutable from the end of the bytecode or emit an event instead of using storage\r\n\r\nBoth methods can be effective, and the choice often depends on factors such as gas efficiency.\r\nIf gas efficiency is a concern, parsing the bytecode might be more expensive than reading from storage, so emitting an event could be a lighter-weight solution. On the other hand, if the gas cost is acceptable, parsing the bytecode might offer a more compact storage and reduce the reliance on additional storage slots.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1908184935/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1908483736",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4850#issuecomment-1908483736",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4850",
    "id": 1908483736,
    "node_id": "IC_kwDOA9tCBs5xwSaY",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-24T16:27:14Z",
    "updated_at": "2024-01-24T16:39:27Z",
    "author_association": "MEMBER",
    "body": "These are all great reasons to avoid the extra SSTORE. Also, an SSTORE is on the list of things we'd push to optimize for.\r\n\r\nNonetheless, ERC1967 didn't provide a standard way to retrieve the beacon address from a client but it suggests doing it by reading from the slot:\r\n\r\n> [...] In order to know the logic contract used by a beacon proxy, a client SHOULD:\r\n>\r\n> - **Read the address of the beacon for the beacon logic storage slot;**\r\n> - Call the implementation() function on the beacon contract.\r\n\r\nAside from our upgrades plugins library relying on the slot value, we also agreed that, if following the standard, there's not a more reliable option to retrieve the admin, implementation, and beacon addresses than from the slot.\r\n\r\n> I think a better solution would be to retrieve the immutable from the end of the bytecode\r\n\r\nYeah this is good, but it's non-standard. It's breaking for platforms and tooling supporting EIP-1967, although it's possible everyone just adapts (not optimistic about this).\r\n\r\n>  or emit an event instead of using storage\r\n\r\nThe EIP states that storage slot changes SHOULD be notified by events. If we're not changing the slot, then clients should arguably not expect an event to be emitted. This is just too ambiguous to rely on imo.\r\n\r\nSince this is only done at construction, we generally thought the extra SSTORE was not the end of the world in this case 😅 ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1908483736/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
