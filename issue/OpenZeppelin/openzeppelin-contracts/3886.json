{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886",
  "id": 1501846794,
  "node_id": "I_kwDOA9tCBs5ZhF0K",
  "number": 3886,
  "title": "Extend MerkleProof to support verifying proof from eth_getProof",
  "user": {
    "login": "makoto",
    "id": 2630,
    "node_id": "MDQ6VXNlcjI2MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2630?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/makoto",
    "html_url": "https://github.com/makoto",
    "followers_url": "https://api.github.com/users/makoto/followers",
    "following_url": "https://api.github.com/users/makoto/following{/other_user}",
    "gists_url": "https://api.github.com/users/makoto/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/makoto/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/makoto/subscriptions",
    "organizations_url": "https://api.github.com/users/makoto/orgs",
    "repos_url": "https://api.github.com/users/makoto/repos",
    "events_url": "https://api.github.com/users/makoto/events{/privacy}",
    "received_events_url": "https://api.github.com/users/makoto/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 11,
  "created_at": "2022-12-18T10:14:05Z",
  "updated_at": "2023-01-04T16:09:15Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "**üßê Motivation**\r\n<!-- Is your feature request related to a specific problem? Is it just a crazy idea? Tell us about it! -->\r\n\r\nThe current MerkleProof only works with binary trees, not with eth‚Äôs Patricia trees.\r\nSupporting Patricia trees will be useful so that it can be used to verify account and storage proof via [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\r\n\r\n**üìù Details**\r\n<!-- Please describe your feature request in detail. -->\r\n\r\nThere is a similar solution existing on [web3.py](https://ouvrard-pierre-alain.medium.com/merkle-proof-verification-for-ethereum-patricia-tree-48f29658eec) and [optimism](https://github.com/ethereum-optimism/optimism/blob/ad38dcc02f4bcbc3e61a9722464c0392c9a5e3da/packages/contracts/contracts/libraries/utils/Lib_MerkleTree.sol)\r\n\r\n\r\n\r\n<!-- Make sure that you have reviewed the OpenZeppelin Contracts Contributor Guidelines. -->\r\n<!-- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CONTRIBUTING.md -->\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368069585",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1368069585",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1368069585,
    "node_id": "IC_kwDOA9tCBs5RixXR",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-12-30T19:48:25Z",
    "updated_at": "2022-12-30T19:48:25Z",
    "author_association": "MEMBER",
    "body": "We've considered this in the past. The issue is that this code would break with the introduction of Verkle trees. To be future proof, this should be included in the EVM as a precompile that could be upgraded to support them in the future.\r\n\r\nWe can still consider offering this code, but it would come with the caveat that it isn't future proof.\r\n\r\nCan you share the use cases you have in mind?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368069585/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368782871",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1368782871",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1368782871,
    "node_id": "IC_kwDOA9tCBs5RlfgX",
    "user": {
      "login": "gballet",
      "id": 3272758,
      "node_id": "MDQ6VXNlcjMyNzI3NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3272758?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gballet",
      "html_url": "https://github.com/gballet",
      "followers_url": "https://api.github.com/users/gballet/followers",
      "following_url": "https://api.github.com/users/gballet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gballet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gballet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gballet/subscriptions",
      "organizations_url": "https://api.github.com/users/gballet/orgs",
      "repos_url": "https://api.github.com/users/gballet/repos",
      "events_url": "https://api.github.com/users/gballet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gballet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-02T09:42:28Z",
    "updated_at": "2023-01-02T09:42:28Z",
    "author_association": "NONE",
    "body": "Chiming in about the verkle tree concerns: I can't promise that there will be a verification precompile at this stage, as you know these are frowned upon due to their maintenance cost.\r\n\r\nI was wondering: given that proofs are widely different, it would be possible to determine if a proof is an MPT proof or a verkle one. Even simpler, the call to MerkleProof could receive an extra parameter, that specifies if the user wants a verkle or merkle proof. Then there could be some sort of table that can be updated, that will delegate the verkle verification to an external contract. I think this should be feasible if the verification precompile isn't an option.\r\n\r\nHappy to discuss this further, and I will also investigate the feasability of a verification precompile in the meantime.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368782871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368863162",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1368863162",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1368863162,
    "node_id": "IC_kwDOA9tCBs5RlzG6",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-02T11:25:21Z",
    "updated_at": "2023-01-02T11:25:21Z",
    "author_association": "COLLABORATOR",
    "body": "This would have usage beyond proving \"mainnet\" proofs. I could be usefull to prove statement about other chains providing that the root hash is known. I can foresee this being used to prove statements about the polygon state on mainnet. Even after mainnet moves to verkle trees, this would still prove usefull if the other chain doesn't operate the same transition.\r\n\r\nI would personally love to include this, will all the warning and disclaimers needed about Patricia trees possibly being deprecated in the future.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368863162/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368911190",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1368911190",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1368911190,
    "node_id": "IC_kwDOA9tCBs5Rl-1W",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-02T12:35:29Z",
    "updated_at": "2023-01-02T12:36:39Z",
    "author_association": "MEMBER",
    "body": ">Even simpler, the call to MerkleProof could receive an extra parameter, that specifies if the user wants a verkle or merkle proof.\r\n\r\nIn the ideal scenario, the code would be forward compatible, i.e. automatically adapt to verkle proofs. Unless the contract is upgradeable, this can only be reliably achieved by a precompile, which is why I think there should be one.\r\n\r\n> I can foresee this being used to prove statements about the polygon state on mainnet.\r\n\r\nYeah, I think this is already how the Polygon bridge works in that direction.\r\n\r\nIn general I'm skeptical about the need for Patricia trees given that there are probably other bridges in place that may be more efficient. In rollups this is clearly the case.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368911190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368914419",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1368914419",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1368914419,
    "node_id": "IC_kwDOA9tCBs5Rl_nz",
    "user": {
      "login": "makoto",
      "id": 2630,
      "node_id": "MDQ6VXNlcjI2MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2630?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/makoto",
      "html_url": "https://github.com/makoto",
      "followers_url": "https://api.github.com/users/makoto/followers",
      "following_url": "https://api.github.com/users/makoto/following{/other_user}",
      "gists_url": "https://api.github.com/users/makoto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/makoto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/makoto/subscriptions",
      "organizations_url": "https://api.github.com/users/makoto/orgs",
      "repos_url": "https://api.github.com/users/makoto/repos",
      "events_url": "https://api.github.com/users/makoto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/makoto/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-02T12:41:13Z",
    "updated_at": "2023-01-02T12:44:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "From the use case I have in mind, we can upgrade the contract so no need to have precompiled just for forward compatibility.  \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1368914419/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1369156683",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1369156683",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1369156683,
    "node_id": "IC_kwDOA9tCBs5Rm6xL",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-02T19:12:44Z",
    "updated_at": "2023-01-02T19:12:44Z",
    "author_association": "MEMBER",
    "body": "@makoto Is that a use case you could share? It helps us prioritize the work.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1369156683/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1369282043",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1369282043",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1369282043,
    "node_id": "IC_kwDOA9tCBs5RnZX7",
    "user": {
      "login": "makoto",
      "id": 2630,
      "node_id": "MDQ6VXNlcjI2MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2630?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/makoto",
      "html_url": "https://github.com/makoto",
      "followers_url": "https://api.github.com/users/makoto/followers",
      "following_url": "https://api.github.com/users/makoto/following{/other_user}",
      "gists_url": "https://api.github.com/users/makoto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/makoto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/makoto/subscriptions",
      "organizations_url": "https://api.github.com/users/makoto/orgs",
      "repos_url": "https://api.github.com/users/makoto/repos",
      "events_url": "https://api.github.com/users/makoto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/makoto/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T00:08:05Z",
    "updated_at": "2023-01-03T00:08:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "Sure.\r\nHere are the two places I am using storage verifications. The use case is to verify l2 storage slot on l1. Even though how you verify l2 state on l1 is different to each l2 chains, the way to verify storage is almost identical. \r\n\r\nhttps://github.com/ensdomains/op-resolver/blob/master/packages/contracts/contracts/l1/OptimismResolverStub.sol#L135\r\nhttps://github.com/ensdomains/arb-resolver/blob/master/packages/contracts/contracts/l1/ArbitrumResolverStub.sol#L166\r\n\r\nOptimism's library works perfectly fine so we will be using that for non-Optimism chains, but I thought it would be nice if OZ libraries has the support, too.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1369282043/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370013675",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1370013675",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1370013675,
    "node_id": "IC_kwDOA9tCBs5RqL_r",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T17:06:24Z",
    "updated_at": "2023-01-03T17:09:01Z",
    "author_association": "COLLABORATOR",
    "body": "IMO we would want two things:\r\n\r\n- ***first***, a \"mathematical\" implementation of the merkle-proof verification (as a mathematical primitive) that correpond to [eth_getProof](https://eips.ethereum.org/EIPS/eip-1186) proofs.\r\n- ***maybe later***, a wrapper that process an arbitrary proof using different algorithm (the one above & other) depending on the proof structure. [Note that there have been discussion for a precompile that does that](https://ethresear.ch/t/future-proof-shard-and-history-access-precompiles/9781).\r\n\r\nI believe there is real added value to providing the first element, come with specific warning, because I view it as a \"pure\" mathemical function that can be usefull I many context and needs a \"standard\" solidity implementation. \r\n\r\nIt will have to come with comments stating that the mathematical structure being verified might not be used forever, and that there are plans to transition away from it. Maybe linking to [this article](https://vitalik.eth.limo/general/2022/08/04/zkevm.html) about evm-equivalence:\r\n\r\n> There are a small number of exceptions. One incompatibility arises for applications that verify Merkle proofs of [historical Ethereum blocks](https://github.com/aragon/evm-storage-proofs) to verify claims about historical transactions, receipts or state (eg. bridges sometimes do this). A ZK-EVM that replaces Keccak with a different hash function would break these proofs. However, I usually recommend against building applications this way anyway, because future Ethereum changes (eg. [Verkle trees](https://notes.ethereum.org/@vbuterin/verkle_tree_eip)) will break such applications even on Ethereum itself. A better alternative would be for Ethereum itself to add [future-proof history access precompiles](https://ethresear.ch/t/future-proof-shard-and-history-access-precompiles/9781).\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370013675/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370018600",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1370018600",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1370018600,
    "node_id": "IC_kwDOA9tCBs5RqNMo",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T17:10:22Z",
    "updated_at": "2023-01-03T17:10:22Z",
    "author_association": "COLLABORATOR",
    "body": "Note that the precompile mentioned by Vitalik would **not** render this implementation useless, as this implementation might be used in a post-verge ethereum, to prove properties about other blockchains (Matic, BNB, ...)",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370018600/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370207838",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1370207838",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1370207838,
    "node_id": "IC_kwDOA9tCBs5Rq7Ze",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-03T20:45:30Z",
    "updated_at": "2023-01-03T20:45:57Z",
    "author_association": "MEMBER",
    "body": "Well in an ideal world the precompile would be compatible with other blockchains as well but this is where it starts to become harder to justify to client development teams.\r\n\r\nI don't know if it makes sense to completely disentangle it from the context of Ethereum, but I see the argument that \"mathematically\" a Merkle Patricia Tree verifier makes sense on its own. And this has been requested a few times so it would make sense for us to offer it.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1370207838/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1371123717",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3886#issuecomment-1371123717",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3886",
    "id": 1371123717,
    "node_id": "IC_kwDOA9tCBs5RubAF",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-01-04T16:09:15Z",
    "updated_at": "2023-01-04T16:09:15Z",
    "author_association": "COLLABORATOR",
    "body": "From my understanding, any `eth_getProof` verification algorithm would need to do some RLP decoding. As we don't want to have any dependencies, a first step would be to build a library for manipulating RLP bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1371123717/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
