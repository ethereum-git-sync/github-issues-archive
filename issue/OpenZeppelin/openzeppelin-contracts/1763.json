{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1763",
  "id": 446620643,
  "node_id": "MDU6SXNzdWU0NDY2MjA2NDM=",
  "number": 1763,
  "title": "ERC777 together with dependencies results in 29 warnings in remix",
  "user": {
    "login": "guylando",
    "id": 14879163,
    "node_id": "MDQ6VXNlcjE0ODc5MTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/14879163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/guylando",
    "html_url": "https://github.com/guylando",
    "followers_url": "https://api.github.com/users/guylando/followers",
    "following_url": "https://api.github.com/users/guylando/following{/other_user}",
    "gists_url": "https://api.github.com/users/guylando/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/guylando/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/guylando/subscriptions",
    "organizations_url": "https://api.github.com/users/guylando/orgs",
    "repos_url": "https://api.github.com/users/guylando/repos",
    "events_url": "https://api.github.com/users/guylando/events{/privacy}",
    "received_events_url": "https://api.github.com/users/guylando/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2019-05-21T13:30:12Z",
  "updated_at": "2019-05-24T18:25:50Z",
  "closed_at": "2019-05-24T17:15:24Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "The warnings are:\r\n\r\n1. Potential Violation of Checks-Effects-Interaction pattern in ERC777.(string,string,address[]): Could potentially lead to re-entrancy vulnerability. \r\n\r\n2. browser/Fallback.sol:134:9:CAUTION: The Contract uses inline assembly, this is only advised in rare cases. Additionally static analysis modules do not parse inline Assembly, this can lead to wrong analysis results.\r\n\r\n3. Gas requirement of function ERC777.approve(address,uint256) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n4. Gas requirement of function ERC777.authorizeOperator(address) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n5. Gas requirement of function ERC777.burn(uint256,bytes) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n6. Gas requirement of function ERC777.defaultOperators() high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n7. Gas requirement of function ERC777.name() high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n8. Gas requirement of function ERC777.operatorBurn(address,uint256,bytes,bytes) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n9. Gas requirement of function ERC777.operatorSend(address,address,uint256,bytes,bytes) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n10. Gas requirement of function ERC777.revokeOperator(address) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n11. Gas requirement of function ERC777.send(address,uint256,bytes) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n12. Gas requirement of function ERC777.symbol() high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n13. Gas requirement of function ERC777.transfer(address,uint256) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n14. Gas requirement of function ERC777.transferFrom(address,address,uint256) high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage (this includes clearing or copying arrays in storage)\r\n\r\n15. browser/Fallback.sol:343:9:Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. Additionally, using unbounded loops incurs in a lot of avoidable gas costs. Carefully test how many items at maximum you can pass to such functions to make it successful.\r\n\r\n\r\n16. Address.isContract(address) : Is constant but potentially should not be. \r\n\r\n17. ERC777.transferFrom(address,address,uint256) : Variables have very similar names _operators and operator.\r\n\r\n18. ERC777.authorizeOperator(address) : Variables have very similar names _operators and operator.\r\n\r\n19. ERC777.revokeOperator(address) : Variables have very similar names _operators and operator.\r\n\r\n20. ERC777.isOperatorFor(address,address) : Variables have very similar names _operators and operator.\r\n\r\n21. ERC777._mint(address,address,uint256,bytes,bytes) : Variables have very similar names _operators and operator.\r\n\r\n22. ERC777._send(address,address,address,uint256,bytes,bytes,bool) : Variables have very similar names _operators and operator.\r\n\r\n23. ERC777._burn(address,address,uint256,bytes,bytes) : Variables have very similar names _operators and operator.\r\n\r\n24. ERC777._move(address,address,address,uint256,bytes,bytes) : Variables have very similar names _operators and operator.\r\n\r\n25. ERC777._callTokensToSend(address,address,address,uint256,bytes,bytes) : Variables have very similar names _operators and operator.\r\n\r\n26. ERC777._callTokensReceived(address,address,address,uint256,bytes,bytes,bool) : Variables have very similar names _operators and operator.\r\n\r\n27. Use assert(x) if you never ever want x to be false, not in any circumstance (apart from a bug in your code). Use require(x) if x can be false, due to e.g. invalid input or a failing external component.\r\n\r\n28. browser/Fallback.sol:459:13:Using delete on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the length property. \r\n\r\n29. browser/Fallback.sol:477:13:Using delete on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the length property. \r\n\r\n<details>\r\n<summary>The code inserted to remix is:</summary>\r\n\r\n```\r\npragma solidity 0.5.8;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC1820 Pseudo-introspection Registry Contract\r\n * @author Jordi Baylina and Jacques Dafflon\r\n * @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @notice Sets the contract which implements a specific interface for an address.\r\n     * Only the manager defined for that address can set it.\r\n     * (Each address is the manager for itself until it sets a new manager.)\r\n     * @param account Address for which to set the interface.\r\n     * (If 'account' is the zero address then 'msg.sender' is assumed.)\r\n     * @param interfaceHash Keccak256 hash of the name of the interface as a string.\r\n     * E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\r\n     * @param implementer Contract address implementing `interfaceHash` for `account.address()`.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @notice Sets `newManager.address()` as manager for `account.address()`.\r\n     * The new manager will be able to call 'setInterfaceImplementer' for `account.address()`.\r\n     * @param account Address for which to set the new manager.\r\n     * @param newManager Address of the new manager for `addr.address()`.\r\n     * (Pass '0x0' to reset the manager to `account.address()`.)\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Get the manager of an address.\r\n     *  @param account Address for which to return the manager.\r\n     *  @return Address of the manager for a given address.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     *  @notice Query if an address implements an interface and through which contract.\r\n     *  @param account Address being queried for the implementer of an interface.\r\n     *  (If 'account' is the zero address then 'msg.sender' is assumed.)\r\n     *  @param interfaceHash Keccak256 hash of the name of the interface as a string.\r\n     *  E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\r\n     *  @return The address of the contract which implements the interface `interfaceHash` for `account.address()`\r\n     *  or '0' if `account.address()` did not register an implementer for this interface.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  'updateERC165Cache' with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account.address()` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account.address()` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Compute the keccak256 hash of an interface given its name.\r\n     *  @param interfaceName Name of the interface.\r\n     *  @return The keccak256 hash of an interface name.\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Indicates a contract is the `implementer` of `interfaceHash` for `account`.\r\n     */\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    /**\r\n     *  @notice Indicates `newManager` is the address of the new manager for `account`.\r\n     */\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC777 token recipient interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-777\r\n */\r\ninterface IERC777Recipient {\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC777 token sender interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-777\r\n */\r\ninterface IERC777Sender {\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC777 token interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-777\r\n */\r\ninterface IERC777 {\r\n    function authorizeOperator(address operator) external;\r\n\r\n    function revokeOperator(address operator) external;\r\n\r\n    function send(address to, uint256 amount, bytes calldata data) external;\r\n\r\n    function operatorSend(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    function operatorBurn(\r\n        address from,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function granularity() external view returns (uint256);\r\n\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n/**\r\n * @title ERC777 token implementation, with granularity harcoded to 1.\r\n * @author etsvigun <utgarda@gmail.com>, Bertrand Masius <github@catageeks.tk>\r\n */\r\ncontract ERC777 is IERC777, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\r\n    // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n    // keccak256(\"ERC777TokensSender\")\r\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\r\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n\r\n    // keccak256(\"ERC777TokensRecipient\")\r\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\r\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\r\n    address[] private _defaultOperatorsArray;\r\n\r\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\r\n    mapping(address => bool) private _defaultOperators;\r\n\r\n    // For each account, a mapping of its operators and revoked default operators.\r\n    mapping(address => mapping(address => bool)) private _operators;\r\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\r\n\r\n    // ERC20-allowances\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        address[] memory defaultOperators\r\n    ) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        _defaultOperatorsArray = defaultOperators;\r\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\r\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\r\n        }\r\n\r\n        // register interfaces\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Send the amount of tokens from the address msg.sender to the address to\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param data bytes information attached to the send, and intended for the recipient (to)\r\n     */\r\n    function send(address to, uint256 amount, bytes calldata data) external {\r\n        _send(msg.sender, msg.sender, to, amount, data, \"\", true);\r\n    }\r\n\r\n    /**\r\n     * @dev Send the amount of tokens on behalf of the address from to the address to\r\n     * @param from address token holder address.\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param data bytes information attached to the send, and intended for the recipient (to)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function operatorSend(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    )\r\n    external\r\n    {\r\n        require(isOperatorFor(msg.sender, from), \"ERC777: caller is not an operator for holder\");\r\n        _send(msg.sender, from, to, amount, data, operatorData, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address.\r\n     * Required for ERC20 compatiblity. Note that transferring tokens this way may result in locked tokens (i.e. tokens\r\n     * can be sent to a contract that does not implement the ERC777TokensRecipient interface).\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        require(to != address(0), \"ERC777: transfer to the zero address\");\r\n\r\n        address from = msg.sender;\r\n\r\n        _callTokensToSend(from, from, to, value, \"\", \"\");\r\n\r\n        _move(from, from, to, value, \"\", \"\");\r\n\r\n        _callTokensReceived(from, from, to, value, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * Required for ERC20 compatiblity. Note that transferring tokens this way may result in locked tokens (i.e. tokens\r\n     * can be sent to a contract that does not implement the ERC777TokensRecipient interface).\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\r\n        require(to != address(0), \"ERC777: transfer to the zero address\");\r\n        require(from != address(0), \"ERC777: transfer from the zero address\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _callTokensToSend(operator, from, to, value, \"\", \"\");\r\n\r\n        _move(operator, from, to, value, \"\", \"\");\r\n        _approve(from, operator, _allowances[from][operator].sub(value));\r\n\r\n        _callTokensReceived(operator, from, to, value, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn the amount of tokens from the address msg.sender\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param data bytes extra information provided by the token holder\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external {\r\n        _burn(msg.sender, msg.sender, amount, data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Burn the amount of tokens on behalf of the address from\r\n     * @param from address token holder address.\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function operatorBurn(address from, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\r\n        require(isOperatorFor(msg.sender, from), \"ERC777: caller is not an operator for holder\");\r\n        _burn(msg.sender, from, amount, data, operatorData);\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize an operator for the sender\r\n     * @param operator address to be authorized as operator\r\n     */\r\n    function authorizeOperator(address operator) external {\r\n        require(msg.sender != operator, \"ERC777: authorizing self as operator\");\r\n\r\n        if (_defaultOperators[operator]) {\r\n            delete _revokedDefaultOperators[msg.sender][operator];\r\n        } else {\r\n            _operators[msg.sender][operator] = true;\r\n        }\r\n\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke operator rights from one of the default operators\r\n     * @param operator address to revoke operator rights from\r\n     */\r\n    function revokeOperator(address operator) external {\r\n        require(operator != msg.sender, \"ERC777: revoking self as operator\");\r\n\r\n        if (_defaultOperators[operator]) {\r\n            _revokedDefaultOperators[msg.sender][operator] = true;\r\n        } else {\r\n            delete _operators[msg.sender][operator];\r\n        }\r\n\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * Required for ERC20 compatilibity.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param tokenHolder The address to query the balance of.\r\n        * @return uint256 representing the amount owned by the specified address.\r\n     */\r\n    function balanceOf(address tokenHolder) public view returns (uint256) {\r\n        return _balances[tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 18; // The spec requires that decimals be 18\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token's granularity,\r\n     * i.e. the smallest number of tokens (in the basic unit)\r\n     * which may be minted, sent or burned at any time\r\n     * @return uint256 granularity\r\n     */\r\n    function granularity() public view returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the list of default operators as defined by the token contract.\r\n     * @return address[] default operators\r\n     */\r\n    function defaultOperators() public view returns (address[] memory) {\r\n        return _defaultOperatorsArray;\r\n    }\r\n\r\n    /**\r\n     * @dev Indicate whether an address\r\n     * is an operator of the tokenHolder address\r\n     * @param operator address which may be an operator of tokenHolder\r\n     * @param tokenHolder address of a token holder which may have the operator\r\n     * address as an operator.\r\n     */\r\n    function isOperatorFor(\r\n        address operator,\r\n        address tokenHolder\r\n    ) public view returns (bool) {\r\n        return operator == tokenHolder ||\r\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\r\n            _operators[tokenHolder][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * Required for ERC20 compatibility.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Mint tokens. Does not check authorization of operator\r\n     * @dev the caller may ckeck that operator is authorized before calling\r\n     * @param operator address operator requesting the operation\r\n     * @param to address token recipient address\r\n     * @param amount uint256 amount of tokens to mint\r\n     * @param userData bytes extra information defined by the token recipient (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _mint(\r\n        address operator,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        require(to != address(0), \"ERC777: mint to the zero address\");\r\n\r\n        // Update state variables\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[to] = _balances[to].add(amount);\r\n\r\n        _callTokensReceived(operator, address(0), to, amount, userData, operatorData, true);\r\n\r\n        emit Minted(operator, to, amount, userData, operatorData);\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _send(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n    private\r\n    {\r\n        require(from != address(0), \"ERC777: send from the zero address\");\r\n        require(to != address(0), \"ERC777: send to the zero address\");\r\n\r\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n        _move(operator, from, to, amount, userData, operatorData);\r\n\r\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens\r\n     * @param operator address operator requesting the operation\r\n     * @param from address token holder address\r\n     * @param amount uint256 amount of tokens to burn\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _burn(\r\n        address operator,\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    private\r\n    {\r\n        require(from != address(0), \"ERC777: burn from the zero address\");\r\n\r\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n        // Update state variables\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[from] = _balances[from].sub(amount);\r\n\r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _move(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        private\r\n    {\r\n        _balances[from] = _balances[from].sub(amount);\r\n        _balances[to] = _balances[to].add(amount);\r\n\r\n        emit Sent(operator, from, to, amount, userData, operatorData);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) private {\r\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\r\n        // currently unnecessary.\r\n        //require(owner != address(0), \"ERC777: approve from the zero address\");\r\n        require(spender != address(0), \"ERC777: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Call from.tokensToSend() if the interface is registered\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _callTokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n    private\r\n    {\r\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n     * tokensReceived() was not registered for the recipient\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _callTokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n    private\r\n    {\r\n        address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n        } else if (requireReceptionAck) {\r\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n</details>",
  "closed_by": {
    "login": "nventuro",
    "id": 2530770,
    "node_id": "MDQ6VXNlcjI1MzA3NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nventuro",
    "html_url": "https://github.com/nventuro",
    "followers_url": "https://api.github.com/users/nventuro/followers",
    "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
    "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
    "organizations_url": "https://api.github.com/users/nventuro/orgs",
    "repos_url": "https://api.github.com/users/nventuro/repos",
    "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nventuro/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495715697",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1763#issuecomment-495715697",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763",
    "id": 495715697,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTcxNTY5Nw==",
    "user": {
      "login": "nventuro",
      "id": 2530770,
      "node_id": "MDQ6VXNlcjI1MzA3NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nventuro",
      "html_url": "https://github.com/nventuro",
      "followers_url": "https://api.github.com/users/nventuro/followers",
      "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
      "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
      "organizations_url": "https://api.github.com/users/nventuro/orgs",
      "repos_url": "https://api.github.com/users/nventuro/repos",
      "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nventuro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-24T17:15:24Z",
    "updated_at": "2019-05-24T17:15:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hello @guylando, thank you for reporting this! I took a look at all of them, and found they are all either non-issues or false positives.\r\n\r\n>Potential Violation of Checks-Effects-Interaction pattern in ERC777.(string,string,address[]): Could potentially lead to re-entrancy vulnerability.\r\n\r\nThis is because of the external call to ERC1820Registry during construction. Since this is a trusted contract, this is a non-issue.\r\n\r\n>browser/Fallback.sol:134:9:CAUTION: The Contract uses inline assembly, this is only advised in rare cases.\r\n\r\nUsed by `Address.isContract`, no issues here.\r\n\r\n>Gas requirement of function ERC777.approve(address,uint256) high: infinite. (many of these)\r\n\r\nNot sure what causes this warning to trigger, the functions definitely don't take infinite gas. Even getters like `name` were flagged by this one.\r\n    \r\n>browser/Fallback.sol:343:9:Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. Additionally, using unbounded loops incurs in a lot of avoidable gas costs. Carefully test how many items at maximum you can pass to such functions to make it successful.\r\n\r\nI take it this is related to the `defaultOperators` in the constructor? Sadly there's no real way to avoid this, and as specified in the spec, it is not possible to have an arbitrary large number of default operators.\r\n\r\n>Address.isContract(address) : Is constant but potentially should not be.\r\n\r\n`constant` is a very old attribute, I'm not even sure what this refers to. The function is definitely `view` (it uses `extcodesize`).\r\n\r\n>ERC777.transferFrom(address,address,uint256) : Variables have very similar names _operators and operator.\r\n\r\n`operator` is an `address`, while `_operators` is a `mapping(address => mapping(address => bool))`. I doubt this will be an issue.\r\n\r\n>Use assert(x) if you never ever want x to be false, not in any circumstance (apart from a bug in your code). Use require(x) if x can be false, due to e.g. invalid input or a failing external component.\r\n\r\nNot suure why an assertion is being suggested?\r\n\r\n>browser/Fallback.sol:459:13:Using delete on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the length property.\r\n\r\nWe're calling `delete` on a mapping, not an array, maybe the rule forgot to check for that?\r\n\r\nClosing this, but feel free to reply if you have any questions about my replies!",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495715697/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495724680",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1763#issuecomment-495724680",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763",
    "id": 495724680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTcyNDY4MA==",
    "user": {
      "login": "guylando",
      "id": 14879163,
      "node_id": "MDQ6VXNlcjE0ODc5MTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/14879163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guylando",
      "html_url": "https://github.com/guylando",
      "followers_url": "https://api.github.com/users/guylando/followers",
      "following_url": "https://api.github.com/users/guylando/following{/other_user}",
      "gists_url": "https://api.github.com/users/guylando/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guylando/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guylando/subscriptions",
      "organizations_url": "https://api.github.com/users/guylando/orgs",
      "repos_url": "https://api.github.com/users/guylando/repos",
      "events_url": "https://api.github.com/users/guylando/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guylando/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-24T17:37:56Z",
    "updated_at": "2019-05-24T17:37:56Z",
    "author_association": "NONE",
    "body": "@nventuro Your answers are clear, thanks. I must say that the usage of erc1820 preventing remix javascript VM from being able to deploy the contract for some testing is a real annoyance with the erc777 compared to erc20. Creating and testing an erc777 tokens seems to take much more time than erc20 token because of that.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495724680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495743290",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1763#issuecomment-495743290",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/1763",
    "id": 495743290,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTc0MzI5MA==",
    "user": {
      "login": "nventuro",
      "id": 2530770,
      "node_id": "MDQ6VXNlcjI1MzA3NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2530770?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nventuro",
      "html_url": "https://github.com/nventuro",
      "followers_url": "https://api.github.com/users/nventuro/followers",
      "following_url": "https://api.github.com/users/nventuro/following{/other_user}",
      "gists_url": "https://api.github.com/users/nventuro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nventuro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nventuro/subscriptions",
      "organizations_url": "https://api.github.com/users/nventuro/orgs",
      "repos_url": "https://api.github.com/users/nventuro/repos",
      "events_url": "https://api.github.com/users/nventuro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nventuro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-24T18:25:50Z",
    "updated_at": "2019-05-24T18:25:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, I don't personally consider Remix to be a great development environment, and only use it for quick tests when trying out ideas, measuring gas, etc. It'd be very hard to replicate the ERC1820 registry deployment from it, but it will allow you to work on any of the testnets (where it has already been deployed).\r\n\r\nHowever! If you do make the switch for local development, you can use the [`openzeppelin-test-helpers`](https://github.com/OpenZeppelin/openzeppelin-test-helpers#readme), which let you deploy the registry on your local blockchain via [`singletons.ERC180Registry`](https://github.com/OpenZeppelin/openzeppelin-test-helpers#async-singletonserc1820registry-funder).",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/495743290/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
