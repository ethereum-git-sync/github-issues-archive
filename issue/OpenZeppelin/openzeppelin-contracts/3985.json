{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985",
  "id": 1552161611,
  "node_id": "I_kwDOA9tCBs5chBtL",
  "number": 3985,
  "title": "ERC721Consecutive Meets ERC721Enumerable: A Compatibility Proof-of-Concept",
  "user": {
    "login": "shypink",
    "id": 86266442,
    "node_id": "MDQ6VXNlcjg2MjY2NDQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/shypink",
    "html_url": "https://github.com/shypink",
    "followers_url": "https://api.github.com/users/shypink/followers",
    "following_url": "https://api.github.com/users/shypink/following{/other_user}",
    "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
    "organizations_url": "https://api.github.com/users/shypink/orgs",
    "repos_url": "https://api.github.com/users/shypink/repos",
    "events_url": "https://api.github.com/users/shypink/events{/privacy}",
    "received_events_url": "https://api.github.com/users/shypink/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2023-01-22T15:31:01Z",
  "updated_at": "2023-05-24T15:28:44Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**🧐 Motivation**\r\n\r\nERC721Consecutive make batch minting possible but it is not IERC721Enumerable compatible.\r\nthe following contract Is a proof of concept that shows with some minor changes to ERC721Consecutive and ERC721Enumerable.\r\nit can be merge to one contract. with following features:\r\n* batch minting during constructor.\r\n* single minting after deployment.\r\n* single burning of a token.\r\n* full IERC721Enumerable compatibility.\r\n* all of the indexing functions are O(1)\r\n\r\n**📝 Details**\r\nthe main idea is , how to find the indices of tokens that are not initialized by single minting (like in ERC721Enumerable), while the mappings are empty and they have default  value uint `0`.\r\n\r\nas an example.\r\n` tokenByIndex(uint256 index)`\r\n\r\nsince the tokens that are created from batch minting start from tokenId `0` to `totalConsecutiveSupply() -1 `\r\nand Index of tokens have not initialized we can consider TokenIndex the same as tokenId\r\nand if new tokens were minted we initialize them ` _allIndexToTokenId` and `_allTokenIdToIndex` \r\nand if we burned a token we can initialize the index by a swap operation if it's necessary see  `_removeTokenFromAllTokensEnumeration(uint256 tokenId)`\r\nupon reading the index if  ` _allIndexToTokenId` and `_allTokenIdToIndex` have not initialized and the value inside the mapping was `uint(0)`  it means the token was batch minted and the value is not initialized, so  the tokenId is the same as index and the index is the same as tokenId\r\n\r\nnote: \r\nnote: to remove the ambiguity of value uint(0) with default value of mapping that is also uint(0) while populating the  \r\n `_allIndexToTokenId` and `_allTokenIdToIndex`  we write the values `+ 1` and when we want to access the value if we `-1`\r\nsee `tokenByIndex(uint256 index)` and  `_indexByToken(uint256 tokenId)` and `_addTokenToAllTokensEnumeration(uint256 tokenId)` and `_removeTokenFromAllTokensEnumeration(uint256 tokenId)`\r\n \r\n```solidity\r\n//list of all tokenId available(some values are available virtauly to access use tokenByIndex(_index))\r\n    mapping(uint256 => uint256) private _allIndexToTokenId;\r\n    //mapping of tokenId to index in _allIndexToTokenId(some value are available virtual to access use _indexByToken(tokenId))\r\n    mapping(uint256 => uint256) private _allTokenIdToIndex;\r\n\r\n/**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    /**\r\n     * @dev handling tokens index virtually \r\n     */\r\nfunction tokenByIndex(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            index < ERC721CE.totalSupply(),\r\n            \"ERC721Enumerable: global index out of bounds\"\r\n        );\r\n        uint256 virtualIndex = _allIndexToTokenId[index];\r\n        //if mapping is empty, index is the same as tokenId, since they are all sequential and start from 0\r\n        if (virtualIndex == 0) {\r\n            return index;\r\n        }\r\n        return virtualIndex - 1; //decrement one (-1) to get the value, overflow is impossible because the virtualIndex is not 0.\r\n    }\r\n\r\n     ////provied the token Index in the list of all tokens that have been created.\r\n    function _indexByToken(uint256 tokenId) private view returns (uint256) {\r\n        uint256 virtualIndex = _allTokenIdToIndex[tokenId];\r\n        //if mapping is empty, tokenId is the same as index, since they are all sequential and start from 0\r\n        if (virtualIndex == 0) {\r\n            return tokenId;\r\n        }\r\n        return virtualIndex - 1; //decrement one (-1) to get the value,overflow is impossible becuase the virtualIndex is not 0.\r\n    }\r\n\r\n  /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     * write values + 1 to avoid confusion to mapping default value of uint (uint(0))\r\n     */\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 _index = totalSupply();\r\n        // + 1 to remove the ambiguity of value with default value(uint 0) in mapping of  _allIndexToTokenId and _allTokenIdToIndex\r\n        _allIndexToTokenId[_index] = tokenId + 1;\r\n        _allTokenIdToIndex[tokenId] = _index + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but works with to new mapping _allIndexToTokenId, _allTokenIdToIndex\r\n     * functionality is more similar to _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastIndex = totalSupply() - 1;\r\n        // uint256 tokenIndex = tokenByIndex(tokenId);\r\n        uint256 tokenIndex = _indexByToken(tokenId);\r\n\r\n        if (lastIndex != tokenIndex) {\r\n            uint256 lastTokenId = tokenByIndex(lastIndex);\r\n            // + 1 to remove the ambiguity of value with default value(uint 0) in mapping of  _allIndexToTokenId and _allTokenIdToIndex\r\n            _allIndexToTokenId[tokenIndex] = lastTokenId + 1;\r\n            _allTokenIdToIndex[lastTokenId] = tokenIndex + 1;\r\n        }\r\n        delete _allIndexToTokenId[lastIndex];\r\n        delete _allTokenIdToIndex[tokenId];\r\n    }\r\n```\r\n\r\nthis implementation can be a stand alone extension ERC721ConsecutiveEnumerable.sol or it can be break down as a changes to ERC721Consecutive.sol and ERC721Enumerable to make them compatible with each other.\r\n\r\n[github - ERC721ConsecutiveEnumerable](https://github.com/shypink/ERC721ConsecutiveEnumerable)\r\n\r\nGoerli testnet : [0xaF8fA6fC07Da285a94f37148218fFd170eE827ff](https://goerli.etherscan.io/token/0xaf8fa6fc07da285a94f37148218ffd170ee827ff)\r\n\r\nthank you for your time.\r\nsciNFTist.eth",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1412324830",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1412324830",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1412324830,
    "node_id": "IC_kwDOA9tCBs5ULl3e",
    "user": {
      "login": "shypink",
      "id": 86266442,
      "node_id": "MDQ6VXNlcjg2MjY2NDQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shypink",
      "html_url": "https://github.com/shypink",
      "followers_url": "https://api.github.com/users/shypink/followers",
      "following_url": "https://api.github.com/users/shypink/following{/other_user}",
      "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
      "organizations_url": "https://api.github.com/users/shypink/orgs",
      "repos_url": "https://api.github.com/users/shypink/repos",
      "events_url": "https://api.github.com/users/shypink/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shypink/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-01T16:12:51Z",
    "updated_at": "2023-02-01T16:12:51Z",
    "author_association": "NONE",
    "body": "\r\nIn this comment I will explain how we can Index batch minted tokens by lazy indexing.\r\n`_ownedTokens`  mapping is the data structure responsible for indexing an arbitrary owner tokens, but since in the batch minting this mapping won't be initialize, we can consider all of their token indexes sequentially from their first tokenId that they batch minted. and upon the transfer of a token we populate  `_ownedTokens` and  `_ownedTokensIndex` with a swap operation if it is necessary see ` _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)`.\r\n\r\nif `_ownedTokens[owner][index]` was equal to `0` it means the token index is not initialized and we can access it virtually\r\nwith  ` tokenId -  _ownerStartTokenId[_owner]`\r\n\r\nnote: to remove the ambiguity of value  `uint(0)` with default value of mapping that is also `uint(0)`  while populating the  `_ownedTokens` and  `_ownedTokensIndex` we write the values `+ 1` and when we want to access `_ownedTokens` and  `_ownedTokensIndex`  we `- 1`.  see ` _addTokenToOwnerEnumeration(address to, uint256 tokenId)` and `_ownerTokenByIndex(address owner, uint256 index)`  and ` _ownerIndexByToken(uint256 tokenId)`\r\n\r\n\r\n\r\n\r\n\r\n```solidity\r\n\r\n // Mapping from owner to list of owned token IDs (some values are available virtualy to access use _ownerTokenByIndex(_owner,_index) )\r\nmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list(some values are available virtualy to access use _ownerIndexByToken(_tokenId))\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n////-------starting tokenId for batch minters , populated by _mintConsecutive(address to, uint96 batchSize)\r\n    mapping(address => uint256) private _ownerStartTokenId;\r\n\r\n\r\n/**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            index < ERC721.balanceOf(owner),\r\n            \"ERC721Enumerable: owner index out of bounds\"\r\n        );\r\n        return _ownerTokenByIndex(owner, index); //see _ownerTokenByIndex(owner, index)\r\n    }\r\n\r\n/**\r\n     *\r\n     *\r\n     * @dev See {ERC721-_beforeTokenTransfer}, Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * hook modified for consecutive transfer while maintaning enumarability\r\n     */\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 batchSize\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\r\n\r\n        //enumeration operations does not triger during batch minting and instead will be handled virtualy.\r\n        if (batchSize > 1) {\r\n            require(\r\n                !Address.isContract(address(this)),\r\n                \"batch minting is restricted to constructor\"\r\n            );\r\n        } else {\r\n            if (from == address(0)) {\r\n                _addTokenToAllTokensEnumeration(tokenId);\r\n            } else if (from != to) {\r\n                _removeTokenFromOwnerEnumeration(from, tokenId);\r\n            }\r\n            if (to == address(0)) {\r\n                _removeTokenFromAllTokensEnumeration(tokenId);\r\n            } else if (to != from) {\r\n                _addTokenToOwnerEnumeration(to, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     * write values + 1 to avoid confussion to mapping default value of uint (uint(0))\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        // + 1 to remove the ambiguity of value with default value(uint 0) in mapping of  _ownedTokens and _ownedTokensIndex\r\n        _ownedTokens[to][length] = tokenId + 1;\r\n        _ownedTokensIndex[tokenId] = length + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     * write values + 1 to avoid confussion to mapping default value of uint (uint(0))\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\r\n        private\r\n    {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        // uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n        uint256 tokenIndex = _ownerIndexByToken(tokenId);\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            // uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n            uint256 lastTokenId = _ownerTokenByIndex(from, lastTokenIndex); //[from][lastTokenIndex];\r\n            // + 1 to remove the ambiguity of value with default value(uint 0) in mapping of  _ownedTokens and _ownedTokensIndex\r\n            _ownedTokens[from][tokenIndex] = lastTokenId + 1; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex + 1; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n//like tokenOfOwnerByIndex but does NOT revert\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function _ownerTokenByIndex(address owner, uint256 index)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 virtual_tokenId = _ownedTokens[owner][index];\r\n        //if there is noting is stored in the mapping, consider tokenId sequentialy from _ownerStartTokenId[owner]\r\n        if (virtual_tokenId == 0) {\r\n            return index + _ownerStartTokenId[owner]; //new\r\n        } else {\r\n            return virtual_tokenId - 1; //decrement one (-1) to get the value,overflow is impossible becuase the virtual_tokenId is not 0.\r\n        }\r\n    }\r\n\r\n    //finding the index of a token in tokens list that owned by the owner\r\n    function _ownerIndexByToken(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //if there is noting is stored in the mapping, consider index sequentialy from _ownerStartTokenId[_owner]\r\n        uint256 virtual_index = _ownedTokensIndex[tokenId];\r\n        if (virtual_index == 0) {\r\n            address _owner = _ownerOf(tokenId);\r\n            return tokenId - _ownerStartTokenId[_owner];\r\n        } else {\r\n            return virtual_index - 1; //decrement one (-1) to get the value,overflow is impossible becuase the virtual_Index is not 0.\r\n        }\r\n    }\r\n\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1412324830/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1412377051",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1412377051",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1412377051,
    "node_id": "IC_kwDOA9tCBs5ULynb",
    "user": {
      "login": "shypink",
      "id": 86266442,
      "node_id": "MDQ6VXNlcjg2MjY2NDQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shypink",
      "html_url": "https://github.com/shypink",
      "followers_url": "https://api.github.com/users/shypink/followers",
      "following_url": "https://api.github.com/users/shypink/following{/other_user}",
      "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
      "organizations_url": "https://api.github.com/users/shypink/orgs",
      "repos_url": "https://api.github.com/users/shypink/repos",
      "events_url": "https://api.github.com/users/shypink/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shypink/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-01T16:47:20Z",
    "updated_at": "2023-02-01T16:47:20Z",
    "author_association": "NONE",
    "body": "In this comment I'm going to explain how we can calculate the totalSupply of the token.\r\n\r\n`_totalConsecutiveSupply()` count how many tokens were batch minted, and this value won't change after batch minting is finished.\r\n`totalSupply()` is equal to number of tokens that were batch minted + number of tokens that exist beyond batch minted range - number of the tokens that we burned inside the batch minting range.\r\n\r\n*  `_totalConsecutiveSupply()`  : number of tokens that are batch minted\r\n* `_mintCounter` :  number of tokens that exist beyond batch minted range\r\n* `_burnCounter` : number of the tokens that we burned inside the batch minting range\r\n\r\n`_mintCounter` and `_burnCounter` are updated via {_afterTokenTransfer} hook.\r\n\r\nnote:\r\n{_afterTokenTransfer} won't trigger during batch minting. `require(batchSize > 1, \"for single Mint use _mint()\");` [see batch minting](https://github.com/shypink/ERC721ConsecutiveEnumerable/blob/59f0855fa35a50f08f4d316afc8fb0e1dec8cc9d/contracts/ERC721CE.sol#L375)\r\n\r\n```solidity\r\n // number of tokens minted beyond consecutiveSupply range\r\nuint256 private _mintCounter;\r\n    // number of token burned inside consecutiveSupply range\r\n    uint256 private _burnCounter;\r\n\r\n\r\n /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalConsecutiveSupply() + _mintCounter - _burnCounter;\r\n    }\r\n\r\n\r\nfunction _totalConsecutiveSupply() private view returns (uint96) {\r\n        (bool exists, uint96 latestId, ) = _sequentialOwnership\r\n            .latestCheckpoint();\r\n        return exists ? latestId + 1 : 0;\r\n    }\r\n\r\n/**\r\n     * @dev See {ERC721-_afterTokenTransfer}. Burning of tokens that have been sequentially minted must be explicit.\r\n     */\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 firstTokenId,\r\n        uint256 batchSize\r\n    ) internal virtual override {\r\n        if (to == address(0)) {\r\n            require(\r\n                batchSize == 1,\r\n                \"ERC721Consecutive: batch burn not supported\"\r\n            );\r\n            if (firstTokenId < _totalConsecutiveSupply()) {\r\n                _sequentialBurn.set(firstTokenId);\r\n                _burnCounter += 1;\r\n            } else {\r\n                _mintCounter -= 1;\r\n            }\r\n        }\r\n\r\n        if (from == address(0) && batchSize == 1) {\r\n            if (firstTokenId < _totalConsecutiveSupply()) {\r\n                _burnCounter -= 1;\r\n                _sequentialBurn.unset(firstTokenId);\r\n            } else {\r\n                _mintCounter += 1;\r\n            }\r\n        }\r\n\r\n        super._afterTokenTransfer(from, to, firstTokenId, batchSize);\r\n    }\r\n\r\n\r\n \r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1412377051/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1416889398",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1416889398",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1416889398,
    "node_id": "IC_kwDOA9tCBs5UdAQ2",
    "user": {
      "login": "TrejGun",
      "id": 185285,
      "node_id": "MDQ6VXNlcjE4NTI4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/185285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TrejGun",
      "html_url": "https://github.com/TrejGun",
      "followers_url": "https://api.github.com/users/TrejGun/followers",
      "following_url": "https://api.github.com/users/TrejGun/following{/other_user}",
      "gists_url": "https://api.github.com/users/TrejGun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TrejGun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TrejGun/subscriptions",
      "organizations_url": "https://api.github.com/users/TrejGun/orgs",
      "repos_url": "https://api.github.com/users/TrejGun/repos",
      "events_url": "https://api.github.com/users/TrejGun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TrejGun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-05T00:54:20Z",
    "updated_at": "2023-02-05T00:54:20Z",
    "author_association": "NONE",
    "body": "Hi @shypink \r\nI'm really interested in your solution because I was working with old contact and [found](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3740) out that it is impossible to expose _consecutiveMint function to mint the next batch.\r\n\r\nMy case is to mint the first batch of 10k NFTs and then mint 10k more.\r\nWith the not-enumerable contracts after minting the first batch and before minting the next batch, a token with id 15000 might be already taken, so this is impossible (or gas-heavy) to keep track of the sequence\r\nBut with the enumerable, this is not the case, so I can do at least 2 mints\r\nBtw I don't understand why it uses the uint96 restriction, In the same way, it can use unit128 or uint256, it does not change the storage layout.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1416889398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1417870816",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1417870816",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1417870816,
    "node_id": "IC_kwDOA9tCBs5Ugv3g",
    "user": {
      "login": "shypink",
      "id": 86266442,
      "node_id": "MDQ6VXNlcjg2MjY2NDQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shypink",
      "html_url": "https://github.com/shypink",
      "followers_url": "https://api.github.com/users/shypink/followers",
      "following_url": "https://api.github.com/users/shypink/following{/other_user}",
      "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
      "organizations_url": "https://api.github.com/users/shypink/orgs",
      "repos_url": "https://api.github.com/users/shypink/repos",
      "events_url": "https://api.github.com/users/shypink/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shypink/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-05T13:39:44Z",
    "updated_at": "2023-02-05T13:39:44Z",
    "author_association": "NONE",
    "body": "Hi @TrejGun ,\r\nthank you for reading,\r\n1. If you want to batch mint outside of contract constructor you should be aware that if you made single mint between batch mints for example( in above scenario that you batch minted 10k in constructor, let say you minted tokenId `12345` and then you batch minted 10k item again tokens 10000 ~ 19999, we have problem. because there are 20000 token in existence in the contract 0 ~ 19999 but your balance would be 20001 and the contract counted token 12345 twice) so if you are not very  careful in the implementation of batch minting your contract won't be ERC721 compliant, this why OpenZeppelin [ERC721Consecutive batch mint](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3b591a48acaab78008ed39d60fbcf429a83155ca/contracts/token/ERC721/extensions/ERC721Consecutive.sol#L89) require to be called in constructor, and [disable single mint](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3b591a48acaab78008ed39d60fbcf429a83155ca/contracts/token/ERC721/extensions/ERC721Consecutive.sol#L114) in the constructor. this also true in the case of ERC721A developed by chirulab, but if you are careful in your implementation you can work around it. for instance you can disable single mint and force the contract to perform minting in sequential order.\r\n2. for enumerability of you have to be careful if you want to enable one owner to batch mint twice, in my implementation of ERC721ConsecutiveEnumerable I forced the mint function to check for `require(balanceOf(owner) == 0)` to guarantee each user only mint one batch so all of the tokens are in sequential order, if you want to batch mint twice to same owner in different times you have to provide an structure to store start TokenId for each batch and owner.\r\n3. the uint96 restriction, it's because ERC721Consecutive.sol uses  [Checkpoints.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3b591a48acaab78008ed39d60fbcf429a83155ca/contracts/utils/Checkpoints.sol#L364) for storing batch minted data as list checkpont160\r\n```solidity\r\nstruct Checkpoint160 {\r\n        uint96 _key;\r\n        uint160 _value;\r\n    }\r\n```\r\nsince the Ethereum addresses are 20 bytes long they can be converted to `uint160` and since EVM store data in chunks of 32bytes the efficient data structure is to use 20bytes for address and 12bytes for key, in this case TokenId and  a 12 bytes uint is (12*8) `uint96` , if we use uint256 it need 2 word of storage, [Ethereum yellow paper](https://ethereum.org/en/developers/tutorials/yellow-paper-evm/#91-basics)",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1417870816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418023262",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1418023262",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1418023262,
    "node_id": "IC_kwDOA9tCBs5UhVFe",
    "user": {
      "login": "TrejGun",
      "id": 185285,
      "node_id": "MDQ6VXNlcjE4NTI4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/185285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TrejGun",
      "html_url": "https://github.com/TrejGun",
      "followers_url": "https://api.github.com/users/TrejGun/followers",
      "following_url": "https://api.github.com/users/TrejGun/following{/other_user}",
      "gists_url": "https://api.github.com/users/TrejGun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TrejGun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TrejGun/subscriptions",
      "organizations_url": "https://api.github.com/users/TrejGun/orgs",
      "repos_url": "https://api.github.com/users/TrejGun/repos",
      "events_url": "https://api.github.com/users/TrejGun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TrejGun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-05T15:11:50Z",
    "updated_at": "2023-02-05T15:38:45Z",
    "author_association": "NONE",
    "body": "@shypink thanks for the detailed explanation\r\n\r\n1. that is what I tried to say\r\n\r\nit also looks like I can't do consecutive mints twice in the constructor with the current implementation too\r\n```solidity\r\n  constructor() ERC721(\"X\",\"Y\") {\r\n    _mintConsecutive(_msgSender(), 5000);\r\n    _mintConsecutive(_msgSender(), 5000);\r\n  }\r\n```\r\nand this is impossible to prevent\r\n\r\n2. It looks like by providing a structure \r\n\r\n```solidity\r\n   struct MyStructure {\r\n        uint256 _startTokenId;\r\n        uint256 _batchSize;\r\n        address _owner;\r\n    }\r\n```\r\n\r\nI can get rid of the Checkpoint and the uint96 restriction too. but the downside would be algorithm complexity and the storage size\r\n\r\nAt this point looping through all tokens in the batch doesn't seem that bad to me\r\n\r\n```solidity\r\n    function function _mintConsecutive(address to, uint256 batchSize) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n\r\n       // there should be some check to ensure currentTokenId + batchSize < uint256\r\n       // maybe even check batchSize < 5000\r\n\r\n       uint256 tokenId = _tokenIdTracker.current();\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId, batchSize);\r\n\r\n        unchecked {\r\n            _balances[to] += batchSize;\r\n        }\r\n\r\n        for (uint256 i = 0; i < batchSize; i++) {\r\n           tokenId = _tokenIdTracker.current();\r\n           _owners[tokenId] = to;\r\n           _tokenIdTracker.increment();\r\n        }\r\n\r\n        emit ConsecutiveTransfer(tokenId, tokenId + batchSize, address(0), to);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId, batchSize);\r\n    }\r\n```\r\n\r\n3. thanks for pointing me out to Checkpoint implementation, maybe you can also explain to me why there is a cap of 5000 tokens per batch?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418023262/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418079551",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1418079551",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1418079551,
    "node_id": "IC_kwDOA9tCBs5Uhi0_",
    "user": {
      "login": "shypink",
      "id": 86266442,
      "node_id": "MDQ6VXNlcjg2MjY2NDQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shypink",
      "html_url": "https://github.com/shypink",
      "followers_url": "https://api.github.com/users/shypink/followers",
      "following_url": "https://api.github.com/users/shypink/following{/other_user}",
      "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
      "organizations_url": "https://api.github.com/users/shypink/orgs",
      "repos_url": "https://api.github.com/users/shypink/repos",
      "events_url": "https://api.github.com/users/shypink/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shypink/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-05T15:57:29Z",
    "updated_at": "2023-02-05T15:57:29Z",
    "author_association": "NONE",
    "body": "I'm glad that I could help,\r\n1. there is nothing that prevent you to use `{_mintConsecutive}` twice, maybe data type isn't right if you are using ERC721Consecutive.sol since `_mintConsecutive(address to, uint96 batchSize)` need batchSize `uint96` you can cast or safeCast `uint256` to `uint96` if you should.\r\n2. Checkpoint library provide a binary search that is more efficient. and remove the need to initialize the `_owner[tokenId]` storage for all of the token, sequentially. and you populate the storage when they transferred.\r\n3.  5000 batch size limitation is an artificial limitation posed by notable NFT marketplaces, and I think there should be better way like a daily limitation on token creation, but there is this limitation for now, maybe you could use my Implementation of [ERC721ConsecuitveEnumerable](https://github.com/shypink/ERC721ConsecutiveEnumerable/blob/master/contracts/ERC721CE.sol) and emit consecutiveTransfer event in batches of 5k at most. \r\n\r\n\r\n```solidity\r\n ////////-------------------------\r\n    /**\r\n     * @dev some minor changes to ERC721Consecutive\r\n     * @param receivers should be list of unique user(no duplicates)\r\n     * @param amounts amounts can be more than 5000 and emiting consecutiveTransfer() event will be handled in batches of 5000 at most. see _mintConsecutive()\r\n     * @param amounts can not be equal to 1, for single minting use _mint, this was forced to avoid trigering {_afterTokenTransfer} during batch minting.\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address[] memory receivers,\r\n        uint96[] memory amounts\r\n    ) ERC721(name_, symbol_) {\r\n        for (uint256 i = 0; i < receivers.length; ++i) {\r\n            uint96 a = _mintConsecutive(receivers[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n\r\n//see ERC721Consecutive.sol // omited for now and set to 5k\r\n    // function _maxBatchSize() internal view virtual returns (uint96) {\r\n    //     return 5000;\r\n    // }\r\n\r\n    // private\r\n    function _mintConsecutive(address to, uint96 batchSize)\r\n        private\r\n        returns (uint96)\r\n    {\r\n        uint96 first = _totalConsecutiveSupply();\r\n\r\n        // minting a batch of size 0 is a no-op//require batchSize > 1\r\n        if (batchSize > 0) {\r\n            require(\r\n                !Address.isContract(address(this)),\r\n                \"ERC721Consecutive: batch minting restricted to constructor\"\r\n            );\r\n            require(\r\n                to != address(0),\r\n                \"ERC721Consecutive: mint to the zero address\"\r\n            );\r\n            // require(\r\n            //     batchSize <= _maxBatchSize(),\r\n            //     \"ERC721Consecutive: batch too large\"\r\n            // );\r\n            // for not trigerimg {_afterTokenTransfer} during batch minting\r\n            require(batchSize > 1, \"for single Mint use _mint()\");\r\n            require(\r\n                ERC721.balanceOf(to) == 0,\r\n                \"each account can batch mint once\"\r\n            );\r\n\r\n            // hook before\r\n            _beforeTokenTransfer(address(0), to, first, batchSize);\r\n            /*\r\n             *new\r\n             */\r\n            _ownerStartTokenId[to] = first; //storing start token id of batch minting to batch minter address\r\n            // push an ownership checkpoint & emit event\r\n            uint96 last = first + batchSize - 1;\r\n            _sequentialOwnership.push(last, uint160(to));\r\n            //emit in bundle of 5k\r\n            while (first < last) {\r\n                if (last - first > 5000) {\r\n                    emit ConsecutiveTransfer(\r\n                        first,\r\n                        first + 4999,\r\n                        address(0),\r\n                        to\r\n                    );\r\n                    first = first + 5000;\r\n                } else {\r\n                    emit ConsecutiveTransfer(first, last, address(0), to);\r\n                    first = first + 5000;\r\n                }\r\n            }\r\n            // emit ConsecutiveTransfer(first, last, address(0), to);\r\n\r\n            // hook after\r\n            _afterTokenTransfer(address(0), to, first, batchSize);\r\n        }\r\n\r\n        return first;\r\n    }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418079551/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418156205",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1418156205",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1418156205,
    "node_id": "IC_kwDOA9tCBs5Uh1it",
    "user": {
      "login": "TrejGun",
      "id": 185285,
      "node_id": "MDQ6VXNlcjE4NTI4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/185285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TrejGun",
      "html_url": "https://github.com/TrejGun",
      "followers_url": "https://api.github.com/users/TrejGun/followers",
      "following_url": "https://api.github.com/users/TrejGun/following{/other_user}",
      "gists_url": "https://api.github.com/users/TrejGun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TrejGun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TrejGun/subscriptions",
      "organizations_url": "https://api.github.com/users/TrejGun/orgs",
      "repos_url": "https://api.github.com/users/TrejGun/repos",
      "events_url": "https://api.github.com/users/TrejGun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TrejGun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-05T16:59:43Z",
    "updated_at": "2023-02-05T16:59:43Z",
    "author_association": "NONE",
    "body": "1 It has the same problem as your implementation, however, you check `require(balanceOf(owner) == 0)` and the current implementation does not\r\n\r\n2 I will run both solutions and check gas usage with `hardhat-gas-reporter`, not sure how to check storage size tho",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1418156205/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1420168497",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1420168497",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1420168497,
    "node_id": "IC_kwDOA9tCBs5Upg0x",
    "user": {
      "login": "TrejGun",
      "id": 185285,
      "node_id": "MDQ6VXNlcjE4NTI4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/185285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TrejGun",
      "html_url": "https://github.com/TrejGun",
      "followers_url": "https://api.github.com/users/TrejGun/followers",
      "following_url": "https://api.github.com/users/TrejGun/following{/other_user}",
      "gists_url": "https://api.github.com/users/TrejGun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TrejGun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TrejGun/subscriptions",
      "organizations_url": "https://api.github.com/users/TrejGun/orgs",
      "repos_url": "https://api.github.com/users/TrejGun/repos",
      "events_url": "https://api.github.com/users/TrejGun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TrejGun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-07T04:05:21Z",
    "updated_at": "2023-02-07T04:05:21Z",
    "author_association": "NONE",
    "body": "that would not work anyway( the _owners and _balances are both private(",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1420168497/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1420730449",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3985#issuecomment-1420730449",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3985",
    "id": 1420730449,
    "node_id": "IC_kwDOA9tCBs5UrqBR",
    "user": {
      "login": "shypink",
      "id": 86266442,
      "node_id": "MDQ6VXNlcjg2MjY2NDQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/86266442?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shypink",
      "html_url": "https://github.com/shypink",
      "followers_url": "https://api.github.com/users/shypink/followers",
      "following_url": "https://api.github.com/users/shypink/following{/other_user}",
      "gists_url": "https://api.github.com/users/shypink/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shypink/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shypink/subscriptions",
      "organizations_url": "https://api.github.com/users/shypink/orgs",
      "repos_url": "https://api.github.com/users/shypink/repos",
      "events_url": "https://api.github.com/users/shypink/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shypink/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-02-07T12:58:34Z",
    "updated_at": "2023-02-07T12:58:34Z",
    "author_association": "NONE",
    "body": "for updating _balances you can use [{_beforeTokenTransfer}](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1575cc6908f0f38bfb36d459c4ce7295f0f89c49/contracts/token/ERC721/ERC721.sol#L437) hook in ERC721 OpenZepplen v4.8.0 and for _owners you can override the` _ownerOf(tokenId)` see [{ownerOf}](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1575cc6908f0f38bfb36d459c4ce7295f0f89c49/contracts/token/ERC721/ERC721.sol#L198) but you should be careful in your implementation. ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1420730449/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
