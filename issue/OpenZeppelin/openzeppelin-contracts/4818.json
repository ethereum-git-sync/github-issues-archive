{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818",
  "id": 2067349027,
  "node_id": "I_kwDOA9tCBs57OT4j",
  "number": 4818,
  "title": "Enhancing Security in MerkleProof.sol with safeVerify() Function for Double Hashing 64-Byte Leaves",
  "user": {
    "login": "Erengonen",
    "id": 49316630,
    "node_id": "MDQ6VXNlcjQ5MzE2NjMw",
    "avatar_url": "https://avatars.githubusercontent.com/u/49316630?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Erengonen",
    "html_url": "https://github.com/Erengonen",
    "followers_url": "https://api.github.com/users/Erengonen/followers",
    "following_url": "https://api.github.com/users/Erengonen/following{/other_user}",
    "gists_url": "https://api.github.com/users/Erengonen/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Erengonen/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Erengonen/subscriptions",
    "organizations_url": "https://api.github.com/users/Erengonen/orgs",
    "repos_url": "https://api.github.com/users/Erengonen/repos",
    "events_url": "https://api.github.com/users/Erengonen/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Erengonen/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2024-01-05T13:25:40Z",
  "updated_at": "2024-01-20T08:01:19Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**üßê Motivation**\r\nThe current implementation of MerkleProof.sol in the OpenZeppelin library exhibits a vulnerability when handling leaf data that is exactly 64 bytes in size. This issue, detailed in [Issue #278](https://github.com/sherlock-audit/2023-04-footium-judging/issues/278) from the sherlock-audit repository, enables an attacker to bypass the merkle-tree proof, leading to significant security risks. Additionally, this vulnerability is acknowledged with a warning in the [MerkleProof.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol) contract(https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091). To address this, I propose introducing a `safeVerify()` function in the MerkleProof contract, which implements double hashing of leaves regardless of their size.\r\n\r\n**üìù Details**\r\nThis enhancement involves extending the existing [MerkleProof.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)  contract by adding a `safeVerify()` function. This function will apply double hashing to the provided leaf, irrespective of its size, thereby ensuring enhanced security and mitigating the identified vulnerability.\r\n\r\nThe proposed `safeVerify()` function could be implemented as follows:\r\n\r\n```\r\n    function safeVerify(bytes32[] memory proof, bytes32 leaf) internal pure returns (bool) {\r\n        return MerkleProof.verify(proof, root, keccak256(leaf));\r\n    }\r\n```\r\n\r\nI welcome feedback and further suggestions from the OpenZeppelin community on this proposal.\r\n\r\n\r\n<!-- Make sure that you have reviewed the OpenZeppelin Contracts Contributor Guidelines. -->\r\n<!-- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CONTRIBUTING.md -->\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1878807934",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1878807934",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1878807934,
    "node_id": "IC_kwDOA9tCBs5v_FV-",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-05T14:57:39Z",
    "updated_at": "2024-01-05T14:57:39Z",
    "author_association": "COLLABORATOR",
    "body": "Hello @Erengonen \r\n\r\nThe `MerkleProof.sol` library is designed to support as many merkle trees as possible. In fact, the only requirement is that internal hashes are produced using the keccak256 hash of the sorted child values.\r\n\r\nIt is indeed true that this includes support for trees that are poorly designed. If the leaves are unhashed 32bytes values, than internal nodes can be proven even though they are no leaves. Similarly, if the leaves are produced by hashing 64 bytes, then you may prove non existing leaves that match some internal nodes.\r\n\r\nWe believe this is out of scope of the solidity library that verifies the trees, and it should be addressed by the tooling that build the trees. That is why we maintain [@openzeppelin/merkle-tree](https://github.com/OpenZeppelin/merkle-tree). This library will encourage you to double hash your leaves in a way that is safe from the issues you describe.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1878807934/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1879131553",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1879131553",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1879131553,
    "node_id": "IC_kwDOA9tCBs5wAUWh",
    "user": {
      "login": "SteMak",
      "id": 26607726,
      "node_id": "MDQ6VXNlcjI2NjA3NzI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/26607726?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SteMak",
      "html_url": "https://github.com/SteMak",
      "followers_url": "https://api.github.com/users/SteMak/followers",
      "following_url": "https://api.github.com/users/SteMak/following{/other_user}",
      "gists_url": "https://api.github.com/users/SteMak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SteMak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SteMak/subscriptions",
      "organizations_url": "https://api.github.com/users/SteMak/orgs",
      "repos_url": "https://api.github.com/users/SteMak/repos",
      "events_url": "https://api.github.com/users/SteMak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SteMak/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-05T19:01:17Z",
    "updated_at": "2024-01-05T19:01:17Z",
    "author_association": "NONE",
    "body": "I support the idea.\r\n\r\nLeafs double hashing is considered to be a best practice when generating any Merkle Trees and is implemented by default in [@openzeppelin/merkle-tree](https://github.com/OpenZeppelin/merkle-tree) generator.\r\n\r\n@Amxx I don't think that introducing safe way to validate if a leaf is included in the tree without a backward compatibility break will harm the library. The function can be named `verifyLeaf` and be referenced as a preferable way to validate Merkle Trees generated by the mentioned library.\r\n\r\nHaving `keccak256(bytes.concat(keccak256(abi.encodePacked(params...))))` in smart contract looks a bit confusing.\r\n\r\nAdding that function will make the notation a bit more clear and will prevent both the \"unhashed 32 bytes length leafs\" and \"hashed 64 bytes length leafs\" issues.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1879131553/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1879141765",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1879141765",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1879141765,
    "node_id": "IC_kwDOA9tCBs5wAW2F",
    "user": {
      "login": "SteMak",
      "id": 26607726,
      "node_id": "MDQ6VXNlcjI2NjA3NzI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/26607726?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SteMak",
      "html_url": "https://github.com/SteMak",
      "followers_url": "https://api.github.com/users/SteMak/followers",
      "following_url": "https://api.github.com/users/SteMak/following{/other_user}",
      "gists_url": "https://api.github.com/users/SteMak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SteMak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SteMak/subscriptions",
      "organizations_url": "https://api.github.com/users/SteMak/orgs",
      "repos_url": "https://api.github.com/users/SteMak/repos",
      "events_url": "https://api.github.com/users/SteMak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SteMak/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-05T19:11:03Z",
    "updated_at": "2024-01-05T19:11:03Z",
    "author_association": "NONE",
    "body": "The only argument against I see is that for consistency reasons it is reasonable to apply the pattern for `multiProofVerify` function as well and it may be a bit more resource consuming.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1879141765/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1895688671",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1895688671",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1895688671,
    "node_id": "IC_kwDOA9tCBs5w_enf",
    "user": {
      "login": "Erengonen",
      "id": 49316630,
      "node_id": "MDQ6VXNlcjQ5MzE2NjMw",
      "avatar_url": "https://avatars.githubusercontent.com/u/49316630?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Erengonen",
      "html_url": "https://github.com/Erengonen",
      "followers_url": "https://api.github.com/users/Erengonen/followers",
      "following_url": "https://api.github.com/users/Erengonen/following{/other_user}",
      "gists_url": "https://api.github.com/users/Erengonen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Erengonen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Erengonen/subscriptions",
      "organizations_url": "https://api.github.com/users/Erengonen/orgs",
      "repos_url": "https://api.github.com/users/Erengonen/repos",
      "events_url": "https://api.github.com/users/Erengonen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Erengonen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-17T12:15:17Z",
    "updated_at": "2024-01-17T12:15:17Z",
    "author_association": "NONE",
    "body": "Hi @Amxx, applying additional hashing will solve both problems.\r\n\r\n**Problem 1: ‚ÄúIf the leaves are unhashed 32bytes values, than internal nodes can be proven even though they are no leaves.‚Äù**\r\n\r\n**Let‚Äôs examine this Merkle tree structure:**\r\n\r\n\t              Root\r\n\t             /    \\\r\n\t            /      \\\r\n\t           /        \\\r\n\t    [Hash_AB]      [Hash_CD]\r\n\t     /    \\          /    \\\r\n\t    /      \\        /      \\\r\n    LeafA    LeafB  LeafC     LeafD\r\n\t  |         |     |          |\r\n\t   \\        |     |         /\r\n\t    \\ --->(Not hashed) <---/\r\n\r\nTypically, in a Merkle tree, all leaves are hashed. However, in this example, the leaves are intentionally not hashed, illustrating a specific issue; they represent 32 bytes of actual data  `[Hash_AB]`, and  `[Hash_CD]`  are the hashes of (32 bytes of actual data + 32 bytes of actual data).Imagine a  `claim()`  function that implements the  `MerkleProof.verify()`  function, which does not hash the leaf parameter. For example:\r\n\r\n    claim(bytes32[] proof, bytes32 leaf){\r\n    ‚Ä¶  \r\n       return MerkleProof.verify(proof, root, leaf);\r\n    ‚Ä¶  \r\n    }\r\n\r\nIn this scenario, it‚Äôs possible to pass unhashed leaves since the OpenZeppelin MerkleProof library does not apply hashing internally. However, if  `LeafA`  is 32 bytes of unhashed data, leaf could be misidentified as an intermediate node, leading to incorrect verification. For instance, in this Merkle tree,  `[Hash_AB]`  could be erroneously identified as a leaf (which is not accurate, as  `[Hash_AB]`  is an intermediate node), and  `[Hash_CD]`, `LeafA`  can be used as proof. \r\n\r\nTo verify  `LeafA`  is in the Merkle tree the following proof can be applied to  `MerkleProof.verify()`  function as a  `proof`  parameter:\r\n\r\n\r\n    [LeafA, Hash_CD]\r\n\r\n\r\nTo verify that LeafA is included in the Merkle tree, the following leaf can be validly applied to  `MerkleProof.verify()`function as a  `leaf`  parameter:\r\n\r\n\r\n    [Hash_AB]\r\n\r\n\r\n`[Hash_AB]`  is not a leaf! It is an intermediate node. This misrepresentation allows for incorrect proof verification using an intermediate node rather than the actual leaves (LeafA, LeafB, LeafC, LeafD). Implementing a  `safeVerify()`  function that applies additional hashing to the leaves can fix this issue. If leaves are presented as an unhashed 32-byte value, the function will hash the  `leaf`  parameter internally, preventing the misinterpretation of internal nodes as leaves.\r\n\r\n**Problem 2: ‚Äúif the leaves are produced by hashing 64 bytes, then you may prove non existing leaves that match some internal nodes‚Äù**\r\n\r\n\t              Root\r\n\t             /    \\\r\n\t            /      \\\r\n\t           /        \\\r\n\t    [Hash_AB]      [Hash_CD]\r\n\t     /    \\          /    \\\r\n\t    /      \\        /      \\\r\n\t LeafA    LeafB  LeafC     LeafD\r\n\r\nIn this example, all leaves are hashed. Each leaf is formed by concatenating two integer values. For instance, LeafA is derived as follows:  \r\n\r\n\r\n    keccak256(abi.encodePacked(1, 2))\r\n\r\n\r\nAssume the Merkle Tree is defined by:\r\n\r\n\r\n    const pairs = [\r\n      [1, 2],\r\n      [3, 4],\r\n      [5, 6],\r\n      [7, 8]\r\n    ];\r\n\r\nHere, LeafA equates to [1,2], and similarly, LeafB, LeafC, and LeafD correspond to elements in the  `pairs`  list.\r\n\r\nEnvision a  `claim()`  function that incorporates the  `MerkleProof.verify()`  function. This function creates a leaf by hashing the provided ‚Äòone‚Äô and ‚Äòtwo‚Äô parameters, exemplified as follows: \r\n\r\n    claim(bytes32[] proof, uint256 one, uint256 two){  \r\n    ‚Ä¶\r\n\t   return MerkleProof.verify(proof, root, keccak256(abi.encodePacked(one, two));  \r\n    ‚Ä¶  \r\n    }\r\n\r\nIn scenarios where  `keccak256(abi.encodePacked(one, two))`  is 64 bytes long(uint256 + uint256 = 32 bytes + 32 bytes = 64 bytes) Consequently, an intermediate node may be used to circumvent the verification process. Suppose we wish to confirm that  `LeafA`  is in the Merkle tree using the claim function. \r\n\r\nTo validate LeafA‚Äôs presence in the Merkle tree, the following  `proof`  parameter can be utilized in the claim function:\r\n\r\n\r\n    [LeafB, Hash_CD]\r\n\r\n\r\nTo verify the proof, we need to provide a  `leaf`  parameter, which will be constructed by hashing the provided  `one`  and  `two`  parameters. In this case, for the same verification, the following  `one`  and  `two`  parameters can be employed:  \r\n\r\n    uint256 one = LeafB\r\n    uint256 two = LeafA\r\n\r\nIn order to create a  `leaf`  parameter, these parameters will be hashed inside the  `claim()`  function using  `keccak256`. However, hashing these values results in the creation of an intermediate node:  \r\n\r\n    [Hash_AB] = keccak256(abi.encodePacked(one, two)\r\n\r\nIn this instance,  `[Hash_AB]`  is mistakenly provided as a leaf parameter to the  `MerkleProof.verify()`.  `[Hash_AB]`  is not a leaf but an intermediate node with a hash value of 64 bytes:  \r\n\r\n    (uint256 + uint256 = 32 bytes + 32 bytes = 64 bytes)\r\n\r\nAs it matches the 64-byte criterion and represents an intermediate node, the verify function can erroneously be executed with the supplied intermediate node instead of the actual leaf. To counteract this, implementing a  `safeVerify()`  function is advisable. This function incorporates an additional hashing step, ensuring that internal nodes cannot be misinterpreted as leaves. Even if the intermediate node  `[Hash_AB]`  is sent to the function as a leaf parameter, the function‚Äôs additional hashing will ensure that  `[Hash_AB]`, when hashed inside the  `safeVerify()`  function, does not correspond to any intermediate node.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1895688671/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1901787884",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1901787884",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1901787884,
    "node_id": "IC_kwDOA9tCBs5xWvrs",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-20T06:41:05Z",
    "updated_at": "2024-01-20T06:41:05Z",
    "author_association": "MEMBER",
    "body": "> Hi @Amxx, applying additional hashing will solve both problems.\r\n\r\nWe never said it's not solving the problem, and we do agree it's a problem. However, we think it's reasonable to evaluate the severity and likelihood of the issue. Note not every contract without double hashing the leaves is vulnerable. In some cases, the design of the contract makes it impossible to get a valid intermediate preimage. Consider a function like this:\r\n\r\n```solidity\r\n function claim(address account, uint256 amount, bytes32[] memory proof) external {\r\n      ...\r\n      bytes32 leaf = keccak256(abi.encodePacked(account, amount));\r\n      ...\r\n  }\r\n```\r\n\r\nI'd say this is a common construction for airdrops, and note that since the leaf is constructed by concatenating `account` and `amount`, each leaf's preimage is 52 bytes long (20 + 32), so you would need an intermediate value in the tree with 10 trailing zeroes to make it work (in case keccak256 pads the input which I don't think so). Even if you were able to verify an intermediate value, you would only do it with a random `account`, restricting your ability to pick an arbitrary receiver.\r\n\r\nWhile `safeVerify` is indeed the safest option for verifying trees, there are trees out there working fine with single hashed leaves and they aren't bugged, so they should still get support with the regular `verify` function. Also, we've never liked providing multiple options for the same thing, so keeping both `safeVerify` and `verify` wouldn't be our preferred option.\r\n\r\n> That is why we maintain [@openzeppelin/merkle-tree](https://github.com/OpenZeppelin/merkle-tree). This library will encourage you to double hash your leaves in a way that is safe from the issues you describe.\r\n\r\nI support this stand. Developers need a utility to produce Merkle Trees, and it's best for them if the asymmetry is built-in the tree itself, not the verifying library.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1901787884/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1901901271",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4818#issuecomment-1901901271",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4818",
    "id": 1901901271,
    "node_id": "IC_kwDOA9tCBs5xXLXX",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-20T07:59:34Z",
    "updated_at": "2024-01-20T08:01:19Z",
    "author_association": "COLLABORATOR",
    "body": "By feeling is also that it is very easy for a user to write \r\n```solidity\r\nMerkleProof.verify(proof, root, keccak256(leaf))\r\n```\r\ninstead of \r\n```solidity\r\nMerkleProof.verify(proof, root, leaf)\r\n```\r\nif that is how its tree is constructed.\r\n\r\nThe added value of having both functions at the same time is unclear to me, while it feels like an unecessary risk of confusion for users. \r\n\r\nI stand by my opinion that the important part is making sure the tree are constructed in a safe way. Once that is the case, I feel the current solidity tools are sufficient to verify any tree (including but not limited to the safe ones).",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1901901271/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
