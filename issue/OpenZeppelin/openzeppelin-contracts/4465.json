{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465",
  "id": 1810005369,
  "node_id": "I_kwDOA9tCBs5r4n15",
  "number": 4465,
  "title": "AccessControl extensions don't have instructions for overriding functions defined more than once",
  "user": {
    "login": "SvenMeyer",
    "id": 25609,
    "node_id": "MDQ6VXNlcjI1NjA5",
    "avatar_url": "https://avatars.githubusercontent.com/u/25609?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/SvenMeyer",
    "html_url": "https://github.com/SvenMeyer",
    "followers_url": "https://api.github.com/users/SvenMeyer/followers",
    "following_url": "https://api.github.com/users/SvenMeyer/following{/other_user}",
    "gists_url": "https://api.github.com/users/SvenMeyer/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/SvenMeyer/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/SvenMeyer/subscriptions",
    "organizations_url": "https://api.github.com/users/SvenMeyer/orgs",
    "repos_url": "https://api.github.com/users/SvenMeyer/repos",
    "events_url": "https://api.github.com/users/SvenMeyer/events{/privacy}",
    "received_events_url": "https://api.github.com/users/SvenMeyer/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2023-07-18T14:02:35Z",
  "updated_at": "2023-07-23T08:09:19Z",
  "closed_at": "2023-07-20T19:23:23Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Using `AccessControlDefaultAdminRules` or `AccessControlEnumerable` on its own looks straight forward.\r\nHowever if I derive from both, I get quite some error messages.\r\n\r\n`contract SecureContract is AccessControlDefaultAdminRules, AccessControlEnumerable, Pausable, ReentrancyGuard { ... }\r\n\r\n```\r\nDerived contract must override function \"_grantRole\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"_revokeRole\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"_setRoleAdmin\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"grantRole\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"renounceRole\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"revokeRole\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\nDerived contract must override function \"supportsInterface\". Two or more base classes define function with same name and parameter types.solidity(6480)\r\n```\r\n\r\nEven if it is intented, I would be helpful the have example code in the documentation, however ideally just deriving from both should work and implement some reasonable default behaviour (if possible)",
  "closed_by": {
    "login": "ernestognw",
    "id": 33379285,
    "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ernestognw",
    "html_url": "https://github.com/ernestognw",
    "followers_url": "https://api.github.com/users/ernestognw/followers",
    "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
    "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
    "organizations_url": "https://api.github.com/users/ernestognw/orgs",
    "repos_url": "https://api.github.com/users/ernestognw/repos",
    "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ernestognw/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1640709574",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465#issuecomment-1640709574",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
    "id": 1640709574,
    "node_id": "IC_kwDOA9tCBs5hyz3G",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-18T18:07:50Z",
    "updated_at": "2023-07-18T18:07:50Z",
    "author_association": "MEMBER",
    "body": "This is a good point and I agree it undermines the developer experience. However, I think the proposal has some nuances because neither Solidity nor us can define a default behavior for this because in order to disambiguate, one must assess the linearization order first.\r\n\r\nhttps://docs.soliditylang.org/en/v0.8.20/contracts.html#multiple-inheritance-and-linearization\r\n\r\nBasically, the order of execution of the clashing functions is determined by the order in which you put the inherited contracts, (i.e is not the same `is A, B` to `is B, A`).\r\n\r\nIn this particular case, I think the linearization order doesn't seem to cause issues so the only thing you should do is adding an `override (AccessControlDefaultAdminRules, AccessControlEnumerable)` to the clashing functions.\r\n\r\nCurious to know, how would you think it'd be best to orient users in this regard?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1640709574/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1641787450",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465#issuecomment-1641787450",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
    "id": 1641787450,
    "node_id": "IC_kwDOA9tCBs5h27A6",
    "user": {
      "login": "SvenMeyer",
      "id": 25609,
      "node_id": "MDQ6VXNlcjI1NjA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/25609?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SvenMeyer",
      "html_url": "https://github.com/SvenMeyer",
      "followers_url": "https://api.github.com/users/SvenMeyer/followers",
      "following_url": "https://api.github.com/users/SvenMeyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/SvenMeyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SvenMeyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SvenMeyer/subscriptions",
      "organizations_url": "https://api.github.com/users/SvenMeyer/orgs",
      "repos_url": "https://api.github.com/users/SvenMeyer/repos",
      "events_url": "https://api.github.com/users/SvenMeyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SvenMeyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-19T09:57:24Z",
    "updated_at": "2023-07-20T19:04:31Z",
    "author_association": "NONE",
    "body": "Disclaimer : I am not (yet) an expert in multiple inheritance ... \r\n\r\n**1) First idea just for this specific issue.**\r\nIs there anything wrong with making `AccessControl` behave like (replace it with) `AccessControlEnumerable` by default ?\r\n- There is a additional cost, but how often do roles really change ?\r\n- Yes, it would be easier for everybody (not only the admin) to get an overview who has what rule, could that be a security risk? However, any decent attacker would be able to grab that information from a public chain anyway.\r\n\r\n**2)** I understand that functions from child contracts overwrite each other, which is why order is important. However, in this case, function should be merged, like one function called first from `AccessControlDefaultAdminRules` (check rights) and then the function from `AccessControlEnumerable` (add to enumerable list).\r\n\r\nI thought that I could make it work by creating a linear inheritance, leveraging the `super...` code lines,  that i.e. TestERC20.grantrole calls TestERC20_ACDAR `super.grantRole` which does the checks and then execute its code to add a new entry to the list ... \r\nThat looks like the easiest solution to me ... however, I get the same errors as before :-(\r\n\r\n<details>\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// OZ contracts v4.9.2\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\n\r\ncontract TestERC20_ACDAR is ERC20, AccessControlDefaultAdminRules {\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n\r\n    constructor() ERC20(\"TestERC20\", \"TestERC20\") AccessControlDefaultAdminRules (10 days, msg.sender) {\r\n        // _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(MINTER_ROLE, msg.sender);\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\r\n        _mint(to, amount);\r\n    }\r\n}\r\n\r\ncontract TestERC20 is TestERC20_ACDAR, AccessControlEnumerable {\r\n    // nothing to see here\r\n}\r\n```\r\n</details>\r\n\r\n**3)** I think this is what you suggested? At least it compiles without error, but I had to make quite some changes, added code that I would not trust it. Honestly, I would not want to mess around with an OZ code on access control which has been carefully drafted and audited :grimacing: ... misses the whole point of developing a secure contract by using solid code as a base.\r\n\r\nMaybe a OZ provide contract \"AccessControlEnumerable + AccessControlDefaultAdminRules\", but if going that route so many combinations may be needed that it becomes hard to maintain.\r\n\r\n<details>\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// OZ contracts v4.9.2\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\n\r\ncontract TestERC20 is ERC20, AccessControlEnumerable, AccessControlDefaultAdminRules {\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n\r\n    constructor() ERC20(\"TestERC20\", \"TestERC20\") AccessControlDefaultAdminRules(10 days, msg.sender) {\r\n        // _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(MINTER_ROLE, msg.sender);\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view override(AccessControlEnumerable, AccessControlDefaultAdminRules) returns (bool) {\r\n        return\r\n            interfaceId == type(IAccessControlEnumerable).interfaceId ||\r\n            interfaceId == type(IAccessControlDefaultAdminRules).interfaceId ||\r\n            super.supportsInterface(interfaceId); // Do I need this ???\r\n    }\r\n\r\n    function _grantRole(\r\n        bytes32 role,\r\n        address account\r\n    ) internal override(AccessControlEnumerable, AccessControlDefaultAdminRules) {\r\n        AccessControlDefaultAdminRules._grantRole(role, account);\r\n        AccessControlEnumerable._grantRole(role, account);\r\n    }\r\n\r\n    function _revokeRole(\r\n        bytes32 role,\r\n        address account\r\n    ) internal override(AccessControlEnumerable, AccessControlDefaultAdminRules) {\r\n        AccessControlDefaultAdminRules._revokeRole(role, account);\r\n        AccessControlEnumerable._revokeRole(role, account);\r\n    }\r\n\r\n    function _setRoleAdmin(\r\n        bytes32 role,\r\n        bytes32 adminRole\r\n    ) internal override(AccessControl, AccessControlDefaultAdminRules) {\r\n        AccessControlDefaultAdminRules._setRoleAdmin(role, adminRole);\r\n        AccessControl._setRoleAdmin(role, adminRole);\r\n    }\r\n\r\n    function grantRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public override(AccessControlDefaultAdminRules, AccessControl, IAccessControl) {\r\n        AccessControlDefaultAdminRules.grantRole(role, account);\r\n    }\r\n\r\n    function renounceRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public override(AccessControlDefaultAdminRules, AccessControl, IAccessControl) {\r\n        AccessControlDefaultAdminRules.renounceRole(role, account);\r\n    }\r\n\r\n    function revokeRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public override(AccessControlDefaultAdminRules, AccessControl, IAccessControl) {\r\n        AccessControlDefaultAdminRules.revokeRole(role, account);\r\n    }\r\n}\r\n\r\n```\r\n</details>\r\n\r\nI do not even want to think about adding `AccessControlCrossChain` also to the mix ... :grimacing: ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1641787450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1642080075",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465#issuecomment-1642080075",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
    "id": 1642080075,
    "node_id": "IC_kwDOA9tCBs5h4CdL",
    "user": {
      "login": "SvenMeyer",
      "id": 25609,
      "node_id": "MDQ6VXNlcjI1NjA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/25609?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SvenMeyer",
      "html_url": "https://github.com/SvenMeyer",
      "followers_url": "https://api.github.com/users/SvenMeyer/followers",
      "following_url": "https://api.github.com/users/SvenMeyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/SvenMeyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SvenMeyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SvenMeyer/subscriptions",
      "organizations_url": "https://api.github.com/users/SvenMeyer/orgs",
      "repos_url": "https://api.github.com/users/SvenMeyer/repos",
      "events_url": "https://api.github.com/users/SvenMeyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SvenMeyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-19T13:25:32Z",
    "updated_at": "2023-07-20T19:11:19Z",
    "author_association": "NONE",
    "body": "**4)** Finally, I could copy-paste the whole code of `AccessControlEnumerable`. It works, but of course adds problems in terms of code bloat, ungradeability to new OZ contract versions, and renders the whole idea of multiple inheritance (largely) useless .. but I would trust it more than solution 3) as I did not have to change/invent any code.\r\n\r\n<details>\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// OZ contracts v4.9.2\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\";\r\nimport \"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\n\r\ncontract TestERC20 is ERC20, AccessControlDefaultAdminRules {\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n\r\n    constructor() ERC20(\"TestERC20\", \"TestERC20\") AccessControlDefaultAdminRules (10 days, msg.sender) {\r\n        // _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(MINTER_ROLE, msg.sender);\r\n    }\r\n\r\n    // import \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\"; - copy-paste whole code\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns one of the accounts that have `role`. `index` must be a\r\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n     *\r\n     * Role bearers are not sorted in any particular way, and their ordering may\r\n     * change at any point.\r\n     *\r\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n     * you perform all queries on the same block. See the following\r\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n     * for more information.\r\n     */\r\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\r\n        return _roleMembers[role].at(index);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of accounts that have `role`. Can be used\r\n     * together with {getRoleMember} to enumerate all bearers of a role.\r\n     */\r\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\r\n        return _roleMembers[role].length();\r\n    }\r\n\r\n    /**\r\n     * @dev Overload {_grantRole} to track enumerable memberships\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual override {\r\n        super._grantRole(role, account);\r\n        _roleMembers[role].add(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload {_revokeRole} to track enumerable memberships\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual override {\r\n        super._revokeRole(role, account);\r\n        _roleMembers[role].remove(account);\r\n    }\r\n\r\n}\r\n\r\n```\r\n</details>\r\n\r\nI am actually surprised that 2) does not work ... or is just my syntax wrong ?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1642080075/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1644472848",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465#issuecomment-1644472848",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
    "id": 1644472848,
    "node_id": "IC_kwDOA9tCBs5iBKoQ",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-20T19:23:23Z",
    "updated_at": "2023-07-20T19:27:56Z",
    "author_association": "MEMBER",
    "body": "Hey @SvenMeyer, I edited your replies and added `10 days` to the `AccessControlDefaultAdminRules` examples because I think it'd be dangerous if anyone comes here and picks the initial example with `0 days`.\r\n\r\nThat said, I'm answering your questions:\r\n\r\n> <details>\r\n> <summary>1) First idea just for this specific issue.</summary>\r\n> \r\n> Is there anything wrong with making AccessControl behave like (replace it with) AccessControlEnumerable by default ?\r\n> \r\n> - There is a additional cost, but how often do roles really change ?\r\n> - Yes, it would be easier for everybody (not only the admin) to get an overview who has what rule, could that be a security risk? However, any decent attacker would be able to grab that information from a public chain anyway.\r\n> </details>\r\n\r\nWe think enumerability should usually be solved by offchain indexers and not something to be tracked onchain because of the code size and runtime costs. You can see more information about why we made this change [here](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2511).\r\n\r\nAlso, yes, the access control information is always public and not supposed to be hidden. The security model doesn't rely on the privileged addresses to be unknown.\r\n\r\n> <details>\r\n> <summary>2) I understand that functions from child contracts overwrite each other ... </summary>\r\n> which is why order is important. However, in this case, function should be merged, like one function called first from AccessControlDefaultAdminRules (check rights) and then the function from AccessControlEnumerable (add to enumerable list).\r\n> </details>\r\n\r\nYou're sort of right. What changes the inheritance order is the order in which a contract `is A, B, C`. It doesn't matter if the clashing function uses `override(A, B, C)` or `override(B, C, A)`, you just need to add the `override` modifier.\r\n\r\nIn the example you're sharing, the inheritance graph for `TestERC20` is the same as if you were doing:\r\n\r\n```solidity\r\ncontract TestERC20 is ERC20, AccessControlDefaultAdminRules, AccessControlEnumerable { ... }\r\n```\r\n\r\nTherefore, you still need to use the `override`.\r\n\r\n> <details>\r\n> <summary>3) I think this is what you suggested? </summary>\r\n> At least it compiles without error, but I had to make quite some changes, added code that I would not trust it. Honestly, I would not want to mess around with an OZ code on access control which has been carefully drafted and audited 😬 ... misses the whole point of developing a secure contract by using solid code as a base.\r\n> </details>\r\n\r\nYes, it looks similar to what I suggested. I'd say there's no problem with making these overrides because this is only added behavior and it's not changing the code from OpenZeppelin Contracts\r\n\r\n> super.supportsInterface(interfaceId); // Do I need this ???\r\n\r\nYes, otherwise you'll lose the already supported interfaces from the inherited contracts. Particularly ERC165 in this case. Also both `ERC721Enumerable` and `AccessControlDefaultAdminRules` are already supported by using `super` afaik (may require testing though).\r\n\r\n> Maybe a OZ provide contract \"AccessControlEnumerable + AccessControlDefaultAdminRules\", but if going that route so many combinations may be needed that it becomes hard to maintain.\r\n\r\nWe're not fans of multiple versions of the same contract, also as I previously mentioned, the inheritance order is something we usually can't decide because it depends on the way users are composing contracts. In this particular case, it seems viable but the contract in our library will be exactly (or very similar) to the one you shared in point 3.\r\n\r\n> <details>\r\n> <summary>4) Finally, I could copy-paste the whole code of AccessControlEnumerabl </summary>\r\n>  It works, but of course adds problems in terms of code bloat, ungradeability to new OZ contract versions, and renders the whole idea of multiple inheritance (largely) useless .. but I would trust it more than solution 3) as I did not have to change/invent any code.\r\n> </details>\r\n\r\n⚠️  This is not advised as copypasting can break the security guarantees provided along with the contract. \r\n\r\nThe contract variables are private by design so the business logic remains untouched. The correct way of handling multiple inheritance is by following the linearization order.\r\n\r\nI still agree with you that the linearization order could be a problem for newcomers, so perhaps we can suggest/think of better alternatives to document this behavior. Currently, [this is our official inheritance recommendation from the docs](https://docs.openzeppelin.com/learn/developing-smart-contracts#about_inheritance).\r\n\r\nI'll close this thread because it's becoming more support-related, which is provided in the [forum](https://forum.openzeppelin.com/), feel free to post your questions there and also feel free to open another issue if there's a concrete suggestion on how to improve the documentation for multiple inheritance.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1644472848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1646775804",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4465#issuecomment-1646775804",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4465",
    "id": 1646775804,
    "node_id": "IC_kwDOA9tCBs5iJ838",
    "user": {
      "login": "SvenMeyer",
      "id": 25609,
      "node_id": "MDQ6VXNlcjI1NjA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/25609?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SvenMeyer",
      "html_url": "https://github.com/SvenMeyer",
      "followers_url": "https://api.github.com/users/SvenMeyer/followers",
      "following_url": "https://api.github.com/users/SvenMeyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/SvenMeyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SvenMeyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SvenMeyer/subscriptions",
      "organizations_url": "https://api.github.com/users/SvenMeyer/orgs",
      "repos_url": "https://api.github.com/users/SvenMeyer/repos",
      "events_url": "https://api.github.com/users/SvenMeyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SvenMeyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-23T08:09:19Z",
    "updated_at": "2023-07-23T08:09:19Z",
    "author_association": "NONE",
    "body": "@ernestognw Thanks a lot for your extensive reply explaining the options to approach this and your design decisions ! :+1: ",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1646775804/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
