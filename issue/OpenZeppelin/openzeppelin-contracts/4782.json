{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4782",
  "id": 2028919580,
  "node_id": "I_kwDOA9tCBs547tsc",
  "number": 4782,
  "title": "Rigidity in Initializable's INITIALIZABLE_STORAGE slot",
  "user": {
    "login": "howydev",
    "id": 132113803,
    "node_id": "U_kgDOB9_liw",
    "avatar_url": "https://avatars.githubusercontent.com/u/132113803?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/howydev",
    "html_url": "https://github.com/howydev",
    "followers_url": "https://api.github.com/users/howydev/followers",
    "following_url": "https://api.github.com/users/howydev/following{/other_user}",
    "gists_url": "https://api.github.com/users/howydev/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/howydev/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/howydev/subscriptions",
    "organizations_url": "https://api.github.com/users/howydev/orgs",
    "repos_url": "https://api.github.com/users/howydev/repos",
    "events_url": "https://api.github.com/users/howydev/events{/privacy}",
    "received_events_url": "https://api.github.com/users/howydev/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2023-12-06T16:17:02Z",
  "updated_at": "2024-01-09T18:30:26Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**🧐 Motivation**\r\nMost ERC4337/ERC6900 smart contract accounts use the UUPSUpgradeable proxy pattern today. In OZ5.0's Initializable, the same `INITIALIZABLE_STORAGE` slot is used. As such, if more than 1 SCA implementation uses OZ5.0's Initializable, when a proxy is initialized with one of those implementations, it would not upgrade to other SCA implementations that require an `initializer` function to set up - as such, for security reasons, no SCA can use the Initializable library\r\n\r\n**📝 Details**\r\n1. Consider switching `_getInitializableStorage()` or `INITIALIZABLE_STORAGE` to `internal virtual` and allow parent contracts to choose which storage slot to use. This also allows child contracts to group storage slots together when verkle trees are adopted without having to worrying about storage collisions across versions.\r\n2. Consider switching to a deterministic, variable `INITIALIZABLE_STORAGE` instead. One possible implementation is: \r\n```\r\nbytes32 private immutable INITIALIZABLE_STORAGE;\r\nconstructor() {\r\n   bytes32 seed = keccak256(abi.encode(\"openzeppelin.storage.Initializable\", address(this) ));\r\n   INITIALIZABLE_STORAGE = keccak256(abi.encode(uint256(seed ) - 1)) & ~bytes32(uint256(0xff));\r\n}\r\n```\r\n\r\nCredit: @gpersoon",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1869715180",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4782#issuecomment-1869715180",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782",
    "id": 1869715180,
    "node_id": "IC_kwDOA9tCBs5vcZbs",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-26T18:48:38Z",
    "updated_at": "2023-12-26T18:48:38Z",
    "author_association": "MEMBER",
    "body": "Hey @howydev, sorry for the late response.\r\n\r\nI'm not sure if I'm following. If I understand correctly, the issue is that most SCA use the UUPSUpgradeable pattern (I assume including an `Initializable` in the inheritance tree), and therefore, if one of these SCA implementations uses `Initializable` as well, a contract can't be initialized twice. Is this correct? \r\n\r\nIf this is the case, I think you can use the `reinitializer` function to reuse the `_initialized` slot, but that depends on the setup.\r\n\r\nCan you provide a concrete example where the use of Initializable becomes a problem?\r\n\r\n> Consider switching _getInitializableStorage() or INITIALIZABLE_STORAGE to internal virtual and allow parent contracts to choose which storage slot to use. This also allows child contracts to group storage slots together when verkle trees are adopted without having to worrying about storage collisions across versions.\r\n\r\nThe `INITIALIZABLE_STORAGE` is following the [EIP-7201](https://eips.ethereum.org/EIPS/eip-7201) formula to avoid storage collisions and also considers grouping variables for verkle tree adoption. I think we'd need a huge reason to allow overriding the storage pointer since implementing it correctly is not trivial.\r\n\r\n> Consider switching to a deterministic, variable INITIALIZABLE_STORAGE instead. One possible implementation is:\r\n\r\nThis sounds better, but I think an example of how `Initializable` can't be reused would help us have an opinion on this.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1869715180/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1883574145",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4782#issuecomment-1883574145",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782",
    "id": 1883574145,
    "node_id": "IC_kwDOA9tCBs5wRQ-B",
    "user": {
      "login": "howydev",
      "id": 132113803,
      "node_id": "U_kgDOB9_liw",
      "avatar_url": "https://avatars.githubusercontent.com/u/132113803?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/howydev",
      "html_url": "https://github.com/howydev",
      "followers_url": "https://api.github.com/users/howydev/followers",
      "following_url": "https://api.github.com/users/howydev/following{/other_user}",
      "gists_url": "https://api.github.com/users/howydev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/howydev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/howydev/subscriptions",
      "organizations_url": "https://api.github.com/users/howydev/orgs",
      "repos_url": "https://api.github.com/users/howydev/repos",
      "events_url": "https://api.github.com/users/howydev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/howydev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-09T18:29:39Z",
    "updated_at": "2024-01-09T18:30:26Z",
    "author_association": "NONE",
    "body": "Thanks for the response @ernestognw. Big fan of yours, hope you're having a great new year so far!\r\n\r\nYep, thats a good summary! \r\n\r\n> The INITIALIZABLE_STORAGE is following the [EIP-7201](https://eips.ethereum.org/EIPS/eip-7201) formula to avoid storage collisions and also considers grouping variables for verkle tree adoption\r\n\r\nYup the chosen storage slot is in line with 7201! However, to fully reap the benefits of 7201, contracts have to intentionally design storage to be clumped. For a private `initializer`, all implementations are forced to use the 99 slots after `keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))`. For the average SC using Initializable, it would be slightly bad having to declare `keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))` as a const in their main contracts to reap this benefit, when they would much prefer to use an identifier like `companyABC.storage.ProtocolXYZ` instead\r\n\r\n> Can you provide a concrete example where the use of Initializable becomes a problem?\r\n\r\nFrom a high level, these are how we think about smart accounts:\r\n1. Users need to be able to upgrade/downgrade to different versions of the accounts.  E.g. Alchemy v1 smart account -> Alchemy v2 smart account and vice versa. There are 2 possibilities here - v2 accounts are backward compatible and we want to reuse the same storage layout through an inherited storage pattern, or v2 accounts are not backward compatible so we want empty storage\r\n3. Users need to have optionality, to be able to upgrade to a smart account from a different company. E.g. Alchemy v1 smart account -> Zerodev v1 smart account\r\n4. Each implementation should only be able to call `initialize` once - this is a security requirement since initialize usually sets up ownership of the account, so it's a path a user can lose their account to. Having it not be single-use-per-implementation incurs additional education/security overhead which is very undesirable\r\n\r\nFor regular protocols, because they design every version of their protocol, they can use the same storage structs or use append-only inherited storage as a solution to minimize storage collision risk. We can adhere to this internally to allow safe upgrades from an Alchemy v1 account to an Alchemy v2 account. But what about the Alchemy v1 smart account -> Zerodev v1 smart account path? If Alchemy and Zerodev both use OZ.Initializable, over a long timespan of versions, storage collisions are nearly guaranteed. Therefore, to derisk, both Alchemy and Zerodev (and all SCA builders) must each choose our own unique storage locations\r\n\r\nI can't think of a way to achieve the above with the current reinit design without requiring massive collaboration across the ecosystem around assigning version id numbers since we need them to be unique. I think the strictly increasing id numbers also prevent downgrades. Let me know if I overlooked something here\r\n\r\n> I think we'd need a huge reason to allow overriding the storage pointer since implementing it correctly is not trivial.\r\n\r\nThinking about this a big more - a large number of Initializable contracts must use some kind of access control to protect the `upgradeTo`/`upgradeToAndCall` function. Looking at the most used one, [OwnableUpgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol#L28), it looks like any contract using both would not be able to fully reap the benefits of verkle trees. If that's the case, then i think the slot should either be variable, or the verkle tree optimization is not used and maybe should be removed",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1883574145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
