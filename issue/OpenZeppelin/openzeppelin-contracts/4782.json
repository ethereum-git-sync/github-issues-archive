{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4782",
  "id": 2028919580,
  "node_id": "I_kwDOA9tCBs547tsc",
  "number": 4782,
  "title": "Rigidity in Initializable's INITIALIZABLE_STORAGE slot",
  "user": {
    "login": "howydev",
    "id": 132113803,
    "node_id": "U_kgDOB9_liw",
    "avatar_url": "https://avatars.githubusercontent.com/u/132113803?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/howydev",
    "html_url": "https://github.com/howydev",
    "followers_url": "https://api.github.com/users/howydev/followers",
    "following_url": "https://api.github.com/users/howydev/following{/other_user}",
    "gists_url": "https://api.github.com/users/howydev/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/howydev/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/howydev/subscriptions",
    "organizations_url": "https://api.github.com/users/howydev/orgs",
    "repos_url": "https://api.github.com/users/howydev/repos",
    "events_url": "https://api.github.com/users/howydev/events{/privacy}",
    "received_events_url": "https://api.github.com/users/howydev/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2023-12-06T16:17:02Z",
  "updated_at": "2023-12-26T18:48:38Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**ðŸ§ Motivation**\r\nMost ERC4337/ERC6900 smart contract accounts use the UUPSUpgradeable proxy pattern today. In OZ5.0's Initializable, the same `INITIALIZABLE_STORAGE` slot is used. As such, if more than 1 SCA implementation uses OZ5.0's Initializable, when a proxy is initialized with one of those implementations, it would not upgrade to other SCA implementations that require an `initializer` function to set up - as such, for security reasons, no SCA can use the Initializable library\r\n\r\n**ðŸ“ Details**\r\n1. Consider switching `_getInitializableStorage()` or `INITIALIZABLE_STORAGE` to `internal virtual` and allow parent contracts to choose which storage slot to use. This also allows child contracts to group storage slots together when verkle trees are adopted without having to worrying about storage collisions across versions.\r\n2. Consider switching to a deterministic, variable `INITIALIZABLE_STORAGE` instead. One possible implementation is: \r\n```\r\nbytes32 private immutable INITIALIZABLE_STORAGE;\r\nconstructor() {\r\n   bytes32 seed = keccak256(abi.encode(\"openzeppelin.storage.Initializable\", address(this) ));\r\n   INITIALIZABLE_STORAGE = keccak256(abi.encode(uint256(seed ) - 1)) & ~bytes32(uint256(0xff));\r\n}\r\n```\r\n\r\nCredit: @gpersoon",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1869715180",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4782#issuecomment-1869715180",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4782",
    "id": 1869715180,
    "node_id": "IC_kwDOA9tCBs5vcZbs",
    "user": {
      "login": "ernestognw",
      "id": 33379285,
      "node_id": "MDQ6VXNlcjMzMzc5Mjg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/33379285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ernestognw",
      "html_url": "https://github.com/ernestognw",
      "followers_url": "https://api.github.com/users/ernestognw/followers",
      "following_url": "https://api.github.com/users/ernestognw/following{/other_user}",
      "gists_url": "https://api.github.com/users/ernestognw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ernestognw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ernestognw/subscriptions",
      "organizations_url": "https://api.github.com/users/ernestognw/orgs",
      "repos_url": "https://api.github.com/users/ernestognw/repos",
      "events_url": "https://api.github.com/users/ernestognw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ernestognw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-26T18:48:38Z",
    "updated_at": "2023-12-26T18:48:38Z",
    "author_association": "MEMBER",
    "body": "Hey @howydev, sorry for the late response.\r\n\r\nI'm not sure if I'm following. If I understand correctly, the issue is that most SCA use the UUPSUpgradeable pattern (I assume including an `Initializable` in the inheritance tree), and therefore, if one of these SCA implementations uses `Initializable` as well, a contract can't be initialized twice. Is this correct? \r\n\r\nIf this is the case, I think you can use the `reinitializer` function to reuse the `_initialized` slot, but that depends on the setup.\r\n\r\nCan you provide a concrete example where the use of Initializable becomes a problem?\r\n\r\n> Consider switching _getInitializableStorage() or INITIALIZABLE_STORAGE to internal virtual and allow parent contracts to choose which storage slot to use. This also allows child contracts to group storage slots together when verkle trees are adopted without having to worrying about storage collisions across versions.\r\n\r\nThe `INITIALIZABLE_STORAGE` is following the [EIP-7201](https://eips.ethereum.org/EIPS/eip-7201) formula to avoid storage collisions and also considers grouping variables for verkle tree adoption. I think we'd need a huge reason to allow overriding the storage pointer since implementing it correctly is not trivial.\r\n\r\n> Consider switching to a deterministic, variable INITIALIZABLE_STORAGE instead. One possible implementation is:\r\n\r\nThis sounds better, but I think an example of how `Initializable` can't be reused would help us have an opinion on this.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1869715180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
