{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4361",
  "id": 1760901388,
  "node_id": "I_kwDOA9tCBs5o9TkM",
  "number": 4361,
  "title": "base class for the \"till\" pattern",
  "user": {
    "login": "moodysalem",
    "id": 7897876,
    "node_id": "MDQ6VXNlcjc4OTc4NzY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7897876?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/moodysalem",
    "html_url": "https://github.com/moodysalem",
    "followers_url": "https://api.github.com/users/moodysalem/followers",
    "following_url": "https://api.github.com/users/moodysalem/following{/other_user}",
    "gists_url": "https://api.github.com/users/moodysalem/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/moodysalem/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/moodysalem/subscriptions",
    "organizations_url": "https://api.github.com/users/moodysalem/orgs",
    "repos_url": "https://api.github.com/users/moodysalem/repos",
    "events_url": "https://api.github.com/users/moodysalem/events{/privacy}",
    "received_events_url": "https://api.github.com/users/moodysalem/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2023-06-16T15:58:50Z",
  "updated_at": "2023-06-21T15:11:24Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**🧐 Motivation**\r\nThe till pattern that utilizes transient storage is useful for many DeFi protocols. \r\n\r\n**📝 Details**\r\n\r\nCreate a base contract that implements the [till pattern](https://www.youtube.com/watch?v=xFp8RlRq0qU), that can be inherited by other contracts. In this pattern:\r\n\r\n- A caller calls the contract and then receives a callback with a new ID\r\n- Within the callback, the caller can make any number of changes (need a modifier and helper function to get current caller ID and prevent calling other methods without a lock)\r\n- At the end of the till, run some abstract validation to ensure the initial call can return successfully\r\n- Note in this pattern, re-entrance is allowed and the nested caller gets a new ID \r\n- Caller must be able to specify input to the callback and receive output from the callback\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 1,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1594981386",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4361#issuecomment-1594981386",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361",
    "id": 1594981386,
    "node_id": "IC_kwDOA9tCBs5fEXwK",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-06-16T16:56:48Z",
    "updated_at": "2023-06-16T16:56:48Z",
    "author_association": "MEMBER",
    "body": "I'm not sure that I understand the till metaphor. Is there an implementation in Uniswap v4 that could be used as reference?\r\n\r\nCan the same caller reenter via the till? Is the validation executed on entry as well? (If not, that seems risky?)",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1594981386/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595095135",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4361#issuecomment-1595095135",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361",
    "id": 1595095135,
    "node_id": "IC_kwDOA9tCBs5fEzhf",
    "user": {
      "login": "moodysalem",
      "id": 7897876,
      "node_id": "MDQ6VXNlcjc4OTc4NzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7897876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/moodysalem",
      "html_url": "https://github.com/moodysalem",
      "followers_url": "https://api.github.com/users/moodysalem/followers",
      "following_url": "https://api.github.com/users/moodysalem/following{/other_user}",
      "gists_url": "https://api.github.com/users/moodysalem/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/moodysalem/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/moodysalem/subscriptions",
      "organizations_url": "https://api.github.com/users/moodysalem/orgs",
      "repos_url": "https://api.github.com/users/moodysalem/repos",
      "events_url": "https://api.github.com/users/moodysalem/events{/privacy}",
      "received_events_url": "https://api.github.com/users/moodysalem/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-06-16T18:16:20Z",
    "updated_at": "2023-06-16T18:28:30Z",
    "author_association": "NONE",
    "body": "> I'm not sure that I understand the till metaphor. Is there an implementation in Uniswap v4 that could be used as reference?\r\n\r\nIt's a till, like a cash register, in that you open it, take some cash out, put some cash in, maybe change currencies (examples of actions you can perform while the till is open), but it has to be balanced (an example of the abstract validation) when you close it (the call returns). Another way to think of it is you don't perform validation of invariants un**til** the end.\r\n \r\n> Can the same caller reenter via the till? Is the validation executed on entry as well? (If not, that seems risky?)\r\n\r\nYes, any caller including the current caller can re-enter any number of times. Each call is assigned a unique ID--unique only within the context of that call stack--for each call to open the till. The abstract validation is only executed just before return. As long as the transient state you validate at the end is related only to that caller's ID, it's plenty safe.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595095135/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595390567",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4361#issuecomment-1595390567",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361",
    "id": 1595390567,
    "node_id": "IC_kwDOA9tCBs5fF7pn",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-06-16T22:29:28Z",
    "updated_at": "2023-06-16T22:29:28Z",
    "author_association": "MEMBER",
    "body": ">As long as the transient state you validate at the end is related only to that caller's ID, it's plenty safe.\r\n\r\nCan you elaborate on this?\r\n\r\nThis pattern seems to break some of my assumptions about what secure reentrancy looks like. It sounds like an invariant can be broken in the middle of the callback execution as long as it's restored at the end. But if you allow reentrancy while invariants are broken, the preconditions that you would normally use to prove that the code does what you intend may not hold. I'm not saying that the pattern can't work, but it seems to have big implications.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595390567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595514228",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4361#issuecomment-1595514228",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/4361",
    "id": 1595514228,
    "node_id": "IC_kwDOA9tCBs5fGZ10",
    "user": {
      "login": "moodysalem",
      "id": 7897876,
      "node_id": "MDQ6VXNlcjc4OTc4NzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7897876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/moodysalem",
      "html_url": "https://github.com/moodysalem",
      "followers_url": "https://api.github.com/users/moodysalem/followers",
      "following_url": "https://api.github.com/users/moodysalem/following{/other_user}",
      "gists_url": "https://api.github.com/users/moodysalem/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/moodysalem/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/moodysalem/subscriptions",
      "organizations_url": "https://api.github.com/users/moodysalem/orgs",
      "repos_url": "https://api.github.com/users/moodysalem/repos",
      "events_url": "https://api.github.com/users/moodysalem/events{/privacy}",
      "received_events_url": "https://api.github.com/users/moodysalem/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-06-17T00:30:38Z",
    "updated_at": "2023-06-17T00:30:38Z",
    "author_association": "NONE",
    "body": "> >As long as the transient state you validate at the end is related only to that caller's ID, it's plenty safe.\n> \n> \n> \n> Can you elaborate on this?\n> \n> \n> \n> This pattern seems to break some of my assumptions about what secure reentrancy looks like. It sounds like an invariant can be broken in the middle of the callback execution as long as it's restored at the end. But if you allow reentrancy while invariants are broken, the preconditions that you would normally use to prove that the code does what you intend may not hold. I'm not saying that the pattern can't work, but it seems to have big implications.\n\nYour invariants that you typically check are based on the state at the beginning of that specific call. The easiest way to do this is to only track the differences. This would be part of the abstract validation though.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1595514228/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
