{
  "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
  "repository_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts",
  "labels_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023/labels{/name}",
  "comments_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023/comments",
  "events_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023/events",
  "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023",
  "id": 1080074402,
  "node_id": "I_kwDOA9tCBs5AYKCi",
  "number": 3023,
  "title": "ERC721URIStorage: add internal getter for _tokenURIs",
  "user": {
    "login": "nxet",
    "id": 16403453,
    "node_id": "MDQ6VXNlcjE2NDAzNDUz",
    "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nxet",
    "html_url": "https://github.com/nxet",
    "followers_url": "https://api.github.com/users/nxet/followers",
    "following_url": "https://api.github.com/users/nxet/following{/other_user}",
    "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
    "organizations_url": "https://api.github.com/users/nxet/orgs",
    "repos_url": "https://api.github.com/users/nxet/repos",
    "events_url": "https://api.github.com/users/nxet/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nxet/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 503650966,
      "node_id": "MDU6TGFiZWw1MDM2NTA5NjY=",
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/labels/good%20first%20issue",
      "name": "good first issue",
      "color": "0e8a16",
      "default": true,
      "description": "Low hanging fruit for new contributors to get involved!"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 11,
  "created_at": "2021-12-14T18:18:17Z",
  "updated_at": "2022-12-02T00:55:59Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "**ðŸ§ Motivation**\r\nThis would allow much easier (and cheaper) implementations of an `hasTokenURI` helper.\r\n\r\n**ðŸ“ Details**\r\nCurrently the `ERC721URIStorage._tokenURIs` variable is defined as `private`, which prevents inheriting contracts from directly accessing the data stored in it.  \r\nAdditionally, when the `_baseURI` method provides a string but the token itself has no URI set, the `ERC721URIStorage.tokenURI` method ends up returning the `super`/`ERC721` implementation, where the `_baseURI` is concatenated with `tokenId` resulting in a non-empty string. Checking against this return value to know if the URI is already set is unnecessarily costly.  \r\n\r\nThe change in visibility to `internal` would allow for a significantly simpler implementation of this check, something like:\r\n```\r\nabstract contract ERC721URIStorage is ERC721 {\r\n    using Strings for uint256;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) internal _tokenURIs;\r\n...\r\n```\r\n```\r\nfunction _hasTokenURI(uint256 tokenId) internal view returns (bool) {\r\n    return bytes(_tokenURIs[tokenId]).length > 0;\r\n}\r\n```\r\n\r\nWould this raise security concerns?",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993855019",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-993855019",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 993855019,
    "node_id": "IC_kwDOA9tCBs47PQYr",
    "user": {
      "login": "nxet",
      "id": 16403453,
      "node_id": "MDQ6VXNlcjE2NDAzNDUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nxet",
      "html_url": "https://github.com/nxet",
      "followers_url": "https://api.github.com/users/nxet/followers",
      "following_url": "https://api.github.com/users/nxet/following{/other_user}",
      "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
      "organizations_url": "https://api.github.com/users/nxet/orgs",
      "repos_url": "https://api.github.com/users/nxet/repos",
      "events_url": "https://api.github.com/users/nxet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nxet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-14T18:21:20Z",
    "updated_at": "2021-12-14T18:21:20Z",
    "author_association": "NONE",
    "body": "Alternatives built into `ERC721URIStorage.tokenURI` could also be considered to avoid this change, and this led me to wonder if the current behaviour is really to be expected of the extension contract.\r\n\r\nWhat I mean is that, being (to my understanding) the extension based on the premise that the user wants to add an extra layer of abstraction on top of the base `ERC721.tokenURI` functionality, returning the super method might not be ideal. Instead, the user could expect the extension to notify them when the URI is not set for a token, implicitly by returning an empty string.  \r\n\r\nThis could be implemented with a simple check, avoiding super altogether. (based on `v4.3.2`)\r\n```\r\nabstract contract ERC721URIStorage is ERC721 {\r\n\r\n  ...\r\n\r\n  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n    require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\r\n    \r\n    string memory _tokenURI = _tokenURIs[tokenId];\r\n\r\n    // If there is no URI set, return empty string\r\n    if (bytes(_tokenURI).length == 0) {\r\n      return \"\";\r\n    }\r\n\r\n    string memory base = _baseURI();\r\n    \r\n    // If there is no base URI, return the token URI.\r\n    if (bytes(base).length == 0) {\r\n      return _tokenURI;\r\n    }\r\n    \r\n    // We got here, so both token's and base URIs are set\r\n    // concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n    return string(abi.encodePacked(base, _tokenURI));\r\n    \r\n  }\r\n\r\n  ...\r\n  \r\n}\r\n```\r\n\r\nApologies if none of this makes any sense, I'm quite new to Solidity and still getting to know my way around a lot of things.  \r\nYour code helped me so much and I'd love to give back, so if anything sounds interesting I can work out a PR to improve on what I discussed above.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993855019/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993868604",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-993868604",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 993868604,
    "node_id": "IC_kwDOA9tCBs47PTs8",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-14T18:37:33Z",
    "updated_at": "2021-12-14T18:37:33Z",
    "author_association": "COLLABORATOR",
    "body": "Hello @nxet\r\n\r\nFirst of all, we understand that having storage private is sometimes difficult to work with, but this is a base rule for us and we are going to change it. \r\n\r\nNow, *given the behaviour that we implement in ERC721URIStorage* I'm not sure how changing the storage is an issue. I think the question here is *what behaviour do you need?*\r\n\r\nIf you need something different ... then you should possibly write your own custom module on top of ERC721\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993868604/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993876594",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-993876594",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 993876594,
    "node_id": "IC_kwDOA9tCBs47PVpy",
    "user": {
      "login": "nxet",
      "id": 16403453,
      "node_id": "MDQ6VXNlcjE2NDAzNDUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nxet",
      "html_url": "https://github.com/nxet",
      "followers_url": "https://api.github.com/users/nxet/followers",
      "following_url": "https://api.github.com/users/nxet/following{/other_user}",
      "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
      "organizations_url": "https://api.github.com/users/nxet/orgs",
      "repos_url": "https://api.github.com/users/nxet/repos",
      "events_url": "https://api.github.com/users/nxet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nxet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-14T18:48:08Z",
    "updated_at": "2021-12-14T18:48:08Z",
    "author_association": "NONE",
    "body": "The behaviour I'm looking to implement is a simple and cheap way to check if a token has the URI set already.  \r\n\r\nChanging the storage visibility to `internal` would allow to implement a very simple `hasTokenURI` check.  \r\nThe second option I put in the comment, the change in behaviour I was discussing, simply proposed that when the URI is not set for a token, the `ERC721URIStorage.tokenURI` getter returns an empty string instead of `ERC721.tokenURI`.\r\n\r\nI totally didn't mean to sound as bad as your reply made it look like, so apologies for anything that came off strong. I'm most definitely not criticizing your design choices, simply trying to better understand them.  \r\nOf course I'm writing plenty of implementations on top of your contracts, and to be fair I will simply compile my contract with a modified version of your ERC721URIStorage. But again, I figured this could have been an interesting point of view and wanted to share it with the community.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/993876594/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994024423",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994024423",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 994024423,
    "node_id": "IC_kwDOA9tCBs47P5vn",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-14T21:20:43Z",
    "updated_at": "2021-12-14T21:21:58Z",
    "author_association": "COLLABORATOR",
    "body": "I'm really sorry if my initial reply made your question sound bad. We always appreciate users questioning the contract mechanism, which in some cases (like this one) are definitely not fitting all needs, and can be questioned.\r\n\r\nYou are interested by an approach where:\r\n\r\n> when the URI is not set for a token, the ERC721URIStorage.tokenURI getter returns an empty string instead of ERC721.tokenURI\r\n\r\nIMO `ERC721URIStorage` meet this requirement out of the box.\r\n\r\nIf you have a look at `ERC721`, you will see that the implementation for `_baseURI()` is the following\r\n```\r\nfunction _baseURI() internal view virtual returns (string memory) {\r\n    return \"\";\r\n}\r\n```\r\nnote that it doesn't read from storage. It cost practically nothing to run, and the compiler can optimize that a lot (inlining)\r\n\r\nThis means that the implementation in `ERC721URIStorage` will do\r\n\r\n```\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = _baseURI(); // â† this doesn't read from storage, just inlining an empty string\r\n\r\n        // If there is no base URI, return the token URI.\r\n        if (bytes(base).length == 0) { // â† this will always be the case, and the optimizer can see that\r\n            return _tokenURI;\r\n        }\r\n        // EVERYTHING BELLOW THAT IS DEAD CODE\r\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n\r\n        return super.tokenURI(tokenId);\r\n}\r\n```\r\ni.e\r\n```\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\r\n        return _tokenURIs[tokenId];\r\n}\r\n```\r\n\r\nSo you may want to rewrite some of it, but actually, you don't need to. Just trust the optimizer, and understand that `tokenURI(uint256)` is almost as good as an accessor to the underlying storage. It adds the cost of the `_exist(uint256)` check, but I don't think its that bad.\r\n\r\nIf you want to optimize further, then by all means fork the `ERC721URIStorage` and use a version with an internal accessor ... or a version with the `tokenURI(uint256)` cleaned up.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994024423/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994463328",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994463328",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 994463328,
    "node_id": "IC_kwDOA9tCBs47Rk5g",
    "user": {
      "login": "nxet",
      "id": 16403453,
      "node_id": "MDQ6VXNlcjE2NDAzNDUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nxet",
      "html_url": "https://github.com/nxet",
      "followers_url": "https://api.github.com/users/nxet/followers",
      "following_url": "https://api.github.com/users/nxet/following{/other_user}",
      "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
      "organizations_url": "https://api.github.com/users/nxet/orgs",
      "repos_url": "https://api.github.com/users/nxet/repos",
      "events_url": "https://api.github.com/users/nxet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nxet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-15T07:53:57Z",
    "updated_at": "2021-12-15T07:53:57Z",
    "author_association": "NONE",
    "body": "First of all thank you for this reply, it sets a totally different tone for the conversation and is deeply appreciated.  \r\nPlus, it made me see that there is still a fundamental misunderstanding between us. I'm sure it stems from my limited understanding of the environment, and I hope you can further help me get things straight.\r\n\r\nAs stated before, the main objective is to be able to cheaply tell if a token has the URI set. I'm finding it impossible to do with the current implementations of `ERC721` and `ERC721URIStorage` and the way they interact together.   \r\n\r\nUsing the current release of OZ, some example code would look like:\r\n```solidity\r\ncontract MyToken is ERC721, ERC721URIStorage {\r\n\r\n  ...\r\n  \r\n  // override baseURI\r\n  function _baseURI() internal view override(ERC721) returns (string memory) {\r\n    return \"https://ipfs.io/ipfs/\";\r\n  }\r\n\r\n  /**\r\n   * @dev Set `tokenId` URI string\r\n   * NB: This prevents overwrites, requiring `tokenId` to have no URI\r\n   */\r\n  function setTokenURI(uint256 tokenId, string memory uri) internal {\r\n    require(\r\n      _hasTokenURI(tokenId) == false,\r\n      \"Token URI can not be overwritten\"\r\n    );\r\n    _setTokenURI(tokenId, uri); // this will require(exists)\r\n  }\r\n  \r\n  /**\r\n   * @dev Check if `tokenId` URI is set, with current implementation\r\n   */\r\n  function _hasTokenURI(uint256 tokenId) internal view returns (bool) {\r\n\r\n    // Assuming we're calling this method for a token\r\n    // with the URI unset in the ERC721URIStorage._tokenURIs storage,\r\n    // i.e. _tokenURIs[tokenId] is an empty string.\r\n    // This call returns 'https://ipfs.io/ipfs/{tokenId}',\r\n    // because ERC721URIStorage.tokenURI:\r\n    // - requires(exist)\r\n    // - checks if base.length == 0, but continues\r\n    // - checks if tokenURI.length > 0, but continues\r\n    // - returns super(), which:\r\n    //   - requires(exist)\r\n    //   - checks if base.length > 0, and concatenates base with tokenId\r\n    string memory current = tokenURI(tokenId);\r\n\r\n    // at this point we have a token with the URI still unset in the storage\r\n    // i.e. _tokenURIs[tokenId] is still an empty string\r\n    // but the result we received is a full URI, which can be misleading\r\n\r\n    // the only way to check if the URI is an autogenerated string, rather than\r\n    // a deliberately set one, is to recreate the placeholder URI and check\r\n    // against the result we received above, basically calling `ERC721.tokenURI`\r\n    // once again\r\n\r\n    // of course here we can skip all the checks, since we know that baseURI is set\r\n    string memory autogenerated = string(\r\n      abi.encodePacked(\r\n        _baseURI(), tokenId.toString()\r\n      )\r\n    );\r\n\r\n    // at this point, check that the \"stored\" URI is not autogenerated\r\n    return keccak256(bytes(current)) != keccak256(bytes(autogenerated));\r\n    \r\n  }\r\n  \r\n}\r\n```\r\n\r\nHere you can see that the costs involved in creating a custom `hasTokenURI` check extend far beyond the extra `require`, but rather lie in how the storage is either 1. handled or 2. presented. This forces the user to provide extra logic to check if the value returned by `tokenURI` represents a token without a URI stored in `_tokenURIs`.\r\n\r\n---\r\n\r\nMy idea for 1 was a simple change in visibility from `private` to `internal` for the `_tokenURIs` variable. Again this would allow for direct access from inheriting contracts, making the `hasTokenURI` getter implementation a trivial one-liner.  \r\n\r\n```solidity\r\nfunction _hasTokenURI(uint256 tokenId) internal view returns (bool) {\r\n  return bytes(_tokenURIs[tokenId]).length > 0;\r\n}\r\n```\r\n\r\nDue to my evident lack of knowledge, I honestly fail to understand the implications of this change, and I'd be grateful for any further insight on the reasoning that led OZ to this design choice.\r\n\r\n---\r\n\r\nThe change in behavior proposed for 2 is instead for `ERC721URIStorage.tokenURI` to explicitly return an empty string when the URI is not set in storage, i.e. `_tokenURIs[tokenId] == \"\"`.  \r\nIn this regard I do understand how this would need a lot more consideration, but the resulting `_hasTokenURI` helper would once again be a simple one-liner:\r\n\r\n```solidity\r\nfunction _hasTokenURI(uint256 tokenId) internal view returns (bool) {\r\n  return bytes(tokenURI(tokenId)).length > 0;\r\n}\r\n```\r\n\r\n---\r\n\r\nOnce again, let me say that I'm new to this space and trying daily to improve my knowledge about the inner mechanics of Solidity.  \r\nThere's a high chance I'm overlooking some crucial aspects of the language design, which would make my reasoning invalid.  \r\nAnd if that's the case, please be kind enough to point me in the right direction (i.e. links to docs) for a better understanding.  \r\n\r\nThanks once again for your patience",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994463328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994661871",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994661871",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 994661871,
    "node_id": "IC_kwDOA9tCBs47SVXv",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-15T10:40:02Z",
    "updated_at": "2021-12-15T10:41:17Z",
    "author_association": "COLLABORATOR",
    "body": "This piece of code makes you request much clearer. It appears (and correct me if I'm wrong) that:\r\n\r\n- by default you want to use the token id as a ipfs hash ... which is strange since the tokenId will appear in a decimal format, which is not a valid base58 ipfs hash\r\n- have a mechanism that allows \"someone\" to change the URI from the default to something that can not be updated later on, but that still has to be an ipfs hash\r\n\r\nWe could add a `_hasTokenURI` function to `ERC721URIStorage`, but before we do that I'd like to understand your workflow better ... because I'm not sure that your usage should really be based on `ERC721URIStorage`. In particular, I don't think it makes any sens to have a default value that is not a valid IPFS hash. On the other hand, If your URI are all ipfs hash, I'm not sure if you need to set it manually for all tokens anyway.\r\n\r\nAs an example, I would take [this contract](https://etherscan.io/address/0x6d0de90cdc47047982238fcf69944555d27ecb25#readProxyContract). It has a base URI that is `ipfs://QmX9wDSPVGXfWkmCzPRRzNPUUrmXFNXgdKBdTbhTrrbAPV/` (note that it uses pure ipfs, and not a centralized ipfs provider). This is the hash of a folder, with files numbered from 0 to 9999. That way they don't need to store individual URI for each token, and the default ERC721 behavior is sufficient.\r\n\r\nCould that be a cheaper solution for you? If not, do you intend to use both the default resolution (fallback) and custom URIs ?",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994661871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994721461",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994721461",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 994721461,
    "node_id": "IC_kwDOA9tCBs47Sj61",
    "user": {
      "login": "nxet",
      "id": 16403453,
      "node_id": "MDQ6VXNlcjE2NDAzNDUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nxet",
      "html_url": "https://github.com/nxet",
      "followers_url": "https://api.github.com/users/nxet/followers",
      "following_url": "https://api.github.com/users/nxet/following{/other_user}",
      "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
      "organizations_url": "https://api.github.com/users/nxet/orgs",
      "repos_url": "https://api.github.com/users/nxet/repos",
      "events_url": "https://api.github.com/users/nxet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nxet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-15T11:58:36Z",
    "updated_at": "2021-12-15T11:58:36Z",
    "author_association": "NONE",
    "body": "I'm glad the last example has been helpful to better explain myself.  \r\n \r\n> by default you want to use the token id as a ipfs hash ... which is strange since the tokenId will appear in a decimal format, which is not a valid base58 ipfs hash\r\n\r\nNo, this is exactly the behaviour I intend to change. I *dont* want the URI to be an invalid IPFS url, as mistakenly concatenated by `ERC721`.  \r\nMy goal is to have a common base uri for all tokens, in this case the IPFS endpoint, which is then concatenated with a string I will store in `_tokenURIs`.  \r\nBut, crucially, the `_tokenURIs[tokenId]` value will NOT be set at mint, and will instead be provided at later date with a public method wrapping `ERC721URIStorage._setTokenURI` (as shown above). The tokens will be minted and left without the URI, until an external action will set it to a valid IPFS hash.\r\n\r\nAs you can see, in this scenario it is very problematic to have `ERC721URIStorage.tokenURI` returning an invalid autogenerated URI. And [the workaround I proposed](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994463328) is not DRY, extremely unsatisfactory, not to mention costly.\r\n\r\n> As an example, I would take this contract...\r\n\r\nThis example is *very* interesting, and something I didn't think of at all. Will definitely keep in mind this approach to IPFS storage.   \r\nUnfortunately (and this is totally unrelated to the question at hand) this would bring along major changes in the design of other components (outside of the smart contracts suite) of my project.\r\n\r\n> We could add a _hasTokenURI function to ERC721URIStorage\r\n\r\nIndeed this would be a useful helper to add to the interface, but I didn't want to mention it because of the (negligible) increase in footprint size of the extension contract, which would then be passed on to users which might honestly never need it.  \r\nBy the same metric, [proposal 1](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issue-1080074402) would basically leave things unchanged, and [proposal 2](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-993855019) might even reduce both deploy and operation costs since there would be one less `require` necessary (being `super` left out of the logic).  \r\nBut then again, my analysis mostly takes in account gas costs, and might overlook serious security concerns.\r\n\r\nLater today I will work out a couple improved examples to better explain my suggestions, but mostly to provide tangible code (instead of snippets spread across the whole discussion) to help better discuss and eventually move forward with the issue.\r\n\r\nAgain, thanks for your time",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/994721461/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995018128",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-995018128",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 995018128,
    "node_id": "IC_kwDOA9tCBs47TsWQ",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-15T17:42:07Z",
    "updated_at": "2021-12-15T17:42:53Z",
    "author_association": "COLLABORATOR",
    "body": "If you dont the tokenURI method to return `base + tokenId` when the token specific uri is not set, then you shouldn't be using ERC721URIStorage.\r\n\r\nmaybe something like\r\n```\r\nabstract contract ERC721CustomURI is ERC721 {\r\n    using Strings for uint256;\r\n\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        require(_tokenURI.length != 0);\r\n        return string(abi.encodePacked(_baseURI(), _tokenURI));\r\n    }\r\n    \r\n    function _isTokenURISet(uint256 tokenId) internal virtual view returns (bool) {\r\n        return bytes(_tokenURIs[tokenId]).length != 0\r\n    }\r\n    \r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual override {\r\n        super._burn(tokenId);\r\n\r\n        if (_isTokenURISet(tokenId)) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995018128/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995165881",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-995165881",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 995165881,
    "node_id": "IC_kwDOA9tCBs47UQa5",
    "user": {
      "login": "nxet",
      "id": 16403453,
      "node_id": "MDQ6VXNlcjE2NDAzNDUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16403453?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nxet",
      "html_url": "https://github.com/nxet",
      "followers_url": "https://api.github.com/users/nxet/followers",
      "following_url": "https://api.github.com/users/nxet/following{/other_user}",
      "gists_url": "https://api.github.com/users/nxet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nxet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nxet/subscriptions",
      "organizations_url": "https://api.github.com/users/nxet/orgs",
      "repos_url": "https://api.github.com/users/nxet/repos",
      "events_url": "https://api.github.com/users/nxet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nxet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-15T19:54:34Z",
    "updated_at": "2021-12-15T19:54:34Z",
    "author_association": "NONE",
    "body": "Let me just say this is frankly getting quite frustrating. I hoped it was clear at this point I'm not here asking for hastily developed examples on how to do the homework, but rather gain better insight about the framework I'm operating in and understand why the assumptions that brought me here were wrong.  \r\nThe patronising attitude and deliberate overlooking of the points made is really disheartening, above all because there are questions left unanswered (i.e. would the change in visibility raise security concerns).\r\n\r\nBack on topic, you say:\r\n\r\n> If you dont the tokenURI method to return base + tokenId when the token specific uri is not set, then you shouldn't be using ERC721URIStorage.\r\n\r\nBut what you just described is precisely what the base `ERC721` implementation already does.  \r\nUser doesn't need to inherit from `ERC721URIStorage` to achieve the behaviour you are describing here or [providing in the example above](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-994661871): a simple override of the `ERC721._baseURI` method returning a custom string (i.e. IPFS folder URI) would then provide a return value of `ERC721.tokenURI` composed of `baseURI + tokenId`.  \r\nShouldn't this be is a scenario where there's no point in inheriting from `ERC721URIStorage`, since the desired behaviour is what the base `ERC721` implementation already does?  \r\nOn the other hand, inheriting from a contract implementing a dedicated storage, `ERC721URIStorage`, IMO kind of implies that the user wants to primarily refer to the values stored in it (and know at a glance when the data isn't there).  \r\n\r\nSo *please*, help me understand why this opinion is wrong.  \r\nI sincerely didn't mean to be rude with this comment, I just really want to learn a solid foundation upon which to base future interactions with the OZ contracts, and most of all avoid major misunderstandings starting from my very first line of code.\r\n\r\nThank you",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995165881/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995633142",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-995633142",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 995633142,
    "node_id": "IC_kwDOA9tCBs47WCf2",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-12-16T10:18:51Z",
    "updated_at": "2021-12-16T10:18:51Z",
    "author_association": "COLLABORATOR",
    "body": "I'm sorry if my tone sounds patronizing, this is really not the emotion I'm trying to convey. There might be some frustration that we are not understanding each other, but please be assured that I am trying to understand your request and answer it as best as possible. I'm sorry I've not been understanding it so far.\r\n\r\n`ERC721` includes a default implementation of URI, which we believe is the most common. You will note that this default implementation does not rely on any storage, so it's as effective as possible, and so it can be overridden with no hidden cost. Our logic here is that if someone wants a custom logic, they will just override the public `tokenURI` function, and the internal `_basURI` function will be optimized out (same for the library calls).\r\n\r\nIn other words, if you don't like the default tokenURI, your can swap it easily and you shouldn't have to pay any costs for the default one that you are no longer using.\r\n\r\n`ERC721URIStorage` is a more expensive version, that is just here to replicate the behavior we had in an earlier version of contracts (3.x.x). Again, its designed to be somehow configurable (trough the baseURI) ... but it remains an opt-in solution for people that want/like the old behaviour.\r\n\r\nIn other words, if ERC721URIStorage doesn't clearly meet your demand, you should just not be using it. And when I say \"you\" I don't mean you personally, I mean anyone that is building an ERC721 contract.\r\n\r\nAs developers of OZ, we have some key rules that apply here:\r\n- Maintain backward compatibility, either in the contract itself or optionally through option extensions.\r\n- Have the smallest core possible, not forcing anyone to ship code they don't use.\r\n- Protect against the direct edition of the storage (all updates should go through \"setters\") ... this is not critical here, but it is in other places, and we like consistency in the application of our rules.\r\n- Let users expand the contract, by making the function virtual, and making sure that things can be swapped (hopefully without leaving extra dead code behind)\r\n\r\nIn your particular case, you seem to want something that doesn't really fit the behavior of `ERC721URIStorage` (even if we added a viewer to the storage), just because `ERC721URIStorage` behavior is having a fallback that in your context would be invalid. This is why I've always thought that you would be better of writing your own URI management mechanism on top of the core `ERC721`. It is not because we don't want to help, it is because we think this is really the better option. You are the person that best understands your workflow and your needs, and that is in the better position to write a URI function that correspond to your needs ... and if you need help building that custom module, we are ready to provide that help, but please don't see that proposal as \"hastily developed examples on how to do the homework\"",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/995633142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1089461378",
    "html_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3023#issuecomment-1089461378",
    "issue_url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/3023",
    "id": 1089461378,
    "node_id": "IC_kwDOA9tCBs5A79yC",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-04-05T22:42:33Z",
    "updated_at": "2022-04-05T22:42:33Z",
    "author_association": "MEMBER",
    "body": "I'm not sure why there was such a big misunderstanding in this thread.\r\n\r\n@nxet's purpose could probably be accomplished with a custom implementation of ERC721URIStorage. For simple contracts like this, we encourage forking the code to add custom behavior. However, it's a fair point that there is no way to inspect whether the storage URI for a token ID has been set. There is no getter counterpart to `_setTokenURI`, because `tokenURI` concatenates the base URI.\r\n\r\nI don't see an issue with including an additional internal getter. It does not add to bytecode size unless the function is used, so that's not an issue.",
    "reactions": {
      "url": "https://api.github.com/repos/OpenZeppelin/openzeppelin-contracts/issues/comments/1089461378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
