{
  "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
  "repository_url": "https://api.github.com/repos/prysmaticlabs/prysm",
  "labels_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122/labels{/name}",
  "comments_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122/comments",
  "events_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122/events",
  "html_url": "https://github.com/prysmaticlabs/prysm/issues/122",
  "id": 323470118,
  "node_id": "MDU6SXNzdWUzMjM0NzAxMTg=",
  "number": 122,
  "title": "Exploring the Current Client Protocol Architecture",
  "user": {
    "login": "rauljordan",
    "id": 5572669,
    "node_id": "MDQ6VXNlcjU1NzI2Njk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rauljordan",
    "html_url": "https://github.com/rauljordan",
    "followers_url": "https://api.github.com/users/rauljordan/followers",
    "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
    "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
    "organizations_url": "https://api.github.com/users/rauljordan/orgs",
    "repos_url": "https://api.github.com/users/rauljordan/repos",
    "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rauljordan/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 934596141,
      "node_id": "MDU6TGFiZWw5MzQ1OTYxNDE=",
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/labels/Discussion",
      "name": "Discussion",
      "color": "f9d0c4",
      "default": false,
      "description": "Simply a thread for talking about stuff"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "rauljordan",
    "id": 5572669,
    "node_id": "MDQ6VXNlcjU1NzI2Njk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rauljordan",
    "html_url": "https://github.com/rauljordan",
    "followers_url": "https://api.github.com/users/rauljordan/followers",
    "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
    "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
    "organizations_url": "https://api.github.com/users/rauljordan/orgs",
    "repos_url": "https://api.github.com/users/rauljordan/repos",
    "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rauljordan/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2018-05-16T05:05:20Z",
  "updated_at": "2018-12-12T16:27:44Z",
  "closed_at": "2018-05-24T22:30:44Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Hi all,\r\n\r\nAs more of our sharding client code is being created in our fork, it is critical to understand the design considerations of the current Ethereum nodes baked into go-ethereum. In particular, our notary/proposer clients need to be designed with good event loop management, pluggable services, and solid entry points for p2p functionality built in. As a case study, we will be looking at lightsync nodes as they are currently implemented in geth, understand their full responsibilities, and figure out the bigger picture behind the design considerations of their architecture.\r\n\r\nThe key question we will be asking ourselves is: **_what exactly happens when we start a light client? What are the design considerations that came into play when designing the code that gets the light client to work?_**\r\n\r\nWe will cap off this document by determining what aspects of the protocols in geth we can use as part of our sharding clients. We have an opportunity to write clean, straightforward code that does not have a massive number of file dependencies and complicated configs as geth currently does.\r\n\r\nLet’s dive in.\r\n\r\n## Case Study: Light Client Nodes\r\n\r\nEthereum’s light client sync mode allows users to spin up a geth node that only downloads block headers and relies on merkle proofs to verify specific parts of the state tree as needed. Light peers are extremely commonplace and critical components in the Ethereum network today. Their architecture serves as a great starting point for anyone extending or redesigning geth in a secure, concurrent, and performant way. \r\n\r\nUnfortunately, the current geth code is very hard to read, has a ton of dependencies across packages, and contains obscure configuration options. This doc will attempt to explain light client sync from start to finish, light node peer-to-peer networking, and other responsibilities of the protocol.\r\n\r\n### How is a Light Node Triggered?\r\n\r\nLaunching a geth light node is as easy as:\r\n\r\n```bash\r\n$ geth --syncmode=\"light\"\r\n```\r\n\r\nUpon the command being executed, the main function within `go-ethereum/cmd/geth/main.go` runs as follows:\r\n\r\n```go\r\nfunc main() {\r\n  if err := app.Run(os.Args); err != nil {\r\n    fmt.Fprintln(os.Stderr, err)\r\n    os.Exit(1)\r\n  }\r\n}\r\n```\r\n\r\nThis triggers the urfave/cli external package’s Run function, which will trigger the geth function a few lines below main(). \r\n\r\n```go\r\nfunc geth(ctx *cli.Context) error {\r\n  node := makeFullNode(ctx)\r\n  startNode(ctx, node)\r\n  node.Wait()\r\n  return nil\r\n}\r\n```\r\n\r\nBased on the cli context, this function initializes a `node` instance, which is a critical entry point. Let’s take a look at how `makeFullNode` does this.\r\n\r\nIn `go-ethereum/cmd/geth/config.go`:\r\n\r\n```go\r\nfunc makeFullNode(ctx _cli.Context) _node.Node {\r\n  stack, cfg := makeConfigNode(ctx)\r\n\r\n  utils.RegisterEthService(stack, &cfg.Eth)\r\n// a bunch of other services are configured below…\r\n…\r\n// then it returns the node, which is a var called a “stack”,\r\n// representing a protocol stack of the node (i.e. p2p services, rpc, etc.).\r\n  return stack\r\n}\r\n```\r\n\r\nTwo important functions are at play here:\r\n- `makeConfigNode` returns a configuration object that uses the cli context to fetch relevant command line flags and returns a node instance + a configuration object instance.\r\n- `utils.RegisterEthService` is a function that, based on the command line flags from the context, will use configuration options to add a `Service` object to the node instance we just declared above.  In this case, the cli context contains the `--syncmode=\"light\"` flag that we will be using to setup a light client protocol instead of a full Ethereum node.\r\n\r\nLet's see `makeConfigNode` in `go-ethereum/cmd/geth/config.go`:\r\n\r\n```go\r\nfunc makeConfigNode(ctx _cli.Context) (_node.Node, gethConfig) {\r\n\r\n  // Load defaults.\r\n  cfg := gethConfig{\r\n    Eth:       eth.DefaultConfig,\r\n    Shh:       whisper.DefaultConfig,\r\n    Node:      defaultNodeConfig(),\r\n    Dashboard: dashboard.DefaultConfig\r\n  }\r\n\r\n  // Load config file.\r\n  if file := ctx.GlobalString(configFileFlag.Name); file != \"\" {\r\n    if err := loadConfig(file, &cfg); err != nil {\r\n      utils.Fatalf(\"%v\", err)\r\n    }\r\n  }\r\n\r\n  // Apply flags.\r\n  utils.SetNodeConfig(ctx, &cfg.Node)\r\n  stack, err := node.New(&cfg.Node)\r\n  if err != nil {\r\n    utils.Fatalf(\"Failed to create the protocol stack: %v\", err)\r\n  }\r\n  utils.SetEthConfig(ctx, stack, &cfg.Eth)\r\n  if ctx.GlobalIsSet(utils.EthStatsURLFlag.Name) {\r\n    cfg.Ethstats.URL = ctx.GlobalString(utils.EthStatsURLFlag.Name)\r\n  }\r\n\r\n  utils.SetShhConfig(ctx, stack, &cfg.Shh)\r\n  utils.SetDashboardConfig(ctx, &cfg.Dashboard)\r\n\r\n  return stack, cfg\r\n\r\n}\r\n```\r\n\r\nCool, so this function just sets up some basic, default configurations to start a node. This sets up some basic, familiar options we have in the Ethereum network.\r\n\r\n```go\r\nvar DefaultConfig = Config{\r\n\tSyncMode: downloader.FastSync,\r\n\tEthash: ethash.Config{\r\n\t\tCacheDir:       \"ethash\",\r\n\t\tCachesInMem:    2,\r\n\t\tCachesOnDisk:   3,\r\n\t\tDatasetsInMem:  1,\r\n\t\tDatasetsOnDisk: 2,\r\n\t},\r\n\tNetworkId:     1,\r\n\tLightPeers:    100,\r\n\tDatabaseCache: 768,\r\n\tTrieCache:     256,\r\n\tTrieTimeout:   5 _ time.Minute,\r\n\tGasPrice:      big.NewInt(18 _ params.Shannon),\r\n\r\n    TxPool: core.DefaultTxPoolConfig,\r\n    GPO: gasprice.Config{\r\n    \tBlocks:     20,\r\n    \tPercentile: 60,\r\n    },\r\n\r\n}\r\n```\r\n\r\nThe `utils.SetEthConfig(ctx, stack, &cfg.Eth)` line is what will modify the `cfg` option based on command line flags. In this case, if `SyncMode` is set to `light`, then the config is updated to reflect that flag. Then, we go into the actual code that initializes a Light Protocol instance and registers it as the node's ETH service.\r\n\r\nIn `go-ethereum/cmd/flags.go`:\r\n\r\n```go\r\n// RegisterEthService adds an Ethereum client to the stack.\r\nfunc RegisterEthService(stack _node.Node, cfg _eth.Config) {\r\n\r\n  var err error\r\n  if cfg.SyncMode == downloader.LightSync {\r\n    err = stack.Register(func(ctx _node.ServiceContext) (node.Service, error) {\r\n      return les.New(ctx, cfg)\r\n    })\r\n  } else {\r\n    err = stack.Register(func(ctx _node.ServiceContext) (node.Service, error) {\r\n      fullNode, err := eth.New(ctx, cfg)\r\n      if fullNode != nil && cfg.LightServ > 0 {\r\n        ls, \\_ := les.NewLesServer(fullNode, cfg)\r\n        fullNode.AddLesServer(ls)\r\n      }\r\n      return fullNode, err\r\n    })\r\n  }\r\n  if err != nil {\r\n    Fatalf(\"Failed to register the Ethereum service: %v\", err)\r\n  }\r\n\r\n}\r\n```\r\n\r\nSo here, if the config option for the downloader is set to `LightSync`, which was set in the `makeConfigNode` function we saw before, we register a `Service` object into the node (referred to as stack in the code above). Nodes contain an array of `Service` instances that all implement useful functions we will come back to later. In this case, the service a `LightEthereum` instance that gives us all the functionality we need to run a light client.\r\n\r\n### How Do These Attached Services Start Running?\r\n\r\nHere's where everything _actually_ ties together. If you go back to the `main` function in `go-ethereum/cmd/geth/main.go`, \r\n\r\n```go\r\nfunc geth(ctx *cli.Context) error {\r\n\r\n  node := makeFullNode(ctx)\r\n  startNode(ctx, node)\r\n  node.Wait()\r\n  return nil\r\n\r\n}\r\n```\r\n\r\nthe `startNode` func actually kicks things off.\r\n\r\n```go\r\n// startNode boots up the system node and all registered protocols, after which\r\n// it unlocks any requested accounts, and starts the RPC/IPC interfaces and the\r\n// miner.\r\nfunc startNode(ctx _cli.Context, stack _node.Node) {\r\n\r\n  // Start up the node itself\r\n  utils.StartNode(stack)\r\n\r\n  // a lot of stuff below is related to wallet opening/closing events and setting up\r\n  // full node mining functionality...\r\n  ...\r\n}\r\n```\r\n\r\nWhen we look at `utils.StartNode` in `go-ethereum/cmd/utils/cmd.go`:\r\n\r\n```go\r\nfunc StartNode(stack *node.Node) {\r\n\r\n  if err := stack.Start(); err != nil {\r\n    Fatalf(\"Error starting protocol stack: %v\", err)\r\n  }\r\n\r\n  // stuff below handles signal interrupts to stop the service...\r\n  ...\r\n}\r\n```\r\n\r\n...we see the actual code that starts off a node! Let's explore. In `go-ethereum/node/node.go`, a lot of things happen (simplified for readability):\r\n\r\n```go\r\nfunc (n *Node) Start() error {\r\n\r\n  n.lock.Lock()\r\n  defer n.lock.Unlock()\r\n\r\n  // Short circuit if the node's already running\r\n  if n.server != nil {\r\n    return ErrNodeRunning\r\n  }\r\n  if err := n.openDataDir(); err != nil {\r\n    return err\r\n  }\r\n\r\n  // Initialize the p2p server. This creates the node key and\r\n  // discovery databases.\r\n  n.serverConfig = n.config.P2P\r\n  n.serverConfig.PrivateKey = n.config.NodeKey()\r\n  n.serverConfig.Name = n.config.NodeName()\r\n  n.serverConfig.Logger = n.log\r\n\r\n  // setting up more config stuff...\r\n  ...\r\n\r\n  // sets up a peer to peer server instance!\r\n  running := &p2p.Server{Config: n.serverConfig}\r\n  n.log.Info(\"Starting peer-to-peer node\", \"instance\", n.serverConfig.Name)\r\n\r\n  services := make(map[reflect.Type]Service)\r\n\r\n  // serviceFuncs is an internal slice updated in a node whenever node.Register() is called!\r\n  for _, constructor := range n.serviceFuncs {\r\n\r\n    // Create a new context for the particular service\r\n    ctx := &ServiceContext{\r\n      config:         n.config,\r\n      services:       make(map[reflect.Type]Service),\r\n      EventMux:       n.eventmux,\r\n      AccountManager: n.accman,\r\n    }\r\n\r\n    // does some stuff for threaded access...\r\n    ...\r\n   \r\n    // Construct and save the service\r\n    service, err := constructor(ctx)\r\n\r\n    // sets up the service and adds it to the services slice defined above...\r\n    ...\r\n\r\n    // updates the services slice\r\n    services[kind] = service\r\n  }\r\n\r\n  // this uses the .Protocols() property of each attached service (yes, LightEthereum has this defined)\r\n  // and attaches it to the running p2p server instance.\r\n  for _, service := range services {\r\n    running.Protocols = append(running.Protocols, service.Protocols()...)\r\n  }\r\n\r\n  // this starts the p2p server!\r\n  if err := running.Start(); err != nil {\r\n    ...\r\n  }\r\n  // Start each of the services\r\n  for kind, service := range services {\r\n    // Start the next service, stopping all previous upon failure\r\n    if err := service.Start(running); err != nil {\r\n      ...\r\n    }\r\n  }\r\n\r\n  // code below starts some RPC stuff and cleans up the node when it exits...\r\n\r\n  return nil\r\n}\r\n```\r\n\r\n**Aha!** So this is the function that iterates over each attached service and runs the `.Start()` function for each! The `LightEthereum` instance that was attached as a service to the node implements the `Service` interface that contains a `.Start()` function. **This is how it all fits together!**\r\n\r\n## The Light Ethereum Package\r\n\r\nWe will focusing our attention on the `go-ethereum/les` package in this section, as this is the service that is attached to the running node upon launching a geth instance with the `--syncmode=\"light\"` flag.\r\n\r\nThe light client needs to implement the `Service` interface defined in `go-ethereum/node/service.go` as follows:\r\n\r\n```go\r\ntype Service interface {\r\n\r\n  // Protocols retrieves the P2P protocols the service wishes to start.\r\n  Protocols() []p2p.Protocol\r\n\r\n  // APIs retrieves the list of RPC descriptors the service provides.\r\n  APIs() []rpc.API\r\n\r\n  // Start is called after all services have been constructed and the networking\r\n  // layer was also initialized to spawn any goroutines required by the service.\r\n  Start(server *p2p.Server) error\r\n\r\n  // Stop terminates all goroutines belonging to the service, blocking until they\r\n  // are all terminated.\r\n  Stop() error\r\n  \r\n}\r\n```\r\n\r\nThe core of the entire light client is written in `go-ethereum/les/backend.go`. This is where we find the functions required to satisfy this `Service` interface, alongside the code that initializes an actual `LightEthereum` instance in a function known called `New`.\r\n\r\n```go\r\nfunc New(ctx _node.ServiceContext, config _eth.Config) (_LightEthereum, error) {\r\n  \r\n  // sets up the chainDB and genesis configuration for the light node...\r\n  chainDb, err := eth.CreateDB(ctx, config, \"lightchaindata\")\r\n  if err != nil {\r\n    return nil, err\r\n  }\r\n  chainConfig, genesisHash, genesisErr := core.SetupGenesisBlock(chainDb, config.Genesis)\r\n \r\n  ...\r\n\r\n  log.Info(\"Initialised chain configuration\", \"config\", chainConfig)\r\n\r\n  leth := &LightEthereum{\r\n    ...\r\n  }\r\n\r\n  // sets up a transaction relayer, a server pool, and info retrieval systems\r\n\r\n  leth.relay = NewLesTxRelay(peers, leth.reqDist)\r\n  leth.serverPool = newServerPool(chainDb, quitSync, &leth.wg)\r\n  leth.retriever = newRetrieveManager(peers, leth.reqDist, leth.serverPool)\r\n  \r\n  ...\r\n\r\n  // sets up the light tx pool\r\n  leth.txPool = light.NewTxPool(leth.chainConfig, leth.blockchain, leth.relay)\r\n\r\n  // sets up a protocol manager: we'll get into this shortly...\r\n  if leth.protocolManager, err = NewProtocolManager(...); err != nil {\r\n    return nil, err\r\n  }\r\n\r\n  // sets up the light ethereum APIs for RPC interactions\r\n  leth.ApiBackend = &LesApiBackend{leth, nil}\r\n \r\n  ...\r\n\r\n  return leth, nil\r\n\r\n}\r\n\r\n```\r\n\r\nLet's see what the light client's `.Start()` function does and how it sets up the p2p stack:\r\n\r\n```go\r\nfunc (s _LightEthereum) Start(srvr _p2p.Server) error {\r\n\r\n  ...\r\n\r\n  log.Warn(\"Light client mode is an experimental feature\")\r\n  s.netRPCService = ethapi.NewPublicNetAPI(srvr, s.networkId)\r\n\r\n  ...\r\n\r\n  s.serverPool.start(srvr, lesTopic(s.blockchain.Genesis().Hash(), protocolVersion))\r\n  ...\r\n  return nil\r\n  \r\n}\r\n```\r\n\r\n### Light Protocol Event Loop\r\n\r\nThe creation of the `LightEthereum` instance kicks off a bunch of goroutines, but where the actual sync and retrieval of state occurs is in the creation of a `ProtocolManager` in the `New` function.\r\n\r\nIn `go-ethereum/les/handler.go`, we see at the bottom of the `NewProtocolManager` function, code that runs some event loops:\r\n\r\n```go\r\nif lightSync {\r\n\t\tmanager.downloader = downloader.New(downloader.LightSync, chainDb, manager.eventMux, nil, blockchain, removePeer)\r\n\t\tmanager.peers.notify((*downloaderPeerNotify)(manager))\r\n\t\tmanager.fetcher = newLightFetcher(manager)\r\n\t}\r\n```\r\n\r\nIn this case, we the instance starts a new `downloader` instance and a `newLightFetcher`, which work in tandem with the p2p layer to sync the state and respond to RPC requests that trigger events on peers or respond to incoming messages from peers.\r\n\r\nThe implementation diverges into a variety of files at this point, but an important aspect of the `les` package is the usage of **on-demand requests** or **ODR's**. Through the p2p light server, nodes receive requests that are processed via goroutines such as in the example below.\r\n\r\nIn `go-ethereum/les/odr_requests.go`:\r\n\r\n```go\r\nfunc (r _TrieRequest) Validate(db ethdb.Database, msg _Msg) error {\r\n\r\n  log.Debug(\"Validating trie proof\", \"root\", r.Id.Root, \"key\", r.Key)\r\n\r\n  switch msg.MsgType {\r\n  case MsgProofsV1:\r\n    proofs := msg.Obj.([]light.NodeList)\r\n    if len(proofs) != 1 {\r\n      return errInvalidEntryCount\r\n    }\r\n    nodeSet := proofs[0].NodeSet()\r\n    // Verify the proof and store if checks out\r\n    if _, err, _ := trie.VerifyProof(r.Id.Root, r.Key, nodeSet); err != nil {\r\n      return fmt.Errorf(\"merkle proof verification failed: %v\", err)\r\n    }\r\n    r.Proof = nodeSet\r\n    return nil\r\n\r\n  case MsgProofsV2:\r\n    proofs := msg.Obj.(light.NodeList)\r\n    // Verify the proof and store if checks out\r\n    nodeSet := proofs.NodeSet()\r\n    reads := &readTraceDB{db: nodeSet}\r\n    if _, err, _ := trie.VerifyProof(r.Id.Root, r.Key, reads); err != nil {\r\n      return fmt.Errorf(\"merkle proof verification failed: %v\", err)\r\n    }\r\n    // check if all nodes have been read by VerifyProof\r\n    if len(reads.reads) != nodeSet.KeyCount() {\r\n      return errUselessNodes\r\n    }\r\n    r.Proof = nodeSet\r\n    return nil\r\n\r\n  default:\r\n    return errInvalidMessageType\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\nThe node in question has the capacity to immediately respond to a message received via other peers, which is a critical piece of functionality we will need the more we elaborate on our notary/proposer clients.\r\n\r\n## Key Takeaways\r\n\r\nOverall, taking full advantage of Go's concurrency primitives along with mutexes for managing services is a great benefit of working with the geth client. We should maintain the pluggability of `Services` via a `Service`-like interface and allow for easy management and testing of relevant code.\r\n\r\nWhat we should avoid, however, is the extremely dependent spaghetti code around configuration options. There is a lot of hetereogeneity around configuring structs in the geth client, with packages often following their own approaches compared to others throughout the project. We should aim to constrain all configuration to a single, initial entrypoint and avoid redundancy of `.Start()` methods. After reading this code, it often feels like the geth team really drove themselves into a corner here. We have the opportunity to keep things simple, DRY, and performant.\r\n\r\nWe have to leverage the powerful constructs shown above in our notary/proposer implementations to make the most out of Go. Please let me know your thoughts below as to how we can improve upon what the `go-ethereum` team has done.\r\n\r\nLet's go for it.\r\n",
  "closed_by": {
    "login": "rauljordan",
    "id": 5572669,
    "node_id": "MDQ6VXNlcjU1NzI2Njk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rauljordan",
    "html_url": "https://github.com/rauljordan",
    "followers_url": "https://api.github.com/users/rauljordan/followers",
    "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
    "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
    "organizations_url": "https://api.github.com/users/rauljordan/orgs",
    "repos_url": "https://api.github.com/users/rauljordan/repos",
    "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rauljordan/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122/reactions",
    "total_count": 5,
    "+1": 5,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389600088",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/122#issuecomment-389600088",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
    "id": 389600088,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTYwMDA4OA==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T17:25:30Z",
    "updated_at": "2018-05-16T17:25:30Z",
    "author_association": "MEMBER",
    "body": "Great read! it definitely opened my eyes. We should turn your write up into a Medium article to benefit broader audiences. \r\n\r\nTake Notary as an example, do we think the following is the right path?  \r\n\r\n`makeNotaryNode()` gets notary config by calling `makeConfigNotaryNode()` and registers notary services by calling `registerNotaryService()`. Then `makeNotaryNode()` starts notary node via `startNotaryNode()`\r\nWithin `startNotaryNode()`we iterates each notary services and `start()`. Notary should implement the Service interface under `service.go`. While creation of the `notaryEthereum` service instance should kick off go routines such as downloader, fetcher.. etc",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389600088/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389606880",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/122#issuecomment-389606880",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
    "id": 389606880,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTYwNjg4MA==",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T17:47:25Z",
    "updated_at": "2018-05-16T17:47:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm not a fan of the complicated config setups that are spread across multiple files, but I'm a fan of having a bunch of services that implement a certain interface be attached to our notary client with each of them having a `.Start()` func. I don't think we should copy exactly what they did, but instead trim it down as much as possible and keep the good parts that leverage concurrency.",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389606880/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389676077",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/122#issuecomment-389676077",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
    "id": 389676077,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTY3NjA3Nw==",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T21:45:49Z",
    "updated_at": "2018-05-16T21:45:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hey all,\r\n\r\nSo thinking more about this as I transition into creating a PR for #109, here is a proposal I would like to make for our sharding clients moving forward. As our code base grows, it's important to think about how we can best leverage concurrency, event management, and simple configuration options that don't cause any headaches to those reading our work. There are elements of the light node design that I'd like to incorporate into our system for spinning up notary/proposer clients. Here are the ideas:\r\n\r\n## Design\r\n\r\nThe key idea is that our sharding entry point will spin up a `ShardingClient` struct, which is analogous to geth spinning up an instance of a `Node`.\r\n\r\n- There is a key command line flag called `ClientType` that specifies if the client will be a `Notary` or `Proposer` instead\r\n- The main entry point sets up a `ShardingClient` instance\r\n  - attaches configuration options from cli flags\r\n  - contains a utility function that registers a `ShardingService`: either `Notary` or `Proposer`\r\n  - starts each of these services in a concurrency-safe fashion\r\n- `Notary` and `Proposer` instances implement a `ShardingService` interface that defines common methods to both, including, but not limited to:\r\n\r\n```go\r\n  type Service interface {\r\n\r\n    // Protocols retrieves the P2P protocols the service wishes to start.\r\n    Protocols() []p2p.Protocol\r\n    \r\n    // APIs retrieves the list of RPC descriptors the service provides\r\n    APIs() []rpc.API\r\n\r\n    // Start is called after all services have been constructed and the networking\r\n    // layer was also initialized to spawn any goroutines required by the service.\r\n    Start(server *p2p.Server) error\r\n\r\n    // Stop terminates all goroutines belonging to the service, blocking until they\r\n    // are all terminated.\r\n    Stop() error\r\n  }\r\n```\r\n\r\nThe idea of attaching services this way to the sharding client allows service life-cycle management to be the responsibility of the sharding client itself. Moreover, every single goroutine pertaining to a service can be spun up and contained within its `.Start()` method.\r\n\r\n- The `.Start()` function will open a local shardchaindb file storage, and spin up notaries and proposers' respective p2p `ServerPools` and `ProtocolManager`'s `.Start()` methods\r\n  - `ServerPool` kickstarts an event loop that handles peer discovery, new connections, and disconnections from peers\r\n  - `ProtocolManager` is struct that handles notaries and proposers' respective event loops (i.e. interacting with the SMC, the voting process, etc.), their corresponding serverPools, their chaindb, txpools, and message requests/responses from other peers.\r\n  \r\nA `ProtocolManager` interface allows for a well-defined set of responsibilities and goroutines executed by notaries and proposers.\r\n\r\nThe lifecycle of notaries and proposers in the p2p network can be handled via a callback as in the `les` package that deals with the handshake between peers, and an eternal loop of responding to incoming messages via the `ProtocolManager`'s `handleMsg` functionality.\r\n\r\n**Clients React to Each Other Via the `ProtocoManager`'s `handleMsg` Function**\r\n\r\nThere is a fixed set of messages sharding clients can respond to and send. We can follow the same approach as done in the `les` package's `ProtocolManager.handleMsg` function to do this.\r\n\r\nOverall, I suggest we keep configurations in a single place, without many dependencies across files, and we document everything extensively. Let me know your thoughts.\r\n\r\n@prestonvanloon @terenc3t @nisdas @enriquefynn @Magicking ",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389676077/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389695424",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/122#issuecomment-389695424",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
    "id": 389695424,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTY5NTQyNA==",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T23:17:39Z",
    "updated_at": "2018-05-16T23:17:39Z",
    "author_association": "MEMBER",
    "body": "Looks good. In regard to how clients interact with each other, check out this LES flow control writeup: https://github.com/zsfelfoldi/go-ethereum/wiki/Client-Side-Flow-Control-model-for-the-LES-protocol",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/389695424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/446650597",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/122#issuecomment-446650597",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/122",
    "id": 446650597,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NjY1MDU5Nw==",
    "user": {
      "login": "rosulucian",
      "id": 12020395,
      "node_id": "MDQ6VXNlcjEyMDIwMzk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/12020395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rosulucian",
      "html_url": "https://github.com/rosulucian",
      "followers_url": "https://api.github.com/users/rosulucian/followers",
      "following_url": "https://api.github.com/users/rosulucian/following{/other_user}",
      "gists_url": "https://api.github.com/users/rosulucian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rosulucian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rosulucian/subscriptions",
      "organizations_url": "https://api.github.com/users/rosulucian/orgs",
      "repos_url": "https://api.github.com/users/rosulucian/repos",
      "events_url": "https://api.github.com/users/rosulucian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rosulucian/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-12T16:27:43Z",
    "updated_at": "2018-12-12T16:27:43Z",
    "author_association": "NONE",
    "body": "Raul, do you know of any other similar docs that could help a new developer peek inside the geth architecture& design? \r\nGreat job on this one, though! It really helped me get a broad picture of the geth design (not limited to the light client)",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/446650597/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
