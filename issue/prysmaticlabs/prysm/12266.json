{
  "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266",
  "repository_url": "https://api.github.com/repos/prysmaticlabs/prysm",
  "labels_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266/labels{/name}",
  "comments_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266/comments",
  "events_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266/events",
  "html_url": "https://github.com/prysmaticlabs/prysm/issues/12266",
  "id": 1666123900,
  "node_id": "I_kwDOBvuov85jTwh8",
  "number": 12266,
  "title": "How do we ensure new consensus field are well tested",
  "user": {
    "login": "terencechain",
    "id": 21316537,
    "node_id": "MDQ6VXNlcjIxMzE2NTM3",
    "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/terencechain",
    "html_url": "https://github.com/terencechain",
    "followers_url": "https://api.github.com/users/terencechain/followers",
    "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
    "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
    "organizations_url": "https://api.github.com/users/terencechain/orgs",
    "repos_url": "https://api.github.com/users/terencechain/repos",
    "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
    "received_events_url": "https://api.github.com/users/terencechain/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2023-04-13T10:09:48Z",
  "updated_at": "2023-04-13T21:46:25Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "One takeaway from #12263 is when adding a new consensus (especially `List`) field to a consensus object, it gets inherently riskier in the Prysm code. This is due to Go initializing `nil` as `0` or empty. Too many places where we cast to the underlying types and copy everything field-by-field. This means the author has to be careful to initialize the new field correctly or the reviewer must review carefully and ensure the unit test has satisfactory coverage. Both are hard to enforce. I'm open to ideas on how to enforce such behavior better. Some ideas I thought about\r\n- Static analysis. This behavior primarily exhibits from protobuf object conversion like converting blind to non blind or the other way around\r\n- Better test setup. Have `util.NewBlock` function to return a non-empty block",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/1507647471",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/12266#issuecomment-1507647471",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/12266",
    "id": 1507647471,
    "node_id": "IC_kwDOBvuov85Z3N_v",
    "user": {
      "login": "rauljordan",
      "id": 5572669,
      "node_id": "MDQ6VXNlcjU1NzI2Njk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5572669?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rauljordan",
      "html_url": "https://github.com/rauljordan",
      "followers_url": "https://api.github.com/users/rauljordan/followers",
      "following_url": "https://api.github.com/users/rauljordan/following{/other_user}",
      "gists_url": "https://api.github.com/users/rauljordan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rauljordan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rauljordan/subscriptions",
      "organizations_url": "https://api.github.com/users/rauljordan/orgs",
      "repos_url": "https://api.github.com/users/rauljordan/repos",
      "events_url": "https://api.github.com/users/rauljordan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rauljordan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-13T21:46:25Z",
    "updated_at": "2023-04-13T21:46:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "One approach is we could encapsulate this information in how a beacon block is initialized and built. For example, in Rust we use a pattern called the [builder pattern](https://refactoring.guru/design-patterns/builder/rust/example) which works as follows:\r\n\r\n```rs\r\nlet block = BeaconBlock::new()\r\n  .deposit(deposit_items)\r\n  .voluntary_exits(exits)\r\n  .attestations(atts)\r\n  ...\r\n  .build()?\r\n```\r\n\r\nThe idea is that we have a function called `BeaconBlock::new()` which gives you something called a `BeaconBlockHandle`, not an actual beacon block. This handle has methods to update its fields, such as `.SetBLSChanges(changes)`, or `SetAttestations(atts)`. To turn that handle into a beacon block, one has to call a `.Build()` method. One proposal is this build method can use the `reflect` package to inspect all necessary fields have been set based on the block type and that they have the correct defaults. This could be the canonical way of initializing a block and has an ergonomic, functional API.\r\n\r\nWith this approach, one _must_ call .Build() method to get a block as that is the only way to initialize one. If we forget to add an important field even in a single place, the code will fail to run. This reduces the surface area of where we need to audit the codebase to a single method, the `.Build()` method.\r\n\r\nThe #12240 PR is an example of the current status, where we will need to remember to update that function in a future hard fork once fields are added and could lead to another silent failure affecting mainnet if we are not careful.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/1507647471/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
