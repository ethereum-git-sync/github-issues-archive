{
  "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738",
  "repository_url": "https://api.github.com/repos/prysmaticlabs/prysm",
  "labels_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738/labels{/name}",
  "comments_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738/comments",
  "events_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738/events",
  "html_url": "https://github.com/prysmaticlabs/prysm/issues/6738",
  "id": 666418560,
  "node_id": "MDU6SXNzdWU2NjY0MTg1NjA=",
  "number": 6738,
  "title": "Hash Token Defense",
  "user": {
    "login": "mrabino1",
    "id": 4902221,
    "node_id": "MDQ6VXNlcjQ5MDIyMjE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4902221?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mrabino1",
    "html_url": "https://github.com/mrabino1",
    "followers_url": "https://api.github.com/users/mrabino1/followers",
    "following_url": "https://api.github.com/users/mrabino1/following{/other_user}",
    "gists_url": "https://api.github.com/users/mrabino1/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mrabino1/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mrabino1/subscriptions",
    "organizations_url": "https://api.github.com/users/mrabino1/orgs",
    "repos_url": "https://api.github.com/users/mrabino1/repos",
    "events_url": "https://api.github.com/users/mrabino1/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mrabino1/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 802129906,
      "node_id": "MDU6TGFiZWw4MDIxMjk5MDY=",
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/labels/Enhancement",
      "name": "Enhancement",
      "color": "84b6eb",
      "default": false,
      "description": "New feature or request"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2020-07-27T16:19:25Z",
  "updated_at": "2022-02-01T23:13:25Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Prysm proposal\n\nToken hash defense\n\nThis is really for advanced node operators that have more than 5 validators running on a node\n\nIn this proposal we have four fundamental attributes to add to prysm:\nmax number of replicas\nreplica_id\ntime between node rotation \ncollision gap between node rotation\n\nAbstract:\nGiven an attack vector to inhibit finality being the DDOS to overwhelm the known and announced validators as the node IP can be determined after a sufficient amount of time, a defense strategy to rotate validators amongst different nodes using the same validator keys has been developed. An important aspect is to acknowledge that the validator wallet is identical on all nodes and all nodes and validators are listening while only one talks at a time. So a node might have 30 validators of 32 ETH each, but all of them on one node move at the same time. \n\nThe observed DDOS attack vector was able to predict the IP address of the upcoming validator and cause finality breakage because the IP address predictable. Thus the defense is to have a sufficient distribution of nodes such that DDOS is multiple factors more expensive and harder to predict. \n\nThis \"who's turn is it to talk\" (and not get slashed requires precise synchronization across nodes that do not have communication between them.\n\nTo accomplish this, a modified and inspired version of a token ring technology and TOTP authentication has been developed.\n\nBy each node having the same wallet, they naturally share a common secret (the sha256 digest of the wallet). By definition this secret is automatically shared between those that use the same wallet. Next, each validator needs to know how many twins it has out there in the world along with which # each validator is.\n\nFor example, there might be 10 nodes using the exact same keys (which is the wonderful side effect of allowing near 100% redundancy), thus,\nLaptop id #1\nVPS #2 \nand so on\n\nImportant again that each node instance only use the ID once. \n\nAnother important operational aspect is that it is essential to shut all the validators down (in all node locations) before adding new validators or twins, and then spool them back up when ready.\n\nSince node rotation is driven by time, time synchronization is essential. Of course ETH2 already relies on time sync and roughtime thus this issue is largely mitigated.\n\nSimilar to the math associated to the lottery, if there are three nodes with the exact same wallet, the sequence is:\n\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n\nWhich of the 6 above options is determined based on the sha256 digest of the wallet (the secret).\n\nFrom statistics, we have:\n3 replicas - 6 possible sequences\n4 replicas - 24 possible sequences\n5 replicas - 120 possible sequences\n6 replicas - 720 possible sequences\n\nNow comes in the third attribute, the time duration between node rotation. One the validator has adjusted its time w roughtime , we can assume the nodes are all in sync with time (if not ETH2 wouldn't work anyway). Now we have a defense point in time (01 Jan 1970). \n\nThe default time between node rotation is 10 minutes (600 seconds). To ensure no propagation collisions, the final attribute of node collision gap is added (with a default of 3s). Thus it is recommended to have the validator drop all validator requests for the first and last Xs during its \"turn to talk\". Depending on how long the time between node rotation, one can predict the node loss of efficiency. (with 3s / 600s being 99.5% which should be acceptable given the benefits).\n\nThe above table with 3 nodes will clearly become exponentially larger the mode nodes you have. That said, the more nodes, the more robust the redundancy and harder it is to attack the \"right\" validator as predicting the sequence becomes a challenge, especially if the time between node rotation is tight (but you sacrifice node efficiency (which can be \"tuned\" with the gap timing) . \n\nThere is virtually no consequence for selecting too many node replicas when fewer exist however the opposite is not true as it would cause some slashing. \n\nThe above is currently a patch to the given architecture and should be integrated deeper into the protocol and not only at the client. Further, the underlying validator (not only the node) could also migrate around independent of the node, but that can be addressed in the future.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/665587579",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/6738#issuecomment-665587579",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738",
    "id": 665587579,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2NTU4NzU3OQ==",
    "user": {
      "login": "mrabino1",
      "id": 4902221,
      "node_id": "MDQ6VXNlcjQ5MDIyMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4902221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrabino1",
      "html_url": "https://github.com/mrabino1",
      "followers_url": "https://api.github.com/users/mrabino1/followers",
      "following_url": "https://api.github.com/users/mrabino1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrabino1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrabino1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrabino1/subscriptions",
      "organizations_url": "https://api.github.com/users/mrabino1/orgs",
      "repos_url": "https://api.github.com/users/mrabino1/repos",
      "events_url": "https://api.github.com/users/mrabino1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrabino1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-29T10:38:21Z",
    "updated_at": "2020-07-29T10:38:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "As a follow-on... if we only follow a defined sequence as outlined above and repeat it.. over enough time, that sequence could also be tracked and \"broken\". Thus, in a similar way we have a OTP that creates 6 (or X) digits based on the hash of the current time and the secret, we need to include a constraint of max #... but otherwise, the objective is that sequence of which replica is allowed to talk should OTP hash randomized such that following the replica sequence is unpredictable. and by the time a node has validated, etc.. the would-be attacker has no idea which other node in the world would speak next. So even if over a period of a month (or longer depending on how many validators a user was using and how many replicas existed), even if all of the IP addresses of the nodes were determined.. because they keep quasi-randomly changing who responds.. an attacker wont have the resources to attack all of them all of the time.",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/665587579/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/669017475",
    "html_url": "https://github.com/prysmaticlabs/prysm/issues/6738#issuecomment-669017475",
    "issue_url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/6738",
    "id": 669017475,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2OTAxNzQ3NQ==",
    "user": {
      "login": "mrabino1",
      "id": 4902221,
      "node_id": "MDQ6VXNlcjQ5MDIyMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4902221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrabino1",
      "html_url": "https://github.com/mrabino1",
      "followers_url": "https://api.github.com/users/mrabino1/followers",
      "following_url": "https://api.github.com/users/mrabino1/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrabino1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrabino1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrabino1/subscriptions",
      "organizations_url": "https://api.github.com/users/mrabino1/orgs",
      "repos_url": "https://api.github.com/users/mrabino1/repos",
      "events_url": "https://api.github.com/users/mrabino1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrabino1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-05T06:57:09Z",
    "updated_at": "2020-08-05T06:57:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "following on\n\nTOTP has already been battle tested. We already have a shared keystore so we can compute the sha256 of that keystore for uniqueness. That sha256 digest is the TOTP secret\n\nTOTP generates a 6 digit code that changes every X seconds. \n\nonce we know how many clones / replica validator nodes we will have (and each one has a constant number), we should have to do the following to that TOTP code\n\nround(({TOTP}/1000000)*{number of replicas))\n\nthis will uniquely determine which node / clone / replica should talk at any given time. ",
    "reactions": {
      "url": "https://api.github.com/repos/prysmaticlabs/prysm/issues/comments/669017475/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
