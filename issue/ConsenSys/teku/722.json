{
  "url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
  "repository_url": "https://api.github.com/repos/ConsenSys/teku",
  "labels_url": "https://api.github.com/repos/ConsenSys/teku/issues/722/labels{/name}",
  "comments_url": "https://api.github.com/repos/ConsenSys/teku/issues/722/comments",
  "events_url": "https://api.github.com/repos/ConsenSys/teku/issues/722/events",
  "html_url": "https://github.com/ConsenSys/teku/issues/722",
  "id": 457049411,
  "node_id": "MDU6SXNzdWU0NTcwNDk0MTE=",
  "number": 722,
  "title": "v0.7.1 Beacon Chain Updates",
  "user": {
    "login": "dangerousfood",
    "id": 4099038,
    "node_id": "MDQ6VXNlcjQwOTkwMzg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dangerousfood",
    "html_url": "https://github.com/dangerousfood",
    "followers_url": "https://api.github.com/users/dangerousfood/followers",
    "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
    "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
    "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
    "repos_url": "https://api.github.com/users/dangerousfood/repos",
    "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-06-17T17:19:37Z",
  "updated_at": "2019-06-21T19:17:38Z",
  "closed_at": "2019-06-21T19:17:38Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Update TODO\r\n\r\n### Constants\r\n\r\n- [x]  `MAX_INDICES_PER_ATTESTATION` added\r\n- [x]  `MIN_PER_EPOCH_CHURN_LIMIT` added\r\n- [x]  `CHURN_LIMIT_QUOTIENT` added\r\n- [x]  `BASE_REWARDS_PER_EPOCH` added\r\n\r\n- [x]  `MAX_BALANCE_CHURN_QUOTIENT` removed\r\n- [x]  `MAX_INDICES_PER_SLASHABLE_VOTE` removed\r\n- [x]  `MAX_EXIT_DEQUEUES_PER_EPOCH` removed\r\n\r\n- [x]  `MAX_DEPOSIT_AMOUNT` removed\r\n- [x]  `MAX_EFFECTIVE_BALANCE` added\r\n\r\n- [x]  `FORK_CHOICE_BALANCE_INCREMENT` removed\r\n- [x]  `EFFECTIVE_BALANCE_INCREMENT` added\r\n\r\n- [x]  `GENESIS_FORK_VERSION` removed\r\n- [x]  `GENESIS_SLOT` modified\r\n- [x]  `GENESIS_EPOCH` modified\r\n- [x]  `GENESIS_START_SHARD` removed\r\n\r\n- [x]  `ZERO_HASH` modified\r\n- [x]  `EMPTY_SIGNATURE` removed\r\n- [x]  `BLS_WITHDRAWAL_PREFIX_BYTE` removed\r\n- [x]  `BLS_WITHDRAWAL_PREFIX` added\r\n\r\n- [x]  `SECONDS_PER_SLOT` removed\r\n- [x]  `EPOCHS_PER_ETH1_VOTING_PERIOD` removed\r\n\r\n- [x]  `SLOTS_PER_ETH1_VOTING_PERIOD` added\r\n- [x]  `MAX_EPOCHS_PER_CROSSLINK` added\r\n- [x]  `MIN_EPOCHS_TO_INACTIVITY_PENALTY` added\r\n- [x]  `MAX_EPOCHS_PER_CROSSLINK` added\r\n\r\n- [x]  `BASE_REWARD_QUOTIENT` -> `BASE_REWARD_FACTOR`\r\n- [x]  `ATTESTATION_INCLUSION_REWARD_QUOTIENT` -> `PROPOSER_REWARD_QUOTIENT`\r\n- [x]  `MIN_PENALTY_QUOTIENT` -> `MIN_SLASHING_PENALTY_QUOTIENT`\r\n\r\n- [x]  `MAX_TRANSFERS` modified\r\n- [x]  `DOMAIN_BEACON_BLOCK` -> `DOMAIN_BEACON_PROPOSER`\r\n\r\n### Datastructures\r\n\r\n- [x]  `Eth1DataVote` removed\r\n- [x]  `SlashableAttestation` removed\r\n- [x]  `DepositInput` removed\r\n\r\n- [x]  `IndexedAttestation` added\r\n- [x]  `Fork` modified\r\n- [x]  `Crosslink` modified\r\n- [x]  `AttestationData` modified\r\n- [x]  `IndexedAttestation` modified\r\n\r\n- [x]  `PendingAttestation` modified\r\n- [x]  `DepositData` modified\r\n\r\n- [x]  `BeaconBlockHeader` modified\r\n- [x]  `AttesterSlashing` modified\r\n- [x]  `BeaconBlockBody` modified\r\n- [x]  `BeaconBlock` modified\r\n- [x]  `BeaconState` modified\r\n\r\n### Helper Functions\r\n\r\n- [x]  `signed_root` -> `signing_root`\r\n- [x]  `get_temporary_block_header` removed\r\n- [x]  `get_permuted_index` removed\r\n- [x]  `split` removed\r\n- [x]  `get_shuffling` removed\r\n- [x]  `get_previous_epoch_committee_count` removed\r\n- [x]  `get_current_epoch_committee_count` removed\r\n- [x]  `get_next_epoch_committee_count` removed\r\n- [x]  `get_crosslink_committees_at_slot` removed\r\n- [x]  `get_state_root` removed\r\n- [x]  `get_attestation_participants` removed\r\n- [x]  `is_power_of_two` removed \r\n- [ ]  ~~`int_to_bytes1, int_to_bytes2, ...` removed~~\r\n- [x]  `get_effective_balance` removed\r\n- [x]  `get_fork_version` removed\r\n- [x]  `is_double_vote` removed\r\n- [x]  `is_surround_vote` removed\r\n- [x]  `prepare_validator_for_withdrawal` removed\r\n\r\n- [x]  `is_slashable_validator` added\r\n- [x]  `increase_balance` added\r\n- [x]  `decrease_balance` added\r\n- [x]  `get_shard_delta` added\r\n- [x]  `get_epoch_start_shard` added\r\n- [x]  `get_attestation_data_slot` added\r\n- [x]  `get_block_root_at_slot` added\r\n- [x]  `get_shuffled_index` added\r\n- [x]  `compute_committee` added\r\n- [x]  `get_crosslink_committee` added\r\n- [x]  `get_attesting_indices` added\r\n- [ ]  ~~`int_to_bytes` added~~\r\n- [x]  `convert_to_indexed` added\r\n- [x]  `validate_indexed_attestation` added\r\n- [x]  `is_slashable_attestation_data` added\r\n- [x]  `get_churn_limit` added\r\n- [x]  `bls_domain` added\r\n\r\n- [ ]  ~~`xor` modified~~\r\n- [ ]  ~~`hash` modified~~\r\n- [x]  `signing_root` modified\r\n- [x]  `get_previous_epoch` modified\r\n- [x]  `is_slashable_validator ` modified\r\n- [x]  `get_active_validator_indices` modified\r\n- [x]  `get_epoch_committee_count` modified\r\n- [x]  `get_block_root` modified\r\n- [x]  `get_randao_mix` modified\r\n- [x]  `get_active_index_root` modified\r\n- [x]  `generate_seed` modified\r\n- [x]  `get_beacon_proposer_index` modified\r\n- [x]  `get_attesting_indices` modified\r\n- [x]  `get_total_balance` modified\r\n- [x]  `get_domain` modified\r\n\r\n### State Processing\r\n- [ ]  `get_genesis_beacon_state` modified\r\n- [x]  `state_transition` added\r\n- [x]  `process_slots` added\r\n- [x]  `process_slot` added\r\n- [x]  `process_epoch` added\r\n- [x]  `get_total_active_balance` added\r\n- [x]  `get_matching_source_attestations` added\r\n- [x]  `get_matching_target_attestations` added\r\n- [x]  `get_matching_head_attestations` added\r\n- [x]  `get_unslashed_attesting_indices` added\r\n- [x]  `get_attesting_balance` modified\r\n- [x]  `get_winning_crosslink_and_attesting_indices` added\r\n- [x]  `process_justification_and_finalization` added\r\n- [x]  `process_crosslinks` modified\r\n- [x]  `get_base_reward` modified\r\n- [x]  `get_attestation_deltas` added\r\n- [x]  `get_crosslink_deltas` modified\r\n- [x]  `process_rewards_and_penalties` added\r\n- [x]  `process_registry_updates` added\r\n- [x]  `process_slashings` modified\r\n- [x]  `process_final_updates` added\r\n- [x]  `process_block` added\r\n- [x]  `process_block_header` modified\r\n- [x]  `process_randao` modified\r\n- [x]  `process_eth1_data` modified\r\n- [x]  `process_operations` added\r\n- [x]  `process_proposer_slashing` modified\r\n- [x]  `process_attester_slashing` modified\r\n- [x]  `process_attestation` modified\r\n- [x]  `process_deposit` modified\r\n- [x]  `process_voluntary_exit` modified\r\n- [x]  `process_transfer` modified",
  "closed_by": {
    "login": "dangerousfood",
    "id": 4099038,
    "node_id": "MDQ6VXNlcjQwOTkwMzg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dangerousfood",
    "html_url": "https://github.com/dangerousfood",
    "followers_url": "https://api.github.com/users/dangerousfood/followers",
    "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
    "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
    "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
    "repos_url": "https://api.github.com/users/dangerousfood/repos",
    "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/722/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ConsenSys/teku/issues/722/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502783053",
    "html_url": "https://github.com/ConsenSys/teku/issues/722#issuecomment-502783053",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
    "id": 502783053,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjc4MzA1Mw==",
    "user": {
      "login": "dangerousfood",
      "id": 4099038,
      "node_id": "MDQ6VXNlcjQwOTkwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dangerousfood",
      "html_url": "https://github.com/dangerousfood",
      "followers_url": "https://api.github.com/users/dangerousfood/followers",
      "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
      "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
      "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
      "repos_url": "https://api.github.com/users/dangerousfood/repos",
      "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-17T17:44:31Z",
    "updated_at": "2019-06-17T18:32:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "## Data structures\r\n\r\nThe following data structures are defined as [SimpleSerialize (SSZ)](../simple-serialize.md) objects.\r\n\r\nThe types are defined topologically to aid in facilitating an executable version of the spec.\r\n\r\n### Misc dependencies\r\n\r\n#### `Fork`\r\n\r\n```python\r\nclass Fork(Container):\r\n    # Previous fork version\r\n    previous_version: Bytes4\r\n    # Current fork version\r\n    current_version: Bytes4\r\n    # Fork epoch number\r\n    epoch: uint64\r\n```\r\n\r\n#### `Validator`\r\n\r\n<pre>python\r\nclass Validator(Container):\r\n    # BLS public key\r\n    pubkey: Bytes48\r\n    # Withdrawal credentials\r\n    withdrawal_credentials: Bytes32\r\n    # Epoch when became eligible for activation\r\n    activation_eligibility_epoch: uint64\r\n    # Epoch when validator activated\r\n    activation_epoch: uint64\r\n    # Epoch when validator exited\r\n    exit_epoch: uint64\r\n    # Epoch when validator is eligible to withdraw\r\n    withdrawable_epoch: uint64\r\n    # Was the validator slashed\r\n    slashed: bool\r\n    # Effective balance\r\n   <b>effective_balance: uint64</b>\r\n</pre>\r\n\r\n#### `Crosslink`\r\n\r\n<pre>python\r\nclass Crosslink(Container):\r\n    # Shard number\r\n    <b>shard: uint64</b>\r\n    # Crosslinking data from epochs [start....end-1]\r\n    <b>start_epoch: uint64</b>\r\n    <b>end_epoch: uint64</b>\r\n    # Root of the previous crosslink\r\n    <b>parent_root: Bytes32</b>\r\n    # Root of the crosslinked shard data since the previous crosslink\r\n    <b>data_root: Bytes32</b>\r\n</pre>\r\n\r\n#### `AttestationData`\r\n\r\n<pre>python\r\nclass AttestationData(Container):\r\n    # LMD GHOST vote\r\n    beacon_block_root: Bytes32\r\n    # FFG vote\r\n    source_epoch: uint64\r\n    source_root: Bytes32\r\n    <b>target_epoch: uint64</b>\r\n    target_root: Bytes32\r\n    # Crosslink vote\r\n    <b>crosslink: Crosslink</b>\r\n</pre>\r\n\r\n#### `AttestationDataAndCustodyBit`\r\n\r\n```python\r\nclass AttestationDataAndCustodyBit(Container):\r\n    # Attestation data\r\n    data: AttestationData\r\n    # Custody bit\r\n    custody_bit: bool\r\n```\r\n\r\n#### `IndexedAttestation`\r\n\r\n<pre>python\r\n<b>class IndexedAttestation(Container):</b>\r\n    # Validator indices\r\n    <b>custody_bit_0_indices: List[uint64]</b>\r\n    <b>custody_bit_1_indices: List[uint64]</b>\r\n    # Attestation data\r\n    data: AttestationData\r\n    # Aggregate signature\r\n    <b>signature: Bytes96</b>\r\n</pre>\r\n\r\n#### `PendingAttestation`\r\n\r\n<pre>python\r\nclass PendingAttestation(Container):\r\n    # Attester aggregation bitfield\r\n    aggregation_bitfield: bytes\r\n    # Attestation data\r\n    data: AttestationData\r\n    # Inclusion delay\r\n    <b>inclusion_delay: uint64</b>\r\n    # Proposer index\r\n    <b>proposer_index: uint64</b>\r\n</pre>\r\n\r\n#### `Eth1Data`\r\n\r\n```python\r\nclass Eth1Data(Container):\r\n    # Root of the deposit tree\r\n    deposit_root: Bytes32\r\n    # Total number of deposits\r\n    deposit_count: uint64\r\n    # Block hash\r\n    block_hash: Bytes32\r\n```\r\n\r\n#### `HistoricalBatch`\r\n\r\n```python\r\nclass HistoricalBatch(Container):\r\n    # Block roots\r\n    block_roots: Vector[Bytes32, SLOTS_PER_HISTORICAL_ROOT]\r\n    # State roots\r\n    state_roots: Vector[Bytes32, SLOTS_PER_HISTORICAL_ROOT]\r\n```\r\n\r\n#### `DepositData`\r\n\r\n<pre>python\r\nclass DepositData(Container):\r\n    # BLS pubkey\r\n    <b>pubkey: Bytes48</b>\r\n    # Withdrawal credentials\r\n    <b>withdrawal_credentials: Bytes32</b>\r\n    # Amount in Gwei\r\n    amount: uint64\r\n    # Container self-signature\r\n    <b>signature: Bytes96</b>\r\n</pre>\r\n\r\n#### `BeaconBlockHeader`\r\n\r\n```python\r\nclass BeaconBlockHeader(Container):\r\n    slot: uint64\r\n    <b>parent_root: Bytes32</b>\r\n    state_root: Bytes32\r\n    <b>body_root: Bytes32</b>\r\n    signature: Bytes96\r\n```\r\n\r\n### Beacon operations\r\n\r\n#### `ProposerSlashing`\r\n\r\n```python\r\nclass ProposerSlashing(Container):\r\n    # Proposer index\r\n    proposer_index: uint64\r\n    # First block header\r\n    header_1: BeaconBlockHeader\r\n    # Second block header\r\n    header_2: BeaconBlockHeader\r\n```\r\n\r\n#### `AttesterSlashing`\r\n\r\n<pre>python\r\nclass AttesterSlashing(Container):\r\n    # First attestation\r\n    <b>attestation_1: IndexedAttestation</b>\r\n    # Second attestation\r\n    <b>attestation_2: IndexedAttestation</b>\r\n</pre>\r\n\r\n#### `Attestation`\r\n\r\n```python\r\nclass Attestation(Container):\r\n    # Attester aggregation bitfield\r\n    aggregation_bitfield: bytes\r\n    # Attestation data\r\n    data: AttestationData\r\n    # Custody bitfield\r\n    custody_bitfield: bytes\r\n    # BLS aggregate signature\r\n    signature: Bytes96\r\n```\r\n\r\n#### `Deposit`\r\nindex field removed\r\n```python\r\nclass Deposit(Container):\r\n    # Branch in the deposit tree\r\n    proof: Vector[Bytes32, DEPOSIT_CONTRACT_TREE_DEPTH]\r\n    # Data\r\n    data: DepositData\r\n```\r\n\r\n#### `VoluntaryExit`\r\n\r\n```python\r\nclass VoluntaryExit(Container):\r\n    # Minimum epoch for processing exit\r\n    epoch: uint64\r\n    # Index of the exiting validator\r\n    validator_index: uint64\r\n    # Validator signature\r\n    signature: Bytes96\r\n```\r\n\r\n#### `Transfer`\r\n\r\n```python\r\nclass Transfer(Container):\r\n    # Sender index\r\n    sender: uint64\r\n    # Recipient index\r\n    recipient: uint64\r\n    # Amount in Gwei\r\n    amount: uint64\r\n    # Fee in Gwei for block proposer\r\n    fee: uint64\r\n    # Inclusion slot\r\n    slot: uint64\r\n    # Sender withdrawal pubkey\r\n    pubkey: Bytes48\r\n    # Sender signature\r\n    signature: Bytes96\r\n```\r\n\r\n### Beacon blocks\r\n\r\n#### `BeaconBlockBody`\r\n\r\n<pre>python\r\nclass BeaconBlockBody(Container):\r\n    randao_reveal: Bytes96\r\n    eth1_data: Eth1Data\r\n    <b>graffiti: Bytes32</b>\r\n    proposer_slashings: List[ProposerSlashing]\r\n    attester_slashings: List[AttesterSlashing]\r\n    attestations: List[Attestation]\r\n    deposits: List[Deposit]\r\n    voluntary_exits: List[VoluntaryExit]\r\n    transfers: List[Transfer]\r\n</pre>\r\n\r\n#### `BeaconBlock`\r\n\r\n<pre>python\r\nclass BeaconBlock(Container):\r\n    # Header\r\n    slot: uint64\r\n    <b>parent_root: Bytes32</b>\r\n    state_root: Bytes32\r\n    body: BeaconBlockBody\r\n    signature: Bytes96\r\n</pre>\r\n\r\n### Beacon state\r\n\r\n#### `BeaconState`\r\n\r\n<pre>python\r\nclass BeaconState(Container):\r\n    # Misc\r\n    slot: uint64\r\n    genesis_time: uint64\r\n    fork: Fork  # For versioning hard forks\r\n    # Validator registry\r\n    validator_registry: List[Validator]\r\n    <b>balances: List[uint64]</b>\r\n    # Randomness and committees\r\n    latest_randao_mixes: Vector[Bytes32, LATEST_RANDAO_MIXES_LENGTH]\r\n    <b>latest_start_shard: uint64</b>\r\n    # Finality\r\n    previous_epoch_attestations: List[PendingAttestation]\r\n    current_epoch_attestations: List[PendingAttestation]\r\n    previous_justified_epoch: uint64\r\n    current_justified_epoch: uint64\r\n    previous_justified_root: Bytes32\r\n    current_justified_root: Bytes32\r\n    justification_bitfield: uint64\r\n    finalized_epoch: uint64\r\n    finalized_root: Bytes32\r\n    # Recent state\r\n    <b>current_crosslinks: Vector[Crosslink, SHARD_COUNT]</b>\r\n    <b>previous_crosslinks: Vector[Crosslink, SHARD_COUNT]</b>\r\n    latest_block_roots: Vector[Bytes32, SLOTS_PER_HISTORICAL_ROOT]\r\n    latest_state_roots: Vector[Bytes32, SLOTS_PER_HISTORICAL_ROOT]\r\n    latest_active_index_roots: Vector[Bytes32, LATEST_ACTIVE_INDEX_ROOTS_LENGTH]\r\n    latest_slashed_balances: Vector[uint64, LATEST_SLASHED_EXIT_LENGTH]\r\n    latest_block_header: BeaconBlockHeader\r\n    historical_roots: List[Bytes32]\r\n    # Ethereum 1.0 chain data\r\n    latest_eth1_data: Eth1Data\r\n    <b>eth1_data_votes: List[Eth1Data]</b>\r\n    deposit_index: uint64\r\n</pre>\r\n\r\n## Custom types\r\n\r\nWe define the following Python custom types for type hinting and readability:\r\n\r\n| Name | SSZ equivalent | Description |\r\n| - | - | - |\r\n| `Slot` | `uint64` | a slot number |\r\n| `Epoch` | `uint64` | an epoch number |\r\n| `Shard` | `uint64` | a shard number |\r\n| `ValidatorIndex` | `uint64` | a validator registry index |\r\n| `Gwei` | `uint64` | an amount in Gwei |\r\n| `BLSPubkey` | `Bytes48` | a BLS12-381 public key |\r\n| `BLSSignature` | `Bytes96` | a BLS12-381 signature |",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502783053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502800313",
    "html_url": "https://github.com/ConsenSys/teku/issues/722#issuecomment-502800313",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
    "id": 502800313,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjgwMDMxMw==",
    "user": {
      "login": "dangerousfood",
      "id": 4099038,
      "node_id": "MDQ6VXNlcjQwOTkwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dangerousfood",
      "html_url": "https://github.com/dangerousfood",
      "followers_url": "https://api.github.com/users/dangerousfood/followers",
      "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
      "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
      "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
      "repos_url": "https://api.github.com/users/dangerousfood/repos",
      "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-17T18:33:28Z",
    "updated_at": "2019-06-17T19:24:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "## Helper functions\r\n\r\n*Note*: The definitions below are for specification purposes and are not necessarily optimal implementations.\r\n\r\n### `xor`\r\n\r\n<pre>python\r\ndef xor(bytes1: Bytes32, bytes2: Bytes32) -> Bytes32:\r\n    <b>return Bytes32(a ^ b for a, b in zip(bytes1, bytes2))</b>\r\n</pre>\r\n### `hash`\r\n\r\n**The `hash` function is SHA256.**\r\n\r\n*Note*: We aim to migrate to a S[T/N]ARK-friendly hash function in a future Ethereum 2.0 deployment phase.\r\n\r\n### `hash_tree_root`\r\n\r\n`def hash_tree_root(object: SSZSerializable) -> Bytes32` is a function for hashing objects into a single root utilizing a hash tree structure. `hash_tree_root` is defined in the [SimpleSerialize spec](../simple-serialize.md#merkleization).\r\n\r\n### `signing_root`\r\n\r\n**`def signing_root(object: Container) -> Bytes32`** is a function defined in the [SimpleSerialize spec](../simple-serialize.md#self-signed-containers) to compute signing messages.\r\n\r\n### **`bls_domain`**\r\n\r\n<pre>python\r\n<b>def bls_domain(domain_type: int, fork_version: bytes=b'\\x00\\x00\\x00\\x00') -> int:\r\n    \"\"\"\r\n    Return the bls domain given by the ``domain_type`` and optional 4 byte ``fork_version`` (defaults to zero).\r\n    \"\"\"\r\n    return bytes_to_int(int_to_bytes(domain_type, length=4) + fork_version)</b>\r\n</pre>\r\n\r\n### `slot_to_epoch`\r\n\r\n```python\r\ndef slot_to_epoch(slot: Slot) -> Epoch:\r\n    \"\"\"\r\n    Return the epoch number of the given ``slot``.\r\n    \"\"\"\r\n    return slot // SLOTS_PER_EPOCH\r\n```\r\n\r\n### `get_previous_epoch`\r\n\r\n<pre>python\r\ndef get_previous_epoch(state: BeaconState) -> Epoch:\r\n    \"\"\"`\r\n    Return the previous epoch of the given ``state``.\r\n    <b>Return the current epoch if it's genesis epoch.</b>\r\n    \"\"\"\r\n    <b>current_epoch = get_current_epoch(state)\r\n    return GENESIS_EPOCH if current_epoch == GENESIS_EPOCH else current_epoch - 1</b>\r\n</pre>\r\n\r\n### `get_current_epoch`\r\n\r\n```python\r\ndef get_current_epoch(state: BeaconState) -> Epoch:\r\n    \"\"\"\r\n    Return the current epoch of the given ``state``.\r\n    \"\"\"\r\n    return slot_to_epoch(state.slot)\r\n```\r\n\r\n### `get_epoch_start_slot`\r\n\r\n```python\r\ndef get_epoch_start_slot(epoch: Epoch) -> Slot:\r\n    \"\"\"\r\n    Return the starting slot of the given ``epoch``.\r\n    \"\"\"\r\n    return epoch * SLOTS_PER_EPOCH\r\n```\r\n\r\n### `is_active_validator`\r\n\r\n```python\r\ndef is_active_validator(validator: Validator, epoch: Epoch) -> bool:\r\n    \"\"\"\r\n    Check if ``validator`` is active.\r\n    \"\"\"\r\n    return validator.activation_epoch <= epoch < validator.exit_epoch\r\n```\r\n\r\n### **`is_slashable_validator`**\r\n\r\n<pre>python\r\n<b>def is_slashable_validator(validator: Validator, epoch: Epoch) -> bool:\r\n    \"\"\"\r\n    Check if ``validator`` is slashable.\r\n    \"\"\"\r\n    return validator.slashed is False and (validator.activation_epoch <= epoch < validator.withdrawable_epoch)</b>\r\n</pre>\r\n\r\n### `get_active_validator_indices`\r\n\r\n<pre>python\r\ndef get_active_validator_indices(<b>state: BeaconState</b>, epoch: Epoch) -> List[ValidatorIndex]:\r\n    \"\"\"\r\n    <b>Get active validator indices at ``epoch``.</b>\r\n    \"\"\"\r\n    <b>return [i for i, v in enumerate(state.validator_registry) if is_active_validator(v, epoch)]</b>\r\n</pre>\r\n\r\n### **`increase_balance`**\r\n\r\n<pre>python\r\n<b>def increase_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -> None:\r\n    \"\"\"\r\n    Increase validator balance by ``delta``.\r\n    \"\"\"\r\n    state.balances[index] += delta</b>\r\n</pre>\r\n\r\n### **`decrease_balance`**\r\n\r\n<pre>python\r\n<b>def decrease_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -> None:\r\n    \"\"\"\r\n    Decrease validator balance by ``delta`` with underflow protection.\r\n    \"\"\"\r\n    state.balances[index] = 0 if delta > state.balances[index] else state.balances[index] - delta</b>\r\n</pre>\r\n\r\n### `get_epoch_committee_count`\r\n\r\n<pre>python\r\ndef get_epoch_committee_count(<b>state: BeaconState, epoch: Epoch</b>) -> int:\r\n    \"\"\"\r\n    <b>Return the number of committees at ``epoch``.</b>\r\n    \"\"\"\r\n    <b>active_validator_indices = get_active_validator_indices(state, epoch)</b>\r\n    return max(\r\n        1,\r\n        min(\r\n            SHARD_COUNT // SLOTS_PER_EPOCH,\r\n            <b>len(active_validator_indices)</b> // SLOTS_PER_EPOCH // TARGET_COMMITTEE_SIZE,\r\n        )\r\n    ) * SLOTS_PER_EPOCH\r\n</pre>\r\n\r\n### **`get_shard_delta`**\r\n\r\n<pre>python\r\n<b>def get_shard_delta(state: BeaconState, epoch: Epoch) -> int:\r\n    \"\"\"\r\n    Return the number of shards to increment ``state.latest_start_shard`` during ``epoch``.\r\n    \"\"\"\r\n    return min(get_epoch_committee_count(state, epoch), SHARD_COUNT - SHARD_COUNT // SLOTS_PER_EPOCH)</b>\r\n</pre>\r\n\r\n### **`get_epoch_start_shard`**\r\n\r\n<pre>python\r\n<b>def get_epoch_start_shard(state: BeaconState, epoch: Epoch) -> Shard:\r\n    assert epoch <= get_current_epoch(state) + 1\r\n    check_epoch = get_current_epoch(state) + 1\r\n    shard = (state.latest_start_shard + get_shard_delta(state, get_current_epoch(state))) % SHARD_COUNT\r\n    while check_epoch > epoch:\r\n        check_epoch -= 1\r\n        shard = (shard + SHARD_COUNT - get_shard_delta(state, check_epoch)) % SHARD_COUNT\r\n    return shard</b>\r\n</pre>\r\n\r\n### **`get_attestation_data_slot`**\r\n\r\n<pre>python\r\n<b>def get_attestation_data_slot(state: BeaconState, data: AttestationData) -> Slot:\r\n    committee_count = get_epoch_committee_count(state, data.target_epoch)\r\n    offset = (data.crosslink.shard + SHARD_COUNT - get_epoch_start_shard(state, data.target_epoch)) % SHARD_COUNT\r\n    return get_epoch_start_slot(data.target_epoch) + offset // (committee_count // SLOTS_PER_EPOCH)</b>\r\n</pre>\r\n\r\n### **`get_block_root_at_slot`**\r\n\r\n<pre>python\r\n<b>def get_block_root_at_slot(state: BeaconState,\r\n                           slot: Slot) -> Bytes32:\r\n    \"\"\"\r\n    Return the block root at a recent ``slot``.\r\n    \"\"\"\r\n    assert slot < state.slot <= slot + SLOTS_PER_HISTORICAL_ROOT\r\n    return state.latest_block_roots[slot % SLOTS_PER_HISTORICAL_ROOT]</b>\r\n</pre>\r\n\r\n### `get_block_root`\r\n\r\n<pre>python\r\ndef get_block_root(state: BeaconState,\r\n                   <b>epoch: Epoch</b>) -> Bytes32:\r\n    \"\"\"\r\n    Return the block root at a recent <b>``epoch``</b>.\r\n    \"\"\"\r\n    <b>return get_block_root_at_slot(state, get_epoch_start_slot(epoch))</b>\r\n</pre>\r\n\r\n### `get_randao_mix`\r\n\r\n<pre>python\r\ndef get_randao_mix(state: BeaconState,\r\n                   epoch: Epoch) -> Bytes32:\r\n    \"\"\"\r\n    Return the randao mix at a recent ``epoch``.\r\n    <b>``epoch`` expected to be between (current_epoch - LATEST_RANDAO_MIXES_LENGTH, current_epoch].</b>\r\n    \"\"\"\r\n    <b>return state.latest_randao_mixes[epoch % LATEST_RANDAO_MIXES_LENGTH]</b>\r\n</pre>\r\n\r\n### `get_active_index_root`\r\n\r\n<pre>python\r\ndef get_active_index_root(state: BeaconState,\r\n                          epoch: Epoch) -> Bytes32:\r\n    \"\"\"\r\n    Return the index root at a recent ``epoch``.\r\n    <b>``epoch`` expected to be between\r\n    (current_epoch - LATEST_ACTIVE_INDEX_ROOTS_LENGTH + ACTIVATION_EXIT_DELAY, current_epoch + ACTIVATION_EXIT_DELAY].</b>\r\n    \"\"\"\r\n    <b>return state.latest_active_index_roots[epoch % LATEST_ACTIVE_INDEX_ROOTS_LENGTH]</b>\r\n</pre>\r\n\r\n### `generate_seed`\r\n\r\n<pre>python\r\ndef generate_seed(state: BeaconState,\r\n                  epoch: Epoch) -> Bytes32:\r\n    \"\"\"\r\n    Generate a seed for the given ``epoch``.\r\n    \"\"\"\r\n    return hash(\r\n       <b>get_randao_mix(state, epoch + LATEST_RANDAO_MIXES_LENGTH - MIN_SEED_LOOKAHEAD) +\r\n        get_active_index_root(state, epoch) +\r\n        int_to_bytes(epoch, length=32)</b>\r\n    )\r\n</pre>\r\n\r\n### `get_beacon_proposer_index`\r\n\r\n<pre>python\r\ndef get_beacon_proposer_index(<b>state: BeaconState</b>) -> ValidatorIndex:\r\n    \"\"\"\r\n    <b>Return the current beacon proposer index.</b>\r\n    \"\"\"\r\n    <b>epoch = get_current_epoch(state)\r\n    committees_per_slot = get_epoch_committee_count(state, epoch) // SLOTS_PER_EPOCH\r\n    offset = committees_per_slot * (state.slot % SLOTS_PER_EPOCH)\r\n    shard = (get_epoch_start_shard(state, epoch) + offset) % SHARD_COUNT\r\n    first_committee = get_crosslink_committee(state, epoch, shard)\r\n    MAX_RANDOM_BYTE = 2**8 - 1\r\n    seed = generate_seed(state, epoch)\r\n    i = 0\r\n    while True:\r\n        candidate_index = first_committee[(epoch + i) % len(first_committee)]\r\n        random_byte = hash(seed + int_to_bytes(i // 32, length=8))[i % 32]\r\n        effective_balance = state.validator_registry[candidate_index].effective_balance\r\n        if effective_balance * MAX_RANDOM_BYTE >= MAX_EFFECTIVE_BALANCE * random_byte:\r\n            return candidate_index\r\n        i += 1</b>\r\n</pre>\r\n\r\n### `verify_merkle_branch`\r\n\r\n```python\r\ndef verify_merkle_branch(leaf: Bytes32, proof: List[Bytes32], depth: int, index: int, root: Bytes32) -> bool:\r\n    \"\"\"\r\n    Verify that the given ``leaf`` is on the merkle branch ``proof``\r\n    starting with the given ``root``.\r\n    \"\"\"\r\n    value = leaf\r\n    for i in range(depth):\r\n        if index // (2**i) % 2:\r\n            value = hash(proof[i] + value)\r\n        else:\r\n            value = hash(value + proof[i])\r\n    return value == root\r\n```\r\n\r\n### **`get_shuffled_index`**\r\n\r\n<pre>python\r\n<b>def get_shuffled_index(index: ValidatorIndex, index_count: int, seed: Bytes32) -> ValidatorIndex:\r\n    \"\"\"\r\n    Return the shuffled validator index corresponding to ``seed`` (and ``index_count``).\r\n    \"\"\"\r\n    assert index < index_count\r\n    assert index_count <= 2**40\r\n    # Swap or not (https://link.springer.com/content/pdf/10.1007%2F978-3-642-32009-5_1.pdf)\r\n    # See the 'generalized domain' algorithm on page 3\r\n    for round in range(SHUFFLE_ROUND_COUNT):\r\n        pivot = bytes_to_int(hash(seed + int_to_bytes(round, length=1))[0:8]) % index_count\r\n        flip = (pivot + index_count - index) % index_count\r\n        position = max(index, flip)\r\n        source = hash(seed + int_to_bytes(round, length=1) + int_to_bytes(position // 256, length=4))\r\n        byte = source[(position % 256) // 8]\r\n        bit = (byte >> (position % 8)) % 2\r\n        index = flip if bit else index\r\n    return index</b>\r\n</pre>\r\n\r\n### **`compute_committee`**\r\n\r\n<pre>python\r\n<b>def compute_committee(indices: List[ValidatorIndex], seed: Bytes32, index: int, count: int) -> List[ValidatorIndex]:\r\n    start = (len(indices) * index) // count\r\n    end = (len(indices) * (index + 1)) // count\r\n    return [indices[get_shuffled_index(i, len(indices), seed)] for i in range(start, end)]</b>\r\n</pre>\r\n\r\n### **`get_crosslink_committee`**\r\n\r\n<pre>python\r\n<b>def get_crosslink_committee(state: BeaconState, epoch: Epoch, shard: Shard) -> List[ValidatorIndex]:\r\n    return compute_committee(\r\n        indices=get_active_validator_indices(state, epoch),\r\n        seed=generate_seed(state, epoch),\r\n        index=(shard + SHARD_COUNT - get_epoch_start_shard(state, epoch)) % SHARD_COUNT,\r\n        count=get_epoch_committee_count(state, epoch),\r\n    )</b>\r\n</pre>\r\n\r\n### `get_attesting_indices`\r\n\r\n<pre>python\r\ndef get_attesting_indices(state: BeaconState,\r\n                          <b>attestation_data: AttestationData,\r\n                          bitfield: bytes</b>) -> List[ValidatorIndex]:\r\n    \"\"\"\r\n    <b>Return the sorted attesting indices corresponding to ``attestation_data`` and ``bitfield``.</b>\r\n    \"\"\"\r\n    <b>committee = get_crosslink_committee(state, attestation_data.target_epoch, attestation_data.crosslink.shard)\r\n    assert verify_bitfield(bitfield, len(committee))\r\n    return sorted([index for i, index in enumerate(committee) if get_bitfield_bit(bitfield, i) == 0b1])</b>\r\n</pre>\r\n\r\n### **`int_to_bytes`**\r\n\r\n<pre>python\r\n<b>def int_to_bytes(integer: int, length: int) -> bytes:\r\n    return integer.to_bytes(length, 'little')</b>\r\n</pre>\r\n\r\n### `bytes_to_int`\r\n\r\n```python\r\ndef bytes_to_int(data: bytes) -> int:\r\n    return int.from_bytes(data, 'little')\r\n```\r\n\r\n### `get_total_balance`\r\n\r\n<pre>python\r\ndef get_total_balance(state: BeaconState, indices: List[ValidatorIndex]) -> Gwei:\r\n    \"\"\"\r\n    <b>Return the combined effective balance of the ``indices``. (1 Gwei minimum to avoid divisions by zero.)</b>\r\n    \"\"\"\r\n    <b>return max(sum([state.validator_registry[index].effective_balance for index in indices]), 1)</b>\r\n</pre>\r\n\r\n### `get_domain`\r\n\r\n<pre>python\r\ndef get_domain(<b>state: BeaconState,\r\n               domain_type: int,\r\n               message_epoch: int=None</b>) -> int:\r\n    \"\"\"\r\n    <b>Return the signature domain (fork version concatenated with domain type) of a message.</b>\r\n    \"\"\"\r\n    <b>epoch = get_current_epoch(state) if message_epoch is None else message_epoch\r\n    fork_version = state.fork.previous_version if epoch < state.fork.epoch else state.fork.current_version\r\n    return bls_domain(domain_type, fork_version)</b>\r\n</pre>\r\n\r\n### `get_bitfield_bit`\r\n\r\n```python\r\ndef get_bitfield_bit(bitfield: bytes, i: int) -> int:\r\n    \"\"\"\r\n    Extract the bit in ``bitfield`` at position ``i``.\r\n    \"\"\"\r\n    return (bitfield[i // 8] >> (i % 8)) % 2\r\n```\r\n\r\n### `verify_bitfield`\r\n\r\n```python\r\ndef verify_bitfield(bitfield: bytes, committee_size: int) -> bool:\r\n    \"\"\"\r\n    Verify ``bitfield`` against the ``committee_size``.\r\n    \"\"\"\r\n    if len(bitfield) != (committee_size + 7) // 8:\r\n        return False\r\n    # Check `bitfield` is padded with zero bits only\r\n    for i in range(committee_size, len(bitfield) * 8):\r\n        if get_bitfield_bit(bitfield, i) == 0b1:\r\n            return False\r\n    return True\r\n```\r\n\r\n### **`convert_to_indexed`**\r\n\r\n<pre>python\r\n<b>def convert_to_indexed(state: BeaconState, attestation: Attestation) -> IndexedAttestation:\r\n    \"\"\"\r\n    Convert ``attestation`` to (almost) indexed-verifiable form.\r\n    \"\"\"\r\n    attesting_indices = get_attesting_indices(state, attestation.data, attestation.aggregation_bitfield)\r\n    custody_bit_1_indices = get_attesting_indices(state, attestation.data, attestation.custody_bitfield)\r\n    custody_bit_0_indices = [index for index in attesting_indices if index not in custody_bit_1_indices]\r\n    return IndexedAttestation(\r\n        custody_bit_0_indices=custody_bit_0_indices,\r\n        custody_bit_1_indices=custody_bit_1_indices,\r\n        data=attestation.data,\r\n        signature=attestation.signature,\r\n    )</b>\r\n</pre>\r\n\r\n### **`validate_indexed_attestation`**\r\n\r\n<pre>python\r\n<b>def validate_indexed_attestation(state: BeaconState, indexed_attestation: IndexedAttestation) -> None:\r\n    \"\"\"\r\n    Verify validity of ``indexed_attestation``.\r\n    \"\"\"\r\n    bit_0_indices = indexed_attestation.custody_bit_0_indices\r\n    bit_1_indices = indexed_attestation.custody_bit_1_indices\r\n    # Verify no index has custody bit equal to 1 [to be removed in phase 1]\r\n    assert len(bit_1_indices) == 0\r\n    # Verify max number of indices\r\n    assert len(bit_0_indices) + len(bit_1_indices) <= MAX_INDICES_PER_ATTESTATION\r\n    # Verify index sets are disjoint\r\n    assert len(set(bit_0_indices).intersection(bit_1_indices)) == 0\r\n    # Verify indices are sorted\r\n    assert bit_0_indices == sorted(bit_0_indices) and bit_1_indices == sorted(bit_1_indices)\r\n    # Verify aggregate signature\r\n    assert bls_verify_multiple(\r\n        pubkeys=[\r\n            bls_aggregate_pubkeys([state.validator_registry[i].pubkey for i in bit_0_indices]),\r\n            bls_aggregate_pubkeys([state.validator_registry[i].pubkey for i in bit_1_indices]),\r\n        ],\r\n        message_hashes=[\r\n            hash_tree_root(AttestationDataAndCustodyBit(data=indexed_attestation.data, custody_bit=0b0)),\r\n            hash_tree_root(AttestationDataAndCustodyBit(data=indexed_attestation.data, custody_bit=0b1)),\r\n        ],\r\n        signature=indexed_attestation.signature,\r\n        domain=get_domain(state, DOMAIN_ATTESTATION, indexed_attestation.data.target_epoch),\r\n    )</b>\r\n</pre>\r\n\r\n### **`is_slashable_attestation_data`**\r\n\r\n<pre>python\r\n<b>def is_slashable_attestation_data(data_1: AttestationData, data_2: AttestationData) -> bool:\r\n    \"\"\"\r\n    Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.\r\n    \"\"\"\r\n    return (\r\n        # Double vote\r\n        (data_1 != data_2 and data_1.target_epoch == data_2.target_epoch) or\r\n        # Surround vote\r\n        (data_1.source_epoch < data_2.source_epoch and data_2.target_epoch < data_1.target_epoch)\r\n    )</b>\r\n</pre>\r\n\r\n### `integer_squareroot`\r\n\r\n```python\r\ndef integer_squareroot(n: int) -> int:\r\n    \"\"\"\r\n    The largest integer ``x`` such that ``x**2`` is less than or equal to ``n``.\r\n    \"\"\"\r\n    assert n >= 0\r\n    x = n\r\n    y = (x + 1) // 2\r\n    while y < x:\r\n        x = y\r\n        y = (x + n // x) // 2\r\n    return x\r\n```\r\n\r\n### `get_delayed_activation_exit_epoch`\r\n\r\n```python\r\ndef get_delayed_activation_exit_epoch(epoch: Epoch) -> Epoch:\r\n    \"\"\"\r\n    Return the epoch at which an activation or exit triggered in ``epoch`` takes effect.\r\n    \"\"\"\r\n    return epoch + 1 + ACTIVATION_EXIT_DELAY\r\n```\r\n\r\n### **`get_churn_limit`**\r\n\r\n<pre>python\r\n<b>def get_churn_limit(state: BeaconState) -> int:\r\n    \"\"\"\r\n    Return the churn limit based on the active validator count.\r\n    \"\"\"\r\n    return max(\r\n        MIN_PER_EPOCH_CHURN_LIMIT,\r\n        len(get_active_validator_indices(state, get_current_epoch(state))) // CHURN_LIMIT_QUOTIENT\r\n    )</b>\r\n</pre>\r\n\r\n### `bls_verify`\r\n\r\n`bls_verify` is a function for verifying a BLS signature, defined in the [BLS Signature spec](../bls_signature.md#bls_verify).\r\n\r\n### `bls_verify_multiple`\r\n\r\n`bls_verify_multiple` is a function for verifying a BLS signature constructed from multiple messages, defined in the [BLS Signature spec](../bls_signature.md#bls_verify_multiple).\r\n\r\n### `bls_aggregate_pubkeys`\r\n\r\n`bls_aggregate_pubkeys` is a function for aggregating multiple BLS public keys into a single aggregate key, defined in the [BLS Signature spec](../bls_signature.md#bls_aggregate_pubkeys).\r\n\r\n### Routines for updating validator status\r\n\r\n*Note*: All functions in this section mutate `state`.\r\n\r\n#### `initiate_validator_exit`\r\n\r\n<pre>python\r\n<b>def initiate_validator_exit(state: BeaconState, index: ValidatorIndex) -> None:\r\n    \"\"\"\r\n    Initiate the exit of the validator of the given ``index``.\r\n    \"\"\"\r\n    # Return if validator already initiated exit\r\n    validator = state.validator_registry[index]\r\n    if validator.exit_epoch != FAR_FUTURE_EPOCH:\r\n        return\r\n    # Compute exit queue epoch\r\n    exit_epochs = [v.exit_epoch for v in state.validator_registry if v.exit_epoch != FAR_FUTURE_EPOCH]\r\n    exit_queue_epoch = max(exit_epochs + [get_delayed_activation_exit_epoch(get_current_epoch(state))])\r\n    exit_queue_churn = len([v for v in state.validator_registry if v.exit_epoch == exit_queue_epoch])\r\n    if exit_queue_churn >= get_churn_limit(state):\r\n        exit_queue_epoch += 1\r\n    # Set validator exit epoch and withdrawable epoch\r\n    validator.exit_epoch = exit_queue_epoch\r\n    validator.withdrawable_epoch = validator.exit_epoch + MIN_VALIDATOR_WITHDRAWABILITY_DELAY</b>\r\n</pre>\r\n\r\n#### `slash_validator`\r\n\r\n<pre>python\r\ndef slash_validator(<b>state: BeaconState,\r\n                    slashed_index: ValidatorIndex,\r\n                    whistleblower_index: ValidatorIndex=None</b>) -> None:\r\n    \"\"\"\r\n    Slash the validator with index ``slashed_index``.\r\n    \"\"\"\r\n    <b>current_epoch = get_current_epoch(state)\r\n    initiate_validator_exit(state, slashed_index)\r\n    state.validator_registry[slashed_index].slashed = True\r\n    state.validator_registry[slashed_index].withdrawable_epoch = current_epoch + LATEST_SLASHED_EXIT_LENGTH\r\n    slashed_balance = state.validator_registry[slashed_index].effective_balance\r\n    state.latest_slashed_balances[current_epoch % LATEST_SLASHED_EXIT_LENGTH] += slashed_balance\r\n    proposer_index = get_beacon_proposer_index(state)\r\n    if whistleblower_index is None:\r\n        whistleblower_index = proposer_index\r\n    whistleblowing_reward = slashed_balance // WHISTLEBLOWING_REWARD_QUOTIENT\r\n    proposer_reward = whistleblowing_reward // PROPOSER_REWARD_QUOTIENT\r\n    increase_balance(state, proposer_index, proposer_reward)\r\n    increase_balance(state, whistleblower_index, whistleblowing_reward - proposer_reward)\r\n    decrease_balance(state, slashed_index, whistleblowing_reward)</b>\r\n</pre>\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502800313/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502818325",
    "html_url": "https://github.com/ConsenSys/teku/issues/722#issuecomment-502818325",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
    "id": 502818325,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjgxODMyNQ==",
    "user": {
      "login": "dangerousfood",
      "id": 4099038,
      "node_id": "MDQ6VXNlcjQwOTkwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dangerousfood",
      "html_url": "https://github.com/dangerousfood",
      "followers_url": "https://api.github.com/users/dangerousfood/followers",
      "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
      "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
      "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
      "repos_url": "https://api.github.com/users/dangerousfood/repos",
      "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-17T19:27:04Z",
    "updated_at": "2019-06-17T20:13:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "## Genesis\r\n\r\n### `Eth2Genesis`\r\n\r\n**When enough deposits of size `MAX_EFFECTIVE_BALANCE` have been made to the deposit contract an `Eth2Genesis` log is emitted triggering the genesis of the beacon chain. Let:**\r\n\r\n* **`eth2genesis` be the object corresponding to `Eth2Genesis`**\r\n* **`genesis_eth1_data` be object of type `Eth1Data` where**\r\n    * **`genesis_eth1_data.deposit_root = eth2genesis.deposit_root`**\r\n    * **`genesis_eth1_data.deposit_count = eth2genesis.deposit_count`**\r\n    * **`genesis_eth1_data.block_hash` is the hash of the Ethereum 1.0 block that emitted the** **`Eth2Genesis` log**\r\n* **`genesis_deposits` be the object of type `List[Deposit]` with deposits ordered chronologically up to and including the deposit that triggered the `Eth2Genesis` log**\r\n\r\n### Genesis state\r\n\r\n**Let `genesis_state = get_genesis_beacon_state(genesis_deposits, eth2genesis.genesis_time, genesis_eth1_data)`.**\r\n\r\n<pre>python\r\ndef get_genesis_beacon_state(deposits: List[Deposit], genesis_time: int, genesis_eth1_data: Eth1Data) -> BeaconState:\r\n    <b>state = BeaconState(\r\n        genesis_time=genesis_time,\r\n        latest_eth1_data=genesis_eth1_data,\r\n        latest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\r\n    )\r\n    # Process genesis deposits\r\n    for deposit in deposits:\r\n        process_deposit(state, deposit)\r\n    # Process genesis activations\r\n    for validator in state.validator_registry:\r\n        if validator.effective_balance >= MAX_EFFECTIVE_BALANCE:\r\n            validator.activation_eligibility_epoch = GENESIS_EPOCH\r\n            validator.activation_epoch = GENESIS_EPOCH\r\n    # Populate latest_active_index_roots\r\n    genesis_active_index_root = hash_tree_root(get_active_validator_indices(state, GENESIS_EPOCH))\r\n    for index in range(LATEST_ACTIVE_INDEX_ROOTS_LENGTH):\r\n        state.latest_active_index_roots[index] = genesis_active_index_root\r\n    return state</b>\r\n</pre>\r\n\r\n### Genesis block\r\n\r\n**Let `genesis_block = BeaconBlock(state_root=hash_tree_root(genesis_state))`.**\r\n\r\n## Beacon chain state transition function\r\n\r\n**The post-state corresponding to a pre-state `state` and a block `block` is defined as `state_transition(state, block)`. State transitions that trigger an unhandled excpetion (e.g. a failed `assert` or an out-of-range list access) are considered invalid.**\r\n\r\n<pre>python\r\n<b>def state_transition(state: BeaconState, block: BeaconBlock, validate_state_root: bool=False) -> BeaconState:\r\n    # Process slots (including those with no blocks) since block\r\n    process_slots(state, block.slot)\r\n    # Process block\r\n    process_block(state, block)\r\n    # Validate state root (`validate_state_root == True` in production)\r\n    if validate_state_root:\r\n        assert block.state_root == hash_tree_root(state)\r\n    # Return post-state\r\n    return state</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def process_slots(state: BeaconState, slot: Slot) -> None:\r\n    assert state.slot <= slot\r\n    while state.slot < slot:\r\n        process_slot(state)\r\n        # Process epoch on the first slot of the next epoch\r\n        if (state.slot + 1) % SLOTS_PER_EPOCH == 0:\r\n            process_epoch(state)\r\n        state.slot += 1</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def process_slot(state: BeaconState) -> None:\r\n    # Cache state root\r\n    previous_state_root = hash_tree_root(state)\r\n    state.latest_state_roots[state.slot % SLOTS_PER_HISTORICAL_ROOT] = previous_state_root\r\n    # Cache latest block header state root\r\n    if state.latest_block_header.state_root == ZERO_HASH:\r\n        state.latest_block_header.state_root = previous_state_root\r\n    # Cache block root\r\n    previous_block_root = signing_root(state.latest_block_header)\r\n    state.latest_block_roots[state.slot % SLOTS_PER_HISTORICAL_ROOT] = previous_block_root</b>\r\n</pre>\r\n\r\n### Epoch processing\r\n\r\nNote: the `# @LabelHere` lines below are placeholders to show that code will be inserted here in a future phase.\r\n\r\n<pre>python\r\n<b>def process_epoch(state: BeaconState) -> None:\r\n    process_justification_and_finalization(state)\r\n    process_crosslinks(state)\r\n    process_rewards_and_penalties(state)\r\n    process_registry_updates(state)\r\n    # @process_reveal_deadlines\r\n    # @process_challenge_deadlines\r\n    process_slashings(state)\r\n    process_final_updates(state)\r\n    # @after_process_final_updates</b>\r\n</pre>\r\n\r\n#### Helper functions\r\n\r\n<pre>python\r\n<b>def get_total_active_balance(state: BeaconState) -> Gwei:\r\n    return get_total_balance(state, get_active_validator_indices(state, get_current_epoch(state)))</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_matching_source_attestations(state: BeaconState, epoch: Epoch) -> List[PendingAttestation]:\r\n    assert epoch in (get_current_epoch(state), get_previous_epoch(state))\r\n    return state.current_epoch_attestations if epoch == get_current_epoch(state) else state.previous_epoch_attestations</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_matching_target_attestations(state: BeaconState, epoch: Epoch) -> List[PendingAttestation]:\r\n    return [\r\n        a for a in get_matching_source_attestations(state, epoch)\r\n        if a.data.target_root == get_block_root(state, epoch)\r\n    ]</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_matching_head_attestations(state: BeaconState, epoch: Epoch) -> List[PendingAttestation]:\r\n    return [\r\n        a for a in get_matching_source_attestations(state, epoch)\r\n        if a.data.beacon_block_root == get_block_root_at_slot(state, get_attestation_data_slot(state, a.data))</b>\r\n    ]\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_unslashed_attesting_indices(state: BeaconState,\r\n                                    attestations: List[PendingAttestation]) -> List[ValidatorIndex]:\r\n    output = set()\r\n    for a in attestations:\r\n        output = output.union(get_attesting_indices(state, a.data, a.aggregation_bitfield))\r\n    return sorted(filter(lambda index: not state.validator_registry[index].slashed, list(output)))</b>\r\n</pre>\r\n\r\n<pre>python\r\ndef get_attesting_balance(state: BeaconState, attestations: List[PendingAttestation]) -> Gwei:\r\n    return get_total_balance(state, <b>get_unslashed_attesting_indices(state, attestations)</b>)\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_winning_crosslink_and_attesting_indices(state: BeaconState,\r\n                                                epoch: Epoch,\r\n                                                shard: Shard) -> Tuple[Crosslink, List[ValidatorIndex]]:\r\n    attestations = [a for a in get_matching_source_attestations(state, epoch) if a.data.crosslink.shard == shard]\r\n    crosslinks = list(filter(\r\n        lambda c: hash_tree_root(state.current_crosslinks[shard]) in (c.parent_root, hash_tree_root(c)),\r\n        [a.data.crosslink for a in attestations]\r\n    ))\r\n    # Winning crosslink has the crosslink data root with the most balance voting for it (ties broken lexicographically)\r\n    winning_crosslink = max(crosslinks, key=lambda c: (\r\n        get_attesting_balance(state, [a for a in attestations if a.data.crosslink == c]), c.data_root\r\n    ), default=Crosslink())\r\n    winning_attestations = [a for a in attestations if a.data.crosslink == winning_crosslink]\r\n    return winning_crosslink, get_unslashed_attesting_indices(state, winning_attestations)</b>\r\n</pre>\r\n\r\n#### Justification and finalization\r\n\r\n<pre>python\r\n<b>def process_justification_and_finalization(state: BeaconState) -> None:\r\n    if get_current_epoch(state) <= GENESIS_EPOCH + 1:\r\n        return\r\n    previous_epoch = get_previous_epoch(state)\r\n    current_epoch = get_current_epoch(state)\r\n    old_previous_justified_epoch = state.previous_justified_epoch\r\n    old_current_justified_epoch = state.current_justified_epoch\r\n    # Process justifications\r\n    state.previous_justified_epoch = state.current_justified_epoch\r\n    state.previous_justified_root = state.current_justified_root\r\n    state.justification_bitfield = (state.justification_bitfield << 1) % 2**64\r\n    previous_epoch_matching_target_balance = get_attesting_balance(\r\n        state, get_matching_target_attestations(state, previous_epoch)\r\n    )\r\n    if previous_epoch_matching_target_balance * 3 >= get_total_active_balance(state) * 2:\r\n        state.current_justified_epoch = previous_epoch\r\n        state.current_justified_root = get_block_root(state, state.current_justified_epoch)\r\n        state.justification_bitfield |= (1 << 1)\r\n    current_epoch_matching_target_balance = get_attesting_balance(\r\n        state, get_matching_target_attestations(state, current_epoch)\r\n    )\r\n    if current_epoch_matching_target_balance * 3 >= get_total_active_balance(state) * 2:\r\n        state.current_justified_epoch = current_epoch\r\n        state.current_justified_root = get_block_root(state, state.current_justified_epoch)\r\n        state.justification_bitfield |= (1 << 0)\r\n    # Process finalizations\r\n    bitfield = state.justification_bitfield\r\n    # The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source\r\n    if (bitfield >> 1) % 8 == 0b111 and old_previous_justified_epoch + 3 == current_epoch:\r\n        state.finalized_epoch = old_previous_justified_epoch\r\n        state.finalized_root = get_block_root(state, state.finalized_epoch)\r\n    # The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source\r\n    if (bitfield >> 1) % 4 == 0b11 and old_previous_justified_epoch + 2 == current_epoch:\r\n        state.finalized_epoch = old_previous_justified_epoch\r\n        state.finalized_root = get_block_root(state, state.finalized_epoch)\r\n    # The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source\r\n    if (bitfield >> 0) % 8 == 0b111 and old_current_justified_epoch + 2 == current_epoch:\r\n        state.finalized_epoch = old_current_justified_epoch\r\n        state.finalized_root = get_block_root(state, state.finalized_epoch)\r\n    # The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source\r\n    if (bitfield >> 0) % 4 == 0b11 and old_current_justified_epoch + 1 == current_epoch:\r\n        state.finalized_epoch = old_current_justified_epoch\r\n        state.finalized_root = get_block_root(state, state.finalized_epoch)</b>\r\n</pre>\r\n\r\n#### Crosslinks\r\n\r\n<pre>python\r\ndef process_crosslinks(state: BeaconState) -> None:\r\n   <b>state.previous_crosslinks = [c for c in state.current_crosslinks]\r\n    for epoch in (get_previous_epoch(state), get_current_epoch(state)):\r\n        for offset in range(get_epoch_committee_count(state, epoch)):\r\n            shard = (get_epoch_start_shard(state, epoch) + offset) % SHARD_COUNT\r\n            crosslink_committee = get_crosslink_committee(state, epoch, shard)\r\n            winning_crosslink, attesting_indices = get_winning_crosslink_and_attesting_indices(state, epoch, shard)\r\n            if 3 * get_total_balance(state, attesting_indices) >= 2 * get_total_balance(state, crosslink_committee):\r\n                state.current_crosslinks[shard] = winning_crosslink</b>\r\n</pre>\r\n\r\n#### Rewards and penalties\r\n\r\n<pre>python\r\ndef get_base_reward(state: BeaconState, index: ValidatorIndex) -> Gwei:\r\n   <b> total_balance = get_total_active_balance(state)\r\n    effective_balance = state.validator_registry[index].effective_balance\r\n    return effective_balance * BASE_REWARD_FACTOR // integer_squareroot(total_balance) // BASE_REWARDS_PER_EPOCH</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def get_attestation_deltas(state: BeaconState) -> Tuple[List[Gwei], List[Gwei]]:\r\n    previous_epoch = get_previous_epoch(state)\r\n    total_balance = get_total_active_balance(state)\r\n    rewards = [0 for _ in range(len(state.validator_registry))]\r\n    penalties = [0 for _ in range(len(state.validator_registry))]\r\n    eligible_validator_indices = [\r\n        index for index, v in enumerate(state.validator_registry)\r\n        if is_active_validator(v, previous_epoch) or (v.slashed and previous_epoch + 1 < v.withdrawable_epoch)\r\n    ]\r\n    # Micro-incentives for matching FFG source, FFG target, and head\r\n    matching_source_attestations = get_matching_source_attestations(state, previous_epoch)\r\n    matching_target_attestations = get_matching_target_attestations(state, previous_epoch)\r\n    matching_head_attestations = get_matching_head_attestations(state, previous_epoch)\r\n    for attestations in (matching_source_attestations, matching_target_attestations, matching_head_attestations):\r\n        unslashed_attesting_indices = get_unslashed_attesting_indices(state, attestations)\r\n        attesting_balance = get_total_balance(state, unslashed_attesting_indices)\r\n        for index in eligible_validator_indices:\r\n            if index in unslashed_attesting_indices:\r\n                rewards[index] += get_base_reward(state, index) * attesting_balance // total_balance\r\n            else:\r\n                penalties[index] += get_base_reward(state, index)\r\n    # Proposer and inclusion delay micro-rewards\r\n    for index in get_unslashed_attesting_indices(state, matching_source_attestations):\r\n        attestation = min([\r\n            a for a in matching_source_attestations\r\n            if index in get_attesting_indices(state, a.data, a.aggregation_bitfield)\r\n        ], key=lambda a: a.inclusion_delay)\r\n        rewards[attestation.proposer_index] += get_base_reward(state, index) // PROPOSER_REWARD_QUOTIENT\r\n        rewards[index] += get_base_reward(state, index) * MIN_ATTESTATION_INCLUSION_DELAY // attestation.inclusion_delay\r\n    # Inactivity penalty\r\n    finality_delay = previous_epoch - state.finalized_epoch\r\n    if finality_delay > MIN_EPOCHS_TO_INACTIVITY_PENALTY:\r\n        matching_target_attesting_indices = get_unslashed_attesting_indices(state, matching_target_attestations)\r\n        for index in eligible_validator_indices:\r\n            penalties[index] += BASE_REWARDS_PER_EPOCH * get_base_reward(state, index)\r\n            if index not in matching_target_attesting_indices:\r\n                penalties[index] += (\r\n                    state.validator_registry[index].effective_balance * finality_delay // INACTIVITY_PENALTY_QUOTIENT\r\n                )\r\n    return rewards, penalties</b>\r\n</pre>\r\n\r\n<pre>python\r\ndef get_crosslink_deltas(state: BeaconState) -> Tuple[List[Gwei], List[Gwei]]:\r\n    <b>rewards = [0 for index in range(len(state.validator_registry))]\r\n    penalties = [0 for index in range(len(state.validator_registry))]\r\n    epoch = get_previous_epoch(state)\r\n    for offset in range(get_epoch_committee_count(state, epoch)):\r\n        shard = (get_epoch_start_shard(state, epoch) + offset) % SHARD_COUNT\r\n        crosslink_committee = get_crosslink_committee(state, epoch, shard)\r\n        winning_crosslink, attesting_indices = get_winning_crosslink_and_attesting_indices(state, epoch, shard)\r\n        attesting_balance = get_total_balance(state, attesting_indices)\r\n        committee_balance = get_total_balance(state, crosslink_committee)\r\n        for index in crosslink_committee:\r\n            base_reward = get_base_reward(state, index)\r\n            if index in attesting_indices:\r\n                rewards[index] += base_reward * attesting_balance // committee_balance\r\n            else:\r\n                penalties[index] += base_reward\r\n    return rewards, penalties</b>\r\n</pre>\r\n\r\n<pre>python\r\n<b>def process_rewards_and_penalties(state: BeaconState) -> None:\r\n    if get_current_epoch(state) == GENESIS_EPOCH:\r\n        return\r\n    rewards1, penalties1 = get_attestation_deltas(state)\r\n    rewards2, penalties2 = get_crosslink_deltas(state)\r\n    for i in range(len(state.validator_registry)):\r\n        increase_balance(state, i, rewards1[i] + rewards2[i])\r\n        decrease_balance(state, i, penalties1[i] + penalties2[i])</b>\r\n</pre>\r\n\r\n#### Registry updates\r\n\r\n<pre>python\r\n<b>def process_registry_updates(state: BeaconState) -> None:\r\n    # Process activation eligibility and ejections\r\n    for index, validator in enumerate(state.validator_registry):\r\n        if (\r\n            validator.activation_eligibility_epoch == FAR_FUTURE_EPOCH and\r\n            validator.effective_balance >= MAX_EFFECTIVE_BALANCE\r\n        ):\r\n            validator.activation_eligibility_epoch = get_current_epoch(state)\r\n        if is_active_validator(validator, get_current_epoch(state)) and validator.effective_balance <= EJECTION_BALANCE:\r\n            initiate_validator_exit(state, index)\r\n    # Queue validators eligible for activation and not dequeued for activation prior to finalized epoch\r\n    activation_queue = sorted([\r\n        index for index, validator in enumerate(state.validator_registry) if\r\n        validator.activation_eligibility_epoch != FAR_FUTURE_EPOCH and\r\n        validator.activation_epoch >= get_delayed_activation_exit_epoch(state.finalized_epoch)\r\n    ], key=lambda index: state.validator_registry[index].activation_eligibility_epoch)\r\n    # Dequeued validators for activation up to churn limit (without resetting activation epoch)\r\n    for index in activation_queue[:get_churn_limit(state)]:\r\n        validator = state.validator_registry[index]\r\n        if validator.activation_epoch == FAR_FUTURE_EPOCH:\r\n            validator.activation_epoch = get_delayed_activation_exit_epoch(get_current_epoch(state))</b>\r\n</pre>\r\n\r\n#### Slashings\r\n\r\n<pre>python\r\ndef process_slashings(state: BeaconState) -> None:\r\n    current_epoch = get_current_epoch(state)\r\n    <b>total_balance = get_total_active_balance(state)</b>\r\n    # Compute slashed balances in the current epoch\r\n    total_at_start = state.latest_slashed_balances[(current_epoch + 1) % LATEST_SLASHED_EXIT_LENGTH]\r\n    total_at_end = state.latest_slashed_balances[current_epoch % LATEST_SLASHED_EXIT_LENGTH]\r\n    total_penalties = total_at_end - total_at_start\r\n    for index, validator in enumerate(state.validator_registry):\r\n        if validator.slashed and current_epoch == validator.withdrawable_epoch - LATEST_SLASHED_EXIT_LENGTH // 2:\r\n            penalty = max(\r\n                <b>validator.effective_balance * min(total_penalties * 3, total_balance) // total_balance,\r\n                validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT</b>\r\n            )\r\n            <b>decrease_balance(state, index, penalty)</b>\r\n</pre>\r\n\r\n#### Final updates\r\n\r\n<pre>python\r\n<b>def process_final_updates(state: BeaconState) -> None:\r\n    current_epoch = get_current_epoch(state)\r\n    next_epoch = current_epoch + 1\r\n    # Reset eth1 data votes\r\n    if (state.slot + 1) % SLOTS_PER_ETH1_VOTING_PERIOD == 0:\r\n        state.eth1_data_votes = []\r\n    # Update effective balances with hysteresis\r\n    for index, validator in enumerate(state.validator_registry):\r\n        balance = state.balances[index]\r\n        HALF_INCREMENT = EFFECTIVE_BALANCE_INCREMENT // 2\r\n        if balance < validator.effective_balance or validator.effective_balance + 3 * HALF_INCREMENT < balance:\r\n            validator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\r\n    # Update start shard\r\n    state.latest_start_shard = (state.latest_start_shard + get_shard_delta(state, current_epoch)) % SHARD_COUNT\r\n    # Set active index root\r\n    index_root_position = (next_epoch + ACTIVATION_EXIT_DELAY) % LATEST_ACTIVE_INDEX_ROOTS_LENGTH\r\n    state.latest_active_index_roots[index_root_position] = hash_tree_root(\r\n        get_active_validator_indices(state, next_epoch + ACTIVATION_EXIT_DELAY)\r\n    )\r\n    # Set total slashed balances\r\n    state.latest_slashed_balances[next_epoch % LATEST_SLASHED_EXIT_LENGTH] = (\r\n        state.latest_slashed_balances[current_epoch % LATEST_SLASHED_EXIT_LENGTH]\r\n    )\r\n    # Set randao mix\r\n    state.latest_randao_mixes[next_epoch % LATEST_RANDAO_MIXES_LENGTH] = get_randao_mix(state, current_epoch)\r\n    # Set historical root accumulator\r\n    if next_epoch % (SLOTS_PER_HISTORICAL_ROOT // SLOTS_PER_EPOCH) == 0:\r\n        historical_batch = HistoricalBatch(\r\n            block_roots=state.latest_block_roots,\r\n            state_roots=state.latest_state_roots,\r\n        )\r\n        state.historical_roots.append(hash_tree_root(historical_batch))\r\n    # Rotate current/previous epoch attestations\r\n    state.previous_epoch_attestations = state.current_epoch_attestations\r\n    state.current_epoch_attestations = []</b>\r\n</pre>\r\n\r\n### Block processing\r\n\r\n<pre>python\r\n<b>def process_block(state: BeaconState, block: BeaconBlock) -> None:\r\n    process_block_header(state, block)\r\n    process_randao(state, block.body)\r\n    process_eth1_data(state, block.body)\r\n    process_operations(state, block.body)</b>\r\n</pre>\r\n\r\n#### Block header\r\n\r\n<pre>python\r\ndef process_block_header(state: BeaconState, block: BeaconBlock) -> None:\r\n    # Verify that the slots match\r\n    assert block.slot == state.slot\r\n    # Verify that the parent matches\r\n    <b>assert block.parent_root == signing_root(state.latest_block_header)</b>\r\n    # Save current block as the new latest block\r\n    <b>state.latest_block_header = BeaconBlockHeader(\r\n        slot=block.slot,\r\n        parent_root=block.parent_root,\r\n        body_root=hash_tree_root(block.body),\r\n    )</b>\r\n    # Verify proposer is not slashed\r\n    proposer = state.validator_registry[<b>get_beacon_proposer_index(state)</b>]\r\n    <b>assert not proposer.slashed\r\n    # Verify proposer signature\r\n    assert bls_verify(proposer.pubkey, signing_root(block), block.signature, get_domain(state, DOMAIN_BEACON_PROPOSER))</b>\r\n</pre>\r\n\r\n#### RANDAO\r\n\r\n<pre>python\r\ndef process_randao(state: BeaconState, <b>body: BeaconBlockBody</b>) -> None:\r\n    proposer = state.validator_registry[<b>get_beacon_proposer_index(state)</b>]\r\n    <b># Verify that the provided randao value is valid</b>\r\n    assert bls_verify(\r\n        proposer.pubkey,\r\n        hash_tree_root(get_current_epoch(state)),\r\n        <b>body.randao_reveal,</b>\r\n        <b>get_domain(state, DOMAIN_RANDAO),</b>\r\n    )\r\n    # Mix it in\r\n    state.latest_randao_mixes[get_current_epoch(state) % LATEST_RANDAO_MIXES_LENGTH] = (\r\n        xor(get_randao_mix(state, get_current_epoch(state)),\r\n            hash(body.randao_reveal))\r\n    )\r\n</pre>\r\n\r\n#### Eth1 data\r\n\r\n<pre>python\r\ndef process_eth1_data(state: BeaconState, <b>body: BeaconBlockBody</b>) -> None:\r\n    <b>state.eth1_data_votes.append(body.eth1_data)\r\n    if state.eth1_data_votes.count(body.eth1_data) * 2 > SLOTS_PER_ETH1_VOTING_PERIOD:\r\n        state.latest_eth1_data = body.eth1_data</b>\r\n</pre>\r\n\r\n#### Operations\r\n\r\n<pre>python\r\n<b>def process_operations(state: BeaconState, body: BeaconBlockBody) -> None:\r\n    # Verify that outstanding deposits are processed up to the maximum number of deposits\r\n    assert len(body.deposits) == min(MAX_DEPOSITS, state.latest_eth1_data.deposit_count - state.deposit_index)\r\n    # Verify that there are no duplicate transfers\r\n    assert len(body.transfers) == len(set(body.transfers))\r\n    for operations, max_operations, function in (\r\n        (body.proposer_slashings, MAX_PROPOSER_SLASHINGS, process_proposer_slashing),\r\n        (body.attester_slashings, MAX_ATTESTER_SLASHINGS, process_attester_slashing),\r\n        (body.attestations, MAX_ATTESTATIONS, process_attestation),\r\n        (body.deposits, MAX_DEPOSITS, process_deposit),\r\n        (body.voluntary_exits, MAX_VOLUNTARY_EXITS, process_voluntary_exit),\r\n        (body.transfers, MAX_TRANSFERS, process_transfer),\r\n    ):\r\n        assert len(operations) <= max_operations\r\n        for operation in operations:\r\n            function(state, operation)</b>\r\n</pre>\r\n\r\n##### Proposer slashings\r\n\r\n<pre>python\r\ndef process_proposer_slashing(state: BeaconState, proposer_slashing: ProposerSlashing) -> None:\r\n    \"\"\"\r\n    <b>Process ``ProposerSlashing`` operation.</b>\r\n    \"\"\"\r\n    proposer = state.validator_registry[proposer_slashing.proposer_index]\r\n    # Verify that the epoch is the same\r\n    assert slot_to_epoch(proposer_slashing.header_1.slot) == slot_to_epoch(proposer_slashing.header_2.slot)\r\n    # But the headers are different\r\n    assert proposer_slashing.header_1 != proposer_slashing.header_2\r\n    # Check proposer is slashable\r\n    <b>assert is_slashable_validator(proposer, get_current_epoch(state))</b>\r\n    # Signatures are valid\r\n    for header in (proposer_slashing.header_1, proposer_slashing.header_2):\r\n        <b>domain = get_domain(state, DOMAIN_BEACON_PROPOSER, slot_to_epoch(header.slot))\r\n        assert bls_verify(proposer.pubkey, signing_root(header), header.signature, domain)\r\n    slash_validator(state, proposer_slashing.proposer_index)</b>\r\n</pre>\r\n\r\n##### Attester slashings\r\n\r\n<pre>python\r\ndef process_attester_slashing(state: BeaconState, attester_slashing: AttesterSlashing) -> None:\r\n    \"\"\"\r\n    <b>Process ``AttesterSlashing`` operation.</b>\r\n    \"\"\"\r\n    attestation_1 = attester_slashing.attestation_1\r\n    attestation_2 = attester_slashing.attestation_2\r\n    <b>assert is_slashable_attestation_data(attestation_1.data, attestation_2.data)\r\n    validate_indexed_attestation(state, attestation_1)\r\n    validate_indexed_attestation(state, attestation_2)\r\n    slashed_any = False\r\n    attesting_indices_1 = attestation_1.custody_bit_0_indices + attestation_1.custody_bit_1_indices\r\n    attesting_indices_2 = attestation_2.custody_bit_0_indices + attestation_2.custody_bit_1_indices\r\n    for index in sorted(set(attesting_indices_1).intersection(attesting_indices_2)):\r\n        if is_slashable_validator(state.validator_registry[index], get_current_epoch(state)):\r\n            slash_validator(state, index)\r\n            slashed_any = True\r\n    assert slashed_any</b>\r\n</pre>\r\n\r\n##### Attestations\r\n\r\n<pre>python\r\ndef process_attestation(state: BeaconState, attestation: Attestation) -> None:\r\n    \"\"\"\r\n    <b>Process ``Attestation`` operation.</b>\r\n    \"\"\"\r\n    <b>data = attestation.data\r\n    attestation_slot = get_attestation_data_slot(state, data)\r\n    assert attestation_slot + MIN_ATTESTATION_INCLUSION_DELAY <= state.slot <= attestation_slot + SLOTS_PER_EPOCH\r\n    pending_attestation = PendingAttestation(\r\n        data=data,\r\n        aggregation_bitfield=attestation.aggregation_bitfield,\r\n        inclusion_delay=state.slot - attestation_slot,\r\n        proposer_index=get_beacon_proposer_index(state),\r\n    )\r\n    assert data.target_epoch in (get_previous_epoch(state), get_current_epoch(state))\r\n    if data.target_epoch == get_current_epoch(state):\r\n        ffg_data = (state.current_justified_epoch, state.current_justified_root, get_current_epoch(state))\r\n        parent_crosslink = state.current_crosslinks[data.crosslink.shard]\r\n        state.current_epoch_attestations.append(pending_attestation)\r\n    else:\r\n        ffg_data = (state.previous_justified_epoch, state.previous_justified_root, get_previous_epoch(state))\r\n        parent_crosslink = state.previous_crosslinks[data.crosslink.shard]\r\n        state.previous_epoch_attestations.append(pending_attestation)\r\n    # Check FFG data, crosslink data, and signature\r\n    assert ffg_data == (data.source_epoch, data.source_root, data.target_epoch)\r\n    assert data.crosslink.start_epoch == parent_crosslink.end_epoch\r\n    assert data.crosslink.end_epoch == min(data.target_epoch, parent_crosslink.end_epoch + MAX_EPOCHS_PER_CROSSLINK)\r\n    assert data.crosslink.parent_root == hash_tree_root(parent_crosslink)\r\n    assert data.crosslink.data_root == ZERO_HASH  # [to be removed in phase 1]\r\n    validate_indexed_attestation(state, convert_to_indexed(state, attestation))</b>\r\n</pre>\r\n\r\n##### Deposits\r\n\r\n<pre>python\r\ndef process_deposit(state: BeaconState, deposit: Deposit) -> None:\r\n    \"\"\"\r\n    <b>Process an Eth1 deposit, registering a validator or increasing its balance.</b>\r\n    \"\"\"\r\n    # Verify the Merkle branch\r\n    <b>assert verify_merkle_branch(\r\n        leaf=hash_tree_root(deposit.data),\r\n        proof=deposit.proof,\r\n        depth=DEPOSIT_CONTRACT_TREE_DEPTH,\r\n        index=state.deposit_index,\r\n        root=state.latest_eth1_data.deposit_root,\r\n    )\r\n    # Deposits must be processed in order\r\n    state.deposit_index += 1\r\n    pubkey = deposit.data.pubkey\r\n    amount = deposit.data.amount\r\n    validator_pubkeys = [v.pubkey for v in state.validator_registry]\r\n    if pubkey not in validator_pubkeys:\r\n        # Verify the deposit signature (proof of possession).\r\n        # Invalid signatures are allowed by the deposit contract,\r\n        # and hence included on-chain, but must not be processed.\r\n        # Note: deposits are valid across forks, hence the deposit domain is retrieved directly from `bls_domain`\r\n        if not bls_verify(\r\n            pubkey, signing_root(deposit.data), deposit.data.signature, bls_domain(DOMAIN_DEPOSIT)\r\n        ):\r\n            return\r\n        # Add validator and balance entries\r\n        state.validator_registry.append(Validator(\r\n            pubkey=pubkey,\r\n            withdrawal_credentials=deposit.data.withdrawal_credentials,\r\n            activation_eligibility_epoch=FAR_FUTURE_EPOCH,\r\n            activation_epoch=FAR_FUTURE_EPOCH,\r\n            exit_epoch=FAR_FUTURE_EPOCH,\r\n            withdrawable_epoch=FAR_FUTURE_EPOCH,\r\n            effective_balance=min(amount - amount % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\r\n        ))\r\n        state.balances.append(amount)\r\n    else:\r\n        # Increase balance by deposit amount\r\n        index = validator_pubkeys.index(pubkey)\r\n        increase_balance(state, index, amount)</b>\r\n</pre>\r\n\r\n##### Voluntary exits\r\n\r\n<pre>python\r\ndef process_voluntary_exit(state: BeaconState, exit: VoluntaryExit) -> None:\r\n    \"\"\"\r\n    <b>Process ``VoluntaryExit`` operation.</b>\r\n    \"\"\"\r\n    validator = state.validator_registry[exit.validator_index]\r\n    # Verify the validator is active\r\n    <b>assert is_active_validator(validator, get_current_epoch(state))\r\n    # Verify the validator has not yet exited\r\n    assert validator.exit_epoch == FAR_FUTURE_EPOCH\r\n    # Exits must specify an epoch when they become valid; they are not valid before then\r\n    assert get_current_epoch(state) >= exit.epoch\r\n    # Verify the validator has been active long enough\r\n    assert get_current_epoch(state) >= validator.activation_epoch + PERSISTENT_COMMITTEE_PERIOD\r\n    # Verify signature\r\n    domain = get_domain(state, DOMAIN_VOLUNTARY_EXIT, exit.epoch)\r\n    assert bls_verify(validator.pubkey, signing_root(exit), exit.signature, domain)\r\n    # Initiate exit\r\n    initiate_validator_exit(state, exit.validator_index)</b>\r\n</pre>\r\n\r\n##### Transfers\r\n\r\n<pre>python\r\ndef process_transfer(state: BeaconState, transfer: Transfer) -> None:\r\n    \"\"\"\r\n    <b>Process ``Transfer`` operation.</b>\r\n    \"\"\"\r\n    <b># Verify the amount and fee are not individually too big (for anti-overflow purposes)\r\n    assert state.balances[transfer.sender] >= max(transfer.amount, transfer.fee)\r\n    # A transfer is valid in only one slot\r\n    assert state.slot == transfer.slot\r\n    # Sender must be not yet eligible for activation, withdrawn, or transfer balance over MAX_EFFECTIVE_BALANCE\r\n    assert (\r\n        state.validator_registry[transfer.sender].activation_eligibility_epoch == FAR_FUTURE_EPOCH or\r\n        get_current_epoch(state) >= state.validator_registry[transfer.sender].withdrawable_epoch or\r\n        transfer.amount + transfer.fee + MAX_EFFECTIVE_BALANCE <= state.balances[transfer.sender]\r\n    )\r\n    # Verify that the pubkey is valid\r\n    assert (\r\n        state.validator_registry[transfer.sender].withdrawal_credentials ==\r\n        int_to_bytes(BLS_WITHDRAWAL_PREFIX, length=1) + hash(transfer.pubkey)[1:]\r\n    )\r\n    # Verify that the signature is valid\r\n    assert bls_verify(transfer.pubkey, signing_root(transfer), transfer.signature, get_domain(state, DOMAIN_TRANSFER))\r\n    # Process the transfer\r\n    decrease_balance(state, transfer.sender, transfer.amount + transfer.fee)\r\n    increase_balance(state, transfer.recipient, transfer.amount)\r\n    increase_balance(state, get_beacon_proposer_index(state), transfer.fee)\r\n    # Verify balances are not dust\r\n    assert not (0 < state.balances[transfer.sender] < MIN_DEPOSIT_AMOUNT)\r\n    assert not (0 < state.balances[transfer.recipient] < MIN_DEPOSIT_AMOUNT)</b>\r\n</pre>",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502818325/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502840091",
    "html_url": "https://github.com/ConsenSys/teku/issues/722#issuecomment-502840091",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
    "id": 502840091,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjg0MDA5MQ==",
    "user": {
      "login": "dangerousfood",
      "id": 4099038,
      "node_id": "MDQ6VXNlcjQwOTkwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dangerousfood",
      "html_url": "https://github.com/dangerousfood",
      "followers_url": "https://api.github.com/users/dangerousfood/followers",
      "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
      "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
      "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
      "repos_url": "https://api.github.com/users/dangerousfood/repos",
      "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-17T20:33:17Z",
    "updated_at": "2019-06-18T14:06:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "### Misc Constants Updates\r\n\r\n| Name | Value |\r\n| - | - |\r\n| `SHARD_COUNT` | `2**10` (= 1,024) |\r\n| `TARGET_COMMITTEE_SIZE` | `2**7` (= 128) |\r\n| **`MAX_INDICES_PER_ATTESTATION`** | **`2**12` (= 4,096)** |\r\n| **`MIN_PER_EPOCH_CHURN_LIMIT`** | **`2**2` (= 4)** |\r\n| **`CHURN_LIMIT_QUOTIENT`** | **`2**16` (= 65,536)** |\r\n| **`BASE_REWARDS_PER_EPOCH`** | **`5`** |\r\n| `SHUFFLE_ROUND_COUNT` | `90` |\r\n\r\n### Deposit contract\r\n\r\n| Name | Value |\r\n| - | - |\r\n| `DEPOSIT_CONTRACT_TREE_DEPTH` | `2**5` (= 32) |\r\n\r\n### Gwei values\r\n\r\n| Name | Value | Unit |\r\n| - | - | :-: |\r\n| `MIN_DEPOSIT_AMOUNT` | `2**0 * 10**9` (= 1,000,000,000) | Gwei |\r\n| **`MAX_EFFECTIVE_BALANCE`** | **`2**5 * 10**9` (= 32,000,000,000)** | Gwei |\r\n| `EJECTION_BALANCE` | `2**4 * 10**9` (= 16,000,000,000) | Gwei |\r\n| **`EFFECTIVE_BALANCE_INCREMENT`** | **`2**0 * 10**9` (= 1,000,000,000)** | Gwei |\r\n\r\n### Initial values\r\n\r\n| Name | Value |\r\n| - | - |\r\n| **`GENESIS_SLOT`** | **`0`** |\r\n| **`GENESIS_EPOCH`** | **`0`** |\r\n| `FAR_FUTURE_EPOCH` | `2**64 - 1` |\r\n| **`ZERO_HASH`** | **`b'\\x00' * 32`** |\r\n| **`BLS_WITHDRAWAL_PREFIX`** | **`0`** |\r\n\r\n### Time parameters\r\n\r\n| Name | Value | Unit | Duration |\r\n| - | - | :-: | :-: |\r\n| `MIN_ATTESTATION_INCLUSION_DELAY` | `2**2` (= 4) | slots | 24 seconds |\r\n| `SLOTS_PER_EPOCH` | `2**6` (= 64) | slots | 6.4 minutes |\r\n| `MIN_SEED_LOOKAHEAD` | `2**0` (= 1) | epochs | 6.4 minutes |\r\n| `ACTIVATION_EXIT_DELAY` | `2**2` (= 4) | epochs | 25.6 minutes |\r\n| **`SLOTS_PER_ETH1_VOTING_PERIOD`** | **`2**10` (= 1,024)** | **slots** | ~1.7 hours |\r\n| `SLOTS_PER_HISTORICAL_ROOT` | `2**13` (= 8,192) | slots | ~13 hours |\r\n| `MIN_VALIDATOR_WITHDRAWABILITY_DELAY` | `2**8` (= 256) | epochs | ~27 hours |\r\n| `PERSISTENT_COMMITTEE_PERIOD` | `2**11` (= 2,048)  | epochs | 9 days  |\r\n| **`MAX_EPOCHS_PER_CROSSLINK`** | **`2**6` (= 64)** | epochs | ~7 hours |\r\n| **`MIN_EPOCHS_TO_INACTIVITY_PENALTY`** | **`2**2` (= 4)** | epochs | 25.6 minutes |\r\n\r\n* `MAX_EPOCHS_PER_CROSSLINK` should be a small constant times `SHARD_COUNT // SLOTS_PER_EPOCH`\r\n\r\n### State list lengths\r\n\r\n| Name | Value | Unit | Duration |\r\n| - | - | :-: | :-: |\r\n| `LATEST_RANDAO_MIXES_LENGTH` | `2**13` (= 8,192) | epochs | ~36 days |\r\n| `LATEST_ACTIVE_INDEX_ROOTS_LENGTH` | `2**13` (= 8,192) | epochs | ~36 days |\r\n| `LATEST_SLASHED_EXIT_LENGTH` | `2**13` (= 8,192) | epochs | ~36 days |\r\n\r\n### Rewards and penalties\r\n\r\n| Name | Value |\r\n| - | - |\r\n| **`BASE_REWARD_FACTOR`** | **`2**5` (= 32)** |\r\n| **`WHISTLEBLOWING_REWARD_QUOTIENT`** | **`2**9` (= 512)** |\r\n| **`PROPOSER_REWARD_QUOTIENT`** | **`2**3` (= 8)** |\r\n| **`INACTIVITY_PENALTY_QUOTIENT`** | **`2**25` (= 33,554,432)** |\r\n| **`MIN_SLASHING_PENALTY_QUOTIENT`** | **`2**5` (= 32)** |\r\n\r\n* **The `BASE_REWARD_FACTOR` is NOT final. Once all other protocol details are finalized, it will be adjusted to target a theoretical maximum total issuance of `2**21` ETH per year if `2**27` ETH is validating (and therefore `2**20` per year if `2**25` ETH is validating, etc.)**\r\n* **The `INACTIVITY_PENALTY_QUOTIENT` equals `INVERSE_SQRT_E_DROP_TIME**2` where `INVERSE_SQRT_E_DROP_TIME := 2**12 epochs` (~18 days) is the time it takes the inactivity penalty to reduce the balance of non-participating [validators](#dfn-validator) to about `1/sqrt(e) ~= 60.6%`. Indeed, the balance retained by offline [validators](#dfn-validator) after `n` epochs is about `(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(n**2/2)` so after `INVERSE_SQRT_E_DROP_TIME` epochs it is roughly `(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(INACTIVITY_PENALTY_QUOTIENT/2) ~= 1/sqrt(e)`.**\r\n\r\n### Max operations per block\r\n\r\n| Name | Value |\r\n| - | - |\r\n| `MAX_PROPOSER_SLASHINGS` | `2**4` (= 16) |\r\n| `MAX_ATTESTER_SLASHINGS` | `2**0` (= 1) |\r\n| `MAX_ATTESTATIONS` | `2**7` (= 128) |\r\n| `MAX_DEPOSITS` | `2**4` (= 16) |\r\n| `MAX_VOLUNTARY_EXITS` | `2**4` (= 16) |\r\n| **`MAX_TRANSFERS`** | **`0`** |\r\n\r\n### Signature domains\r\n\r\n| Name | Value |\r\n| - | - |\r\n| **`DOMAIN_BEACON_PROPOSER`** | **`0`** |\r\n| `DOMAIN_RANDAO` | `1` |\r\n| `DOMAIN_ATTESTATION` | `2` |\r\n| `DOMAIN_DEPOSIT` | `3` |\r\n| `DOMAIN_VOLUNTARY_EXIT` | `4` |\r\n| `DOMAIN_TRANSFER` | `5` |\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/502840091/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/504542852",
    "html_url": "https://github.com/ConsenSys/teku/issues/722#issuecomment-504542852",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/722",
    "id": 504542852,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNDU0Mjg1Mg==",
    "user": {
      "login": "dangerousfood",
      "id": 4099038,
      "node_id": "MDQ6VXNlcjQwOTkwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4099038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dangerousfood",
      "html_url": "https://github.com/dangerousfood",
      "followers_url": "https://api.github.com/users/dangerousfood/followers",
      "following_url": "https://api.github.com/users/dangerousfood/following{/other_user}",
      "gists_url": "https://api.github.com/users/dangerousfood/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dangerousfood/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dangerousfood/subscriptions",
      "organizations_url": "https://api.github.com/users/dangerousfood/orgs",
      "repos_url": "https://api.github.com/users/dangerousfood/repos",
      "events_url": "https://api.github.com/users/dangerousfood/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dangerousfood/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-21T19:17:38Z",
    "updated_at": "2019-06-21T19:17:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "Resolved in PR #730, PR #731, and PR #736 ",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/504542852/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
