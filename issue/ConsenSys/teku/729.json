{
  "url": "https://api.github.com/repos/ConsenSys/teku/issues/729",
  "repository_url": "https://api.github.com/repos/ConsenSys/teku",
  "labels_url": "https://api.github.com/repos/ConsenSys/teku/issues/729/labels{/name}",
  "comments_url": "https://api.github.com/repos/ConsenSys/teku/issues/729/comments",
  "events_url": "https://api.github.com/repos/ConsenSys/teku/issues/729/events",
  "html_url": "https://github.com/ConsenSys/teku/issues/729",
  "id": 457526609,
  "node_id": "MDU6SXNzdWU0NTc1MjY2MDk=",
  "number": 729,
  "title": "v0.7.1 SSZ Updates",
  "user": {
    "login": "schroedingerscode",
    "id": 25290629,
    "node_id": "MDQ6VXNlcjI1MjkwNjI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/25290629?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/schroedingerscode",
    "html_url": "https://github.com/schroedingerscode",
    "followers_url": "https://api.github.com/users/schroedingerscode/followers",
    "following_url": "https://api.github.com/users/schroedingerscode/following{/other_user}",
    "gists_url": "https://api.github.com/users/schroedingerscode/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/schroedingerscode/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/schroedingerscode/subscriptions",
    "organizations_url": "https://api.github.com/users/schroedingerscode/orgs",
    "repos_url": "https://api.github.com/users/schroedingerscode/repos",
    "events_url": "https://api.github.com/users/schroedingerscode/events{/privacy}",
    "received_events_url": "https://api.github.com/users/schroedingerscode/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2019-06-18T14:46:52Z",
  "updated_at": "2019-06-26T21:39:15Z",
  "closed_at": "2019-06-25T15:23:07Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "- [x] **Implement Default Values**\r\n   _Because we're using library Java types to mimic the behavior of SSZ types, this entails going through Artemis, and ensuring the default values are set whenever an SSZ primitive is initialized and not immediately set._\r\n- [x] **Implement SSZ isEmpty**\r\n   _This will need to be a mix of static methods (for non container types) and methods within the object (for container types) which check that the underlying type which approximates the SSZ type is equal to the null value._\r\n- [ ] **Add Support for Union Types**\r\n- [x] **Implement mix_in_type Helper Method for Merkleization**",
  "closed_by": {
    "login": "cemozerr",
    "id": 16581242,
    "node_id": "MDQ6VXNlcjE2NTgxMjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/16581242?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cemozerr",
    "html_url": "https://github.com/cemozerr",
    "followers_url": "https://api.github.com/users/cemozerr/followers",
    "following_url": "https://api.github.com/users/cemozerr/following{/other_user}",
    "gists_url": "https://api.github.com/users/cemozerr/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cemozerr/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cemozerr/subscriptions",
    "organizations_url": "https://api.github.com/users/cemozerr/orgs",
    "repos_url": "https://api.github.com/users/cemozerr/repos",
    "events_url": "https://api.github.com/users/cemozerr/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cemozerr/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/729/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ConsenSys/teku/issues/729/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/503173064",
    "html_url": "https://github.com/ConsenSys/teku/issues/729#issuecomment-503173064",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/729",
    "id": 503173064,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMzE3MzA2NA==",
    "user": {
      "login": "schroedingerscode",
      "id": 25290629,
      "node_id": "MDQ6VXNlcjI1MjkwNjI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/25290629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/schroedingerscode",
      "html_url": "https://github.com/schroedingerscode",
      "followers_url": "https://api.github.com/users/schroedingerscode/followers",
      "following_url": "https://api.github.com/users/schroedingerscode/following{/other_user}",
      "gists_url": "https://api.github.com/users/schroedingerscode/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/schroedingerscode/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/schroedingerscode/subscriptions",
      "organizations_url": "https://api.github.com/users/schroedingerscode/orgs",
      "repos_url": "https://api.github.com/users/schroedingerscode/repos",
      "events_url": "https://api.github.com/users/schroedingerscode/events{/privacy}",
      "received_events_url": "https://api.github.com/users/schroedingerscode/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-18T14:55:07Z",
    "updated_at": "2019-06-18T18:20:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "# SimpleSerialize (SSZ)\r\n\r\n**Notice**: This document is a work-in-progress describing typing, serialization, and Merkleization of Eth 2.0 objects.\r\n\r\n## Table of contents\r\n<!-- TOC -->\r\n\r\n- [SimpleSerialize (SSZ)](#simpleserialize-ssz)\r\n    - [Table of contents](#table-of-contents)\r\n    - [Constants](#constants)\r\n    - [Typing](#typing)\r\n        - [Basic types](#basic-types)\r\n        - [Composite types](#composite-types)\r\n        - [Aliases](#aliases)\r\n        - <b>[Default values](#default-values)</b>\r\n        - <b>[Illegal types](#illegal-types)</b>\r\n    - [Serialization](#serialization)\r\n        - [`\"uintN\"`](#uintn)\r\n        - [`\"bool\"`](#bool)\r\n        - [`\"null`](#null)\r\n        - <b>[Vectors, containers, lists, unions](#vectors-containers-lists-unions)</b>\r\n    - [Deserialization](#deserialization)\r\n    - [Merkleization](#merkleization)\r\n    - [Self-signed containers](#self-signed-containers)\r\n    - [Implementations](#implementations)\r\n\r\n<!-- /TOC -->\r\n\r\n## Constants\r\n\r\n| Name | Value | Description |\r\n|-|-|-|\r\n| `BYTES_PER_CHUNK` | `32` | Number of bytes per chunk. |\r\n|<b> `BYTES_PER_LENGTH_OFFSET` </b>| `4` | Number of bytes per serialized length offset. |\r\n|<b> `BITS_PER_BYTE` </b>|<b> `8` </b>| Number of bits per byte. |\r\n\r\n## Typing\r\n### Basic types\r\n\r\n* `\"uintN\"`: `N`-bit unsigned integer (where `N in [8, 16, 32, 64, 128, 256]`)\r\n* `\"bool\"`: `True` or `False`\r\n\r\n### Composite types\r\n\r\n* **container**: ordered heterogeneous collection of values\r\n    * key-pair curly bracket notation `{}`, e.g. `{\"foo\": \"uint64\", \"bar\": \"bool\"}`\r\n* <b>vector: ordered fixed-length homogeneous collection of values</b>\r\n   * <b> angle bracket notation `[type, N]`, e.g. `[\"uint64\", N]`</b>\r\n* **list**: ordered variable-length homogeneous collection of values\r\n    * angle bracket notation `[type]`, e.g. `[\"uint64\"]`\r\n* <b>union: union type containing one of the given subtypes</b>\r\n   * <b> round bracket notation `(type_1, type_2, ...)`, e.g. `(\"null\", \"uint64\")`</b>\r\n\r\n### Variable-size and fixed-size\r\n\r\nWe recursively define \"variable-size\" types to be lists and unions and all types that contain a variable-size type. All other types are said to be \"fixed-size\".\r\n\r\n### Aliases\r\n\r\nFor convenience we alias:\r\n\r\n* `\"byte\"` to `\"uint8\"` (this is a basic type)\r\n* `\"bytes\"` to `[\"byte\"]` (this is *not* a basic type)\r\n* `\"bytesN\"` to `[\"byte\", N]` (this is *not* a basic type)\r\n<b>* `\"null\"`: `{}`, i.e. the empty container\r\n\r\n### Default values\r\n\r\nThe default value of a type upon initialization is recursively defined using `0` for `\"uintN\"`, `False` for `\"bool\"`, and `[]` for lists. Unions default to the first type in the union (with type index zero), which is `\"null\"` if present in the union.\r\n\r\n#### `is_empty`\r\n\r\nAn SSZ object is called empty (and thus `is_empty(object)` returns true) if it is equal to the default value for that type.\r\n\r\n### Illegal types\r\n\r\nEmpty vector types (i.e. `[subtype, 0]` for some `subtype`) are not legal. The `\"null\"` type is only legal as the first type in a union subtype (i.e., with type index zero).</b>\r\n\r\n## Serialization\r\n\r\nWe recursively define the `serialize` function which consumes an object `value` (of the type specified) and returns a bytestring of type `\"bytes\"`.\r\n\r\n> *Note*: In the function definitions below (`serialize`, `hash_tree_root`, `signing_root`, `is_variable_size`, etc.) objects implicitly carry their type.\r\n\r\n### `\"uintN\"`\r\n\r\n```python\r\nassert N in [8, 16, 32, 64, 128, 256]\r\nreturn value.to_bytes(N // 8, \"little\")\r\n```\r\n\r\n### `\"bool\"`\r\n\r\n```python\r\nassert value in (True, False)\r\nreturn b\"\\x01\" if value is True else b\"\\x00\"\r\n```\r\n\r\n<b>### `\"null\"`\r\n\r\n<pre>python\r\nreturn b\"\"\r\n</pre></b>\r\n\r\n<b>### Vectors, containers, lists, unions\r\n\r\n<pre>python\r\n# Recursively serialize\r\nfixed_parts = [serialize(element) if not is_variable_size(element) else None for element in value]\r\nvariable_parts = [serialize(element) if is_variable_size(element) else b\"\" for element in value]\r\n\r\n# Compute and check lengths\r\nfixed_lengths = [len(part) if part != None else BYTES_PER_LENGTH_OFFSET for part in fixed_parts]\r\nvariable_lengths = [len(part) for part in variable_parts]\r\nassert sum(fixed_lengths + variable_lengths) < 2**(BYTES_PER_LENGTH_OFFSET * BITS_PER_BYTE)\r\n\r\n# Interleave offsets of variable-size parts with fixed-size parts\r\nvariable_offsets = [serialize(sum(fixed_lengths + variable_lengths[:i])) for i in range(len(value))]\r\nfixed_parts = [part if part != None else variable_offsets[i] for i, part in enumerate(fixed_parts)]\r\n\r\n# Return the concatenation of the fixed-size parts (offsets interleaved) with the variable-size parts\r\nreturn b\"\".join(fixed_parts + variable_parts)\r\n</pre>\r\n\r\nIf `value` is a union type:\r\n\r\nDefine value as an object that has properties `value.value` with the contained value, and `value.type_index` which indexes the type.\r\n\r\n<pre>python\r\nserialized_bytes = serialize(value.value)\r\nserialized_type_index = value.type_index.to_bytes(BYTES_PER_LENGTH_OFFSET, \"little\")\r\nreturn serialized_type_index + serialized_bytes\r\n</pre></b>\r\n\r\n## Deserialization\r\n\r\nBecause serialization is an injective function (i.e. two distinct objects of the same type will serialize to different values) any bytestring has at most one object it could deserialize to. Efficient algorithms for computing this object can be found in [the implementations](#implementations).\r\n\r\n## Merkleization\r\n\r\nWe first define helper functions:\r\n\r\n* `pack`: Given ordered objects of the same basic type, serialize them, pack them into `BYTES_PER_CHUNK`-byte chunks, right-pad the last chunk with zero bytes, and return the chunks.\r\n* `merkleize`: Given ordered `BYTES_PER_CHUNK`-byte chunks, if necessary append zero chunks so that the number of chunks is a power of two, Merkleize the chunks, and return the root. Note that `merkleize` on a single chunk is simply that chunk, i.e. the identity when the number of chunks is one.\r\n* `mix_in_length`: Given a Merkle root `root` and a length `length` (`\"uint256\"` little-endian serialization) return `hash(root + length)`.\r\n* <b>`mix_in_type`: Given a Merkle root `root` and a type_index `type_index` (`\"uint256\"` little-endian serialization) return `hash(root + type_index)`.</b>\r\n\r\nWe now define Merkleization `hash_tree_root(value)` of an object `value` recursively:\r\n\r\n* `merkleize(pack(value))` if `value` is a basic object or a vector of basic objects\r\n* `mix_in_length(merkleize(pack(value)), len(value))` if `value` is a list of basic objects\r\n* `merkleize([hash_tree_root(element) for element in value])` if `value` is a vector of composite objects or a container\r\n* `mix_in_length(merkleize([hash_tree_root(element) for element in value]), len(value))` if `value` is a list of composite objects\r\n* <b>`mix_in_type(merkleize(value.value), value.type_index)` if `value` is of union type</b>\r\n\r\n## Self-signed containers\r\n\r\nLet `value` be a self-signed container object. The convention is that the signature (e.g. a `\"bytes96\"` BLS12-381 signature) be the last field of `value`. Further, the signed message for `value` is `signing_root(value) = hash_tree_root(truncate_last(value))` where `truncate_last` truncates the last element of `value`.",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/503173064/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
