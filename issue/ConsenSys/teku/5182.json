{
  "url": "https://api.github.com/repos/ConsenSys/teku/issues/5182",
  "repository_url": "https://api.github.com/repos/ConsenSys/teku",
  "labels_url": "https://api.github.com/repos/ConsenSys/teku/issues/5182/labels{/name}",
  "comments_url": "https://api.github.com/repos/ConsenSys/teku/issues/5182/comments",
  "events_url": "https://api.github.com/repos/ConsenSys/teku/issues/5182/events",
  "html_url": "https://github.com/ConsenSys/teku/issues/5182",
  "id": 1169495984,
  "node_id": "I_kwDOCM9I9M5FtRew",
  "number": 5182,
  "title": "Aggregate public keys and signatures without jumping the C/Java boundary so often",
  "user": {
    "login": "benjaminion",
    "id": 20796281,
    "node_id": "MDQ6VXNlcjIwNzk2Mjgx",
    "avatar_url": "https://avatars.githubusercontent.com/u/20796281?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/benjaminion",
    "html_url": "https://github.com/benjaminion",
    "followers_url": "https://api.github.com/users/benjaminion/followers",
    "following_url": "https://api.github.com/users/benjaminion/following{/other_user}",
    "gists_url": "https://api.github.com/users/benjaminion/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/benjaminion/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/benjaminion/subscriptions",
    "organizations_url": "https://api.github.com/users/benjaminion/orgs",
    "repos_url": "https://api.github.com/users/benjaminion/repos",
    "events_url": "https://api.github.com/users/benjaminion/events{/privacy}",
    "received_events_url": "https://api.github.com/users/benjaminion/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1271198478,
      "node_id": "MDU6TGFiZWwxMjcxMTk4NDc4",
      "url": "https://api.github.com/repos/ConsenSys/teku/labels/performance%20%F0%9F%9A%80",
      "name": "performance ðŸš€",
      "color": "ffcce3",
      "default": false,
      "description": "Improves performance without changing functionality"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2022-03-15T10:45:52Z",
  "updated_at": "2022-03-21T11:44:47Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "### Summary\r\n\r\nWe could probably significant reduce the cost of signature verification by adding some native code to aggregate public keys.\r\n\r\n### Explanation\r\n\r\nCurrently our code for aggregating public keys looks like [this](https://github.com/ConsenSys/teku/blob/master/infrastructure/bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKey.java#L70):\r\n\r\n```\r\n    for (BlstPublicKey publicKey : publicKeys) {\r\n      sum.add(publicKey.ecPoint);\r\n    }\r\n```\r\n\r\nEach iteration of this is a separate JNI call to the Blst library, the cost of which probably dominates the cost of the relatively lightweight `add()` method.\r\n\r\nWe should\r\n1. Profile this to see if it really is an issue. My gut feel is that there is a good speedup available here.\r\n2. If so, add an external C library wrapper for Blst or fork of Blst that provides a method to aggregate a list of public keys, thus avoiding the calling overhead.\r\n\r\nThere is a [similar issue](https://github.com/ConsenSys/teku/blob/master/infrastructure/bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstSignature.java#L61) for signatures, but for a number of reasons it's probably not so significant: we don't aggregate signatures as often; the cost of addition (aggregation) of signatures is greater; and the signature aggregation does an expensive group check, unlike the public key aggregation. So the JNI overhead would be relatively lower. But if we're adding native code for public keys, we could also do it for signatures for completeness.\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/5182/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ConsenSys/teku/issues/5182/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/1073795966",
    "html_url": "https://github.com/ConsenSys/teku/issues/5182#issuecomment-1073795966",
    "issue_url": "https://api.github.com/repos/ConsenSys/teku/issues/5182",
    "id": 1073795966,
    "node_id": "IC_kwDOCM9I9M5AANN-",
    "user": {
      "login": "benjaminion",
      "id": 20796281,
      "node_id": "MDQ6VXNlcjIwNzk2Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20796281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benjaminion",
      "html_url": "https://github.com/benjaminion",
      "followers_url": "https://api.github.com/users/benjaminion/followers",
      "following_url": "https://api.github.com/users/benjaminion/following{/other_user}",
      "gists_url": "https://api.github.com/users/benjaminion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benjaminion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benjaminion/subscriptions",
      "organizations_url": "https://api.github.com/users/benjaminion/orgs",
      "repos_url": "https://api.github.com/users/benjaminion/repos",
      "events_url": "https://api.github.com/users/benjaminion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benjaminion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-03-21T11:44:47Z",
    "updated_at": "2022-03-21T11:44:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "A quick and dirty update on testing this. It turns out that SWIG is a monster, so coding up the full version of this is complex. For a simple feasibility study I made two versions of point addition:\r\n\r\n```\r\n    P1* add(const P1_Affine &a)\r\n    {   blst_p1_add_or_double_affine(&point, &point, a); return this;   }\r\n    P1* add2(const P1_Affine &a, const P1_Affine &b)\r\n    {   blst_p1_add_or_double_affine(&point, &point, a); blst_p1_add_or_double_affine(&point, &point, b); return this;   }\r\n```\r\n\r\nGiven an even number of points the second will have half as many JNI calls as the first. Running with ten million points I get the following timings:\r\n  - `add`: 7.5s\r\n  - `add2`: 7.2 s\r\n\r\nThus, 5m JNI calls takes 0.3s, for a per-call cost of 0.06 microseconds, and 10m adds without the calling overhead takes 6.9s, for a per-add cost of 0.69 microseconds.\r\n\r\nIn summary, we could likely get around an 8% speed up in public key aggregation by eliminating the calling overhead. This is borderline worth doing. A worst-case verification of a block with 64 full attestations would need around 20,000 of these point additions which would currently take around 0.015s. We could shave just over a millisecond off this by eliminating the calling overhead.\r\n\r\nThe method that adds multiple points at once is already available in Blst and is exposed via some language interfaces, just not Java. In principle it's easy to expose it, except that SWIG is giving me a headache, and we'd have to maintain a branch of Blst or push the change back upstream.\r\n\r\nLeaving this for now, but may come back to it some time.",
    "reactions": {
      "url": "https://api.github.com/repos/ConsenSys/teku/issues/comments/1073795966/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
