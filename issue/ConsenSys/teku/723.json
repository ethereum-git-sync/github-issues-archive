{
  "url": "https://api.github.com/repos/ConsenSys/teku/issues/723",
  "repository_url": "https://api.github.com/repos/ConsenSys/teku",
  "labels_url": "https://api.github.com/repos/ConsenSys/teku/issues/723/labels{/name}",
  "comments_url": "https://api.github.com/repos/ConsenSys/teku/issues/723/comments",
  "events_url": "https://api.github.com/repos/ConsenSys/teku/issues/723/events",
  "html_url": "https://github.com/ConsenSys/teku/issues/723",
  "id": 457123522,
  "node_id": "MDU6SXNzdWU0NTcxMjM1MjI=",
  "number": 723,
  "title": "v0.7.1 Honest Validator Updates",
  "user": {
    "login": "cemozerr",
    "id": 16581242,
    "node_id": "MDQ6VXNlcjE2NTgxMjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/16581242?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cemozerr",
    "html_url": "https://github.com/cemozerr",
    "followers_url": "https://api.github.com/users/cemozerr/followers",
    "following_url": "https://api.github.com/users/cemozerr/following{/other_user}",
    "gists_url": "https://api.github.com/users/cemozerr/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cemozerr/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cemozerr/subscriptions",
    "organizations_url": "https://api.github.com/users/cemozerr/orgs",
    "repos_url": "https://api.github.com/users/cemozerr/repos",
    "events_url": "https://api.github.com/users/cemozerr/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cemozerr/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2019-06-17T20:03:21Z",
  "updated_at": "2019-06-25T15:21:39Z",
  "closed_at": "2019-06-25T15:21:39Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Minimal Changes Needed \r\n\r\n- [x] Construct attestation_data.crosslink\r\n\r\n- [x] Update attestation_data FFG vote variable\r\n\r\n\r\n\r\n### Submit deposit\r\n\r\nIn Phase 0, all incoming validator deposits originate from the Ethereum 1.0 PoW chain. Deposits are made to the [deposit contract](../core/0_deposit-contract.md) located at `DEPOSIT_CONTRACT_ADDRESS`.\r\n\r\nTo submit a deposit:\r\n\r\n* **Pack the validator's [initialization parameters](#initialization) into `deposit_data`, a [`DepositData`](../core/0_beacon-chain.md#depositdata) SSZ object.**\r\n* Let `amount` be the amount in Gwei to be deposited by the validator where **`MIN_DEPOSIT_AMOUNT <= amount <= MAX_EFFECTIVE_BALANCE`**.\r\n* Set **`deposit_data.amount = amount`**.\r\n* **Let `signature` be the result of `bls_sign` of the `signing_root(deposit_data)` with `domain=bls_domain(DOMAIN_DEPOSIT)`. (Deposits are valid regardless of fork version, `bls_domain` will default to zeroes there).**\r\n* **Send a transaction on the Ethereum 1.0 chain to `DEPOSIT_CONTRACT_ADDRESS` executing `def deposit(pubkey: bytes[48], withdrawal_credentials: bytes[32], signature: bytes[96])` along with a deposit of `amount` Gwei.**\r\n\r\n*Note*: Deposits made for the same `pubkey` are treated as for the same validator. A singular `Validator` will be added to `state.validator_registry` with each additional deposit amount added to the validator's balance. A validator can only be activated when total deposits for the validator pubkey meet or exceed `MAX_EFFECTIVE_BALANCE`.\r\n\r\n### Activation\r\n\r\nIn normal operation, the validator is quickly activated at which point the validator is added to the shuffling and begins validation after an additional `ACTIVATION_EXIT_DELAY` epochs (25.6 minutes).\r\n\r\n**The function [`is_active_validator`](../core/0_beacon-chain.md#is_active_validator) can be used to check if a validator is active during a given epoch.** Usage is as follows:\r\n\r\n<pre>\r\nvalidator = state.validator_registry[validator_index]\r\n<b>is_active = is_active_validator(validator, get_current_epoch(state))</b>\r\n</pre>\r\n\r\nOnce a validator is activated, the validator is assigned [responsibilities](#beacon-chain-responsibilities) until exited.\r\n\r\n*Note*: There is a maximum validator churn per finalized epoch so the delay until activation is variable depending upon finality, total active validator balance, and the number of validators in the queue to be activated.\r\n\r\n### Block proposal\r\n\r\n**A validator is expected to propose a [`BeaconBlock`](../core/0_beacon-chain.md#beaconblock) at the beginning of any slot during which `is_proposer(state, validator_index)` returns `True`.** To propose, the validator selects the `BeaconBlock`, `parent`, that in their view of the fork choice is the head of the chain during `slot - 1`. The validator creates, signs, and broadcasts a `block` that is a child of `parent` that satisfies a valid [beacon chain state transition](../core/0_beacon-chain.md#beacon-chain-state-transition-function).\r\n\r\nThere is one proposer per slot, so if there are N active validators any individual validator will on average be assigned to propose once per N slots (e.g. at 312500 validators = 10 million ETH, that's once per ~3 weeks).\r\n\r\n#### Block header\r\n\r\n##### Slot\r\n\r\nSet `block.slot = slot` where `slot` is the current slot at which the validator has been selected to propose. The `parent` selected must satisfy that `parent.slot < block.slot`.\r\n\r\n*Note*: There might be \"skipped\" slots between the `parent` and `block`. These skipped slots are processed in the state transition function without per-block processing.\r\n\r\n##### Parent root\r\n\r\nSet **`block.parent_root = signing_root(parent)`**.\r\n\r\n##### Eth1 Data\r\n\r\n`block.eth1_data` is a mechanism used by block proposers vote on a recent Ethereum 1.0 block hash and an associated deposit root found in the Ethereum 1.0 deposit contract. When consensus is formed, `state.latest_eth1_data` is updated, and validator deposits up to this root can be processed. The deposit root can be calculated by calling the `get_deposit_root()` function of the deposit contract using the post-state of the block hash.\r\n\r\n* Let `D` be the list of `Eth1DataVote` objects `vote` in `state.eth1_data_votes` where:\r\n    * `vote.eth1_data.block_hash` is the hash of an Eth 1.0 block that is (i) part of the canonical chain, (ii) >= `ETH1_FOLLOW_DISTANCE` blocks behind the head, and (iii) **newer than `state.latest_eth1_data.block_hash`**\r\n    * **`vote.eth1_data.deposit_count` is the deposit count of the Eth 1.0 deposit contract at the block defined by `vote.eth1_data.block_hash`.**\r\n    * `vote.eth1_data.deposit_root` is the deposit root of the Eth 1.0 deposit contract at the block defined by `vote.eth1_data.block_hash`.\r\n* If `D` is empty:\r\n    * Let `block_hash` be the block hash of the `ETH1_FOLLOW_DISTANCE`'th ancestor of the head of the canonical Eth 1.0 chain.\r\n    * **Let `deposit_root` and `deposit_count` be the deposit root and deposit count of the Eth 1.0 deposit contract in the post-state of the block referenced by `block_hash`**\r\n    * **Let `best_vote_data = Eth1Data(block_hash=block_hash, deposit_root=deposit_root, deposit_count=deposit_count)`.**\r\n* If `D` is nonempty:\r\n    * **Let `best_vote_data` be the `eth1_data` member of `D` that has the highest vote count (`D.count(eth1_data)`), breaking ties by favoring block hashes with higher associated block height.**\r\n* **Set `block.eth1_data = best_vote_data`.**\r\n\r\n##### Signature\r\n\r\nSet `block.signature = block_signature` where `block_signature` is defined as:\r\n\r\n<pre>\r\nblock_signature = bls_sign(\r\n    privkey=validator.privkey,  # privkey store locally, not in state\r\n    <b>message_hash=signing_root(block),</b>\r\n    domain=get_domain(\r\n        fork=fork,  # `fork` is the fork object at the slot `block.slot`\r\n        epoch=slot_to_epoch(block.slot),\r\n        domain_type=DOMAIN_BEACON_BLOCK,\r\n    )\r\n)\r\n</pre>\r\n\r\n##### Deposits\r\n\r\n**If there are any unprocessed deposits for the existing `state.latest_eth1_data` (i.e. `state.latest_eth1_data.deposit_count > state.deposit_index`), then pending deposits _must_ be added to the block. The expected number of deposits is exactly `min(MAX_DEPOSITS, latest_eth1_data.deposit_count - state.deposit_index)`.**  These [`deposits`](../core/0_beacon-chain.md#deposit) are constructed from the `Deposit` logs from the [Eth 1.0 deposit contract](../core/0_deposit-contract) and must be processed in sequential order. The deposits included in the `block` must satisfy the verification conditions found in [deposits processing](../core/0_beacon-chain.md#deposits).\r\n\r\nThe `proof` for each deposit must be constructed against the deposit root contained in `state.latest_eth1_data` rather than the deposit root at the time the deposit was initially logged from the 1.0 chain. This entails storing a full deposit merkle tree locally and computing updated proofs against the `latest_eth1_data.deposit_root` as needed. See [`minimal_merkle.py`](https://github.com/ethereum/research/blob/master/spec_pythonizer/utils/merkle_minimal.py) for a sample implementation.\r\n\r\n### Attestations\r\n\r\nA validator is expected to create, sign, and broadcast an attestation during each epoch. The `committee`, assigned `shard`, and assigned `slot` for which the validator performs this role during an epoch is defined by `get_committee_assignment(state, epoch, validator_index)`.\r\n\r\nA validator should create and broadcast the attestation halfway through the `slot` during which the validator is assigned â€• that is, `SECONDS_PER_SLOT * 0.5` seconds after the start of `slot`.\r\n\r\n#### Attestation data\r\n\r\nFirst the validator should construct `attestation_data`, an [`AttestationData`](../core/0_beacon-chain.md#attestationdata) object based upon the state at the assigned slot.\r\n\r\n* Let `head_block` be the result of running the fork choice during the assigned slot.\r\n* **Let `head_state` be the state of `head_block` processed through any empty slots up to the assigned slot using `process_slots(state, slot)`.**\r\n\r\n##### LMD GHOST vote\r\n\r\n**Set `attestation_data.beacon_block_root = signing_root(head_block)`**.\r\n\r\n##### FFG vote\r\n\r\n* **Set `attestation_data.source_epoch = head_state.current_justified_epoch`.**\r\n* **Set `attestation_data.source_root = head_state.current_justified_root`.**\r\n* **Set `attestation_data.target_epoch = get_current_epoch(head_state)`**\r\n* **Set `attestation_data.target_root = epoch_boundary_block_root` where `epoch_boundary_block_root` is the root of block at the most recent epoch boundary.\r\n\r\n*Note*: `epoch_boundary_block_root` can be looked up in the state using:\r\n* Let `epoch_start_slot = get_epoch_start_slot(get_current_epoch(head_state))`.\r\n* Let `epoch_boundary_block_root = signing_root(head_block) if epoch_start_slot == head_state.slot else get_block_root(state, epoch_start_slot)`.**\r\n\r\n##### Crosslink vote\r\n\r\nConstruct `attestation_data.crosslink` via the following.\r\n\r\n* **Set `attestation_data.crosslink.shard = shard` where `shard` is the shard associated with the validator's committee.**\r\n* **Let `parent_crosslink = head_state.current_crosslinks[shard]`.**\r\n* **Set `attestation_data.crosslink.start_epoch = parent_crosslink.end_epoch`.**\r\n* **Set `attestation_data.crosslink.end_epoch = min(attestation_data.target_epoch, parent_crosslink.end_epoch + MAX_EPOCHS_PER_CROSSLINK)`.**\r\n* **Set `attestation_data.crosslink.parent_root = hash_tree_root(head_state.current_crosslinks[shard])`.**\r\n* **Set `attestation_data.crosslink.data_root = ZERO_HASH`. *Note*: This is a stub for Phase 0.**\r\n\r\n#### Construct attestation\r\n\r\nNext the validator creates `attestation`, an [`Attestation`](../core/0_beacon-chain.md#attestation) object.\r\n\r\n##### Data\r\n\r\nSet `attestation.data = attestation_data` where `attestation_data` is the `AttestationData` object defined in the previous section, [attestation data](#attestation-data).\r\n\r\n##### Aggregation bitfield\r\n\r\n* Let `aggregation_bitfield` be a byte array filled with zeros of length `(len(committee) + 7) // 8`.\r\n* Let `index_into_committee` be the index into the validator's `committee` at which `validator_index` is located.\r\n* Set `aggregation_bitfield[index_into_committee // 8] |= 2 ** (index_into_committee % 8)`.\r\n* Set `attestation.aggregation_bitfield = aggregation_bitfield`.\r\n\r\n*Note*: **Calling `get_attesting_indices(state, attestation.data, attestation.aggregation_bitfield)` should return a list of length equal to 1, containing `validator_index`.**\r\n\r\n##### Custody bitfield\r\n\r\n* Let `custody_bitfield` be a byte array filled with zeros of length `(len(committee) + 7) // 8`.\r\n* Set `attestation.custody_bitfield = custody_bitfield`.\r\n\r\n*Note*: This is a stub for Phase 0.\r\n\r\n##### Aggregate signature\r\n\r\nSet `attestation.aggregate_signature = signed_attestation_data` where `signed_attestation_data` is defined as:\r\n\r\n```python\r\nattestation_data_and_custody_bit = AttestationDataAndCustodyBit(\r\n    data=attestation.data,\r\n    custody_bit=0b0,\r\n)\r\nattestation_message = hash_tree_root(attestation_data_and_custody_bit)\r\n\r\nsigned_attestation_data = bls_sign(\r\n    privkey=validator.privkey,  # privkey stored locally, not in state\r\n    message_hash=attestation_message,\r\n    domain=get_domain(\r\n        fork=fork,  # `fork` is the fork object at the slot, `attestation_data.slot`\r\n        epoch=slot_to_epoch(attestation_data.slot),\r\n        domain_type=DOMAIN_ATTESTATION,\r\n    )\r\n)\r\n```\r\n### Attester slashing\r\n\r\n**To avoid \"attester slashings\", a validator must not sign two conflicting [`AttestationData`](../core/0_beacon-chain.md#attestationdata) objects, i.e. two attestations that satisfy [`is_slashable_attestation_data`](../core/0_beacon-chain.md#is_slashable_attestation_data).**\r\n\r\nSpecifically, when signing an `Attestation`, a validator should perform the following steps in the following order:\r\n1. Save a record to hard disk that an attestation has been signed for source -- `attestation_data.source_epoch` -- and target -- `slot_to_epoch(attestation_data.slot)`.\r\n2. Generate and broadcast attestation.\r\n\r\nIf the software crashes at some point within this routine, then when the validator comes back online the hard disk has the record of the *potentially* signed/broadcast attestation and can effectively avoid slashing.\r\n\r\n",
  "closed_by": {
    "login": "cemozerr",
    "id": 16581242,
    "node_id": "MDQ6VXNlcjE2NTgxMjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/16581242?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cemozerr",
    "html_url": "https://github.com/cemozerr",
    "followers_url": "https://api.github.com/users/cemozerr/followers",
    "following_url": "https://api.github.com/users/cemozerr/following{/other_user}",
    "gists_url": "https://api.github.com/users/cemozerr/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cemozerr/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cemozerr/subscriptions",
    "organizations_url": "https://api.github.com/users/cemozerr/orgs",
    "repos_url": "https://api.github.com/users/cemozerr/repos",
    "events_url": "https://api.github.com/users/cemozerr/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cemozerr/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ConsenSys/teku/issues/723/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ConsenSys/teku/issues/723/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[

]
