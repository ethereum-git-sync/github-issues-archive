{
  "url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
  "repository_url": "https://api.github.com/repos/status-im/status-desktop",
  "labels_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954/labels{/name}",
  "comments_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954/comments",
  "events_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954/events",
  "html_url": "https://github.com/status-im/status-desktop/issues/11954",
  "id": 1858788669,
  "node_id": "I_kwDOD5KrTM5uyt09",
  "number": 11954,
  "title": "[Community Ownership] deploy Owner Token through community address",
  "user": {
    "login": "osmaczko",
    "id": 33099791,
    "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
    "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/osmaczko",
    "html_url": "https://github.com/osmaczko",
    "followers_url": "https://api.github.com/users/osmaczko/followers",
    "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
    "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
    "organizations_url": "https://api.github.com/users/osmaczko/orgs",
    "repos_url": "https://api.github.com/users/osmaczko/repos",
    "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
    "received_events_url": "https://api.github.com/users/osmaczko/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3047427135,
      "node_id": "MDU6TGFiZWwzMDQ3NDI3MTM1",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/feature",
      "name": "feature",
      "color": "0E8A16",
      "default": false,
      "description": ""
    },
    {
      "id": 4548141040,
      "node_id": "LA_kwDOD5KrTM8AAAABDxcf8A",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/messenger-team",
      "name": "messenger-team",
      "color": "232858",
      "default": false,
      "description": ""
    },
    {
      "id": 5732688644,
      "node_id": "LA_kwDOD5KrTM8AAAABVbHjBA",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/E:Desktop%20Tokenized%20Ownership",
      "name": "E:Desktop Tokenized Ownership",
      "color": "fbca04",
      "default": false,
      "description": "Implementation of the tokenization of community ownership and transfer of said ownership"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [
    {
      "login": "endulab",
      "id": 61889657,
      "node_id": "MDQ6VXNlcjYxODg5NjU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/61889657?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/endulab",
      "html_url": "https://github.com/endulab",
      "followers_url": "https://api.github.com/users/endulab/followers",
      "following_url": "https://api.github.com/users/endulab/following{/other_user}",
      "gists_url": "https://api.github.com/users/endulab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/endulab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/endulab/subscriptions",
      "organizations_url": "https://api.github.com/users/endulab/orgs",
      "repos_url": "https://api.github.com/users/endulab/repos",
      "events_url": "https://api.github.com/users/endulab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/endulab/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": {
    "url": "https://api.github.com/repos/status-im/status-desktop/milestones/65",
    "html_url": "https://github.com/status-im/status-desktop/milestone/65",
    "labels_url": "https://api.github.com/repos/status-im/status-desktop/milestones/65/labels",
    "id": 9039509,
    "node_id": "MI_kwDOD5KrTM4Aie6V",
    "number": 65,
    "title": "0.15",
    "description": "**1. Finish anything that wasn't completed in the previous 0.14 cycle**\r\n- And fix bugs as usual. We need to keep tech. debt at a roughly fixed level as we grow out functionality, can't let it accumulate! ;-)\r\n\r\n**2. Tokenisation of community ownership**\r\n- Work needed already evaluated in spike.  Community and 'Channel in a Community' URLs don't need to be signed if this will present problems. Patryk to work on this as a continuation of the spike already done.\r\n- See priority 4 below, as this also has some implications for the tokenisation of community work.\r\n\r\n**3. Profile showcase backend**\r\n- The long-delayed profile showcase backend!  We have the UI on the desktop ready to go for this feature, and Mobile is going to need the backend for this feature as well, so let's try to get it done in 0.14 [#11081](https://github.com/status-im/status-desktop/issues/11081)\r\n\r\n**4. Community tokens visible in wallet when received by user who is not a member of that community**\r\n- Solution obvs. needs to be fully decenteralised and permissionless\r\n- Perhaps whenever a community token is A) sent from a Status Wallet to another user or B) airdropped by a community or C) retailed by a community, a M2M (invisible to the user) Waku message should be sent to the recipient's *ethereum address*?\r\n- This message could either: A) contain the metadata for the token B) tell the user that they have received token, and to check the metadata in either another Waku channel where Control Nodes periodically post Metadata OR check the metadata embedded in the token contract (embedding metadata in the token contract might be a better idea?).  \r\n- The token metadata stored in the token contract is signed by the Community's private key to ensure authenticity.  When the community's private key changes due to ownership of a community being transferred or due to the control node being moved, a transaction must be made to update this metadata so it is signed by the community's new private key.\r\n- See here for how a Waku message can be sent to and Ethereum address https://rfc.vac.dev/spec/20/\r\n\r\n**5. Discord history import into a single channel in an existing community**\r\n- Pay off any Discord history import service tech. debt first\r\n- Then build the import into a single channel functionality, designs for this are already complete\r\n\r\n**6. UI for community owner to enable manual Waku static shading for their community**\r\n- This will be off by default in 0.15\r\n- This UI is only for the Owner of a community (not TokenMasters or Admins)\r\n- Figma designs are here https://www.figma.com/file/qHfFm7C9LwtXpfdbxssCK3/Kuba%E2%8E%9CDesktop---Communities?type=design&node-id=37242%3A222352&mode=design&t=rw6q6NQYmiz3rSn2-1\r\n\r\n**7. Community chat functionality enhancements**\r\n- Ability to mark a token gated channel as 'hidden', only visible to community members with the requisite tokens\r\n\r\n**8. Refactor synchronisation of contacts**\r\n- To fix various contact request issues, is a large work item\r\n- Mishka and Igor to work on this?\r\n- https://github.com/status-im/status-go/issues/3720\r\n- https://github.com/status-im/status-go/issues/3803#issuecomment-1654588500\r\n\r\n\r\n\r\n**--- Wallet Team ---**\r\n\r\n1. Finish anything that wasn't completed in the previous 0.14 cycle\r\n- And fix bugs as usual. We need to keep tech. debt at a roughly fixed level as we grow out functionality, can't let it accumulate! ;-)\r\n\r\n2. Sending Community created tokens to Status users who are not members of that community\r\n- See priority 4) in the messaging priorities list above.\r\n\r\n3. Send NFT functionality\r\n\r\n4. Updated wallet settings with keypair syncing\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "creator": {
      "login": "iurimatias",
      "id": 176720,
      "node_id": "MDQ6VXNlcjE3NjcyMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/176720?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/iurimatias",
      "html_url": "https://github.com/iurimatias",
      "followers_url": "https://api.github.com/users/iurimatias/followers",
      "following_url": "https://api.github.com/users/iurimatias/following{/other_user}",
      "gists_url": "https://api.github.com/users/iurimatias/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/iurimatias/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/iurimatias/subscriptions",
      "organizations_url": "https://api.github.com/users/iurimatias/orgs",
      "repos_url": "https://api.github.com/users/iurimatias/repos",
      "events_url": "https://api.github.com/users/iurimatias/events{/privacy}",
      "received_events_url": "https://api.github.com/users/iurimatias/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 177,
    "closed_issues": 30,
    "state": "open",
    "created_at": "2023-02-13T19:08:52Z",
    "updated_at": "2023-08-30T22:37:26Z",
    "due_on": "2023-09-29T07:00:00Z",
    "closed_at": null
  },
  "comments": 19,
  "created_at": "2023-08-21T07:38:20Z",
  "updated_at": "2023-08-31T11:52:54Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The Owner Token must be deployed by the community address. This is to prevent malicious owners from deploying multiple Owner Tokens with potentially harmful intentions in the future.\r\n\r\nThis will effectively bind the contract to the community. Clients will verify the owner token contract address by reviewing the transaction history of the community address; only the first deployment is valid.\r\n\r\nEdit: It should be possible to sign the transaction \"offline\" using the community key, then send the transaction using the user's wallet. That would mean the transaction would still count as performed by the community, but the gas would be paid by the user's wallet.\r\n\r\nCheck out Iuri's old presentation on Ethereum for an example of that. TLDW: he started a transaction in his wallet, took the data, signed it using the first wallet's private key, then took that signed transaction data and pasted it in another wallet. He could then send it using that second wallet, but it still did the transfer from the first wallet.\r\n\r\nIf we do it like that, we do not need all those steps below.\r\n\r\n---\r\n\r\nIgnore this if the way above works\r\n\r\nTo facilitate the deployment by the community address, it needs sufficient funds to cover the gas fees. Therefore, the procedure should be:\r\n1. The owner transfers ETH to the community address to cover gas fees.\r\n2. The community address deploys the Owner Token contract.\r\n3. The community address refunds any remaining ETH to the owner.\r\n4. The owner [sets signerPublicKey](https://github.com/status-im/communities-contracts/blob/8d3f185bf4d382d522815cff7cb2b70902cfffa8/contracts/mvp/OwnerToken.sol#L42) with its chat PublicKey.\r\n\r\n---\r\n\r\n### Acceptance criteria:\r\n- [ ] Owner Token contract is deployed by community address\r\n- [ ] Owner Token's [signerPublicKey](https://github.com/status-im/communities-contracts/blob/8d3f185bf4d382d522815cff7cb2b70902cfffa8/contracts/mvp/OwnerToken.sol#L10) property points to Owner's chat PublicKey\r\n\r\n#### Implementation:\r\nIdeally, these four steps should be executed in a single atomic transaction. This ensures that either all operations succeed, or none are executed, preventing any intermediate and undesirable state. If executing all in one transaction is not feasible, a robust recovery/retry mechanism should be implemented in the event that any of the transactions fail.\r\n\r\n#### Considerations:\r\nExtend Owner Token's constructor with `signerPublicKey` parameter to avoid step 4.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/11954/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1686536195",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1686536195",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1686536195,
    "node_id": "IC_kwDOD5KrTM5khoAD",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-21T15:21:22Z",
    "updated_at": "2023-08-21T15:21:22Z",
    "author_association": "MEMBER",
    "body": "Lookup signing a transaction by the community and then send the transaction with the user wallet (to pay the gas)",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1686536195/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690059649",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1690059649",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1690059649,
    "node_id": "IC_kwDOD5KrTM5kvEOB",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-23T14:23:01Z",
    "updated_at": "2023-08-23T14:23:01Z",
    "author_association": "MEMBER",
    "body": "It seems like if we go the route I suggested, it might make it so that the account paying the fee will still be the one marked as signer, which is not what we want, we need to find another solution",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690059649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690068784",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1690068784",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1690068784,
    "node_id": "IC_kwDOD5KrTM5kvGcw",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-23T14:28:08Z",
    "updated_at": "2023-08-23T14:28:08Z",
    "author_association": "MEMBER",
    "body": "One option I discussed with @endulab is to have a \"util/singleton\" contract called CommunityOwnerTokenDeployer, that would basically be a factory that would be deployed once, and we'd \"hardcode\" the address in status-go.\r\n\r\nThen, when deploying the Owner and TokenMaster tokens, we'd use this CommunityOwnerTokenDeployer contract instead and it would then store the addresses of the deployed token contracts in a map using the `communityID`.\r\n\r\nAfterwards, when a user gets sent an OwnerToken, they can ask the CommunityOwnerTokenDeployer if that token is indeed the right one for the community. The contract will check its map and send the address of the deployed token.\r\n\r\nWe need to check with contract experts to know if this option is doable.\r\n\r\nI do think it solves the problem of a malicious owner trying to scam with a fake owner token.\r\n\r\nWe then need to check if there are legal issues with deploying that type of CommunityOwnerTokenDeployer contract. ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690068784/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690134446",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1690134446",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1690134446,
    "node_id": "IC_kwDOD5KrTM5kvWeu",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-23T15:05:32Z",
    "updated_at": "2023-08-23T15:05:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I do think it solves the problem of a malicious owner trying to scam with a fake owner token.\r\n\r\nIf the `CommunityOwnerTokenDeployer` allows only for one contract per community then I think it solves it, no :thinking: ?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690134446/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690183107",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1690183107",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1690183107,
    "node_id": "IC_kwDOD5KrTM5kviXD",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-23T15:34:57Z",
    "updated_at": "2023-08-23T15:34:57Z",
    "author_association": "MEMBER",
    "body": "> > I do think it solves the problem of a malicious owner trying to scam with a fake owner token.\r\n> \r\n> If the `CommunityOwnerTokenDeployer` allows only for one contract per community then I think it solves it, no ðŸ¤” ?\r\n\r\nYep! (that's what I'm saying in the quoted text, maybe you misread)",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690183107/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690203126",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1690203126",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1690203126,
    "node_id": "IC_kwDOD5KrTM5kvnP2",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-23T15:46:31Z",
    "updated_at": "2023-08-23T15:46:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > > I do think it solves the problem of a malicious owner trying to scam with a fake owner token.\r\n> > \r\n> > \r\n> > If the `CommunityOwnerTokenDeployer` allows only for one contract per community then I think it solves it, no ðŸ¤” ?\r\n> \r\n> Yep! (that's what I'm saying in the quoted text, maybe you misread)\r\n\r\nLol, I read \"I don't think..\", sorry :sweat_smile: ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1690203126/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691395944",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691395944",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691395944,
    "node_id": "IC_kwDOD5KrTM5k0Kdo",
    "user": {
      "login": "endulab",
      "id": 61889657,
      "node_id": "MDQ6VXNlcjYxODg5NjU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/61889657?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/endulab",
      "html_url": "https://github.com/endulab",
      "followers_url": "https://api.github.com/users/endulab/followers",
      "following_url": "https://api.github.com/users/endulab/following{/other_user}",
      "gists_url": "https://api.github.com/users/endulab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/endulab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/endulab/subscriptions",
      "organizations_url": "https://api.github.com/users/endulab/orgs",
      "repos_url": "https://api.github.com/users/endulab/repos",
      "events_url": "https://api.github.com/users/endulab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/endulab/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T10:08:37Z",
    "updated_at": "2023-08-24T10:08:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "A few thoughts:\r\n1. We need deployer contract to be deployed on all chains we support.\r\n2. Such a contract will need an upgrade policy - what if we change Owner/Master contracts or want to add another type of contract? \r\n3. This solution will require Status company engagement - this is the legal issue Jo mentioned. This is a question to @John-44 .\r\n4. I still want to discuss with @gravityblast the idea of meta-transactions (transaction in transaction).",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691395944/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691419328",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691419328",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691419328,
    "node_id": "IC_kwDOD5KrTM5k0QLA",
    "user": {
      "login": "John-44",
      "id": 22846356,
      "node_id": "MDQ6VXNlcjIyODQ2MzU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22846356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-44",
      "html_url": "https://github.com/John-44",
      "followers_url": "https://api.github.com/users/John-44/followers",
      "following_url": "https://api.github.com/users/John-44/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-44/subscriptions",
      "organizations_url": "https://api.github.com/users/John-44/orgs",
      "repos_url": "https://api.github.com/users/John-44/repos",
      "events_url": "https://api.github.com/users/John-44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T10:25:29Z",
    "updated_at": "2023-08-24T10:25:29Z",
    "author_association": "NONE",
    "body": "> A few thoughts:\r\n> \r\n> 1. We need deployer contract to be deployed on all chains we support.\r\n> 2. Such a contract will need an upgrade policy - what if we change Owner/Master contracts or want to add another type of contract?\r\n\r\nI don't think it would require an upgrade policy.  If an update is needed, a new deplorer contract could just be deployed, and then we would make the Status client code aware of this new deplorer contract \r\n\r\n> 3. This solution will require Status company engagement - this is the legal issue Jo mentioned. This is a question to @John-44 \r\n\r\nI think this is probably fine, as long as the deplorer contract doesn't have an upgrade mechanism (so the only way to perform an upgrade is to deploy a new contract, and point the status client code at that new contract).   \r\n\r\n> 4. I still want to discuss with @gravityblast the idea of meta-transactions (transaction in transaction).\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691419328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691529643",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691529643",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691529643,
    "node_id": "IC_kwDOD5KrTM5k0rGr",
    "user": {
      "login": "endulab",
      "id": 61889657,
      "node_id": "MDQ6VXNlcjYxODg5NjU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/61889657?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/endulab",
      "html_url": "https://github.com/endulab",
      "followers_url": "https://api.github.com/users/endulab/followers",
      "following_url": "https://api.github.com/users/endulab/following{/other_user}",
      "gists_url": "https://api.github.com/users/endulab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/endulab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/endulab/subscriptions",
      "organizations_url": "https://api.github.com/users/endulab/orgs",
      "repos_url": "https://api.github.com/users/endulab/repos",
      "events_url": "https://api.github.com/users/endulab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/endulab/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T11:49:24Z",
    "updated_at": "2023-08-24T11:53:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "> \r\n> I don't think it would require an upgrade policy. If an update is needed, a new deplorer contract could just be deployed, and then we would make the Status client code aware of this new deplorer contract.\r\n\r\nIn this case we need to use the new and old deployer contract, because old ones already keep community <-> owner token data. Or we break backward-compatibility ?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691529643/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691596880",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691596880",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691596880,
    "node_id": "IC_kwDOD5KrTM5k07hQ",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T12:37:41Z",
    "updated_at": "2023-08-24T12:37:41Z",
    "author_association": "MEMBER",
    "body": "Hi everyone, reading this thread here and I might have some questions (because I do miss some context).\r\n\r\n> Afterwards, when a user gets sent an OwnerToken, they can ask the CommunityOwnerTokenDeployer if that token is indeed the right one for the community. The contract will check its map and send the address of the deployed token.\r\n\r\n@jrainville This \"they can ask the deployer token if it's indeed the right one\" part - is that happening in status-go? Meaning, somehow a Status client gets notified that the logged-in account has received an owner token and now it wants to verify if it's indeed the owner token of this community?\r\n\r\nIf the answer is yes, then:\r\n\r\n> I don't think it would require an upgrade policy. If an update is needed, a new deplorer contract could just be deployed, and then we would make the Status client code aware of this new deplorer contract\r\n\r\n^ This would become a problem. The `CommunityOwnerTokenDeployer` as described above would effectively function as a global registry for known communities <-> tokens. Without a proper upgrade mechanism and simply putting out another deployer contract, status-go wouldn't need to keep track of all deployer contracts in existence and ask them one by one. Not sure if that is feasible.\r\n\r\n> I think this is probably fine, as long as the deplorer contract doesn't have an upgrade mechanism (so the only way to perform an upgrade is to deploy a new contract, and point the status client code at that new contract).\r\n\r\n@John-44 if this part is indeed fine, then we might want to revisit  the deployment of owner/master token altogether because there's patterns that can be used to reduce gas costs by a lot, provided Status deploys some initial contract.\r\nIt talked with @gravityblast about this the other day and he said we couldn't use such a pattern because Status deploying a contract would not be an option.\r\n\r\nIf it *is* an option, we could maybe squeeze out some more gas, but would need to do some profiling on that.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691596880/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691630007",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691630007",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691630007,
    "node_id": "IC_kwDOD5KrTM5k1Dm3",
    "user": {
      "login": "John-44",
      "id": 22846356,
      "node_id": "MDQ6VXNlcjIyODQ2MzU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22846356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-44",
      "html_url": "https://github.com/John-44",
      "followers_url": "https://api.github.com/users/John-44/followers",
      "following_url": "https://api.github.com/users/John-44/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-44/subscriptions",
      "organizations_url": "https://api.github.com/users/John-44/orgs",
      "repos_url": "https://api.github.com/users/John-44/repos",
      "events_url": "https://api.github.com/users/John-44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T12:59:58Z",
    "updated_at": "2023-08-24T12:59:58Z",
    "author_association": "NONE",
    "body": "> > I don't think it would require an upgrade policy. If an update is needed, a new deplorer contract could just be deployed, and then we would make the Status client code aware of this new deplorer contract.\r\n> \r\n> In this case we need to use the new and old deployer contract, because old ones already keep community <-> owner token data. Or we break backward-compatibility ?\r\n\r\nCould a new contract reference data related to previous deplorer contracts?  If so, could this be a solution to the issue of preserving the data written to the previous contract when we deploy a replacement contract?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691630007/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691636029",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1691636029",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1691636029,
    "node_id": "IC_kwDOD5KrTM5k1FE9",
    "user": {
      "login": "John-44",
      "id": 22846356,
      "node_id": "MDQ6VXNlcjIyODQ2MzU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22846356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-44",
      "html_url": "https://github.com/John-44",
      "followers_url": "https://api.github.com/users/John-44/followers",
      "following_url": "https://api.github.com/users/John-44/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-44/subscriptions",
      "organizations_url": "https://api.github.com/users/John-44/orgs",
      "repos_url": "https://api.github.com/users/John-44/repos",
      "events_url": "https://api.github.com/users/John-44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-24T13:03:32Z",
    "updated_at": "2023-08-24T13:03:32Z",
    "author_association": "NONE",
    "body": "> @John-44 if this part is indeed fine, then we might want to revisit the deployment of owner/master token altogether because there's patterns that can be used to reduce gas costs by a lot, provided Status deploys some initial contract.\r\n> It talked with @gravityblast about this the other day and he said we couldn't use such a pattern because Status deploying a contract would not be an option.\r\n\r\nI think it's probably fine if Status deploys some initial contract *for the owner/TokenMaster contracts* only.  Also any initial contract that Status deploys shouldn't have an upgrade mechinism.\r\n\r\nThe contracts where Status *cannot* deploy an initial contract for (even if it saves gas) are:\r\n- The mint Asset contract\r\n- The mint Collectable contract\r\n- The future token retail contracts\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1691636029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1693124365",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1693124365",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1693124365,
    "node_id": "IC_kwDOD5KrTM5k6wcN",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-25T10:12:40Z",
    "updated_at": "2023-08-25T10:12:40Z",
    "author_association": "MEMBER",
    "body": "Hey everyone, a small update here.\r\nI've had a quick call with @endulab and @mprakhov to discuss some details. Here's a summary of what we've discussed/concluded. Please chime in with any thoughts or corrections if you see stuff that needs adjustment:\r\n\r\n1. First and foremost, this issue is about eliminating an attack vector where a malicious owner could deploy multiple (malicious) owner token contracts and put their addresses into the community description. This is why we need some mechanism where clients can verify that a given contract address is indeed the one that was deployed for the owner tokens of a contract.\r\n2. To solve this, the original idea was to have the community itself the contract and rely on the heuristic that only the first contract deployment of such a community would be considered valid and therefore we'd get around the issue that multiple contracts could be deployed by owners with potentially malicious usage.\r\n3. @osmaczko has laid out some path forward where the owner would send funds to the community account and then the community would perform the deployment.\r\n\r\nAt this point, I think it's also worth mentioning that, even though the flow above would ensure the community performs the deployment and therefore one can check on-chain if a given contract address was indeed the first one deployed by the community, **it doesn't actually guarantee *what* is being deployed. A malicious owner can still go ahead and change the source of the contract being deployed** (and still have the community perform the transaction, as the owner owns the private key at this point).\r\n\r\nThat being said, exploring the idea of a `CommunityOwnerDeployer` contract, I think this can indeed solve these issues and I'd like to invite everyone to challenge the trust assumptions and attack vectors.\r\n\r\nHere's how I think this could work:\r\n\r\n1. As already mentioned, Status would deploy the deployer contract which acts as a registry of `[communityID|ethAddress] <-> contractAddress` (or vice versa).\r\n2. We assume that this contract can be trusted and whatever state is represented in this contract is considered valid. Hence, anyone can go and ask the contract what's the owner token `contractAddress` for any given `communityID` or `communityEthAddress`.\r\n3. Deployments of tokens happens through this contract, so everyone can verify on-chain that the source for token deployments is indeed legit and not something unexpected\r\n4. Now it's important to ensure the state in the registry contract cannot be tempered with, and I think there are two options here\r\n4.1. The community account itself performs the deployment and the deployer contract uses `msg.sender` (which is the `communityEthAddress`) for the registry mapping key. In this scenario, only the community itself can perform the deployment with the side effect of having its address stored in the registry\r\n4.2. Since we still have the issue of communities being without funds we could now explore the case of the owner account performing the deployment transaction. In this case however, `msg.sender` is no longer the community, so to ensure the communityID/address ends up in the registry, we'd have the owner provide a signature to the transaction that is signed by the community, proofing that it's fine to have the communityID/address used as key in the registry.\r\n5. The deployer contract checks if the provided tx has a valid signature and only if the there's not already a contract address stored in the registry for this community, does it store the address. \r\n6. There's also no need for clients to check the transaction history of the community\r\n\r\n### Questions to clarify\r\n\r\n- Do clients want to verify token master tokens as well? If yes then their addresses have to be stored in the registry too.\r\n- Is there a chance we'll introduce additional token types in the future that need to live in the registry? Given that contract upgrades are a no-go, this could be an issue. How do we want to handle this case?\r\n\r\n### Additional considerations\r\n\r\n- If there's a chance we'd want to change the deployment process in the future, we might want to consider having the registry live in its own contract and then have the deployer talk to it. That way, we can keep the same registry across deployer versions. However, things get tricky if we have to change the registry itself (mean, new token types that need to be supported)",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1693124365/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1693693109",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1693693109",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1693693109,
    "node_id": "IC_kwDOD5KrTM5k87S1",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-25T17:18:22Z",
    "updated_at": "2023-08-25T17:18:22Z",
    "author_association": "MEMBER",
    "body": "> Since we still have the issue of communities being without funds we could now explore the case of the owner account performing the deployment transaction. In this case however, msg.sender is no longer the community, so to ensure the communityID/address ends up in the registry, we'd have the owner provide a signature to the transaction that is signed by the community, proofing that it's fine to have the communityID/address used as key in the registry.\r\n\r\nI think this 4.2 option is better. Like you said, 4.1 requires sending funds to the community which comes with a slew of possible problems and its not great UX.\r\n\r\n> Do clients want to verify token master tokens as well? If yes then their addresses have to be stored in the registry too.\r\n\r\nI'm not sure. The control node has the last say (only one that can modify the community description), so normal clients don't need to access that information.\r\nMaybe the control node would want that, but if we assume that the control node isn't compromised, then that means the community description is valid, hence the token masters are known and trustworthy.\r\n\r\n> Is there a chance we'll introduce additional token types in the future that need to live in the registry? Given that contract upgrades are a no-go, this could be an issue. How do we want to handle this case?\r\n\r\nWe should assume that we'll have new roles in the future. Will those roles need a special token like the TokenMaster does? I'm not sure. The admin for example can use any ERC721 or ERC20\r\nIf we assume that there will be new tokens, then it's probable that they will be similar to the TokenMaster one. I don't think from the top of my head that we'd have another \"super-master\" token like the Owner token.\r\nThat does mean that the Deployer contract could get upgraded. See next question.\r\n\r\n> If there's a chance we'd want to change the deployment process in the future, we might want to consider having the registry live in its own contract and then have the deployer talk to it. That way, we can keep the same registry across deployer versions. However, things get tricky if we have to change the registry itself (mean, new token types that need to be supported)\r\n\r\nI think having the Registry in its own contract is a good idea. It's more probable that the Deployer will change than the Registry will. \r\nLike I said above, we probably only want to keep Owner token address for a community, since the Owner is the one responsible for all the others.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1693693109/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1694591812",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1694591812",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1694591812,
    "node_id": "IC_kwDOD5KrTM5lAWtE",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-27T07:15:24Z",
    "updated_at": "2023-08-27T07:15:24Z",
    "author_association": "MEMBER",
    "body": "> I'm not sure. The control node has the last say (only one that can modify the community description), so normal clients don't need to access that information.\r\nMaybe the control node would want that, but if we assume that the control node isn't compromised, then that means the community description is valid, hence the token masters are known and trustworthy.\r\n\r\nSo, as far as I understood, the idea was that any (member) node can verify that a given contract address is indeed an owner token contract address for some community. Hence we discussed the idea of a registry that maps communityID<->contractAddress.\r\n\r\nHere I'm asking if these nodes also want to verify that a token address is indeed the tokenmaster token address for that community. So, do we need communityID<->tokenMasterAddress as well?\r\n\r\n> I think having the Registry in its own contract is a good idea. It's more probable that the Deployer will change than the Registry will.\r\n\r\nAfter further discussions offline with @3esmit , we might get away with not having a registry at all, but rather have contract addresses deterministically calculated. Will have to play around with this.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1694591812/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695682916",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1695682916",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1695682916,
    "node_id": "IC_kwDOD5KrTM5lEhFk",
    "user": {
      "login": "endulab",
      "id": 61889657,
      "node_id": "MDQ6VXNlcjYxODg5NjU3",
      "avatar_url": "https://avatars.githubusercontent.com/u/61889657?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/endulab",
      "html_url": "https://github.com/endulab",
      "followers_url": "https://api.github.com/users/endulab/followers",
      "following_url": "https://api.github.com/users/endulab/following{/other_user}",
      "gists_url": "https://api.github.com/users/endulab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/endulab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/endulab/subscriptions",
      "organizations_url": "https://api.github.com/users/endulab/orgs",
      "repos_url": "https://api.github.com/users/endulab/repos",
      "events_url": "https://api.github.com/users/endulab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/endulab/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-28T13:15:48Z",
    "updated_at": "2023-08-28T13:15:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "I also agree that option 4.2. is better than 4.1. 4.1 can be very problematic, especially in case of eg. not enough funds. It's hard to say what to do then, whether community should give back money to the owner or the owner should send more money to redo the transaction.\r\n\r\nRegarding tokenMaster mapping, every change made by tokenMaster should be accepted by the control node after all. Control Node knows who is tokenMaster. I am not sure if a member need to verify any operations made by token master. At the first sight it seems that we do not need to keep a mapping for token master.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695682916/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695706145",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1695706145",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1695706145,
    "node_id": "IC_kwDOD5KrTM5lEmwh",
    "user": {
      "login": "John-44",
      "id": 22846356,
      "node_id": "MDQ6VXNlcjIyODQ2MzU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22846356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-44",
      "html_url": "https://github.com/John-44",
      "followers_url": "https://api.github.com/users/John-44/followers",
      "following_url": "https://api.github.com/users/John-44/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-44/subscriptions",
      "organizations_url": "https://api.github.com/users/John-44/orgs",
      "repos_url": "https://api.github.com/users/John-44/repos",
      "events_url": "https://api.github.com/users/John-44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-28T13:30:31Z",
    "updated_at": "2023-08-28T13:30:31Z",
    "author_association": "NONE",
    "body": "I prefer option 4.2",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695706145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695886704",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1695886704",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1695886704,
    "node_id": "IC_kwDOD5KrTM5lFS1w",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-28T15:19:12Z",
    "updated_at": "2023-08-28T15:19:12Z",
    "author_association": "MEMBER",
    "body": "> Regarding tokenMaster mapping, every change made by tokenMaster should be accepted by the control node after all. Control Node knows who is tokenMaster. I am not sure if a member need to verify any operations made by token master. At the first sight it seems that we do not need to keep a mapping for token master.\r\n\r\nYup, that's what I was trying to say, but I realize I wasn't being very clear :sweat_smile: ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1695886704/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1700876443",
    "html_url": "https://github.com/status-im/status-desktop/issues/11954#issuecomment-1700876443",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11954",
    "id": 1700876443,
    "node_id": "IC_kwDOD5KrTM5lYVCb",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-31T11:38:46Z",
    "updated_at": "2023-08-31T11:52:54Z",
    "author_association": "MEMBER",
    "body": "Quick update here:\r\n\r\nI've implemented a new `CommunityTokenDeployer` contract and a `CommunityOwnerTokenRegistry` contract in this PR here: https://github.com/status-im/communities-contracts/pull/2\r\n\r\nYou can run this locally and execute the tests if you want to see how it works, but generally the idea is the following:\r\n\r\n1. Status has to deploy both `CommunityTokenDeployer` and `CommunityOwnerTokenRegistry`\r\n2. Users of Status will use `CommunityTokenDeployer.deploy()` to deploy their `OwnerToken` and `MasterToken` contracts\r\n3. The deployer contract will add an entry to the registry contract upon successful deployment. The entry is a mapping of the community ETH address to the owner token address. This will allow Status clients to verify a given owner token address was indeed created by a given community (address).\r\n4. While the community address ends up in the registry, it's the user/owner that performs the deployment. To ensure not anyone can create entries in the registry for any community, users have to provide an `EIP712` signature that was created by the community itself.\r\n5. The signature includes the community address, the address of the deployer/owner and a `deadline`. The deadline is a timestamp to ensure the signature isn't valid forever. So Status clients will have to set a reasonable value there.\r\n6. The deployer contracts checks if the deployer/owner address matches the one in the signature and whether the signature was indeed created by the community and only then adds the entry to the registry.\r\n\r\nFeel free to take a look and don't hesitate to ask if anything is unclear.\r\n\r\nThe PR still needs to be peer reviewed but I tried to account for any attack vectors I could think of.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1700876443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
