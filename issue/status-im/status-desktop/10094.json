{
  "url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
  "repository_url": "https://api.github.com/repos/status-im/status-desktop",
  "labels_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094/labels{/name}",
  "comments_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094/comments",
  "events_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094/events",
  "html_url": "https://github.com/status-im/status-desktop/issues/10094",
  "id": 1647961233,
  "node_id": "I_kwDOD5KrTM5iOeSR",
  "number": 10094,
  "title": "[Community permissions] Find a way to mitigate users buying a wallet signature \"attack\"",
  "user": {
    "login": "jrainville",
    "id": 11926403,
    "node_id": "MDQ6VXNlcjExOTI2NDAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jrainville",
    "html_url": "https://github.com/jrainville",
    "followers_url": "https://api.github.com/users/jrainville/followers",
    "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
    "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
    "organizations_url": "https://api.github.com/users/jrainville/orgs",
    "repos_url": "https://api.github.com/users/jrainville/repos",
    "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jrainville/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3047427135,
      "node_id": "MDU6TGFiZWwzMDQ3NDI3MTM1",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/feature",
      "name": "feature",
      "color": "0E8A16",
      "default": false,
      "description": ""
    },
    {
      "id": 4548141040,
      "node_id": "LA_kwDOD5KrTM8AAAABDxcf8A",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/messenger-team",
      "name": "messenger-team",
      "color": "232858",
      "default": false,
      "description": ""
    },
    {
      "id": 5745629806,
      "node_id": "LA_kwDOD5KrTM8AAAABVndabg",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/E:Desktop%20Comm%20Perms%20and%20Minting%20MVP",
      "name": "E:Desktop Comm Perms and Minting MVP",
      "color": "c2e0c6",
      "default": false,
      "description": "Misc tasks about Community permissions that are not part of another Epic, due for the MVP"
    },
    {
      "id": 5978035322,
      "node_id": "LA_kwDOD5KrTM8AAAABZFGUeg",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/E:Desktop%20Security%20Improvements%20MVP",
      "name": "E:Desktop Security Improvements MVP",
      "color": "f9d0c4",
      "default": false,
      "description": "Tasks to improve security for MVP"
    },
    {
      "id": 6176323312,
      "node_id": "LA_kwDOD5KrTM8AAAABcCM28A",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/E:Desktop%20Bugfixes%200.15.5",
      "name": "E:Desktop Bugfixes 0.15.5",
      "color": "BFE9C3",
      "default": false,
      "description": ""
    },
    {
      "id": 6343085517,
      "node_id": "LA_kwDOD5KrTM8AAAABehPNzQ",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/sprint-12-19",
      "name": "sprint-12-19",
      "color": "FFFFFF",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/status-im/status-desktop/milestones/70",
    "html_url": "https://github.com/status-im/status-desktop/milestone/70",
    "labels_url": "https://api.github.com/repos/status-im/status-desktop/milestones/70/labels",
    "id": 9405726,
    "node_id": "MI_kwDOD5KrTM4Aj4Ue",
    "number": 70,
    "title": "0.17",
    "description": "## Messaging & Communities team\r\n\r\n**1. Continue to fix bugs and stabilise chat and communities functionality as top priority**\r\n- includes any issues found during dogfooding\r\n\r\n**2. Status Communities / Discord bridge**\r\n- Ensure bridge works with token gated communities (e.g. permission is set at the community level that requires a token to be held to be a member of that community)\r\n- Ensure bridge works with token gated channels\r\n- On the Status Desktop side, individual messages from Discord are displayed as individual messages with Discord usernames\r\n\r\n**3. Ability to mark a token gated channel as 'hidden'**\r\n- A token gated channel that's marked as 'hidden' is only visible to community members that have the requisite tokens to access this channel\r\n- Design for this is completed\r\n\r\n**4. Continue work on profile showcase**\r\n\r\n**5. Refactor synchronisation of contacts**\r\n- To fix various contact request issues, is a large work item\r\n- Mishka and Igor to work on this?\r\n- https://github.com/status-im/status-go/issues/3720\r\n- https://github.com/status-im/status-go/issues/3803#issuecomment-1654588500\r\n\r\n&nbsp;\r\n\r\n## Wallet Team\r\n\r\n**1. Pre-tx signing dialog, for Community Admin, Browser, WalletConnet**\r\n\r\n**2. Continue work on WalletConnect support**\r\n\r\n**3. Improved 'saved accounts' functionality and 'share address' dialogue**\r\n\r\n**4. Database re-encryption flows**\r\n\r\n**5. If the above is completed before the end of the cycle, start work on total balance graphs for 'All accounts' and each individual account and all graph functionality**\r\n\r\n\r\n\r\n",
    "creator": {
      "login": "iurimatias",
      "id": 176720,
      "node_id": "MDQ6VXNlcjE3NjcyMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/176720?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/iurimatias",
      "html_url": "https://github.com/iurimatias",
      "followers_url": "https://api.github.com/users/iurimatias/followers",
      "following_url": "https://api.github.com/users/iurimatias/following{/other_user}",
      "gists_url": "https://api.github.com/users/iurimatias/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/iurimatias/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/iurimatias/subscriptions",
      "organizations_url": "https://api.github.com/users/iurimatias/orgs",
      "repos_url": "https://api.github.com/users/iurimatias/repos",
      "events_url": "https://api.github.com/users/iurimatias/events{/privacy}",
      "received_events_url": "https://api.github.com/users/iurimatias/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 64,
    "closed_issues": 0,
    "state": "open",
    "created_at": "2023-05-16T17:34:32Z",
    "updated_at": "2024-01-16T13:04:34Z",
    "due_on": "2024-03-28T07:00:00Z",
    "closed_at": null
  },
  "comments": 28,
  "created_at": "2023-03-30T16:42:07Z",
  "updated_at": "2024-01-16T09:57:17Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "# Description\r\n\r\nAs discussed in the meeting, it seems like it would be possible for a user that doesn't have access to a community, because they do not possess the required tokens, to just buy/get a wallet signature from someone who does.\r\n\r\nSince the current way to create the signature is that we sign the address with the wallet account, and then sign it with the Status account, thus linking the two, someone could actually cheat and get someone else to create the address wallet signature, get that signature and then sigh it with their own Status account. That would create a fake link between those two.\r\n\r\nWe need to find a way to either limit that or remove that possibility altogether.\r\n\r\nThis ticket is to first investigate a solution and then either close and fix in another issue or fix using this ticket.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/10094/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1490620785",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1490620785",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1490620785,
    "node_id": "IC_kwDOD5KrTM5Y2RFx",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-30T16:50:39Z",
    "updated_at": "2023-03-30T16:50:39Z",
    "author_association": "MEMBER",
    "body": "Some brainstorm ideas, let me know if I'm saying anything that is not doable:\r\n\r\n1. Add a timestamp to both signatures and the timestamps need to be within X seconds for it to be valid (let's say 5 seconds?)\r\n    - Maybe it's still possible to fake the timestamp inside the wallet address signature, but it does seem harder to get  a \"fake\" wallet signature without the \"attackers\" having an actual software to do it for them.\r\n2. Find a way to sign at the same time with both keys\r\n    - I have no idea if this exists, but some smart cryptography expert probably has thought of something like that before\r\n    - Basically, if we had a signature method that takes both keys at the same time to create a single signature, it would solve the problem.\r\n    - I'm not sure if it's safe or doable to do on our side, but since status-go has access to all keystores, it should be doable.\r\n3. What was proposed was to limit the number of times an address can be used (validated by the owner)\r\n    - This is not great, because it's very possible that someone would have multiple Status accounts and import the same wallet address in them, so we can't just block the re-using of the same address, so any limit we use would be arbitrary\r\n    - It still would work to mitigate the problem slightly\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1490620785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1491667853",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1491667853",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1491667853,
    "node_id": "IC_kwDOD5KrTM5Y6QuN",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-31T10:03:21Z",
    "updated_at": "2023-03-31T10:04:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "Interesting problem.\r\n\r\n> 2. Find a way to sign at the same time with both keys\r\n>    \r\n>    * I have no idea if this exists, but some smart cryptography expert probably has thought of something like that before\r\n>    * Basically, if we had a signature method that takes both keys at the same time to create a single signature, it would solve the problem.\r\n>    * I'm not sure if it's safe or doable to do on our side, but since status-go has access to all keystores, it should be doable.\r\n\r\nThis would be best. I did quick research and found this: https://github.com/hbakhtiyor/schnorr/#aggregatesignaturesprivatekeys-bigint-message-32byte-64byte-error. Although, I am not sure [how it works with secp256k1 keys](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\r\n\r\n![image](https://user-images.githubusercontent.com/33099791/229090479-6f86b9c7-2b80-4f12-b815-120863405875.png)\r\n\r\nFrom my understanding with Schnorr signatures, you can create a combined signature that requires both the wallet and Status account keys simultaneously.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1491667853/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1491673459",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1491673459",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1491673459,
    "node_id": "IC_kwDOD5KrTM5Y6SFz",
    "user": {
      "login": "caybro",
      "id": 5377645,
      "node_id": "MDQ6VXNlcjUzNzc2NDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5377645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/caybro",
      "html_url": "https://github.com/caybro",
      "followers_url": "https://api.github.com/users/caybro/followers",
      "following_url": "https://api.github.com/users/caybro/following{/other_user}",
      "gists_url": "https://api.github.com/users/caybro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/caybro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/caybro/subscriptions",
      "organizations_url": "https://api.github.com/users/caybro/orgs",
      "repos_url": "https://api.github.com/users/caybro/repos",
      "events_url": "https://api.github.com/users/caybro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/caybro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-31T10:07:25Z",
    "updated_at": "2023-03-31T10:07:25Z",
    "author_association": "MEMBER",
    "body": "> Interesting problem.\r\n> \r\n> > 2. Find a way to sign at the same time with both keys\r\n> >    \r\n> >    * I have no idea if this exists, but some smart cryptography expert probably has thought of something like that before\r\n> >    * Basically, if we had a signature method that takes both keys at the same time to create a single signature, it would solve the problem.\r\n> >    * I'm not sure if it's safe or doable to do on our side, but since status-go has access to all keystores, it should be doable.\r\n> \r\n> This would be best. I did quick research and found this: https://github.com/hbakhtiyor/schnorr/#aggregatesignaturesprivatekeys-bigint-message-32byte-64byte-error. Although, I am not sure [how it works with secp256k1 keys](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\r\n\r\nThe very first line says:\r\n> This is a Go implementation of the standard 64-byte Schnorr signature scheme over the elliptic curve secp256k1.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1491673459/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 2,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1492094328",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1492094328",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1492094328,
    "node_id": "IC_kwDOD5KrTM5Y7414",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-03-31T15:13:22Z",
    "updated_at": "2023-03-31T15:13:22Z",
    "author_association": "MEMBER",
    "body": "I read the doc on that library and it seems like what we need. It would totally fix the attack vector we have. I'll wait to start implementation on this until more people can think it through and see if there are maybe edge cases we didn't consider. Also, it's not necessary for the RC.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1492094328/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1850227242",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1850227242",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1850227242,
    "node_id": "IC_kwDOD5KrTM5uSDoq",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-11T14:47:54Z",
    "updated_at": "2023-12-11T14:47:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "For this issue (when a user wants to join the community and we need to be sure that the signature cannot be reused) we should do the following:\r\n\r\n- the user asks the community to join\r\n- community creates a unique message M1 = \"CommunityId|UserPublicKey|CurrentTimestamp\" (basically anything that ensures uniqueness) that needs to be signed and stores that message M1 in the local table for the key that can be user's address\r\n- the user signs the message M1, received from the community \r\n- the user sends the final request to join the community\r\n- the community validates the signature and verifies the message comparing it with the one stored in the table and checks if the timestamp is not older than 5 minutes (let's say 5 minutes is the time after which a generated request expires)\r\n- if all went well, the user becomes a member of the community and the request is removed from the table, otherwise error is returned and the request is removed from the table (also we should periodically check and remove expired requests from the table)\r\n\r\nUsing that approach there is no chance to have user A that will use the signature of user B to successfully join the community.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1850227242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851599266",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851599266",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851599266,
    "node_id": "IC_kwDOD5KrTM5uXSmi",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T09:16:51Z",
    "updated_at": "2023-12-12T09:16:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Using that approach there is no chance to have user A that will use the signature of user B to successfully join the community.\r\n\r\nIsn't there still a 5-minute window where someone else could provide a signature?\r\n\r\n> the user asks the community to join\r\n> community creates a unique message M1 = \"CommunityId|UserPublicKey|CurrentTimestamp\" (basically anything that ensures uniqueness) that needs to be signed and stores that message M1 in the local table for the key that can be user's address\r\n\r\nThis process will make joining a community slightly more complex and potentially less reliable in case any message is lost.\r\n```\r\nrequest to join ->\r\n<- unique message to sign\r\nsigned message ->\r\n<- request to join acceptance\r\n```\r\nvs\r\n```\r\nrequest to join ->\r\n<- request to join acceptance\r\n```\r\n\r\n@saledjenic I don't see the advantage of this proposed approach over Schnorr signatures, am I missing something?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851599266/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851755063",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851755063",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851755063,
    "node_id": "IC_kwDOD5KrTM5uX4o3",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T10:25:38Z",
    "updated_at": "2023-12-12T10:25:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Isn't there still a 5-minute window where someone else could provide a signature?\r\n\r\nEven if we go without a 5-minute window, there is no way that somebody else may sign a message instead of one the message is meant to, until one steals the primary key. A community knows which message is prepared for whom. The only one who can sign it is the one the message is meant to, the community will verify that by inspecting the signature. So if someone else signs the message, the signature will not be correct. \r\n\r\n> This process will make joining a community slightly more complex and potentially less reliable in case any message is lost.\r\n\r\nYes, it will have one step more, will be like:\r\n```\r\n1. request to join ->\r\n2. <- unique message to sign\r\n3. at this step, the user signs the message with each address he wants to reveal to the community and sending those signatures is a prove of ownership of those addresses, where the community decides whether to accept the user as a member of the community or not\r\n```\r\n\r\n> I don't see the advantage of this proposed approach over Schnorr signatures, am I missing something?\r\n\r\nI don't know what's Schnorr signatures, but what I am sure about is that the approach I mentioned above is fully secure.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851755063/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851766782",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851766782",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851766782,
    "node_id": "IC_kwDOD5KrTM5uX7f-",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T10:32:33Z",
    "updated_at": "2023-12-12T10:32:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "@osmaczko ahh I see above, that you shared the link to Schnorr signatures, well as I see it signs the message with multiple addresses, that's good, the same as what I said, but applying that without making a unique new message that needs to be signed for each new join community request, even for the same user, won't help. Cause at the end even if we use Schnorr signatures over the same message the signature will be the same and somebody else can reuse it, and that's what we're trying to solve. \r\n\r\nIn the approach I shared above, when a community generates for each joining community request a new unique message that needs to be signed no way of reusing the signature.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851766782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851929937",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851929937",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851929937,
    "node_id": "IC_kwDOD5KrTM5uYjVR",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T12:20:03Z",
    "updated_at": "2023-12-12T12:20:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Even if we go without a 5-minute window, there is no way that somebody else may sign a message instead of one the message is meant to, until one steals the primary key. A community knows which message is prepared for whom. The only one who can sign it is the one the message is meant to, the community will verify that by inspecting the signature. So if someone else signs the message, the signature will not be correct.\r\n\r\nNot sure I understand. Will this message be signed by chat key or wallet? How do we prove we are indeed the owners of given addresses?\r\n\r\n> Cause at the end even if we use Schnorr signatures over the same message the signature will be the same and somebody else can reuse it, and that's what we're trying to solve.\r\n\r\nThe whole idea with Schnorr is to exactly avoid what you wrote. Let me explain it more explicitly. We now send `RequestToJoin` with signed revealed addresses as follows:\r\n```\r\nRequestToJoin + signature(chat key)\r\n - address1 + signature(wallet key 1)\r\n - address2 + signature(wallet key 2)\r\n ...\r\n - addressN + signature(wallet key N)\r\n```\r\n\r\nThe problem with the above, is that `addressN + signature(wallet key N)` can be provided by someone else. For instance, if I own tokens that allows me to join certain community, I can send you this piece of data. Then you can put it inside `RequestToJoin` and sign it with your chat key, effectively making yourself being able to join the community.\r\n\r\nTo solve that, we need to prove we poses all the keys at the same time, that's when Schnorr kicks in, it will look as follows:\r\n```\r\nRequestToJoin + signature(chat key)\r\n - address1 + signature(wallet key 1 + chat key) aka Schnorr\r\n - address2 + signature(wallet key 2 + chat key) aka Schnorr\r\n ...\r\n - addressN + signature(wallet key N + chat key) aka Schnorr\r\n```\r\n\r\nIn other words, somebody else can't reuse it, because we use the combination of wallet key and chat key.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851929937/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851967189",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851967189",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851967189,
    "node_id": "IC_kwDOD5KrTM5uYsbV",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T12:44:56Z",
    "updated_at": "2023-12-12T12:44:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Not sure I understand. Will this message be signed by chat key or wallet? How do we prove we are indeed the owners of given addresses?\r\n\r\nThat message will be signed by the private key of every address the user wants to reveal to the community.\r\nUser wants to expose 3 addresses, he will need to sign the message prepared by community with each of those 3 addresses and send those 3 signatures to the community as part of the joining community request.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851967189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851979694",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851979694",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851979694,
    "node_id": "IC_kwDOD5KrTM5uYveu",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T12:53:09Z",
    "updated_at": "2023-12-12T12:53:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "@osmaczko not sure what `chat key` and `wallet key` in your examples refer to? Is that chat public key or chat private key?\r\nAlso in that example address is not needed since it can be determined from the signature.\r\nIn order to say more, could you tell me what are all the details we're sending when sending a request to join the community?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851979694/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851979938",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1851979938",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1851979938,
    "node_id": "IC_kwDOD5KrTM5uYvii",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T12:53:18Z",
    "updated_at": "2023-12-12T12:53:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "> That message will be signed by the private key of every address the user wants to reveal to the community.\r\n> User wants to expose 3 addresses, he will need to sign the message prepared by community with each of those 3 addresses and send those 3 signatures to the community as part of the joining community request.\r\n\r\nWhat prevents someone else from signing these messages :thinking: ? For instance, if you received a message from the community and then forwarded it to me, I could sign it with my wallet and send it back to you. Subsequently, you could send it back to the community.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1851979938/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852009468",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1852009468",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1852009468,
    "node_id": "IC_kwDOD5KrTM5uY2v8",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T13:11:53Z",
    "updated_at": "2023-12-12T13:11:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @osmaczko not sure what `chat key` and `wallet key` in your examples refer to? Is that chat public key or chat private key?\r\n\r\nIn order to create a signature you always need a private key, so those are private keys.\r\n\r\n> Also in that example address is not needed since it can be determined from the signature.\r\n\r\nThis is a detail, I just presented high level overview of the problem. We can sign whatever message and retrieve the address from signature. Currently we do it as follows: \r\n\r\nhttps://github.com/status-im/status-go/blob/dfe6baed9b796f2e5440625b640e80eec8b7fdfb/protocol/messenger_communities.go#L919-L922\r\n\r\nhttps://github.com/status-im/status-go/blob/dfe6baed9b796f2e5440625b640e80eec8b7fdfb/protocol/communities/manager.go#L2427-L2442\r\n\r\n> In order to say more, could you tell me what are all the details we're sending when sending a request to join the community?\r\n\r\nhttps://github.com/status-im/status-go/blob/dfe6baed9b796f2e5440625b640e80eec8b7fdfb/protocol/protobuf/communities.pb.go#L1103-L1114\r\n\r\nIn short, we send `RevealedAccounts` array and each element contains a signature. I presented it as simplified expression:\r\n```\r\nRequestToJoin + signature(chat key)\r\n - address1 + signature(wallet key 1)\r\n - address2 + signature(wallet key 2)\r\n ...\r\n - addressN + signature(wallet key N)\r\n```\r\n\r\nHope it makes it clear.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852009468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852141041",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1852141041",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1852141041,
    "node_id": "IC_kwDOD5KrTM5uZW3x",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T14:26:26Z",
    "updated_at": "2023-12-12T14:26:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "> In order to create a signature you always need a private key, so those are private keys.\r\n\r\nExactly, but in the example above you said this...\r\n```\r\nRequestToJoin + signature(chat key)\r\n - address1 + signature(wallet key 1 + chat key) aka Schnorr\r\n - address2 + signature(wallet key 2 + chat key) aka Schnorr\r\n ...\r\n - addressN + signature(wallet key N + chat key) aka Schnorr\r\n```\r\n\r\nDoes that mean we need to make a signature of private key of each address?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852141041/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852308930",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1852308930",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1852308930,
    "node_id": "IC_kwDOD5KrTM5uZ_3C",
    "user": {
      "login": "osmaczko",
      "id": 33099791,
      "node_id": "MDQ6VXNlcjMzMDk5Nzkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/33099791?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osmaczko",
      "html_url": "https://github.com/osmaczko",
      "followers_url": "https://api.github.com/users/osmaczko/followers",
      "following_url": "https://api.github.com/users/osmaczko/following{/other_user}",
      "gists_url": "https://api.github.com/users/osmaczko/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osmaczko/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osmaczko/subscriptions",
      "organizations_url": "https://api.github.com/users/osmaczko/orgs",
      "repos_url": "https://api.github.com/users/osmaczko/repos",
      "events_url": "https://api.github.com/users/osmaczko/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osmaczko/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-12T15:49:56Z",
    "updated_at": "2023-12-12T15:49:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > In order to create a signature you always need a private key, so those are private keys.\r\n> \r\n> Exactly, but in the example above you said this...\r\n> \r\n> ```\r\n> RequestToJoin + signature(chat key)\r\n>  - address1 + signature(wallet key 1 + chat key) aka Schnorr\r\n>  - address2 + signature(wallet key 2 + chat key) aka Schnorr\r\n>  ...\r\n>  - addressN + signature(wallet key N + chat key) aka Schnorr\r\n> ```\r\n> \r\n> Does that mean we need to make a signature of private key of each address?\r\n\r\nchat key - is private key of the chat\r\nwallet key - is private key of the wallet\r\n\r\nWe need to prove (sign) each revealed wallet address with both private keys **at the same time** - the private key of the wallet and private key of the chat key. Schnorr enables that. In pseudocode, again very simplified:\r\n\r\nSender side:\r\n```\r\n  data := addressDataToSign(wallet.address)\r\n  privateKeys := {messenger.privateKey, wallet.privateKey}\r\n  signature := schnorr.sign(privateKeys, data)\r\n  sendMessage(data, signature)\r\n```\r\nReceiver side:\r\n```\r\n  user := getUser(message)\r\n  address := getRevealedAddress(message)\r\n  \r\n  if (!schnorr.verify(user, message.data, message.signature)) {\r\n     error(\"user didn't sign the message\")\r\n  }\r\n  if (!schnorr.verify(address, message.data, message.signature)) {\r\n     error(\"wallet didn't sign the message\")\r\n  }\r\n\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1852308930/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1853493805",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1853493805",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1853493805,
    "node_id": "IC_kwDOD5KrTM5uehIt",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-13T08:46:50Z",
    "updated_at": "2023-12-13T09:29:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "@osmaczko and I had a call to discuss what's the best way to overcome this issue, considering all the features we have implemented so far.\r\n\r\nConclusion:\r\n- The only real proof that the PublicChat key that is going to join a community is the owner of the addresses that it is going to join with is signing a message combining PrivateKey of the chat key and PrivateKey of the address, and making such signature for each address it wants to reveal to a community. That's possible using Schnorr signatures, need to implement this on the status-go side.\r\n- When we come to a Keycard, the fact is that once the user logs in, the private key of the chat key is stored in the RAM, regardless if the profile keypair is migrated to a Keycard or not. That facilitates things a lot. The only we need now is to extend the keycard library that will make a combined signature (using received PrivateKey (which will be the chat key of the logged user) and PrivateKey of the address (which will be calculated on the Keycard)) of the message being signed. Example of the call `signCombined(pin, privateKey, address_path, message)`.\r\n\r\n@John-44 @bitgamma could we hear your thoughts on this? ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1853493805/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1855661351",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1855661351",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1855661351,
    "node_id": "IC_kwDOD5KrTM5umyUn",
    "user": {
      "login": "bitgamma",
      "id": 12899729,
      "node_id": "MDQ6VXNlcjEyODk5NzI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/12899729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitgamma",
      "html_url": "https://github.com/bitgamma",
      "followers_url": "https://api.github.com/users/bitgamma/followers",
      "following_url": "https://api.github.com/users/bitgamma/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitgamma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitgamma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitgamma/subscriptions",
      "organizations_url": "https://api.github.com/users/bitgamma/orgs",
      "repos_url": "https://api.github.com/users/bitgamma/repos",
      "events_url": "https://api.github.com/users/bitgamma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitgamma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-14T11:18:52Z",
    "updated_at": "2023-12-14T11:18:52Z",
    "author_association": "MEMBER",
    "body": "@saledjenic Keycard does not support Schnorr signatures",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1855661351/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1855687114",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1855687114",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1855687114,
    "node_id": "IC_kwDOD5KrTM5um4nK",
    "user": {
      "login": "bitgamma",
      "id": 12899729,
      "node_id": "MDQ6VXNlcjEyODk5NzI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/12899729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitgamma",
      "html_url": "https://github.com/bitgamma",
      "followers_url": "https://api.github.com/users/bitgamma/followers",
      "following_url": "https://api.github.com/users/bitgamma/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitgamma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitgamma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitgamma/subscriptions",
      "organizations_url": "https://api.github.com/users/bitgamma/orgs",
      "repos_url": "https://api.github.com/users/bitgamma/repos",
      "events_url": "https://api.github.com/users/bitgamma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitgamma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-14T11:37:11Z",
    "updated_at": "2023-12-14T11:37:11Z",
    "author_association": "MEMBER",
    "body": "/cc @guylouis ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1855687114/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860121791",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860121791",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860121791,
    "node_id": "IC_kwDOD5KrTM5u3zS_",
    "user": {
      "login": "bitgamma",
      "id": 12899729,
      "node_id": "MDQ6VXNlcjEyODk5NzI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/12899729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitgamma",
      "html_url": "https://github.com/bitgamma",
      "followers_url": "https://api.github.com/users/bitgamma/followers",
      "following_url": "https://api.github.com/users/bitgamma/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitgamma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitgamma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitgamma/subscriptions",
      "organizations_url": "https://api.github.com/users/bitgamma/orgs",
      "repos_url": "https://api.github.com/users/bitgamma/repos",
      "events_url": "https://api.github.com/users/bitgamma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitgamma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T10:53:07Z",
    "updated_at": "2023-12-18T10:53:07Z",
    "author_association": "MEMBER",
    "body": "I don't know all the details so correct me if I am wrong. If the current implementation is:\r\n\r\nsign(sign(address1, wallet_key), chat_key)\r\n\r\nand the proposed solution is\r\n\r\nsign(address1, wallet_key + chat_key) => Schnorr\r\n\r\nto avoid using Schnorr couldn't we do\r\n\r\nsign(sign(address1 + chat_address), wallet_key), chat_key) \r\n\r\nthe advantage would be that we retain compatibility with Keycard and unless this violates some requirements I am not aware of, it should solve the same issue since if you do the second sign step with the wrong chat key it would be easy to detect.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860121791/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860212891",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860212891",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860212891,
    "node_id": "IC_kwDOD5KrTM5u4Jib",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T11:26:06Z",
    "updated_at": "2023-12-18T11:26:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> sign(sign(address1 + chat_address), wallet_key), chat_key)\r\n\r\nIf wallet_key and chat_key refer to private keys, do we really want to send the message containing private keys over the wire?\r\n\r\nIf they don't refer to private keys, then it doesn't work, a user will still be able to cheat.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860212891/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860234167",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860234167",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860234167,
    "node_id": "IC_kwDOD5KrTM5u4Ou3",
    "user": {
      "login": "bitgamma",
      "id": 12899729,
      "node_id": "MDQ6VXNlcjEyODk5NzI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/12899729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitgamma",
      "html_url": "https://github.com/bitgamma",
      "followers_url": "https://api.github.com/users/bitgamma/followers",
      "following_url": "https://api.github.com/users/bitgamma/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitgamma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitgamma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitgamma/subscriptions",
      "organizations_url": "https://api.github.com/users/bitgamma/orgs",
      "repos_url": "https://api.github.com/users/bitgamma/repos",
      "events_url": "https://api.github.com/users/bitgamma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitgamma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T11:35:52Z",
    "updated_at": "2023-12-18T11:37:00Z",
    "author_association": "MEMBER",
    "body": "no the \"wallet_key\" and \"chat_key\" refer to the private key but they are used to sign, not to be transferred. The chat_address is the address associated to the chat_key that is supposed to do the final signature. To put it in words, with wallet key you sign not only address1 but you sign address1 + chat_address (or chat_public_key). This way if the second signature is generated by attacker_chat_key you can simply verify that the signer doesn't match the expected one (the one included in the first signature). \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860234167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860333413",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860333413",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860333413,
    "node_id": "IC_kwDOD5KrTM5u4m9l",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T12:15:01Z",
    "updated_at": "2023-12-18T12:15:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "Let me give you the context about the problem we have. Imagine there is a Community that set a rule saying that only members who have more than 10 ETH on their accounts can join. \r\n\r\nNow imagine there is a poor user A (has less than 10 ETH) who wants to join the Community and a rich user B (has 10+ ETH).\r\n\r\nNow, a joining community request among other things contains the signature of the message signed by chat_private_key and the signature of the message signed by the wallet_private_key. That's how it's implemented now and how we prove that the owner of the chat key is the same as the owner of the wallet address. That approach is not good cause nothing stops user A from paying significantly less to user B to sign the message for him and user A can use that signature to prove that he owns the wallet address and the Community has no way to check that.\r\n\r\nWhat you're saying is:\r\n1. sign message composed of `WalletAddress + ChatAddress` using wallet_private_key\r\n2. sign the signature made in point 1. using chat_private_key\r\n\r\nThat doesn't work, cause user A can still ask user B to sign the message `WalletAddress (of user B) + ChatAddress (of user A)` and send him back the signature which user A can sign using his chat_private_key and send the request to join the Community.\r\n\r\nSo as far as we see we need to include both private keys (chat_private_key + wallet_private_key) in signing the message/request to join.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860333413/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860379360",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860379360",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860379360,
    "node_id": "IC_kwDOD5KrTM5u4yLg",
    "user": {
      "login": "John-44",
      "id": 22846356,
      "node_id": "MDQ6VXNlcjIyODQ2MzU2",
      "avatar_url": "https://avatars.githubusercontent.com/u/22846356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-44",
      "html_url": "https://github.com/John-44",
      "followers_url": "https://api.github.com/users/John-44/followers",
      "following_url": "https://api.github.com/users/John-44/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-44/subscriptions",
      "organizations_url": "https://api.github.com/users/John-44/orgs",
      "repos_url": "https://api.github.com/users/John-44/repos",
      "events_url": "https://api.github.com/users/John-44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T12:34:25Z",
    "updated_at": "2023-12-18T12:34:25Z",
    "author_association": "NONE",
    "body": "FYI @iurimatias for visibility ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860379360/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860381487",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1860381487",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1860381487,
    "node_id": "IC_kwDOD5KrTM5u4ysv",
    "user": {
      "login": "bitgamma",
      "id": 12899729,
      "node_id": "MDQ6VXNlcjEyODk5NzI5",
      "avatar_url": "https://avatars.githubusercontent.com/u/12899729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitgamma",
      "html_url": "https://github.com/bitgamma",
      "followers_url": "https://api.github.com/users/bitgamma/followers",
      "following_url": "https://api.github.com/users/bitgamma/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitgamma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitgamma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitgamma/subscriptions",
      "organizations_url": "https://api.github.com/users/bitgamma/orgs",
      "repos_url": "https://api.github.com/users/bitgamma/repos",
      "events_url": "https://api.github.com/users/bitgamma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitgamma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-12-18T12:35:20Z",
    "updated_at": "2023-12-18T12:38:13Z",
    "author_association": "MEMBER",
    "body": "I was missing the point that user A and user B are collaborating in the attack. I was under the assumption user B is being attacked by user A. \r\n\r\nIf user A and B are collaborating, Schnorr signatures do not help. User A and User B can each produce a signature with just their key and then user A can aggregate them by simply summing them. More info at  https://blog.blockstream.com/en-musig-key-aggregation-schnorr-signatures/. The idea is that individual signatures can be aggregated into a combined one after being generated (as long as they used the same nonce, but if they are collaborating they can do that)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1860381487/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1889541251",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1889541251",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1889541251,
    "node_id": "IC_kwDOD5KrTM5woByD",
    "user": {
      "login": "guylouis",
      "id": 11461437,
      "node_id": "MDQ6VXNlcjExNDYxNDM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/11461437?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guylouis",
      "html_url": "https://github.com/guylouis",
      "followers_url": "https://api.github.com/users/guylouis/followers",
      "following_url": "https://api.github.com/users/guylouis/following{/other_user}",
      "gists_url": "https://api.github.com/users/guylouis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guylouis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guylouis/subscriptions",
      "organizations_url": "https://api.github.com/users/guylouis/orgs",
      "repos_url": "https://api.github.com/users/guylouis/repos",
      "events_url": "https://api.github.com/users/guylouis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guylouis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-12T15:48:41Z",
    "updated_at": "2024-01-12T15:49:03Z",
    "author_association": "NONE",
    "body": "anyone with an idea on how to solve this then?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1889541251/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1891803889",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1891803889",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1891803889,
    "node_id": "IC_kwDOD5KrTM5wwqLx",
    "user": {
      "login": "guylouis",
      "id": 11461437,
      "node_id": "MDQ6VXNlcjExNDYxNDM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/11461437?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guylouis",
      "html_url": "https://github.com/guylouis",
      "followers_url": "https://api.github.com/users/guylouis/followers",
      "following_url": "https://api.github.com/users/guylouis/following{/other_user}",
      "gists_url": "https://api.github.com/users/guylouis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guylouis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guylouis/subscriptions",
      "organizations_url": "https://api.github.com/users/guylouis/orgs",
      "repos_url": "https://api.github.com/users/guylouis/repos",
      "events_url": "https://api.github.com/users/guylouis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guylouis/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-15T10:17:40Z",
    "updated_at": "2024-01-15T10:17:40Z",
    "author_association": "NONE",
    "body": "for info I quickly mentioned this problem with @cammellos, and here's my understanding of the discussion:\r\n- there might not be cryptographic ways to prevent this: a user A could always collaborate with a user B to provide some information that B would sign with his wallet account. Thus B is effectively \"lending\" a wallet account to A. \r\n- if we want to prevent this, which is probably a product decision (@John-44 ) then an option would be to have the community admin to check that only one wallet per community is allowed ",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1891803889/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1891831488",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1891831488",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1891831488,
    "node_id": "IC_kwDOD5KrTM5www7A",
    "user": {
      "login": "cammellos",
      "id": 1017008,
      "node_id": "MDQ6VXNlcjEwMTcwMDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1017008?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cammellos",
      "html_url": "https://github.com/cammellos",
      "followers_url": "https://api.github.com/users/cammellos/followers",
      "following_url": "https://api.github.com/users/cammellos/following{/other_user}",
      "gists_url": "https://api.github.com/users/cammellos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cammellos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cammellos/subscriptions",
      "organizations_url": "https://api.github.com/users/cammellos/orgs",
      "repos_url": "https://api.github.com/users/cammellos/repos",
      "events_url": "https://api.github.com/users/cammellos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cammellos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-15T10:34:06Z",
    "updated_at": "2024-01-15T10:34:06Z",
    "author_association": "MEMBER",
    "body": "> Reference in new issue\r\n\r\n(it would not prevent the issue instead it would mitigate it to some extend)",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1891831488/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1893412731",
    "html_url": "https://github.com/status-im/status-desktop/issues/10094#issuecomment-1893412731",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/10094",
    "id": 1893412731,
    "node_id": "IC_kwDOD5KrTM5w2y97",
    "user": {
      "login": "saledjenic",
      "id": 86303051,
      "node_id": "MDQ6VXNlcjg2MzAzMDUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/86303051?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saledjenic",
      "html_url": "https://github.com/saledjenic",
      "followers_url": "https://api.github.com/users/saledjenic/followers",
      "following_url": "https://api.github.com/users/saledjenic/following{/other_user}",
      "gists_url": "https://api.github.com/users/saledjenic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saledjenic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saledjenic/subscriptions",
      "organizations_url": "https://api.github.com/users/saledjenic/orgs",
      "repos_url": "https://api.github.com/users/saledjenic/repos",
      "events_url": "https://api.github.com/users/saledjenic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saledjenic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2024-01-16T09:57:16Z",
    "updated_at": "2024-01-16T09:57:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "Seems there is no perfect solution for this issue since we cannot claim with 100% certainty that 2 addresses belong even to the same key, but even harder to different keys owned by the same person.\r\n\r\n\r\nDoes the following sound like a possible solution to you?\r\n\r\nWhat Is we add another condition for joining a community, we can say that all addresses the one wants to reveal to the community _must be added to the profile showcase accounts list_. \r\n\r\nKnowing the fact that the only accounts that the Status user can add to the profile showcase accounts list are for sure, in 100% of cases, those which the Status user knows a private key for (cause no other way to add them except import them into the Status app).\r\n\r\nThen a community just needs to check if revealed addresses belong to that list and then do the common check, checking signatures and what else is needed.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1893412731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
