{
  "url": "https://api.github.com/repos/status-im/status-desktop/issues/11572",
  "repository_url": "https://api.github.com/repos/status-im/status-desktop",
  "labels_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572/labels{/name}",
  "comments_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572/comments",
  "events_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572/events",
  "html_url": "https://github.com/status-im/status-desktop/issues/11572",
  "id": 1810380786,
  "node_id": "I_kwDOD5KrTM5r6Dfy",
  "number": 11572,
  "title": "DRAFT Make sure we only have one control node at a time by adding an internal signal with installation_id",
  "user": {
    "login": "jrainville",
    "id": 11926403,
    "node_id": "MDQ6VXNlcjExOTI2NDAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jrainville",
    "html_url": "https://github.com/jrainville",
    "followers_url": "https://api.github.com/users/jrainville/followers",
    "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
    "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
    "organizations_url": "https://api.github.com/users/jrainville/orgs",
    "repos_url": "https://api.github.com/users/jrainville/repos",
    "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jrainville/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2987757762,
      "node_id": "MDU6TGFiZWwyOTg3NzU3NzYy",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/to%20analyze",
      "name": "to analyze",
      "color": "5CC421",
      "default": false,
      "description": ""
    },
    {
      "id": 3047427135,
      "node_id": "MDU6TGFiZWwzMDQ3NDI3MTM1",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/feature",
      "name": "feature",
      "color": "0E8A16",
      "default": false,
      "description": ""
    },
    {
      "id": 4548141040,
      "node_id": "LA_kwDOD5KrTM8AAAABDxcf8A",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/messenger-team",
      "name": "messenger-team",
      "color": "232858",
      "default": false,
      "description": ""
    },
    {
      "id": 5638877635,
      "node_id": "LA_kwDOD5KrTM8AAAABUBpxww",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/C3",
      "name": "C3",
      "color": "82866A",
      "default": false,
      "description": ""
    },
    {
      "id": 5732739708,
      "node_id": "LA_kwDOD5KrTM8AAAABVbKqfA",
      "url": "https://api.github.com/repos/status-im/status-desktop/labels/E:DesktopImportCommunityNewFlow",
      "name": "E:DesktopImportCommunityNewFlow",
      "color": "7CB99C",
      "default": false,
      "description": "Implementation of the new Import community flow for private and public keys"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": {
    "url": "https://api.github.com/repos/status-im/status-desktop/milestones/57",
    "html_url": "https://github.com/status-im/status-desktop/milestone/57",
    "labels_url": "https://api.github.com/repos/status-im/status-desktop/milestones/57/labels",
    "id": 8475715,
    "node_id": "MI_kwDOD5KrTM4AgVRD",
    "number": 57,
    "title": "0.14",
    "description": "Milestone cycles:\r\n\r\n[Cycle 1](https://github.com/status-im/status-desktop/issues?q=is%3Aopen+is%3Aissue+milestone%3A0.14+label%3AC1): 7 July\r\n[Cycle 2](https://github.com/status-im/status-desktop/issues?q=is%3Aopen+is%3Aissue+milestone%3A0.14+label%3AC2): 28 July \r\n[Cycle 3](https://github.com/status-im/status-desktop/issues?q=is%3Aopen+is%3Aissue+milestone%3A0.14+label%3AC3): 18 August\r\n\r\n\r\n**--- Main focus ---**\r\n\r\n**1. Token permissions to enable control of community smart contracts**\r\n- Before a community founder can use any of the community token admin functionality, they first have to deploy Owner and Token Master contracts.\r\n- This work involves: new empty state screen for Mint and Airdrop tokens (before current empty state screen is revealed), new flow for deploying the community's Owner and Token Master contracts in a single step, a fixed uneditable permission giving anybody who holds the Token Master token admin rights for the community should be automatically created.\r\n- Only the holder of the single Owner token can access the Token Master airdrop, remote destruct, and view holders functions. Anybody who holds the Token Master token can access all token admin options, excluding those related to the Token Master token itself, as well as being and Admin of the community.\r\n- This will all be explained in more detail in the designs.\r\n\r\nBackend Epic: https://github.com/status-im/status-desktop/issues/11249\r\n\r\n**2. Update Community Admin home screen inc control node transfer and associated dialogues**\r\n- Remove ability for a Owner to leave a community on the computer that's running as that community's control node\r\n- Community Admin home screen cleanup (inc. adding at least one of the three graphs, whichever is easiest to implement).\r\n  - Graph issue: https://github.com/status-im/status-desktop/issues/11152  \r\n  - Community overview: https://github.com/status-im/status-desktop/issues/11278\r\n\r\n**3. Ability for user to select & manage accounts shared with each community control node**\r\n- This item is quite a bit of work\r\n- Touches Community settings, as well as all of the community join flows\r\n- Backend issues: \r\n  - Join API: https://github.com/status-im/status-desktop/issues/11154\r\n  - Edit API: https://github.com/status-im/status-desktop/issues/11153\r\n\r\n**4. Encryption for token gated channels that are inside Open (not token gated) communities**\r\n[#10998](https://github.com/status-im/status-desktop/issues/10998)\r\n\r\n**5. Final screens and bits and bobs needed prior to public beta**\r\n- Modal that's shown every time after login, reminding user's that Status Desktop is in Beta [#11044](https://github.com/status-im/status-desktop/issues/11044)\r\n- The bug with 'requests to join' a community not constantly arriving, or sometimes arriving after a delay, must be fixed. [#8264](https://github.com/status-im/status-desktop/issues/8264)\r\n- Anything that didn't get completed in 0.13 related to new share URL format\r\n- All the outstanding bugs and small items that got pushed into the 0.14 milestone.\r\n\r\n\r\n**--- Things that we SHOULD NOT work on during the 0.14 cycle ---**\r\n- Messaging and UI teams shouldn't work on perf. in 0.14 (but Wallet team should!)\r\n- Anything big mutual contacts related, other than fixing small bugs we find like #10497 #10498 #11120 #11121  (hopefully this functionality working good enough now!)\r\n\r\n**--- Wallet Team ---**\r\n\r\n1. Finish any outstanding work related to Activity screens (top priority - aim to have complete by July 14th)\r\n\r\n2. Updated Wallet Settings screens UI inc. account syncing functionality  *Synced information should immediately be reflected in the UI after it is received (sometimes synced info is currently only displayed after the next app restart, this needs to be fixed)*\r\n\r\n3. Wallet performance and memory consumption optimisations\r\n\r\n4. Fix bugs, clean up loose ends (to get things in a good state before the work on the Mobile wallet starts)\r\n\r\n\r\n\r\n\r\n\r\n",
    "creator": {
      "login": "iurimatias",
      "id": 176720,
      "node_id": "MDQ6VXNlcjE3NjcyMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/176720?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/iurimatias",
      "html_url": "https://github.com/iurimatias",
      "followers_url": "https://api.github.com/users/iurimatias/followers",
      "following_url": "https://api.github.com/users/iurimatias/following{/other_user}",
      "gists_url": "https://api.github.com/users/iurimatias/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/iurimatias/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/iurimatias/subscriptions",
      "organizations_url": "https://api.github.com/users/iurimatias/orgs",
      "repos_url": "https://api.github.com/users/iurimatias/repos",
      "events_url": "https://api.github.com/users/iurimatias/events{/privacy}",
      "received_events_url": "https://api.github.com/users/iurimatias/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 108,
    "closed_issues": 171,
    "state": "open",
    "created_at": "2022-09-28T20:32:56Z",
    "updated_at": "2023-07-20T18:35:42Z",
    "due_on": "2023-08-18T07:00:00Z",
    "closed_at": null
  },
  "comments": 4,
  "created_at": "2023-07-18T17:15:24Z",
  "updated_at": "2023-07-20T16:40:55Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "### Description\r\n\r\nCurrently, we use the private key to import a community and make it the control node. This brings the possibility that multiple control nodes could exist at the same time.\r\n\r\n@osmaczko and I thought of a way to make it so that only one device would be the control node, even if two or more devices share the same account (chatKey).\r\nThat way would be to send, in parallel to the community description, a signal that would contain the installation_id of the device which is the control node. Each device has an ID that should be different.\r\n\r\nThe signal's object structure could look something like:\r\n```js\r\n{\r\n  communityID: string,\r\n  installationID: string,\r\n  clock: unit64,\r\n  signature: string\r\n}\r\n```\r\n\r\nWe could send it to the same topic as the community one for descriptions. Members that are not owners would just ignore the signal.\r\n\r\nThe proposed way would be that when we import the privateKey (clicking the \"Make this device the control node for Community\" button here https://www.figma.com/file/17fc13UBFvInrLgNUKJJg5/Kuba%E2%8E%9CDesktop?node-id=31166%3A626222&mode=dev), that node becomes the control node and sends the signal.\r\n\r\nTo make sure that the process is secure, we'd need to sign the signal with the community private key, but we also need to add the account's signature. That signature would be to confirm that you are indeed the same account using a different device. \r\nQuestion: what happens in the case of importing from a different account? We also need to only have one control node. I guess we still listen to the signal and we remove our private key. It just makes it so that if your community privateKey is stolen, we actively have a mechanism to kick out the legitimate owner, but then again, if you lose the privateKey, you pretty much screwed the whole community already, so it's not a big deal.\r\n\r\nWe'd need to add a new table that would just contain communityIDs, installationIDs and a clock. Maybe we need the publicKey of the owner's account too, in case of a different account transferred to. Owners of the community would save those. The owner with the highest clock gets to be the control node. Every other owner deletes their privateKey, or maybe they just stop using it?\r\n\r\nWe decided to not put those inside the community description, because only owners care or need that information, so we didn't want to pollute the description.\r\n\r\nWe do have to send that signal periodically like the description however, in case one of the owners was offline for a while. We can send it parallel to the description like so:\r\n```go\r\npublishOrg() {\r\n   sendCommunityDescription()\r\n   sendDevicesSyncInfo()\r\n} \r\n```\r\n\r\nThis is still to analyze, so feel free to add comments, questions or suggestions.\r\n\r\n### Acceptance Criteria\r\n\r\nTBD\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/11572/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1640643151",
    "html_url": "https://github.com/status-im/status-desktop/issues/11572#issuecomment-1640643151",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572",
    "id": 1640643151,
    "node_id": "IC_kwDOD5KrTM5hyjpP",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-18T17:16:14Z",
    "updated_at": "2023-07-18T17:16:14Z",
    "author_association": "MEMBER",
    "body": "@MishkaRogachev FYI, this is related to the privateKey deletion work you are working on. Your work is still needed, but maybe we won't need the Nim part anymore, so just focus on the Go part for now.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1640643151/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1641808074",
    "html_url": "https://github.com/status-im/status-desktop/issues/11572#issuecomment-1641808074",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572",
    "id": 1641808074,
    "node_id": "IC_kwDOD5KrTM5h3ADK",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-19T10:10:00Z",
    "updated_at": "2023-07-19T10:10:00Z",
    "author_association": "MEMBER",
    "body": "This is a nice write-up. Here's a short summary just to make sure I understood it right.\r\nThe flow would be:\r\n\r\n1. Account A using node A owns a private key for community A\r\n2. Account A recovers its account on node B, resulting in (owned) communities being synced (let's ignore the fact that we're syncing the private key atm)\r\n3. Account A then imports the community's private key in node B, making it the control node.\r\n4. node B then sends the described signal saying \"I'm the new control node\"\r\n5. node A receives that signal, verifies its integrity and removes its own private key, resulting it in no longer being a control node\r\n\r\n^ Is this correct?\r\n\r\n> To make sure that the process is secure, we'd need to sign the signal with the community private key, but we also need to add the account's signature. That signature would be to confirm that you are indeed the same account using a different device.\r\n\r\nIf we had a distinction between **signer** and **sender** then we wouldn't need that signature. But that would probably require additional larger changes.\r\n\r\n> Question: what happens in the case of importing from a different account? We also need to only have one control node. I guess we still listen to the signal and we remove our private key. It just makes it so that if your community privateKey is stolen, we actively have a mechanism to kick out the legitimate owner, but then again, if you lose the privateKey, you pretty much screwed the whole community already, so it's not a big deal.\r\n\r\nSo this question actually changes the protocol described above and would remove the need of that sender's signature entirely. If my node receives a \"control node change\" signal that was signed by the community private key, but was done using an account that is not the same as my current control node, then we don't need to verify the sender's signature because we already know the signal was signed by the community and can be considered legit (of course, if the key was stolen, then that malicious account has this power).\r\n\r\nIf we introduce this notion of control node which is tied to the installation/device id, then I think we should indeed not limit those signals to be sent only by one account (the original creator of the community). I should be able to make my node a control node, even with a different account, if I own the private key of that community.\r\n\r\n> We do have to send that signal periodically\r\n\r\nWhy is that?\r\nAlso gotta keep in mind that the first control node will also produce these signals.\r\n\r\n### Some additional questions\r\n\r\n**Should we introduce some sort of ACK?**\r\nImagine I have my control node and I import the private key into some other node.\r\nNow, that other node will send the control node change signal, but for whatever reason the current control node doesn't receive that message.\r\nUntil the original control node receives the message, there'll be a state of multiple control nodes in existence. This can introduce some nasty side effects, especially with regards to the archive protocol. Now consider more than one additional control node. Things just get more hairy from here.\r\nMaybe we should introduce some sort of ACK signal, so that the new control node only behaves like one once the original one gave green light.\r\n\r\n**How do we ensure correctness of archive data?**\r\nAlright so here's one that worries me. As discussed on a call recently, the archive protocol has been designed with only one control node in mind. Because of that, it's crucial that we ensure new control nodes have downloaded the entire archive before they start producing archives themselves.\r\n\r\nWithout going into too much detail, here's why:\r\n\r\nThe original control node has created archives and a corresponding torrent with metadata, describing where do find any particular archive in the torrent. This means for example that it has information that says something like:\r\n\r\n```\r\narchive1: locationStart:locationEnd\r\n```\r\n`locationStart` and `locationEnd` are the bytes for `archive1` somewhere in that one big BLOB of all aggregated archives that the control node has ever created.\r\n\r\nNon-control nodes will use that information to find archives and import them into their own databases.\r\nNow, if a new control node comes along and starts to create archives before it actually managed to download all existing archives first, what's going to happen is that will likely produce metadata that conflicts with existing archives known to non-control nodes.\r\n\r\nFor example, the new control node might produce:\r\n\r\n```\r\narchive99: 0:119\r\n```\r\nMeaning, `archive99`'s bytes are the first 120 of the torrent file, even though the data should live somewhere else because `0- ...` is already occupied by previous archives (but the new control node just doesn't know about this).\r\n\r\nThis will most likely break the protocol.\r\n\r\nSo generally, we need to ensure a control node never starts doing archive work if:\r\n\r\n1. It is known that there's another control node active and\r\n2. that other control node has created archives before and\r\n3. the new control node hasn't downloaded all existing archives yet",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1641808074/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1642198181",
    "html_url": "https://github.com/status-im/status-desktop/issues/11572#issuecomment-1642198181",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572",
    "id": 1642198181,
    "node_id": "IC_kwDOD5KrTM5h4fSl",
    "user": {
      "login": "jrainville",
      "id": 11926403,
      "node_id": "MDQ6VXNlcjExOTI2NDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/11926403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrainville",
      "html_url": "https://github.com/jrainville",
      "followers_url": "https://api.github.com/users/jrainville/followers",
      "following_url": "https://api.github.com/users/jrainville/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrainville/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrainville/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrainville/subscriptions",
      "organizations_url": "https://api.github.com/users/jrainville/orgs",
      "repos_url": "https://api.github.com/users/jrainville/repos",
      "events_url": "https://api.github.com/users/jrainville/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrainville/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-19T14:28:47Z",
    "updated_at": "2023-07-19T14:28:47Z",
    "author_association": "MEMBER",
    "body": "Thanks for the answers and questions @0x-r4bbit . Here are some more.\r\n\r\n> ^ Is this correct?\r\n\r\nYes\r\n\r\n> So this question actually changes the protocol described above and would remove the need of that sender's signature entirely.\r\n\r\nYou're right. In that case, the signature or just checking the signer is useless. The community private key is the ultimate key.\r\n\r\n> I should be able to make my node a control node, even with a different account, if I own the private key of that community.\r\n\r\nYeah you're right\r\n\r\n> Why is that?\r\n> Also gotta keep in mind that the first control node will also produce these signals.\r\n\r\nThis is a possible solution for cases where I import the key in a new device and the first device stays offline for more than a month. We want the old device to still have access to the signal that it is no longer the control node. Doing periodic signals is a naive way to do it, but would work.\r\n\r\n> Should we introduce some sort of ACK?\r\n\r\nThat's probably a better way to fix the problem stated just above, but without the periodic signals.\r\nIt's probably good, but we'd need to think it though. \r\nWhat happens in the original control node never comes back online? Maybe we just send the signal for a couple of days, but give up after a while?\r\n\r\n> Maybe we should introduce some sort of ACK signal, so that the new control node only behaves like one once the original one gave green light.\r\n\r\nBecause if the problem of the first node possibly never coming back online, this solution probably doesn't work.\r\nA possible solution, though it's not super pretty, would be that when owners come online, they do not do archive protocol things in the first X minutes. Just so they can have time to receive the control node change signal before doing anything?\r\nThe other things a control node can do shouldn't break the community I think in case two control nodes do it at the same time?\r\nThis is not simple and deserves more thoughts.\r\n\r\n> Because of that, it's crucial that we ensure new control nodes have downloaded the entire archive before they start producing archives themselves.\r\n\r\nThis creates most of the complexity. How would a node know it has all the archive?",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1642198181/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1642280039",
    "html_url": "https://github.com/status-im/status-desktop/issues/11572#issuecomment-1642280039",
    "issue_url": "https://api.github.com/repos/status-im/status-desktop/issues/11572",
    "id": 1642280039,
    "node_id": "IC_kwDOD5KrTM5h4zRn",
    "user": {
      "login": "0x-r4bbit",
      "id": 445106,
      "node_id": "MDQ6VXNlcjQ0NTEwNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/445106?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0x-r4bbit",
      "html_url": "https://github.com/0x-r4bbit",
      "followers_url": "https://api.github.com/users/0x-r4bbit/followers",
      "following_url": "https://api.github.com/users/0x-r4bbit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0x-r4bbit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0x-r4bbit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0x-r4bbit/subscriptions",
      "organizations_url": "https://api.github.com/users/0x-r4bbit/orgs",
      "repos_url": "https://api.github.com/users/0x-r4bbit/repos",
      "events_url": "https://api.github.com/users/0x-r4bbit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0x-r4bbit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-07-19T15:13:58Z",
    "updated_at": "2023-07-19T15:13:58Z",
    "author_association": "MEMBER",
    "body": "> This creates most of the complexity. How would a node know it has all the archive?\r\n\r\nIt knows it has all the archives when it has downloaded all of the archives listed in the torrent metadata.\r\nHowever, technically we never have a guarantee that there's a newer torrent out there. \r\nWe try to reduce chances by attaching the latest published magnet link to the community description when sharing it to others.\r\n\r\nHowever, you could still receive and old(er) community description.\r\nSo yea, I guess waiting a certain amount of time is the only way forward here.",
    "reactions": {
      "url": "https://api.github.com/repos/status-im/status-desktop/issues/comments/1642280039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
