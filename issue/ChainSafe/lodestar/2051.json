{
  "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051",
  "repository_url": "https://api.github.com/repos/ChainSafe/lodestar",
  "labels_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051/labels{/name}",
  "comments_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051/comments",
  "events_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051/events",
  "html_url": "https://github.com/ChainSafe/lodestar/issues/2051",
  "id": 809976579,
  "node_id": "MDU6SXNzdWU4MDk5NzY1Nzk=",
  "number": 2051,
  "title": "Proposal to store less State Context inside StateContextCache",
  "user": {
    "login": "tuyennhv",
    "id": 10568965,
    "node_id": "MDQ6VXNlcjEwNTY4OTY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/10568965?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tuyennhv",
    "html_url": "https://github.com/tuyennhv",
    "followers_url": "https://api.github.com/users/tuyennhv/followers",
    "following_url": "https://api.github.com/users/tuyennhv/following{/other_user}",
    "gists_url": "https://api.github.com/users/tuyennhv/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tuyennhv/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tuyennhv/subscriptions",
    "organizations_url": "https://api.github.com/users/tuyennhv/orgs",
    "repos_url": "https://api.github.com/users/tuyennhv/repos",
    "events_url": "https://api.github.com/users/tuyennhv/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tuyennhv/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "tuyennhv",
    "id": 10568965,
    "node_id": "MDQ6VXNlcjEwNTY4OTY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/10568965?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tuyennhv",
    "html_url": "https://github.com/tuyennhv",
    "followers_url": "https://api.github.com/users/tuyennhv/followers",
    "following_url": "https://api.github.com/users/tuyennhv/following{/other_user}",
    "gists_url": "https://api.github.com/users/tuyennhv/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tuyennhv/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tuyennhv/subscriptions",
    "organizations_url": "https://api.github.com/users/tuyennhv/orgs",
    "repos_url": "https://api.github.com/users/tuyennhv/repos",
    "events_url": "https://api.github.com/users/tuyennhv/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tuyennhv/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "tuyennhv",
      "id": 10568965,
      "node_id": "MDQ6VXNlcjEwNTY4OTY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/10568965?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tuyennhv",
      "html_url": "https://github.com/tuyennhv",
      "followers_url": "https://api.github.com/users/tuyennhv/followers",
      "following_url": "https://api.github.com/users/tuyennhv/following{/other_user}",
      "gists_url": "https://api.github.com/users/tuyennhv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tuyennhv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tuyennhv/subscriptions",
      "organizations_url": "https://api.github.com/users/tuyennhv/orgs",
      "repos_url": "https://api.github.com/users/tuyennhv/repos",
      "events_url": "https://api.github.com/users/tuyennhv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tuyennhv/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2021-02-17T08:41:30Z",
  "updated_at": "2021-02-23T15:42:30Z",
  "closed_at": "2021-02-23T15:42:30Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "**Is your feature request related to a problem? Please describe.**\r\nAs noted in #2005, we store too many State Contexts inside StateContextCache during initial sync unnecessarily\r\n\r\n**Describe the solution you'd like**\r\n+ Create one more index inside StateContextCache to know the epoch of each State Contexts\r\n+ do `pruneFinalized` if an epoch is finalized\r\n+ keep doing the existing `prune` per check point and make sure `MAX_STATES` there",
  "closed_by": {
    "login": "wemeetagain",
    "id": 1348242,
    "node_id": "MDQ6VXNlcjEzNDgyNDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1348242?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wemeetagain",
    "html_url": "https://github.com/wemeetagain",
    "followers_url": "https://api.github.com/users/wemeetagain/followers",
    "following_url": "https://api.github.com/users/wemeetagain/following{/other_user}",
    "gists_url": "https://api.github.com/users/wemeetagain/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wemeetagain/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wemeetagain/subscriptions",
    "organizations_url": "https://api.github.com/users/wemeetagain/orgs",
    "repos_url": "https://api.github.com/users/wemeetagain/repos",
    "events_url": "https://api.github.com/users/wemeetagain/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wemeetagain/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/780511157",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/2051#issuecomment-780511157",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051",
    "id": 780511157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MDUxMTE1Nw==",
    "user": {
      "login": "dapplion",
      "id": 35266934,
      "node_id": "MDQ6VXNlcjM1MjY2OTM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dapplion",
      "html_url": "https://github.com/dapplion",
      "followers_url": "https://api.github.com/users/dapplion/followers",
      "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
      "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
      "organizations_url": "https://api.github.com/users/dapplion/orgs",
      "repos_url": "https://api.github.com/users/dapplion/repos",
      "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dapplion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-02-17T12:04:10Z",
    "updated_at": "2021-02-17T12:04:53Z",
    "author_association": "MEMBER",
    "body": "I think we can develop a much smarter StateContextCache that self-prunes given some conditions:\r\n- We can track how many times a state cache has been accessed, the last time it has been accessed and delete the ones that are therefore less useful.\r\n- It is possible for this instance to be self-aware of a memory constraint situation. If the memory is tight it could then drop more cached states, between a MIN and MAX number. We could also add a MIN_TIME_TO_KEEP variable in epochs\r\n  - In NodeJS, `process.memoryUsage()`\r\n  - In the browser: `window.performance.memory` https://trackjs.com/blog/monitoring-javascript-memory/\r\n- A super cool solution with a feature that just landed NodeJS v14 is WeakRef. It would allow the cache'd states to be usable until they get garbage collected, not preventing to do so if the engine deems necessary. Ref: https://v8.dev/features/weak-references\r\n\r\nAll three points are complimentary and could be implemented together and optionally depending on the available features",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/780511157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/780717161",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/2051#issuecomment-780717161",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/2051",
    "id": 780717161,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MDcxNzE2MQ==",
    "user": {
      "login": "wemeetagain",
      "id": 1348242,
      "node_id": "MDQ6VXNlcjEzNDgyNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1348242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wemeetagain",
      "html_url": "https://github.com/wemeetagain",
      "followers_url": "https://api.github.com/users/wemeetagain/followers",
      "following_url": "https://api.github.com/users/wemeetagain/following{/other_user}",
      "gists_url": "https://api.github.com/users/wemeetagain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wemeetagain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wemeetagain/subscriptions",
      "organizations_url": "https://api.github.com/users/wemeetagain/orgs",
      "repos_url": "https://api.github.com/users/wemeetagain/repos",
      "events_url": "https://api.github.com/users/wemeetagain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wemeetagain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-02-17T17:24:31Z",
    "updated_at": "2021-02-17T17:24:31Z",
    "author_association": "MEMBER",
    "body": "> Create one more index inside StateContextCache to know the epoch of each State Contexts\r\n> do pruneFinalized if an epoch is finalized\r\n> keep doing the existing prune per check point and make sure MAX_STATES there\r\n\r\nThis seems like an easy solution for the initial sync case. Perhaps we might even call `pruneFinalized` something like `pruneBeforeEpoch` and then `on('checkpoint', (c) => cache.pruneBeforeEpoch(c.epoch))` to prune all cached states before the most-recently processed checkpoint.\r\nThe question is then where to manage/attach this handler. I was hoping that @dapplion 's sync work would be landed at this point, might give a good place to attach this handler. Otherwise we could just add another task. (Though, I was hoping to avoid adding new tasks and rethink how the 'tasks' work. Replace the general-purpose 'task' with purposeful manager objects. Eg: Archive tasks -> `ChainArchiver`)\r\n\r\n---\r\n\r\n> We can track how many times a state cache has been accessed, the last time it has been accessed and delete the ones that are therefore less useful.\r\n\r\nWe likely need more investigation and thinking / asking other clients before picking a strategy for pruning. For instance, it may be that states that have been most accessed are less likely to be accessed in the future. Or that states get superseded by newer states. Or that we don't need to keep states on epoch boundaries.\r\nInitial syncing has vastly different requirements from regular syncing. Regular syncing in a healthy network may have vastly different requirements from regular syncing in a thrashing network. etc etc.\r\n\r\n> It is possible for this instance to be self-aware of a memory constraint situation.\r\n\r\nI tend to think the control should be at a higher level in the stack. Partially bc the pruning strategy may depend on syncing state or other higher-level metrics. Partially bc the memory in this cache is shared between the other state cache (and more robust control of the memory requires coordinating pruning of both caches).",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/780717161/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
