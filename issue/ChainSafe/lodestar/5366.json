{
  "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366",
  "repository_url": "https://api.github.com/repos/ChainSafe/lodestar",
  "labels_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366/labels{/name}",
  "comments_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366/comments",
  "events_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366/events",
  "html_url": "https://github.com/ChainSafe/lodestar/issues/5366",
  "id": 1669492198,
  "node_id": "I_kwDOCD5_Gc5jgm3m",
  "number": 5366,
  "title": "EIP-6110 in-protocol deposits epic",
  "user": {
    "login": "g11tech",
    "id": 76567250,
    "node_id": "MDQ6VXNlcjc2NTY3MjUw",
    "avatar_url": "https://avatars.githubusercontent.com/u/76567250?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/g11tech",
    "html_url": "https://github.com/g11tech",
    "followers_url": "https://api.github.com/users/g11tech/followers",
    "following_url": "https://api.github.com/users/g11tech/following{/other_user}",
    "gists_url": "https://api.github.com/users/g11tech/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/g11tech/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/g11tech/subscriptions",
    "organizations_url": "https://api.github.com/users/g11tech/orgs",
    "repos_url": "https://api.github.com/users/g11tech/repos",
    "events_url": "https://api.github.com/users/g11tech/events{/privacy}",
    "received_events_url": "https://api.github.com/users/g11tech/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3592888034,
      "node_id": "LA_kwDOCD5_Gc7WJx7i",
      "url": "https://api.github.com/repos/ChainSafe/lodestar/labels/Epic",
      "name": "Epic",
      "color": "4660F9",
      "default": false,
      "description": "Issues used as milestones and tracking multiple issues."
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2023-04-15T17:17:52Z",
  "updated_at": "2023-08-15T12:43:26Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The EIP aims to bring deposit mechanism in the beacon chain. Currently the deposits and fetched and processed wiith a sufficient lag  (12 hrs) that sort of effectively rule out any change of re-org in terms of processing deposits. With now the proposed deposit receipt being the first order citizen of the beacon network and a beacon node bundle and pack them in a block to add them into canonical chain (like other messages like exit, bls changes etc)\r\n\r\nFollowing would be the tracker items:\r\n\r\n- [ ] Add new deposit types and its processing as per the consensus specs\r\n- [ ] Add submission, pooling and bundling of such receipts in a block\r\n- [ ] Handle the gossip for receipts \r\n\r\nHowever apart from these routine tasks, lodestar would need to refactor and handle its pubkey <> index map which is currently part of EpochContext which is a global object. Currently since deposit logs from EL are processed with such a big log, its very deterministic the order in which deposits would be processed and packed in the blocks and hence gets assigned indexes in EpochContext without any worries.\r\n\r\nBut with moving the deposit receipt processing in the beacon,  this determinism goes away as now the indexes will now depend on the block receipt packing, more precisely varying between the forks. This leads to the precursor refactoring task.\r\n\r\n- [ ] Refactor the pubkey to index map in the state to be fork specific. This can be done in the following ways:\r\n  - [ ] Now global epoch context's map corresponds to the finalized state of the forkchoice\r\n  - [ ] Each fork represented by the `tip` node in the forkchoice protoarray (i.e no children) have an additional `forkMap` which is basically obtained by applying the receipts in order of the `unfinalized` blocks added in the fork. \r\n  - [ ] Each time a child block is added in forkchoice the corresponding `tip` map is updated and assigned to the new tip \r\n  - [ ] At any forkchoice node, the total map is: map of finalized in epoch context + map of the best Descendant  and can be easily refered to (for any pubkey to find index, check first in epoch context's map and on miss check in forkchoice node's map)\r\n  - [ ] These map doesn't necessarily need to be maintained in forkchoice but a reflecting structure can be maintained in epoch context so that its handily available to the beacon state\r\n \r\nPS: still wip and pending discussions\r\n\r\ncc @dapplion @wemeetagain ",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1511387632",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/5366#issuecomment-1511387632",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366",
    "id": 1511387632,
    "node_id": "IC_kwDOCD5_Gc5aFfHw",
    "user": {
      "login": "dapplion",
      "id": 35266934,
      "node_id": "MDQ6VXNlcjM1MjY2OTM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35266934?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dapplion",
      "html_url": "https://github.com/dapplion",
      "followers_url": "https://api.github.com/users/dapplion/followers",
      "following_url": "https://api.github.com/users/dapplion/following{/other_user}",
      "gists_url": "https://api.github.com/users/dapplion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dapplion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dapplion/subscriptions",
      "organizations_url": "https://api.github.com/users/dapplion/orgs",
      "repos_url": "https://api.github.com/users/dapplion/repos",
      "events_url": "https://api.github.com/users/dapplion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dapplion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-17T13:48:19Z",
    "updated_at": "2023-04-17T14:31:02Z",
    "author_association": "MEMBER",
    "body": "### Background\r\n\r\nThe current interface of the pubkey cache is\r\n\r\n```ts\r\ninterface PubkeyCache {\r\n  /** When processing signed objects must resolve validator indexes into a representation of the pubkey \r\n      optimized for fast aggregation */\r\n  getPubkeyForAggregation(index: ValidatorIndex): bls.PublicKey;\r\n  /** `process_deposit` requires to efficiently lookup if a pubkey is known in the state or not */\r\n  getPubkeyIndex(pubkey: bytes): ValidatorIndex | null;\r\n  /** Register new pubkey to cache. May be done when processing deposit or latter */\r\n  addPubkey(pubkey: bytes, index: ValidatorIndex): void;\r\n}\r\n```\r\n\r\nThat API is currently implemented with two data structures which are globally shared on all states\r\n\r\n```ts\r\ntype Index2PubkeyCache = PublicKey[];\r\ntype PubkeyIndexMap = Map<PubkeyHex, ValidatorIndex>();\r\n```\r\n\r\n### Split cache\r\n\r\nAs @g11tech mentions we must have a cache that's fork aware. We should use the [`persistent-ts`](https://github.com/ChainSafe/ssz/tree/master/packages/persistent-ts) structurally shared data structures to make cloning cheap.\r\n\r\nSo attach to every state this two datastructures that are cloned on each state clone and can be safely mutated on block processing\r\n\r\n```\r\nunfinalizedPubkeyCache = immutable.List<PublicKey | null>\r\nunfinalizedPubkeyIndexMap = immutable.Map<PubkeyHex, ValidatorIndex>\r\n```\r\n\r\nThe mutliplex on both caches\r\n\r\n```ts\r\nfunction getPubkeyForAggregation(index: ValidatorIndex): bls.PublicKey {\r\n  if (index < latestFinalizedValidatorsLen) {\r\n    // Lookup global cache\r\n    // - Should cover +99% of cases. Random access on fast Array\r\n    return globalPubkeyCache[index];\r\n  } else {\r\n    // Lookup state's local cache\r\n    // - Unlikely unless long non-finality. Slower access on immutable.List\r\n    if (unfinalizedPubkeyCache[index] == null) {\r\n      // Prime cache reading into the state.validators[index].pubkey\r\n      // To prevent deserializing pubkey twice, keep global `unfinalizedPubkeyMap = Map<PubkeyHex, PublicKey>`\r\n      // Deserialization may be done proactively if unfinalized validators become active\r\n      primeUnfinalizedPubkeyCache(index);\r\n    }\r\n    return unfinalizedPubkeyCache[index];\r\n  }\r\n}\r\n```\r\n\r\n```ts\r\nfunction getPubkeyIndex(pubkey: bytes): ValidatorIndex | null {\r\n  // Lookup global cache\r\n  return globalPubkeyIndexMap.get(pubkey)\r\n  // Then lookup local cache\r\n  // - Note now for new deposits both caches will be lookup\r\n  || unfinalizedPubkeyIndexMap.get(pubkey);\r\n}\r\n````\r\n\r\nRegarding cache insertion, we must ensure that each pubkey is only deserialized once, since those representations are memory heavy. `getPubkeyForAggregation` should be lazy for the unfinalized portion since it's unlikely to be called in normal cases. The local cache of the finalized state has to be rotated into the global cache\r\n\r\n```ts\r\nfunction addPubkey(pubkey: bytes, index: ValidatorIndex): void {\r\n  unfinalizedPubkeyCache.set(index, null); // lazy cache, prime latter\r\n  unfinalizedPubkeyIndexMap.set(pubkey, index);\r\n}\r\n````\r\n\r\n### Re-use indexes\r\n\r\n- Important to think how re-using indexes impacts a fork-aware cache https://github.com/ethereum/consensus-specs/pull/3307\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1511387632/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1512834435",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/5366#issuecomment-1512834435",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366",
    "id": 1512834435,
    "node_id": "IC_kwDOCD5_Gc5aLAWD",
    "user": {
      "login": "g11tech",
      "id": 76567250,
      "node_id": "MDQ6VXNlcjc2NTY3MjUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/76567250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/g11tech",
      "html_url": "https://github.com/g11tech",
      "followers_url": "https://api.github.com/users/g11tech/followers",
      "following_url": "https://api.github.com/users/g11tech/following{/other_user}",
      "gists_url": "https://api.github.com/users/g11tech/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/g11tech/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/g11tech/subscriptions",
      "organizations_url": "https://api.github.com/users/g11tech/orgs",
      "repos_url": "https://api.github.com/users/g11tech/repos",
      "events_url": "https://api.github.com/users/g11tech/events{/privacy}",
      "received_events_url": "https://api.github.com/users/g11tech/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-04-18T10:27:16Z",
    "updated_at": "2023-04-18T10:27:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think we can make `unfinalizedPubkeyCache = immutable.List<PubkeyHex | null>`, and have a global `hexToPublicKey:  Map <PubkeyHex, PublicKey>` in epoch context itself",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1512834435/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1678661711",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/5366#issuecomment-1678661711",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366",
    "id": 1678661711,
    "node_id": "IC_kwDOCD5_Gc5kDlhP",
    "user": {
      "login": "naviechan",
      "id": 17676176,
      "node_id": "MDQ6VXNlcjE3Njc2MTc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/17676176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naviechan",
      "html_url": "https://github.com/naviechan",
      "followers_url": "https://api.github.com/users/naviechan/followers",
      "following_url": "https://api.github.com/users/naviechan/following{/other_user}",
      "gists_url": "https://api.github.com/users/naviechan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naviechan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naviechan/subscriptions",
      "organizations_url": "https://api.github.com/users/naviechan/orgs",
      "repos_url": "https://api.github.com/users/naviechan/repos",
      "events_url": "https://api.github.com/users/naviechan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naviechan/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-15T09:34:18Z",
    "updated_at": "2023-08-15T09:47:16Z",
    "author_association": "NONE",
    "body": "> ### Background\r\n> The current interface of the pubkey cache is\r\n> \r\n> ```ts\r\n> interface PubkeyCache {\r\n>   /** When processing signed objects must resolve validator indexes into a representation of the pubkey \r\n>       optimized for fast aggregation */\r\n>   getPubkeyForAggregation(index: ValidatorIndex): bls.PublicKey;\r\n>   /** `process_deposit` requires to efficiently lookup if a pubkey is known in the state or not */\r\n>   getPubkeyIndex(pubkey: bytes): ValidatorIndex | null;\r\n>   /** Register new pubkey to cache. May be done when processing deposit or latter */\r\n>   addPubkey(pubkey: bytes, index: ValidatorIndex): void;\r\n> }\r\n> ```\r\n> \r\n> That API is currently implemented with two data structures which are globally shared on all states\r\n> \r\n> ```ts\r\n> type Index2PubkeyCache = PublicKey[];\r\n> type PubkeyIndexMap = Map<PubkeyHex, ValidatorIndex>();\r\n> ```\r\n> \r\n> ### Split cache\r\n> As @g11tech mentions we must have a cache that's fork aware. We should use the [`persistent-ts`](https://github.com/ChainSafe/ssz/tree/master/packages/persistent-ts) structurally shared data structures to make cloning cheap.\r\n> \r\n> So attach to every state this two datastructures that are cloned on each state clone and can be safely mutated on block processing\r\n> \r\n> ```\r\n> unfinalizedPubkeyCache = immutable.List<PublicKey | null>\r\n> unfinalizedPubkeyIndexMap = immutable.Map<PubkeyHex, ValidatorIndex>\r\n> ```\r\n> \r\n> The mutliplex on both caches\r\n> \r\n> ```ts\r\n> function getPubkeyForAggregation(index: ValidatorIndex): bls.PublicKey {\r\n>   if (index < latestFinalizedValidatorsLen) {\r\n>     // Lookup global cache\r\n>     // - Should cover +99% of cases. Random access on fast Array\r\n>     return globalPubkeyCache[index];\r\n>   } else {\r\n>     // Lookup state's local cache\r\n>     // - Unlikely unless long non-finality. Slower access on immutable.List\r\n>     if (unfinalizedPubkeyCache[index] == null) {\r\n>       // Prime cache reading into the state.validators[index].pubkey\r\n>       // To prevent deserializing pubkey twice, keep global `unfinalizedPubkeyMap = Map<PubkeyHex, PublicKey>`\r\n>       // Deserialization may be done proactively if unfinalized validators become active\r\n>       primeUnfinalizedPubkeyCache(index);\r\n>     }\r\n>     return unfinalizedPubkeyCache[index];\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> ```ts\r\n> function getPubkeyIndex(pubkey: bytes): ValidatorIndex | null {\r\n>   // Lookup global cache\r\n>   return globalPubkeyIndexMap.get(pubkey)\r\n>   // Then lookup local cache\r\n>   // - Note now for new deposits both caches will be lookup\r\n>   || unfinalizedPubkeyIndexMap.get(pubkey);\r\n> }\r\n> ```\r\n> \r\n> Regarding cache insertion, we must ensure that each pubkey is only deserialized once, since those representations are memory heavy. `getPubkeyForAggregation` should be lazy for the unfinalized portion since it's unlikely to be called in normal cases. The local cache of the finalized state has to be rotated into the global cache\r\n> \r\n> ```ts\r\n> function addPubkey(pubkey: bytes, index: ValidatorIndex): void {\r\n>   unfinalizedPubkeyCache.set(index, null); // lazy cache, prime latter\r\n>   unfinalizedPubkeyIndexMap.set(pubkey, index);\r\n> }\r\n> ```\r\n> \r\n> ### Re-use indexes\r\n> * Important to think how re-using indexes impacts a fork-aware cache [EIP6914 - Reuse indexes with full sweep ethereum/consensus-specs#3307](https://github.com/ethereum/consensus-specs/pull/3307)\r\n\r\nI have dug into the current use of `index2pubkey` in the codebase. It is used in block, attestation, slashing and sync committee related case for which all of them require active validators. \r\n\r\nThere is also a case where `process_voluntary_exit()` uses `index2pubkey`, but it was guarded by `is_active_validator()` check right before we validate the signature. \r\n\r\nI believe there is no need to have the multiplex in `getPubkeyForAggregation()` and we don’t need to have `unfinalizedPubkeyCache` attached to the states",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1678661711/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1678772764",
    "html_url": "https://github.com/ChainSafe/lodestar/issues/5366#issuecomment-1678772764",
    "issue_url": "https://api.github.com/repos/ChainSafe/lodestar/issues/5366",
    "id": 1678772764,
    "node_id": "IC_kwDOCD5_Gc5kEAoc",
    "user": {
      "login": "g11tech",
      "id": 76567250,
      "node_id": "MDQ6VXNlcjc2NTY3MjUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/76567250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/g11tech",
      "html_url": "https://github.com/g11tech",
      "followers_url": "https://api.github.com/users/g11tech/followers",
      "following_url": "https://api.github.com/users/g11tech/following{/other_user}",
      "gists_url": "https://api.github.com/users/g11tech/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/g11tech/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/g11tech/subscriptions",
      "organizations_url": "https://api.github.com/users/g11tech/orgs",
      "repos_url": "https://api.github.com/users/g11tech/repos",
      "events_url": "https://api.github.com/users/g11tech/events{/privacy}",
      "received_events_url": "https://api.github.com/users/g11tech/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-15T11:19:24Z",
    "updated_at": "2023-08-15T12:43:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "aha very nice analysis @naviechan \r\n\r\n>I believe there is no need to have the multiplex in getPubkeyForAggregation() and we don’t need to have unfinalizedPubkeyCache attached to the state\r\n\r\nwhat about \r\n1. very long cases of non finality that we do see on the devnets if not testnets (and hopefully never on mainnet). i think the suggested `getPubkeyForAggregation` also talks about this. \r\n2. serving beacon apis querying for status of unfinalized validators\r\n\r\ni suggest to keep the original approach proposed, where we prime them in a lazy fashion.",
    "reactions": {
      "url": "https://api.github.com/repos/ChainSafe/lodestar/issues/comments/1678772764/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
