{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/4248",
  "id": 1690265529,
  "node_id": "I_kwDOCFeAzc5kv2e5",
  "number": 4248,
  "title": "Add DVT \"selections\" endpoints to VC",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1232620456,
      "node_id": "MDU6TGFiZWwxMjMyNjIwNDU2",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/RFC",
      "name": "RFC",
      "color": "4aaa19",
      "default": false,
      "description": "Request for comment"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2023-05-01T02:23:19Z",
  "updated_at": "2023-05-28T10:44:23Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Overview\r\n\r\nIn https://github.com/ethereum/beacon-APIs/pull/224, there were two new endpoints added to the Beacon APIs:\r\n\r\n1. `/eth/v1/validator/beacon_committee_selections`\r\n1. `/eth/v1/validator/sync_committee_selections`\r\n\r\nThese two endpoints are *not* expected to be implemented by client BNs. Rather, these endpoints expected to be implemented by \"DVT (distributed validator technology) middleware\" that's sitting between the BN and VC. Whilst no one is asking us to implement this for the LH BN, Obol are asking that we implement it in the LH VC.\r\n\r\nFor clarity, here's a simple illustration:\r\n\r\n```\r\nVC   <---------> DVT Middleware  <--------->  BN\r\n^                ^                            ^\r\nClient-side      Server-side of               Irrelevant\r\nof endpoints     endpoints\r\n```\r\n\r\nThese endpoints solve the issue of *aggregation selection* for attestations and sync aggregates for distributed validators. As you know, a validator is selected to be an aggregated based on the output of their signature of the current slot. The issue with DVT is that distributed validators only have a cryptographic *partial* of the *full* keypair that is know to the Beacon Chain. Unfortunately, DVT validators cannot independently sign with the full keypair (only the partial keypair) and therefore cannot determine if their validator is an aggregator or not.\r\n\r\nThe new endpoints solve this by giving the VC a new endpoint to call which will resolve its *partial* signature over the slot into a *full* signature over the slot.\r\n\r\nThere's more info in this [Google doc](https://docs.google.com/document/d/1q9jOTPcYQa-3L8luRvQJ-M0eegtba4Nmon3dpO79TMk/edit#heading=h.mssb0822zapb) from Obol.\r\n\r\n## Implementation\r\n\r\nTo implement this in Lighthouse, we'd have to make some modifications to the VC. Firstly, we'd need a flag to enable/disable this behavior (perhaps something like `--use-dvt-selections-endpoints` or a more concise alternative).\r\n\r\nThen, we'd need to add additional logic when we're determining aggregate duties to ensure that:\r\n\r\n1. We use the new \"committees\" endpoints to resolve the partial signature to the full slot signature.\r\n1. When determining if we're an aggregator, we use the *full* signature.\r\n1. When producing an aggregate we use the *full* signature for the `selection_proof` field.\r\n\r\nAnyone implementing this should give the Obol Google doc a read. Obol has clearly put effort into thinking about what the implementation looks like for client teams.\r\n\r\n## Additional Considerations\r\n\r\nAs far as I'm aware, this functionality is exclusive to Obol. I'm aware that we need to be careful about favoring any particular entity. However I'm also aware that sometimes a single entity will \"pave roads\" and I don't think we want to get in the way of that.\r\n\r\nIn the Obol Google doc there are two suggestions that I'd personally avoid implementing:\r\n\r\n1. Using the `--distributed` flag to enable/disable the selections endpoints. Although it's deliciously simple, I fear it is too generic and doesn't give room for competing systems.\r\n1. Auto-enabling the selections endpoints via matching against Obol software in `/eth/v1/node/version` output. I'd be open to a more generic method of auto-identification, however I'm not super keen on maintaining a special list of softwares that are allowed to have auto-enabling.\r\n\r\nI've seen a [comment](https://github.com/ConsenSys/teku/issues/6851#issuecomment-1471567524) that this solution goes against the EFs \"latest DVT solution\". I've also heard similar sentiment from SSV Network, a competitor of Obol who have been pioneering in this space for quite some time. That being said, it looks like the [`ethereum/distributed-validator-specs`](https://github.com/ethereum/distributed-validator-specs) haven't had a change to the primary branch since October 2022 (7 months ago). Given that (a) the EF DVT solution smells a little stale and (b) adding the selections endpoints seems safe enough and doesn't exclude an EF/coordinated DVT solution, I'm tempted to give little weight to the argument.\r\n\r\nI'm going to share this issue with a few people so that we can get some feedback. Given that DVT generally aligns with our ethos, I think there's a fairly strong case as to why we *should* implement this. However, I'm particularly interested in the arguments as to why we *should not* implement this.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/4248/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1529607295",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1529607295",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1529607295,
    "node_id": "IC_kwDOCFeAzc5bK_R_",
    "user": {
      "login": "OisinKyne",
      "id": 4981644,
      "node_id": "MDQ6VXNlcjQ5ODE2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4981644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/OisinKyne",
      "html_url": "https://github.com/OisinKyne",
      "followers_url": "https://api.github.com/users/OisinKyne/followers",
      "following_url": "https://api.github.com/users/OisinKyne/following{/other_user}",
      "gists_url": "https://api.github.com/users/OisinKyne/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/OisinKyne/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/OisinKyne/subscriptions",
      "organizations_url": "https://api.github.com/users/OisinKyne/orgs",
      "repos_url": "https://api.github.com/users/OisinKyne/repos",
      "events_url": "https://api.github.com/users/OisinKyne/events{/privacy}",
      "received_events_url": "https://api.github.com/users/OisinKyne/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-01T11:33:02Z",
    "updated_at": "2023-05-01T11:33:02Z",
    "author_association": "NONE",
    "body": "Hey guys, love this in depth issue and happy to add a bit of colour in a few places. \r\n\r\nThe only major point to flag is:\r\n\r\n     3. When producing an aggregate we use the partial signature for the selection_proof field.\r\n\r\nThe full, combined signature, not the partial, should be used as the selection_proof. \r\n\r\nOther than that, I would like to give a bit of history of the original spec, and why I think an easily replaceable, read-only middleware based approach is both safer and better for Ethereum's neutrality. \r\n\r\n    As far as I'm aware, this functionality is exclusive to Obol. I'm aware that we need to be careful about favoring any particular entity. However I'm also aware that sometimes a single entity will \"pave roads\" and I don't think we want to get in the way of that.\r\n    \r\nSo this is true, and I acknowledge there are others in the space that would like to muddy the waters around whether something is canonical or not, but I would like to add a bit of color as to where this design came from, and why I think it is important for client teams, and not *adversely* supportive of any one DV implementation over others. \r\n\r\nCollin and Mara have been working with the EF on DVs since pre devcon 5. They formed the original trustless validators working group, and later when Obol was started, we co-funded a grant with the EF to develop the original spec with Consensys. The main issue with it, in my eyes, was *we made the assumption that changing the base protocol was unviable/out of scope*, and that excluded a middleware approach, as it was not possible for a middleware without private key signing power to determine if it was an aggregator. \r\n\r\nI effectively was uncomfortable with this restriction, as it would have meant that Obol either 1) needed to build a custom validator client, that we would have to convince operators was superior to existing VCs; or 2) we would have to convince every client team to support a single DV protocol, and that we would have to get the protocol near perfect first try, or face a very slow iteration cycle if we have to get full client team consensus for every breaking change. \r\n\r\nTo expand on 1) I was reticent to go down the path of making a custom VC. I think the separation of concerns between coming to consensus on what to sign (DVT) and the code that checks slashing conditions and controls the private keys is important. We saw from other DV teams that did not think this was important resulted in slashing 20+ testnet validators due to a bug in their VC, but worse if their supply chain was compromised and malicious code was in charge, every validator could be slashed, not just a subset. Designing your architecture assuming you will be compromised is important, and that's why I was so insistent on a read-only middleware, which if compromised, will pose a liveness risk not a safety risk to its validators. (And those liveness risks we intend to further mitigate with multiple interoperable middleware implementations.) This decision I believe has made Charon and Obol more trustable for node operators to consider running versus a version requiring private key access. \r\n\r\nAnd to expand on 2), this middleware based approach to distributed validators gives new optionality to client teams, if Obol becomes a bad actor, or stops maintaining its client, or simply gets out-competed, everyone can swap in a new/faster/better middleware without any significant changes to their codebase. If we went the route of a canonical single spec all client teams build into their VCs directly, a new, better protocol might never get enough support/adoption. Or if it does we might fragment the client teams into supporting different variations and end up in an [xkcd standards](https://xkcd.com/927/) problem. \r\n\r\nI raised this to Danny and Ben E last June, and asked if they saw this problem space the same way I did, and whether they had any ideas for how we could minimally change the base spec to enable middleware DVs. They were both very supportive of enabling DVs to run as replaceable middlewares, and with their help, we first made this proposal to [ethresear.ch](https://ethresear.ch/t/distributed-validator-middlewares-and-the-aggregation-duty/13044), [refined it](https://blog.obol.tech/committee-aggregations-with-distributed-validators/), proved it works by building it ourselves with our own (unreleased, dev-only) [VC](https://github.com/ObolNetwork/charon/blob/main/app/vmock.go), and ultimately got it [approved and included](https://www.youtube.com/live/KFc1sWYlVZ4?feature=share&t=3357) in the spec. (59:40 for Danny calling this out explicitly)\r\n\r\nSo to conclude, this was longer than I intended, but I thought it would help provide color on how and why we ended up enabling middleware DVs, and that they are a good idea and this is not overly favouring of a single team/solution. :) ",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1529607295/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1530655979",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1530655979",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1530655979,
    "node_id": "IC_kwDOCFeAzc5bO_Tr",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-02T00:20:12Z",
    "updated_at": "2023-05-02T00:20:12Z",
    "author_association": "MEMBER",
    "body": "> The full, combined signature, not the partial, should be used as the selection_proof.\r\n\r\nThanks for this! I fixed this error in the issue description üôè ",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1530655979/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1530703581",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1530703581",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1530703581,
    "node_id": "IC_kwDOCFeAzc5bPK7d",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-02T00:45:11Z",
    "updated_at": "2023-05-02T00:45:11Z",
    "author_association": "MEMBER",
    "body": "Personally I'm generally not a fan of middleware for two reasons:\r\n\r\n1.  It becomes the source of truth for the VC (i.e. it can lie to the BN about what the head of the chain is)\r\n1. It's not really clear how multiple middlewares scale (e.g. if someone tries to add another piece of middleware it's unclear as to which layer it should be in the middleware sandwich)\r\n\r\nOriginally mev-boost was going to be a BN/EL middleware, but we successfully avoided that by making it a \"sidecar\" instead. This protocol has many different properties though, so I don't think a straight analogue between the two is fair or useful.\r\n\r\nHowever, just because I *generally* don't like middleware it doesn't mean that it's always bad. It could very well be a good solution in this case, especially considering how long it might take to specify and implement an alternative.\r\n\r\nAlthough I don't love middleware, I'm still of the mind that this change is small and safe enough to implement.\r\n\r\n@OisinKyne if there's going to be several implementations of these endpoints in VCs, it might be worth providing some sort of \"mock\" middleware that client teams can use for testing. If client teams don't need to implemented the server side of these endpoints, then each team is going to have to build it's own type of testing/mocking to test them. Deduplicating work is always nice, plus it might give you some sort of conformance testing framework about which VCs you can recommend.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1530703581/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1543521727",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1543521727",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1543521727,
    "node_id": "IC_kwDOCFeAzc5cAEW_",
    "user": {
      "login": "alonmuroch",
      "id": 3773981,
      "node_id": "MDQ6VXNlcjM3NzM5ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3773981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alonmuroch",
      "html_url": "https://github.com/alonmuroch",
      "followers_url": "https://api.github.com/users/alonmuroch/followers",
      "following_url": "https://api.github.com/users/alonmuroch/following{/other_user}",
      "gists_url": "https://api.github.com/users/alonmuroch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alonmuroch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alonmuroch/subscriptions",
      "organizations_url": "https://api.github.com/users/alonmuroch/orgs",
      "repos_url": "https://api.github.com/users/alonmuroch/repos",
      "events_url": "https://api.github.com/users/alonmuroch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alonmuroch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-11T07:59:35Z",
    "updated_at": "2023-05-11T07:59:35Z",
    "author_association": "NONE",
    "body": "Hi everyone, I wanted to jump in the discussion to give my 2 Satoshi \r\n\r\nMe and my team developed the first proof-of-concept DVT as middleware in 2020 together with the EF, same one that later on @OisinKyne joined in testing in it's second iteration after we've invite outsiders to test it out :). \r\n\r\nFull disclosure - I'm not against this PR, competition is good for DVT. Having said that I do feel the backstory of why the remote signer approach was adopted is important. Also, the framing of this being a \"need\" for DVT is a bit misleading as it's unclear it is. \r\n\r\nFor now, this is an Obol specific PR for Charon which currently has a commercial use license. Even if others would want to use the middleware approach they will develop it from scratch (as they can't use the Charon code) which might result in a whole different API requirements (and additional PRs asking clients for changes).\r\nIt's not like MEV-Boost which is a public good developed by the community for the community.\r\n\r\nMiddleware was abandoned in favor of a remote signer approach for several reasons: \r\n1) Before moving to a remote signer approach we conducted calls about this very issue with Lighthouse, Prysm and Teku. It was clear back then, as it's clear now, that further changes will need to be done in the VC code to make it perfectly suitable for DVT (and not just happy flow scenarios). Such changes included timeout configs, api changes to handle late replies and more(happy to expand on it if needed).\r\n2) VC code (excluding signer and slashing protection) is just a coordination software for duties, the sensitive part is the signer itself.\r\n3) There are strong and super scalable remote signer implementations out there which are widely used.\r\n4) Many staking applications use some sort of a remote signer, many don't use the default signer VCs come with. This PR will force them to have the following setup: remote singer <> VC <> DVT <> BN ... instead of just remote signer <> DVT <> BN. More complex with no obvious value.\r\n5) VC <> BN have many moving parts, putting a 3rd wheel between them is an engineering mess. Every change/ fix/ feature will potentially need more changes from client teams. This PR puts a foot in the door which will later require it to open completely once new issues/ changes will be required.\r\n6) Future changes to the beacon chain might require other/ additional \"pre-consensus\" signing (e.g. randao) that will again require more changes in VC code. Considering that API changes always lag protocol changes it might be the case that a BN fork happened but a DVT implementation can't support it until all VCs push changes as well. Seems risky.\r\n\r\nThinking long term here is crucial as DVT gets into its mainnet phase. \r\nWe need to have a \"no-coupling\" approach here so DVT can evolve independently of VC/ BN code and not be fully dependent on them as it will be an engineering nightmare in the future.  \r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1543521727/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1546136930",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1546136930",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1546136930,
    "node_id": "IC_kwDOCFeAzc5cKC1i",
    "user": {
      "login": "OisinKyne",
      "id": 4981644,
      "node_id": "MDQ6VXNlcjQ5ODE2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4981644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/OisinKyne",
      "html_url": "https://github.com/OisinKyne",
      "followers_url": "https://api.github.com/users/OisinKyne/followers",
      "following_url": "https://api.github.com/users/OisinKyne/following{/other_user}",
      "gists_url": "https://api.github.com/users/OisinKyne/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/OisinKyne/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/OisinKyne/subscriptions",
      "organizations_url": "https://api.github.com/users/OisinKyne/orgs",
      "repos_url": "https://api.github.com/users/OisinKyne/repos",
      "events_url": "https://api.github.com/users/OisinKyne/events{/privacy}",
      "received_events_url": "https://api.github.com/users/OisinKyne/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-12T18:40:42Z",
    "updated_at": "2023-05-12T18:40:42Z",
    "author_association": "NONE",
    "body": "> @OisinKyne if there's going to be several implementations of these endpoints in VCs, it might be worth providing some sort of \"mock\" middleware that client teams can use for testing. If client teams don't need to implemented the server side of these endpoints, then each team is going to have to build it's own type of testing/mocking to test them. Deduplicating work is always nice, plus it might give you some sort of conformance testing framework about which VCs you can recommend.\r\n\r\nFeedback received, thanks Paul! We will see what we can do on this front, potentially we can PR something into Hive in the near term. \r\n\r\nAnd to refute some points and address some inaccuracies in Alon's statement about 'abandoning' a middleware because I can't not: \r\n\r\n> It was clear back then, as it's clear now, that further changes will need to be done in the VC code to make it perfectly suitable for DVT\r\n\r\nThis model is running just fine on mainnet and at scale on testnet. Of course every team can tweak and optimize some performance parameters, but I would like to hear you expand on what other unilateral change is needed, because I do not believe there is one. \r\n\r\n> VC code (excluding signer and slashing protection) is just a coordination software for duties, the sensitive part is the signer itself\r\n\r\nYes that is the point of separating concerns into coordination software and signing software. Charon is the coordination software and does not need to be near the private keys. \r\n\r\n> There are strong and super scalable remote signer implementations out there which are widely used.\r\n\r\nThere are more validator implementations out there than remote signers. Also I believe all validator clients support one or more remote signers, this is a false either or. Also of the three main remote signer implementations out there, one recently caused an [outage](https://forum.stakewise.io/t/post-mortem-for-2023-01-16-validator-outage-on-gnosis-chain-cryptomanufaktur/1041), and another caused a [slashing](https://research.lido.fi/t/slashing-incident-involving-rocklogic-gmbh-validators-april-13-2023/4399). \r\n\r\n> Many staking applications use some sort of a remote signer, many don't use the default signer VCs come with. This PR will force them to have the following setup: remote singer <> VC <> DVT <> BN ... instead of just remote signer <> DVT <> BN. More complex with no obvious value.\r\n\r\nHere are some reasons its valuable:\r\n- Less to change for an operator to integrate than a new VC-like client, their runbooks and key management can stay the same. \r\n- An operator does not have to trust the distributed validator client to the same extent if it is a HTTP server rather than a HTTP client capable of running privileged requests on a sensitive API. They can keep the internet connected DV client separated on a network firewall level from their web3signer. \r\n- If the software is compromised, one design can cause much more harm than the other. A VC talking to a signer can change fee recipients or delete keys. \r\n\r\n> VC <> BN have many moving parts, putting a 3rd wheel between them is an engineering mess. Every change/ fix/ feature will potentially need more changes from client teams. \r\n\r\nVC's and BN's communicate over a succint and [standardised API](https://ethereum.github.io/beacon-APIs/#/ValidatorRequiredApi). There are three+ implementations of key manager API interfaces. \r\n\r\n> This PR puts a foot in the door which will later require it to open completely once new issues/ changes will be required.\r\n\r\nEthereum validators have been intended to be MPC friendly since the earliest of [serenity designs](https://notes.ethereum.org/@vbuterin/serenity_design_rationale#The-proof-of-custody-game), with work from V, [Dankrad](https://ethresear.ch/t/using-the-legendre-symbol-as-a-prf-for-the-proof-of-custody/5169), [Justin Drake](https://ethresear.ch/t/bitwise-xor-custody-scheme/5139), [Carl Beek](https://slideslive.com/38920085/ethereum-20-trustless-staking-pools) and more, on how to design a validator interface that is simple and MPC-compatible. This is not a foot in the door, this is \"hey we've gone and built what you planned for and the only snag is this piece left, can you help us finish it?\".\r\n\r\n> it might be the case that a BN fork happened but a DVT implementation can't support it until all VCs push changes as well. Seems risky\r\n\r\nYes this can happen, but as above, the plan since adopting BLS signatures has been for Ethereum validators to be MPC-friendly and communicate over a simple API. This also happens at the remote signer layer, they have to pass pre-signatures amongst themselves, to assemble an aggregate, to conclude what to sign next. Pre-signatures present complexity at any layer, and determinism and avoiding multi-round complexity where possible leads to simpler designs for client teams of all types to implement.   \r\n\r\n> We need to have a \"no-coupling\" approach here so DVT can evolve independently of VC/ BN code and not be fully dependent on them as it will be an engineering nightmare in the future.\r\n\r\nAdopting simple, standard APIs; separating 'what to sign' from 'power to sign it', and favoring optionality instead of replacement software is how we stay out of an engineering nightmare in future. An SSV client extracts Lighthouse from the most important piece of the entire puzzle, and puts an internet-connected piece of software in there instead. If the 'distributed' part of 'distributed validators' is not something that every validator can easily opt into (by using the api they already support), then we will either get stuck on unanimous support of a single protocol that cannot mature/iterate, or we fragment into different VCs speaking [different protocols](https://xkcd.com/927/). ",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1546136930/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1566081510",
    "html_url": "https://github.com/sigp/lighthouse/issues/4248#issuecomment-1566081510",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4248",
    "id": 1566081510,
    "node_id": "IC_kwDOCFeAzc5dWIHm",
    "user": {
      "login": "alonmuroch",
      "id": 3773981,
      "node_id": "MDQ6VXNlcjM3NzM5ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3773981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alonmuroch",
      "html_url": "https://github.com/alonmuroch",
      "followers_url": "https://api.github.com/users/alonmuroch/followers",
      "following_url": "https://api.github.com/users/alonmuroch/following{/other_user}",
      "gists_url": "https://api.github.com/users/alonmuroch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alonmuroch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alonmuroch/subscriptions",
      "organizations_url": "https://api.github.com/users/alonmuroch/orgs",
      "repos_url": "https://api.github.com/users/alonmuroch/repos",
      "events_url": "https://api.github.com/users/alonmuroch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alonmuroch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-28T10:44:23Z",
    "updated_at": "2023-05-28T10:44:23Z",
    "author_association": "NONE",
    "body": "> This model is running just fine on mainnet and at scale on testnet. Of course every team can tweak and optimize some performance parameters, but I would like to hear you expand on what other unilateral change is needed, because I do not believe there is one.\r\nWell Obol requires changes from all clients so for one that's a dependency which should be avoided. Further more timeouts are super sensitive as QBFT protocols by their nature have no upper bound on random delays. Some clients set api timeouts for a few seconds and some more but it means your QBFT protocol doesn't support round changes beyond the first few rounds which means, at scale, this can cause liveness issues just due to the fact VCs are not meant to work this way. \r\nI'm sure there are other issues which will naturally raise when you \"tweak\" software for use cases it's not intended for. \r\n\r\n> An operator does not have to trust the distributed validator client to the same extent if it is a HTTP server rather than a HTTP client capable of running privileged requests on a sensitive API. They can keep the internet connected DV client separated on a network firewall level from their web3signer.\r\nIT security is per the operator to chose, it can be safe or not. Blaming slashing/ outage on remote signers is nit-picking.. all of them are pretty solid projects running tens of thousands(if not more) of validators for years.\r\n\r\n> If the software is compromised, one design can cause much more harm than the other. A VC talking to a signer can change fee recipients or delete keys.\r\nCharon can ignore validators if it's misconfigured. It can't change fee recipient without 2/3 of the cluster being malicious or the core team being malicious (in which case nothing is safe anyhow).\r\nWith a remote signer approach you have such protections\r\n\r\n> Ethereum validators have been intended to be MPC friendly since the earliest of [serenity designs](https://notes.ethereum.org/@vbuterin/serenity_design_rationale#The-proof-of-custody-game), with work from V, [Dankrad](https://ethresear.ch/t/using-the-legendre-symbol-as-a-prf-for-the-proof-of-custody/5169), [Justin Drake](https://ethresear.ch/t/bitwise-xor-custody-scheme/5139), [Carl Beek](https://slideslive.com/38920085/ethereum-20-trustless-staking-pools) and more, on how to design a validator interface that is simple and MPC-compatible. This is not a foot in the door, this is \"hey we've gone and built what you planned for and the only snag is this piece left, can you help us finish it?\".\r\nMPC friendly says nothing about software integrations ... \r\n\r\n> ... and puts an internet-connected piece of software in there instead ...\r\nA middleware Charon is still internet connected otherwise it can't talk with the other operators..\r\n\r\n\r\nStill claiming this approach is overly complicated, creates dependency between 5 implementation teams and 1 DVT team, will require more and more maintenance and changes down the line (for a commercially license project) and really doesn't help with the above points since it \"tells\" the VC what it wants and it can cause issues if it grows. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1566081510/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
