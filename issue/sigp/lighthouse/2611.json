{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/2611",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/2611",
  "id": 1003633930,
  "node_id": "I_kwDOCFeAzc470j0K",
  "number": 2611,
  "title": "Duplicate block imports between gossip and RPC",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 985647281,
      "node_id": "MDU6TGFiZWw5ODU2NDcyODE=",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/bug",
      "name": "bug",
      "color": "d73a4a",
      "default": true,
      "description": "Something isn't working"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2021-09-22T01:37:10Z",
  "updated_at": "2022-01-20T07:31:14Z",
  "closed_at": "2022-01-20T07:31:13Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Overview\r\n\r\nWhilst our Prater nodes were overloaded (before we implemented #2399), I noticed that the nodes were frequently doing RPC block imports that took over a second (sometimes multiple seconds).\r\n\r\nWhilst troubleshooting I found an edge case that's *potentially* the cause. Put simply, it's possible that we can attempt to import the same block twice; once via gossip and once via RPC. This double-import would result in reading a `BeaconState` from disk since the first import would use the value in the `snapshot_cache`.\r\n\r\nEven if it turns out that this double-import issue isn't the issue I observed on Prater, I think it's still worth fixing. I believe it's likely to occur and the impact is high (reading states from disk is slow and IO heavy).\r\n\r\n# Detail\r\n\r\nHere's a detailed sequence of events:\r\n\r\n*For clarity, I only refer to a single block throughout this whole example.* \r\n\r\n1. A block is received via gossip, queued and then imported by [`Worker::process_gossip_block`](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/network/src/beacon_processor/worker/gossip_methods.rs#L279-L293). For the sake of argument, lets say this block was received somewhat late at 3.9s after the start of the slot.\r\n1. The block is processed to a point somewhere between where it has [taken the parent block/state from the `snapshot_cache`](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/beacon_chain/src/block_verification.rs#L1285-L1291) but has *not yet* been [applied to fork choice](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/beacon_chain/src/beacon_chain.rs#L2329-L2331).\r\n1. An attestation is received from the network which references the block we're already importing via gossip.\r\n1. Since the block being imported via gossip has not reached fork-choice or the database, we think that the attestation references an unknown block. Therefore, we ask the peer who sent us the attestation for the block via RPC.\r\n1. The block is returned via RPC and imported it via [`Worker::process_rpc_block`](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/network/src/beacon_processor/worker/sync_methods.rs#L23-L32).\r\n1. Since we already took the parent state/block from the `snapshot_cache`, we have to [load them from the database](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/beacon_chain/src/block_verification.rs#L1293-L1319).\r\n\r\nNow, we have the same block being imported twice. This cost us a state read from the database and gained us nothing.\r\n\r\n# Solutions\r\n\r\nThe solution seems fairly simple; remember the blocks that we're already importing and don't try to import them twice.\r\n\r\nI can see two competing solutions:\r\n\r\n## 1. Solve it at the `BeaconChain` level\r\n\r\nWe could add an `importing_blocks: HashSet<Hash256>` to the `BeaconChain` that contains the roots of all blocks that are currently being imported. Then, we can know if we're about to import a duplicate.\r\n\r\nThis seems simple, however there are a few questions:\r\n\r\n- Do we block the calling thread during a duplicate import, or do we return an error? I'm not certain.\r\n- How do we treat a peer that sent us a block that we are already importing? We don't actually know if the block is valid or not.\r\n- There's more the one way to import a block (e.g., individually or in a batch). If we forget to pop a block out of `importing_blocks` on success/failure then we're at risk of always rejecting that block in the future. I can't think of a way to force errors at compile-time if we forget to do this, so it seems quite risky.\r\n- There's waste here since we still download the duplicate block from the peer and let it bubble-up our stack.\r\n\r\n## 2. Solve it inside the `network`\r\n\r\nThe network already has de-dup logic for RPC blocks; it avoids requesting the same block twice via the RPC. We could extend this logic so that it wont request an RPC block if it's in the process of importing it via gossip.\r\n\r\nThis has the nice property that it reduces the unnecessary block download from the peer and it also doesn't raise questions about how to score peers that send us known blocks.\r\n\r\nIt also seems simpler to implement, from my perspective. There's a [single pathway](https://github.com/sigp/lighthouse/blob/f9bba92db3468321b28ddd9010e26b359f88bafe/beacon_node/network/src/router/processor.rs#L223-L240) for importing gossip blocks so it seems easy to know when it succeed or failed.\r\n\r\nThis doesn't solve the problem generally across the whole application (i.e., it's still possible to do duplicate concurrent imports to the `BeaconChain`), but I'm not sure we actually want to do that. Reducing the generality of the `BeaconChain` might hurt us in ways we haven't envisaged.\r\n\r\n# Proposed Solution\r\n\r\nI'm in favor of solution (2), since I think it reduces waste and seems a bit simpler. However, the network is not my field of expertise. I'm open to suggestion. \r\n\r\n",
  "closed_by": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/2611/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/924606737",
    "html_url": "https://github.com/sigp/lighthouse/issues/2611#issuecomment-924606737",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611",
    "id": 924606737,
    "node_id": "IC_kwDOCFeAzc43HGER",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-22T05:49:46Z",
    "updated_at": "2021-09-22T05:49:46Z",
    "author_association": "MEMBER",
    "body": "After feedback from @AgeManning it seems that it might be that the RPC block arrives before the gossip block.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/924606737/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/925383719",
    "html_url": "https://github.com/sigp/lighthouse/issues/2611#issuecomment-925383719",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611",
    "id": 925383719,
    "node_id": "IC_kwDOCFeAzc43KDwn",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-22T22:50:08Z",
    "updated_at": "2021-09-22T22:50:08Z",
    "author_association": "MEMBER",
    "body": "I think its quite likely we may receive attestations that reference unknown blocks and during the RPC request we receive the block via gossip. Therefore we try and process the RPC block whilst processing the gossip block. In this case, I think we need a version of 1. To address some of the potential issues with 1 :\r\n\r\nI think it should be fine in this case, to just not process the block sent via the RPC and pretend it is valid. If it was an invalid block, its unlikely that we would be seeing the same one via gossip (because gossip should filter out bad blocks) and we would be penalizing multiple peers especially if they are sending attestations referencing bad blocks. Also the RPC penalty for a bad block is not fatal, so often we allow one or two at most. I think its relatively harmless to essentially drop (or mark as success) the RPC imported block as thats essentially the same thing as not having asked for the block in the first place. \r\nI think we'd probably find that after rejecting a gossip block, we'd still see attestations for that block and future peers will get penalized when we import that block from the RPC.  \r\n\r\nI dont think we can avoid the waste in the RPC request as we can't be sure we would get the block from gossip, so i think this is fine.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/925383719/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/928543648",
    "html_url": "https://github.com/sigp/lighthouse/issues/2611#issuecomment-928543648",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/2611",
    "id": 928543648,
    "node_id": "IC_kwDOCFeAzc43WHOg",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-28T01:01:18Z",
    "updated_at": "2021-09-28T01:01:53Z",
    "author_association": "MEMBER",
    "body": "I had an idea about how to implement (1) and mitigate the risk of forgetting to pop the block from the cache.\r\n\r\nWhen we add a block to the `importing_blocks` cache, return a `ImportingBlockHandle` which contains an `Arc<Rwlock>` reference to the `importing_blocks` cache.\r\n\r\nWhen that handle is dropped (i.e. `impl Drop`), it will remove its entry from the cache. Then, we thread that handle through the block verification process and then drop it once the block is verified. If we happen to forget about the handle and accidentally drop it, the entry will be removed from the cache automatically.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/928543648/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
