{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/4332",
  "id": 1725267937,
  "node_id": "I_kwDOCFeAzc5m1X_h",
  "number": 4332,
  "title": "Beacon node failing to recover after a SIGINT shutdown (fork choice store corruption)",
  "user": {
    "login": "jimmygchen",
    "id": 742762,
    "node_id": "MDQ6VXNlcjc0Mjc2Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/742762?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jimmygchen",
    "html_url": "https://github.com/jimmygchen",
    "followers_url": "https://api.github.com/users/jimmygchen/followers",
    "following_url": "https://api.github.com/users/jimmygchen/following{/other_user}",
    "gists_url": "https://api.github.com/users/jimmygchen/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jimmygchen/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jimmygchen/subscriptions",
    "organizations_url": "https://api.github.com/users/jimmygchen/orgs",
    "repos_url": "https://api.github.com/users/jimmygchen/repos",
    "events_url": "https://api.github.com/users/jimmygchen/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jimmygchen/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 985647281,
      "node_id": "MDU6TGFiZWw5ODU2NDcyODE=",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/bug",
      "name": "bug",
      "color": "d73a4a",
      "default": true,
      "description": "Something isn't working"
    },
    {
      "id": 2034355093,
      "node_id": "MDU6TGFiZWwyMDM0MzU1MDkz",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/consensus",
      "name": "consensus",
      "color": "5e59bf",
      "default": false,
      "description": "An issue/PR that touches consensus code, such as state_processing or block verification."
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2023-05-25T07:42:23Z",
  "updated_at": "2023-05-27T08:16:03Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nA discord user reported that Lighthouse Beacon Node won't start after a `SIGINT` shutdown due to the below error. \r\n\r\n```\r\nFailed to start beacon node, reason: Unable to load fork choice from disk: ForkChoiceError(ProtoArrayStringError(\"find_head failed: InvalidBestNode(InvalidBestNodeInfo...\r\n```\r\n\r\nFull beacon logs [here](https://seamonkey.tech/goerli/goerli-lighthouse-nethermind.lighthouse.log).\r\n\r\n### Timelines\r\n\r\n- 22:20:02 EE went offline\r\n- 22:21:24 Starting to receive a lot of \"Rejected gossip block\" due to `ParentUnknown`\r\n- 22:26:54 INFO Syncing, est_time: 7 mins, speed: 0.08 slots/sec, distance: 35 slots (7 mins)\r\n- 22:56:54 INFO Syncing, est_time: --, distance: 185 slots (37 mins)\r\n- 22:56:54 EE online, upcheck complete, state: Synced\r\n- 22:56:59 User initiated SIGINT, seeing a bunch of beacon processing failures due to async tasks being cancelled.\r\n\r\n### Diagnosis\r\n\r\nIt looks like the fork choice data got corrupted during the shutdown, and the beacon node was unable to recover from the invalid fork choice data stored on disk. We were able to obtain the fork choice DB dump from the user, which helped identity that `find_head` was failing due to the below evaluating to false:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/7f17b8e35127c0a082f04f0485b502ef933337e3/consensus/proto_array/src/proto_array.rs#L964-L965\r\n\r\nAfter some digging with @michaelsproul, we think the root cause is likely due to the fork choice store mutation being aborted mid way, and in the shutdown handler we would persist the in memory fork choice store to disk, which could be corrupted due to the processing being half completed.\r\n\r\nThis could happen in various places, e.g. import blocks, pruning fork choice store after finalization etc.\r\n\r\nI've placed `SIGINT` trigger in various places of the code but wasn't able to reproduce it consistently. I reproduced once by placing a `SIGINT` trigger at the end of the pruning function [here](https://github.com/sigp/lighthouse/blob/7f17b8e35127c0a082f04f0485b502ef933337e3/consensus/proto_array/src/proto_array.rs#L808), but wasn't able to reproduce this consistently.\r\n\r\n### Additional Details from @michaelsproul \r\n\r\n> It's possible that the fork choice store's global checkpoints maybe have been updated before the block which did the justifying was added, here:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/consensus/fork_choice/src/fork_choice.rs#L790-L810\r\n\r\n> whereas the block itself doesn't get added to fork choice until here: \r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/consensus/fork_choice/src/fork_choice.rs#L865-L893\r\n\r\n> if the thread running that function was cancelled midway, then the mutations to the fork choice store could be persisted, and stored on disk by the shutdown handler here:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L5918\r\n\r\n> so even though we're atomic with our writing of the fork choice store to disk, we are not atomic in memory when we account for threads getting cancelled\r\n\r\n## Version\r\n\r\nhttps://github.com/sigp/lighthouse/commit/981c72e863f37113f45306246775dcf715705a1c\r\n\r\n## Present Behaviour\r\n\r\n1. Start Lighthouse beacon node.\r\n2. Terminate the process with `CTRL + C` or `SIGINT`.\r\n3. Restart Lighthouse. Beacon node crashes with the following error.\r\n\r\n```\r\nCRIT Failed to start beacon node, reason: Unable to load fork choice from disk: ForkChoiceError(ProtoArrayStringError(\"find_head failed: InvalidBestNode(InvalidBestNodeInfo { current_slot: Slot(5683485), start_root: 0x5c44cef93338a459c34b62b641d1e11fd56a7d71e66e8e732a31723af91a800c, justified_checkpoint: Checkpoint { epoch: Epoch(177603), root: 0x5c44cef93338a459c34b62b641d1e11fd56a7d71e66e8e732a31723af91a800c }, finalized_checkpoint: Checkpoint { epoch: Epoch(177602), root: 0x1ebccdc8503c40e9c22467ffdbb6f752c6d502990739d6d84f40997d85ea7340 }, head_root: 0x5c44cef93338a459c34b62b641d1e11fd56a7d71e66e8e732a31723af91a800c, head_justified_checkpoint: Checkpoint { epoch: Epoch(177602), root: 0x1ebccdc8503c40e9c22467ffdbb6f752c6d502990739d6d84f40997d85ea7340 }, head_finalized_checkpoint: Checkpoint { epoch: Epoch(177601), root: 0x1453fc32d1cb2d476688857e7ca0c6487ce9f1bed5e36c027fc900194c7f346b } })\")), module: lighthouse:588\r\n```\r\n\r\n## Expected Behaviour\r\n\r\nLighthouse beacon node should restart without crashing, even if the previous shutdown was triggered by a `SIGINT` signal (e.g. CTRL + C).\r\n\r\n## Possible Solutions\r\n\r\nA few options were being discussed:\r\n1. Use a `copy-on-write` data structure for fork choice, the simplest version would be to replace the `HashMap` and `Vec`s in fork choice with types from here: https://docs.rs/rpds/latest/rpds/index.html\r\n2. Keep tasks running until finish when after receiving a `SIGINT`, e.g. use `spawn_without_exit`. \r\n3. Remove fork choice persistence from shutdown handle\r\n\r\nOption 1 is interesting and probably a good long term fix, but may be harder to do. \r\n\r\nOption 2 could be a bit complicated, because we use `spawn_async` in beacon processor, and it's probably something we'd want to avoid changing given the amount of surface it touches. \r\n\r\nOption 3 is probably the easiest and cleanest, we'd at most lose one epoch of data, and Lighthouse should be able to recover. Since Lighthouse usually recovers from `SIGKILL` OK, where the shutdown handlers were not triggered. Best to check with @paulhauner on this.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/4332/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563827351",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1563827351",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1563827351,
    "node_id": "IC_kwDOCFeAzc5dNhyX",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-26T05:24:10Z",
    "updated_at": "2023-05-26T05:25:13Z",
    "author_association": "MEMBER",
    "body": "> thread running that function was cancelled midway\r\n\r\nWhat are the scenarios where the thread is cancelled midway? My understanding is that this should only happen when there's an ungraceful termination (e.g. `kill -9`/`SIGKILL`). Specifically, it should not happen if we're giving it a `Ctrl + C`/`SIGINT`.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563827351/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563856009",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1563856009",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1563856009,
    "node_id": "IC_kwDOCFeAzc5dNoyJ",
    "user": {
      "login": "jimmygchen",
      "id": 742762,
      "node_id": "MDQ6VXNlcjc0Mjc2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/742762?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimmygchen",
      "html_url": "https://github.com/jimmygchen",
      "followers_url": "https://api.github.com/users/jimmygchen/followers",
      "following_url": "https://api.github.com/users/jimmygchen/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimmygchen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimmygchen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimmygchen/subscriptions",
      "organizations_url": "https://api.github.com/users/jimmygchen/orgs",
      "repos_url": "https://api.github.com/users/jimmygchen/repos",
      "events_url": "https://api.github.com/users/jimmygchen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimmygchen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-26T06:08:41Z",
    "updated_at": "2023-05-26T06:08:41Z",
    "author_association": "MEMBER",
    "body": "\r\n```\r\nMay 21 22:56:59.776 INFO Shutting down.., reason: Success(\"Received SIGINT\"), module: lighthouse:643\r\nMay 21 22:56:59.782 WARN Unable to free worker, error: channel closed, msg: did not free worker, shutdown may be underway, module: network::beacon_processor:2046\r\nMay 21 22:56:59.814 DEBG Persisting DHT to store, Number of peers: 259, service: network, module: network::service:967\r\nMay 21 22:56:59.821 INFO Saved DHT state, service: network, module: network::service:982\r\nMay 21 22:56:59.821 INFO Network service shutdown, service: network, module: network::service:991\r\nMay 21 22:56:59.891 DEBG Beacon block processing cancelled, error: BeaconChainError(TokioJoin(JoinError::Cancelled(Id(25890335)))), service: beacon, module: beacon_chain::beacon_chain:2713\r\nMay 21 22:56:59.892 WARN BlockProcessingFailure, outcome: TokioJoin(JoinError::Cancelled(Id(25890335))), msg: unexpected condition in processing block., module: network::beacon_processor::worker::sync_methods:555\r\nMay 21 22:56:59.892 DEBG Couldn't spawn task. Runtime shutting down, service: beacon, module: task_executor:294\r\nMay 21 22:56:59.892 ERRO Failed to spawn recompute head task, error: RuntimeShutdown, service: beacon, module: beacon_chain::canonical_head:546\r\nMay 21 22:56:59.892 DEBG Batch processing failed, service: sync, error: Internal error whilst processing block: TokioJoin(JoinError::Cancelled(Id(25890335))), imported_blocks: 21, last_block_slot: 5683360, chain: 16984880338948048269, first_block_slot: 5683297, batch_epoch: 177603, module: network::beacon_processor::worker::sync_methods:249\r\nMay 21 22:56:59.892 DEBG Could not send message to the sync service, error: channel closed, module: network::beacon_processor::worker:31\r\nMay 21 22:56:59.898 WARN Unable to free worker, error: channel closed, msg: did not free worker, shutdown may be underway, module: network::beacon_processor:2046\r\nMay 21 22:57:00.910 DEBG Couldn't spawn task. Runtime shutting down, service: beacon, module: task_executor:263\r\nMay 21 22:57:02.493 INFO Saved beacon chain to disk, service: beacon, module: beacon_chain::beacon_chain:5930\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563856009/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563875178",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1563875178",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1563875178,
    "node_id": "IC_kwDOCFeAzc5dNtdq",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-26T06:32:50Z",
    "updated_at": "2023-05-26T06:32:50Z",
    "author_association": "MEMBER",
    "body": "The first log about cancellation comes from `BeaconChain::process_block`:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L2712-L2719\r\n\r\nThe block processed comes from a chain segment (2nd log):\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/network/src/beacon_processor/worker/sync_methods.rs#L554-L559\r\n\r\nAnd after the chain segment processing fails we try to re-run fork choice here:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/network/src/beacon_processor/worker/sync_methods.rs#L368-L370\r\n\r\nWhich fails with this error (3rd log):\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/canonical_head.rs#L545-L551\r\n\r\nFork choice is called from `BeaconChain::process_block` via `import_execution_pending_block`, which calls `import_block`, which calls `on_block`:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L2683-L2694\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L2802-L2819\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L2897-L2908\r\n\r\nThe strange part is that the `import_block` happens inside a `spawn_blocking_handle`, and according to the [Tokio docs](https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html) blocking tasks are _not interrupted by shutdown_:\r\n\r\n> Closures spawned using spawn_blocking cannot be cancelled abruptly; there is no standard low level API to cause a thread to stop running.\r\n\r\n> When you shut down the executor, it will wait indefinitely for all blocking operations to finish. You can use [shutdown_timeout](https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html#method.shutdown_timeout) to stop waiting for them after a certain timeout. Be aware that this will still not cancel the tasks — they are simply allowed to keep running after the method returns. It is possible for a blocking task to be cancelled if it has not yet started running, but this is not guaranteed.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563875178/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563886441",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1563886441",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1563886441,
    "node_id": "IC_kwDOCFeAzc5dNwNp",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-26T06:46:33Z",
    "updated_at": "2023-05-26T06:46:33Z",
    "author_association": "MEMBER",
    "body": "Notably, _if_ Tokio were to return a JoinError in `spawn_blocking_handle`, we would log this debug log which we don't see:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/common/task_executor/src/lib.rs#L298-L308",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563886441/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563994107",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1563994107",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1563994107,
    "node_id": "IC_kwDOCFeAzc5dOKf7",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-26T08:16:16Z",
    "updated_at": "2023-05-27T08:16:03Z",
    "author_association": "MEMBER",
    "body": "Summary of current thinking:\r\n\r\n- We don't think the corruption is caused by the SIGINT, per the reasoning above. It seems impossible for fork choice `on_block` to be cancelled mid-way (hat-tip to @paulhauner).\r\n- Looking at Forky we found that the first block to update unrealized justification was 5683324. In the fork choice dump its unrealized justification is `None`, presumably because the block was imported by sync here with `CountUnrealized::False`:\r\n\r\nhttps://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/network/src/sync/range_sync/chain.rs#L321-L325\r\n- The _slot_ of the fork choice dump is 5683326 which matches the last block in the fork choice store. This also isn't consistent with a crash mid-way through `on_block`, because in that case we would expect the store's time and checkpoints to be updated ahead of its contained blocks (i.e. if we crashed importing 5683326 the time should be 5683326, but the last block should be earlier).\r\n- There must be another bug lurking somewhere here that causes the fork choice store's global checkpoints to be updated _without_ corresponding blocks with those checkpoints being present in the store. This could either be because A) checkpoints are computed and used to update the global checkpoints which are not stored in the `ProtoNode`s, or B) checkpoints are computed and stored in the `ProtoNode`s but later blanked out. Attempts to find cases where either of these can happen have been unsuccessful. The only place we call `set_unrealized_justified_checkpoint` is on `on_block` where we _also set the node's unrealized checkpoint to `Some` (rules out A). Similarly, there don't seem to be any cases where we mutate the `unrealized_justified_checkpoint` of a `ProtoNode` (rules out B).",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1563994107/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1565092279",
    "html_url": "https://github.com/sigp/lighthouse/issues/4332#issuecomment-1565092279",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4332",
    "id": 1565092279,
    "node_id": "IC_kwDOCFeAzc5dSWm3",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-05-27T00:10:43Z",
    "updated_at": "2023-05-27T00:13:35Z",
    "author_association": "MEMBER",
    "body": "New theory (untested):\r\n\r\nOne of the blocks with unrealized justification (i.e. 5683324/5/6) was imported _twice_: once via a chain segment, and once via RPC (or maybe gossip). In this case, a data race can occur between _checking whether the block is already known_ and _writing the block to fork choice_. The sequence of steps is:\r\n\r\n1. While importing the chain segment, we check whether the block is already known using a read lock [here](https://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/block_verification.rs#L1634-L1642).\r\n2. Concurrently, the same block is being processed via RPC, and also does the same check using the read lock. It succeeds, because the block from the chain segment hasn't been added to fork choice yet.\r\n3. The chain segment block obtains the _write_ lock on fork choice [here](https://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/beacon_node/beacon_chain/src/beacon_chain.rs#L2881-L2909), and calls `on_block`. Due to the block being processed with `CountUnrealized::False` this runs through `on_block` but _does not_ update the store's global `unrealized_justified_checkpoint`. A `ProtoNode` for the block gets written to the store containing `unrealized_justified_checkpoint: None`.\r\n4. The RPC block obtains the same write lock in `import_block` and runs through `on_block` all over again. Because RPC blocks are imported with `CountUnrealized::True`, this time the store's global checkpoints _will_ be updated. However, when it comes to adding the `ProtoNode` containing the unrealized justification to the store, we will _return early without making any changes_ [here](https://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/consensus/proto_array/src/proto_array.rs#L370-L373).\r\n\r\nThe end result is a fork choice store that has had the global `unrealized_justified_checkpoint` updated, but contains no `ProtoNode` satisfying this. This is consistent with the fork choice dump we saw, which had an advanced global checkpoint and `ProtoNode::unrealized_justified_checkpoints` set to `Some` seemingly at random, i.e. in the cases where the RPC block was imported before the chain segment block (rather than the other way around).\r\n\r\nIn terms of a fix, it isn't sufficient to just remove the duplicate check from `ProtoArray::on_block`, because then the last block to be processed would just clobber the first one, and we'll get the same corruption if the RPC block is processed before the chain segment block.\r\n\r\nI think the fundamental issue is that when we obtain the write lock we're acting on stale information from the previous time we held the read lock. This suggests that an appropriate fix might be to check that the block isn't already known right at the start of `ForkChoice::on_block`, i.e. [here](https://github.com/sigp/lighthouse/blob/c547a11b0da48db6fdd03bca2c6ce2448bbcc3a9/consensus/fork_choice/src/fork_choice.rs#L664-L667). In this case we can return `Ok(())` immediately and avoid the situation where the same block is applied to fork choice with different `CountUnrealized` behaviour.\r\n\r\nOther options would be:\r\n\r\n- Remove `CountUnrealized::False` altogether. We're currently using it to avoid extra work during sync, but with optimisations like #4118 this may not be so important.\r\n- Hold a write lock from the first time we check for duplicates (too slow IMO).\r\n- Make changes to sync to avoid processing blocks from RPC and chain segments simultaneously. This might be nice to do anyway to save work, but it feels like the wrong place to guard against this error. I think fixing it in fork choice would be preferable.\r\n\r\nOn the whole the impact of this bug is quite minimal, it can only cause damage if the node is shutdown while it's syncing, and _only if_ an RPC block is being processed concurrently.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1565092279/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
