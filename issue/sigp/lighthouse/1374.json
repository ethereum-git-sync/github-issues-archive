{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/1374",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/1374/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/1374/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/1374/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/1374",
  "id": 662594892,
  "node_id": "MDU6SXNzdWU2NjI1OTQ4OTI=",
  "number": 1374,
  "title": "Target Peer count",
  "user": {
    "login": "AgeManning",
    "id": 7454587,
    "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AgeManning",
    "html_url": "https://github.com/AgeManning",
    "followers_url": "https://api.github.com/users/AgeManning/followers",
    "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
    "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
    "organizations_url": "https://api.github.com/users/AgeManning/orgs",
    "repos_url": "https://api.github.com/users/AgeManning/repos",
    "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AgeManning/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2020-07-21T05:09:41Z",
  "updated_at": "2020-07-23T04:00:19Z",
  "closed_at": "2020-07-23T04:00:19Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nCurrently, Lighthouse has a cli flag called `max-peers` which is more or less a stub at the moment. Once we reach `max-peers` we stop searching for new peers, but do not prevent new peers being connected. This often ends up with lighthouse nodes having excessive peers. The reason this has been the case, is because we have been waiting for bones of the peer scoring system to be put into place (an initial version is now in place). \r\n\r\n### Overview\r\n\r\nWe want to control the maximum number of peers a node will allow from the CLI. I suggest the following: \r\n\r\n- Rename the `max-peers` CLI param to `target-peers`. \r\n- Once we reach or exceed `target-peers` we stop performing `FindPeers` discoveries (these are discoveries which search randomly for new peers). We continue subnet discovery queries (these are discovery queries which search for peers on specific subnets and are still crucial if we have a validator attached). \r\n- We allow a factor, `MAX_PEER_FACTOR` (or something more aptly named) which is a fraction of `target-peers` that we allow to connect to us in excess of `target-peers`. For clarity, if `target-peers` is 50 and `MAX_PEER_FACTOR` = 0.1 or 10 (if you want to use uints) we allow 10% more nodes, i.e 55. \r\n- The `PeerManager` has a heartbeat for performing various operations. It fires every 30 seconds. In this heartbeat we prune some (or all) of the excess peers. We disconnect peers who have the lowest score. If peers have equal score, a random subset should be chosen to be disconnected. There is added complexity is choosing peers to disconnect which I'll outline at the bottom of this issue. \r\n\r\n### Why the excess? \r\n\r\nI've seen situations in other clients which have a fixed upper bound on peers. I find that they often form networks amongst themselves where they all reach their peer limit preventing new peers outside to join. There becomes a large fail rate of connections and discovery of peers that haven't maxed out takes more time. Having an excess buffer, I think, should help prevent this. If we design it right, it also gives us the opportunity to remove poorly scored peers in favour of new peers. \r\n\r\n### Disconnection Complexity\r\n\r\nIf we have more than one validator attached to the beacon node, the beacon node will perform subnet queries. That is, search for peers on specific subnets. A validator may need to attest to a slot in the next epoch. We will then search for peers for that slot and subnet an epoch in advance. This is relevant, because these peers are more valuable to us. We don't want to find a specific peer for a subnet only to have them be disconnected during the heartbeat because we have too many peers. Therefore these peers need to be prioritised. \r\n\r\n### How to implement\r\n\r\nThe CLI param `max-peers` gets set in the CLI, then put into the `NetworkConfig` struct. Ultimately it gets set in the peer manager [here](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/peer_manager/mod.rs#L102)\r\n\r\n#### Dialing peers \r\n\r\nThe peer manager performs the discovery queries in its heartbeat. If we are less than `max-peers` we perform a normal discovery. See [here](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/peer_manager/mod.rs#L670)\r\n\r\nOnce peers are discovered, they enter [this](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/peer_manager/mod.rs#L478) function. We only dial newly discovered peers if we have less than `max-peers` connected.  In this function, we need to modify it to ensure we dial peers for a given subnet, even if we've reached our `max-peers * ( 1 + MAX_PEER_FACTOR)` peer count. We never want to not-dial a discovered subnet peer (they are very valuable to us). When doing a subnet discovery, we already check to see if we need peers for that subnet. So, in principle discovery will only return subnet peers if we need them, so we should always connect to them. We can distinguish subnet peers if `min_ttl.is_some()`. \r\n\r\n#### Disconnecting Peers\r\n\r\nAs mentioned above, we dont want to disconnect a peer that we need for a future validator duty. We can distinguish these peers by the `min_ttl` field. At it's root, it's stored [here](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/peer_manager/peer_info.rs#L37). However typically we access such variables via the [PeerDb](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/peer_manager/peerdb.rs#L17) which is `Arc<RwLock<>>` on `NetworkGlobals` and the PeerManager has access to it. It might be cleaner to add a function to the `PeerDb` to find peers that have a non-none `min_ttl`. In fact the PeerDb has iterators that allow you to iterate over peers by score. So when disconnecting we may want to filter out peers that have a `min_ttl` that is less than now. The `min_ttl` field gives the instant at which we need to keep the peer around, once we pass that instant, the peer is no longer special and we can disconnect if we want. \r\n\r\n#### Preventing incoming connections\r\n\r\nIf we are at our peer limit, we want to reject new incoming connections. \r\n\r\nThe logic for this is similar to the current banning logic where we prevent incoming connections from banned peers. This is done in the behaviour. \r\nFor an incoming connection we want to reject the connection and send an RPC Goodbye with a `TooManyPeers` reponse (129). See [here](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/rpc/methods.rs#L123). \r\n\r\nFor this we can just follow the banning logic. See [here](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/behaviour/mod.rs#L728) (we dont want to emit a BehaviourEvent::PeerConnected if we block this). Also instead of `Goodbye(GoodbyeReason::Banned)` we should use `TooManyPeers`. \r\n\r\nAlso update [this](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/behaviour/mod.rs#L773)\r\n\r\nAnd [this](https://github.com/sigp/lighthouse/blob/master/beacon_node/eth2_libp2p/src/behaviour/mod.rs#L824)",
  "closed_by": {
    "login": "AgeManning",
    "id": 7454587,
    "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AgeManning",
    "html_url": "https://github.com/AgeManning",
    "followers_url": "https://api.github.com/users/AgeManning/followers",
    "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
    "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
    "organizations_url": "https://api.github.com/users/AgeManning/orgs",
    "repos_url": "https://api.github.com/users/AgeManning/repos",
    "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AgeManning/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/1374/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/1374/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/662807497",
    "html_url": "https://github.com/sigp/lighthouse/issues/1374#issuecomment-662807497",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1374",
    "id": 662807497,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjgwNzQ5Nw==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-23T04:00:19Z",
    "updated_at": "2020-07-23T04:00:19Z",
    "author_association": "MEMBER",
    "body": "Resolved in #1383",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/662807497/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
