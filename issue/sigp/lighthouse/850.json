{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/850",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/850/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/850/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/850/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/850",
  "id": 563840552,
  "node_id": "MDU6SXNzdWU1NjM4NDA1NTI=",
  "number": 850,
  "title": "Block processing \"lanes\" (WIP)",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2020-02-12T08:41:56Z",
  "updated_at": "2020-02-16T21:30:46Z",
  "closed_at": "2020-02-16T21:30:46Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nI've been thinking about block processing and memory usage and I wanted to share an idea about block processing and state caching. **This post is currently a WIP, it's structurally there but missing some detail.**\r\n\r\n## The current state caching solution\r\n\r\nPresently we store 5 `BeaconState` in a LRU cache in the `Store` maybe/maybe not with their caches built and we just kinda hope that we have some useful ones in there. Now that we have a committee cache (#841) for processing attestations I think we can do better than this.\r\n\r\nHaving a look at the reasons we have/might use beacon state caches:\r\n\r\n1. Block processing: we definitely need caches here.\r\n1. Attestation processing: we don't _really_ need a state cache for this if we have the committee caches from #841. With that PR, in typical chain operation (a few short forks) we only need to load a state from disk if it's an attestation with a head from several epochs ago and those are likely to not be in our beacon state cache anyway. The committee caches are so much smaller than the `BeaconState` caches that I'm confident we can cover many more scenarios with much less memory usage.\r\n1. Block/state root iterators: For syncing and all the other general cases I can think of, these iterators start from the head. So, as long as we keep a canonical head state on the beacon chain we don't need caches here. If someone wants to iterate off some weird state then they can just cop a database read.\r\n1. API calls: our most important requests are those from the validator client and they deal with the head, so they can just use the canonical head state. For other calls, a cache might help them with speed, but I'm also tempted to just say that if you want to read non-head states then you can just cop a database read.\r\n\r\nSo, with this info it seems we only _really_ need to cache any non-canonical-head caches for block processing. If we only need caches for block processing, then we can start to specialize the caches for exactly that. One very useful specialization would be allow mutable access to the cache so we don't need to copy it in/out of the cache whilst we apply a block to it (this costs us a lot of time during block processing). This is where \"block processing lanes\" come in..\r\n\r\n ## Block Processing Lanes\r\n\r\nSo the idea is that you have a finite amount of `BeaconState`s waiting in \"block processing lanes\" where you can start processing a block.\r\n\r\n```rust\r\nLane {\r\n  // Hash of the last processed beacon block.\r\n  block_root: Option<Hash256>,\r\n  // The state of the last processed beacon block.\r\n  state: Option<BeaconState>\r\n}\r\n```\r\n\r\nand then, on the beacon chain you have some finite amount of these lanes:\r\n\r\n```rust\r\nBeaconChain {\r\n  ...\r\n  lanes: [RwLock<Lane>; LANE_COUNT]\r\n  ...\r\n}\r\n```\r\n\r\n### Processing a new block\r\n\r\nSay you get a new block (`block`) and you want to process it somewhere:\r\n\r\n1. Iterate through `chain.lanes` and take a `read` lock on each lane and check to see if `block.parent_root == lane.block_root`. If so, try and take a `write` lock on the lane. If the write lock fails or there is no suitable lane, go to \"there is no available lane\". If you got the write lock, continue to the next step.\r\n1. Use `lane.state` to verify the signature of `block`. This is to try and stop us from mutating `lane.state` with rouge blocks (DoS vector). If `block` is past the \"next\" epoch of `lane.state` we might have to do a state clone to perform this check without mutating.\r\n1. Start verifying `block`, mutating `lane.state`.\r\n1. If `block` is valid, update `lane.block_root` and you're done. If block was invalid and we mutated the state we need to destroy the lane, so set `lane.block_root` and `lane.state` to `None`.\r\n\r\n### There is no available lane\r\n\r\nYou have a `block`, but there's no available lane with `block.parent_root` in it.\r\n\r\n1. Iterate through the lanes and try and find one where `lane.block_root.is_none()` this is an empty lane where you'll have to BYO `state` from the DB. If you found an empty lane proceed from step 3 in \"processing a new block\". If there are no empty slots, continue.\r\n1. Now we need to drop an existing lane. First learn the `block_root` of the canonical head, we never drop this lane. Then, iterate through all lanes (except the head lane) starting from the lane with the lowest `state.slot`. If we can get a write lock on this lane, set `lane.block_root` and `lane.state` to `None` and proceed to \"processing a new block\" step 3.\r\n1. If we were unable to get a write lock on any of the lanes (they're all busy) then we need to go into some sort of waiting queue (TBC).\r\n\r\n## TODO\r\n\r\n- [ ] Figure out wait queue\r\n- [ ] Update with note that we can apply a chain of blocks to a queue, not just one.\r\n\r\n",
  "closed_by": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/850/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/850/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/586756422",
    "html_url": "https://github.com/sigp/lighthouse/issues/850#issuecomment-586756422",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/850",
    "id": 586756422,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4Njc1NjQyMg==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-02-16T21:30:46Z",
    "updated_at": "2020-02-16T21:30:46Z",
    "author_association": "MEMBER",
    "body": "Closing this because I have a better idea that's far less complicated. Will share at some point.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/586756422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
