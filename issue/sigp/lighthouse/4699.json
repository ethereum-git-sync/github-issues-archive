{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/4699",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/4699/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/4699/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/4699/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/4699",
  "id": 1880992838,
  "node_id": "I_kwDOCFeAzc5wHaxG",
  "number": 4699,
  "title": "Handle unknown head block during attestation publishing",
  "user": {
    "login": "michaelsproul",
    "id": 4452260,
    "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/michaelsproul",
    "html_url": "https://github.com/michaelsproul",
    "followers_url": "https://api.github.com/users/michaelsproul/followers",
    "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
    "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
    "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
    "repos_url": "https://api.github.com/users/michaelsproul/repos",
    "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
    "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 985647284,
      "node_id": "MDU6TGFiZWw5ODU2NDcyODQ=",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/enhancement",
      "name": "enhancement",
      "color": "a2eeef",
      "default": true,
      "description": "New feature or request"
    },
    {
      "id": 2336800343,
      "node_id": "MDU6TGFiZWwyMzM2ODAwMzQz",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/HTTP-API",
      "name": "HTTP-API",
      "color": "5A63A2",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2023-09-05T00:28:08Z",
  "updated_at": "2023-09-05T00:28:08Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nPresently if an attestation is POSTed to the beacon node for a head block that hasn't finished being imported, Lighthouse will log a nasty `ERRO`:\r\n\r\n> ERRO Failure verifying attestation for gossip, attestation_slot: XX, committee_index: XX, request_index: X, error: UnknownHeadBlock { beacon_block_root: 0xa98ce8635c5493907d6536905b46eb09db54f8465a82d95aae90650509884f4a }\r\n\r\nIt will also return a `400 BAD REQUEST` to the VC, which creates a knock-on effect. There's an old issue about this here #1971, which was closed because we started queueing attestations _from gossip_ in #635. We still don't have any queueing for attestations from the HTTP API, which is why this error occurs.\r\n\r\nIn practice, this will often be encountered by users running Vouch â€“ which broadcasts attestations to all nodes, regardless of whether they already know the head block.\r\n\r\n## Version\r\n\r\nLighthouse v4.4.1 and older\r\n\r\n## Present Behaviour\r\n\r\n- Lighthouse rejects any attestation received on the HTTP API that doesn't immediately pass gossip validation. This includes attestations for blocks that are in the process of being imported.\r\n\r\n## Expected Behaviour\r\n\r\n- Lighthouse queues attestations received on the HTTP API so that it can:\r\n  - Return a 200 OK to the caller, and\r\n  - Not log an error message\r\n\r\n## Steps to resolve\r\n\r\nIn terms of implementation I think we could use the reprocessing queue. The hard part is blocking the HTTP handler waiting for the attestation to be dequeued and processed. I had a go at implementing something similar for blocks in #4643, which wasn't merged because it ended up being poorly suited to the problem it was trying to solve. We could probably adapt that code, particularly the use of a channel to send back the completion message, and use it for attestations. We could even extend the existing attestation reprocessing logic with an optional channel that gets initialized (and waited on) only for HTTP attestations.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/4699/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/4699/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
