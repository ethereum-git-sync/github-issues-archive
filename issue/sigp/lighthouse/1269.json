{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/1269",
  "id": 638591335,
  "node_id": "MDU6SXNzdWU2Mzg1OTEzMzU=",
  "number": 1269,
  "title": "Encrypted comms between VC & GUI",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1232620456,
      "node_id": "MDU6TGFiZWwxMjMyNjIwNDU2",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/RFC",
      "name": "RFC",
      "color": "4aaa19",
      "default": false,
      "description": "Request for comment"
    },
    {
      "id": 2336800343,
      "node_id": "MDU6TGFiZWwyMzM2ODAwMzQz",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/HTTP-API",
      "name": "HTTP-API",
      "color": "5A63A2",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 10,
  "created_at": "2020-06-15T06:47:54Z",
  "updated_at": "2020-10-02T23:52:40Z",
  "closed_at": "2020-10-02T23:52:40Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nThis issue is an RFC regarding communications between the validator client and the upcoming GUI.\r\n\r\n**See https://github.com/sigp/lighthouse/issues/1269#issuecomment-649879855 for the latest proposal.**\r\n\r\n## Problem Statement\r\n\r\n\"The GUI\" (a single-page browser application) will connect to a validator client (VC) using a HTTP API hosted by the VC (e.g., hyper).\r\n\r\nThere are two desirable attributes about this communication channel:\r\n\r\n- The GUI knows that it is communicating with the correct VC.\r\n- The VC knows it is talking to an authorized GUI.\r\n- The comms are encrypted.\r\n\r\nWe're basically looking for attributes that are common across most web apps:\r\n\r\n- The client (GUI) knows that the server (VC) is legit, thanks to a public SSL\\TLS certificate.\r\n- The server (VC) knows the client (GUI) is legit thanks to some login system.\r\n- TLS encrypts the channel.\r\n\r\nHowever, our scenario is rather constrained. A public SSL cert is not really viable, we don't want users to have to purchase a certificate and install it on the VC. A login system is doable in Rust, but it seems a little overkill (we only *really* need one \"user\").\r\n\r\nWhat we're looking for is basically what Parity-Ethereum used for their now-deprecated UI.\r\n\r\n## Potential Solutions\r\n\r\nSo it's fairly easy to imagine some system that uses some asymmetric crypto to establish the identity of the VC, then Diffie-Hellman to encrypt the comms between them. We could then run that *on top of* HTTP (i.e., inside the HTTP message body), however that's (a) a pain in the ass and (b) going to be *even more* of a pain in the ass once you start to harden it against replay attacks, etc. Also, it feels like this problem should already be solved and we would be \"rolling our own crypto\" in a way.\r\n\r\nWhat would be great is to implement the auth/encryption on the *transport* layer, like TLS. We can very easily implement whatever we want in Rust, but I think browser support is going to be our biggest challenge.\r\n\r\nI suspect there's a pretty simple solution out there that I just haven't discovered yet.\r\n\r\nKeen to hear suggestions.",
  "closed_by": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/1269/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/644006240",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-644006240",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 644006240,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NDAwNjI0MA==",
    "user": {
      "login": "johnsBeharry",
      "id": 183140,
      "node_id": "MDQ6VXNlcjE4MzE0MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/183140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/johnsBeharry",
      "html_url": "https://github.com/johnsBeharry",
      "followers_url": "https://api.github.com/users/johnsBeharry/followers",
      "following_url": "https://api.github.com/users/johnsBeharry/following{/other_user}",
      "gists_url": "https://api.github.com/users/johnsBeharry/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/johnsBeharry/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/johnsBeharry/subscriptions",
      "organizations_url": "https://api.github.com/users/johnsBeharry/orgs",
      "repos_url": "https://api.github.com/users/johnsBeharry/repos",
      "events_url": "https://api.github.com/users/johnsBeharry/events{/privacy}",
      "received_events_url": "https://api.github.com/users/johnsBeharry/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-15T09:11:00Z",
    "updated_at": "2020-06-15T09:13:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "I would recommend using JSON web tokens which is a standard for frontend backend authentication and communication on the web.\r\n\r\nhttps://jwt.io/introduction/\r\n\r\nThe client could store a authentication token -- possibly also with some expiration.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/644006240/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648656823",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-648656823",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 648656823,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0ODY1NjgyMw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-24T07:49:27Z",
    "updated_at": "2020-06-26T00:18:52Z",
    "author_association": "MEMBER",
    "body": "**Note: this proposal has been replaced by https://github.com/sigp/lighthouse/issues/1269#issuecomment-649879855. Please refer to it instead.**\r\n\r\n---\r\n\r\nAlright, after some discussion with @AgeManning and @zedt3ster we have the first workable proposal.\r\n\r\n## Proposal (1)\r\n\r\n\r\n**Setup**: Assume we have some asymmetric signature scheme. The VC assigns itself a keypair according to this scheme and we call these keys `vc_pk` and `vc_sk`.\r\n\r\nThe proposal goes:\r\n\r\n- The API between the VC and GUI is HTTP/REST.\r\n- Any sensitive endpoints require a `Signature` HTTP header where;\r\n  - requests are signed using `vc_pk`.\r\n  - responses are signed using `vc_sk`.\r\n\r\n### Authentication\r\n\r\nThis proposal provides authentication such that;\r\n\r\n- The GUI knows it is talking to the correct VC.\r\n- The VC knows the GUI has been granted access to `vc_pk`.\r\n\r\nAs such, `vc_pk` becomes a very basic \"access token\" to the VC.\r\n\r\n### Encryption\r\n\r\nThis proposal does not provide any encryption. Instead, I propose we use transport level security, when required.\r\n\r\nUsers running the GUI and VC on the same machine can communicate via `localhost`, no encryption required.\r\n\r\nUsers running the GUI and VC on separate computers, across an untrusted network can use:\r\n\r\n- SSL/TLS (nginx + letsencrypt, etc)\r\n- If getting a domain is too hard/not applicable, then reverse-SSH can be used to encrypt the traffic.\r\n\r\n## Reasoning\r\n\r\n#### Why not JWT?\r\n\r\nI feel like the JWT really shines where you need to track users and sessions, that's where I've used them in the past. In our scenario, our authentication requirements are very simple: one access token to rule them all. As such, I think the `Signature` header is a simpler solution here.\r\n\r\n#### Why not encrypt the HTTP body and avoid relying on SSL or reverse-SSH?\r\n\r\nYou can't feasibly encrypt the HTTP headers, so even if you encrypt the body you're going to be leaking info via headers.\r\n\r\nEncrypting the body seems like a solution that is:\r\n\r\n- Incomplete on it's own.\r\n- Redundant when implemented properly (with some transport-level security).\r\n\r\n#### Why not have multiple access tokens for revocable access control?\r\n\r\nUsing the `vc_pk` is *super* simple and mean we don't need to store state to track users, sessions, etc.\r\n\r\nI think we really want to avoid complexity in the VC. Adding the state to store users, sessions, etc. is bad enough, but if we do that then we also need some interface to revoke/grant tokens. This is *more* complexity that I just really don't think we need.\r\n\r\n## Open questions\r\n\r\n1. Which signature scheme?\r\n1. Which signing algorithm?",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648656823/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648759550",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-648759550",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 648759550,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0ODc1OTU1MA==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-24T11:18:48Z",
    "updated_at": "2020-06-24T11:18:48Z",
    "author_association": "MEMBER",
    "body": "I think there is no need to sign with the public key, as it is public anyone would be able to sign with it. I'm assuming here that anyone can get access to `vc_pk`.\r\n\r\nWe could simply attach `vc_pk` as plain text (which is encrypted at the transport layer) to act as an ID token access / ID token to ensure that the VC is the intended receiver. That would mean we don't need to have an algorithm that allows for signing with the public key. The VC would then sign the response with `vc_sk`. \r\n\r\nThen we can use any of the public key signing algorithms already in use e.g.\r\n- SECP256k1 (should be faster for signing/verifying single signatures)\r\n- BLS12-381",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648759550/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648771635",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-648771635",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 648771635,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0ODc3MTYzNQ==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-24T11:47:40Z",
    "updated_at": "2020-06-24T11:47:40Z",
    "author_association": "MEMBER",
    "body": "# Proposal (2)\r\n\r\nUse ECIES + AES with ephemeral keys for each request. ECIES will be used to generate an ephemeral AES key which will encrypt one request and one response.\r\n\r\n\r\nThis would cover both the encryption and singing of messages.\r\nPrelude:\r\n- VC create a key pair (`vc_pk`, `vc_sk`) and share `vc_pk`\r\n\r\nRequest\r\n- GUI - make an ephemeral key for a request (`gui_pk`, `gui_sk`)\r\n- GUI - Using ECIES create an AES key `aes_sk = gui_sk * vc_pk`\r\n- GUI - AES Encrypt request: `enc_request` using `aes_sk`\r\n- GUI - Send (`gui_pk`, `enc_request`)\r\n- VC - computes `aes_sk = vc_sk * gui_pk`\r\n- VC - decodes and processes request (keep `aes_sk` for response)\r\n\r\nResponse\r\n- VC - AES Encode response `enc_response` using `aes_sk`\r\n- VC - Sends `enc_response` \r\n- GUI - decodes `enc_response` using `aes_sk`\r\n\r\nBoth parties may now drop `aes_sk`.\r\n\r\n## Authentication\r\n\r\nThis proposal provides authentication such that;\r\n- The GUI knows it is talking to the correct VC. Else they would not be able to decode the request nor send a valid response.\r\n- The VC knows the GUI has been granted access to `vc_pk`. Else they would not be able to encode a request.\r\n\r\n## Encryption\r\n\r\nAll messages are AES encrypted\r\n\r\n## ECIES\r\n\r\nAny elliptic curve can be used for this, but again likely one of the two we already use:\r\n- SECP256k1\r\n- BLS12-381\r\n\r\n## Benefits\r\n\r\n- We do not need to store state.\r\n- All messages are encrypted at the application layer.\r\n- Public key is secret to any one listening in.\r\n\r\n## Cons\r\n\r\n- Requires additional encryption (which may be unnecessary if we already do this at the application layer).\r\n- AES and ECIES are required (although we already use AES and ECIES is trivial).\r\n- Anyone with the public key could send requests. To revoke a malicious node would require generating and sharing a new public key.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/648771635/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649148948",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-649148948",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 649148948,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0OTE0ODk0OA==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-25T00:49:00Z",
    "updated_at": "2020-06-25T00:49:00Z",
    "author_association": "MEMBER",
    "body": "> I think there is no need to sign with the public key, as it is public anyone would be able to sign with it.\r\n\r\nThis is an excellent point.\r\n\r\n> I'm assuming here that anyone can get access to vc_pk.\r\n\r\nWeirdly, the `vc_pk` is still intended to be somewhat of a secret in this system. If you reveal your `vc_pk` then anyone (with HTTP access) can control your validator.\r\n\r\nWe should be very careful of calling it a \"public key\" in user-facing scenarios. Perhaps we should use something else, but it just seems so convenient to use the `vc_pk` as the access token.\r\n\r\n> Proposal (2)\r\n\r\nThis is a great scheme, but I'm still not convinced that we should be encrypting the HTTP body.\r\n\r\nIf we do encryption on the body we are, in a way, communicating that this message is safe to travel across a public network. However, since we can't feasibly encrypt the HTTP headers we're leaking information about that request, most notably the fact that we're talking to a validator client. I think that would make it unsafe to travel across a public network.\r\n\r\nSo, this is what lead me to state that encrypting the body is either insufficient on its own or redundant when combined with transport-layer security.\r\n\r\n> Public key is secret to any one listening in.\r\n\r\nThis is cool, but I think to prevent replay attacks we'd need to store state in the VC and ensure uniqueness.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649148948/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649176513",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-649176513",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 649176513,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0OTE3NjUxMw==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-25T02:30:06Z",
    "updated_at": "2020-06-25T02:30:06Z",
    "author_association": "MEMBER",
    "body": "> Weirdly, the vc_pk is still intended to be somewhat of a secret in this system. If you reveal your vc_pk then anyone (with HTTP access) can control your validator.\r\n\r\nSounds like SECP256k1 would do the trick then if you've got transport layer encryption.\r\n\r\n> So, this is what lead me to state that encrypting the body is either insufficient on its own or redundant when combined with transport-layer security.\r\n\r\nThat's a good point, is HTTP a must? I'm not sure what the alternatives would be but I would say proposal 2 would work best on a direct connection.\r\n\r\n> > Public key is secret to any one listening in.\r\n> \r\n> This is cool, but I think to prevent replay attacks we'd need to store state in the VC and ensure uniqueness.\r\n\r\nYou're right there would need to be some kind of persistent nonce system. It could be a random nonce that is stored in the VC and common between all users say u64 or u128 which would be extremely improbable that any two nodes would randomly select the same nonce (and if they do they could just send a new request).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649176513/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649877715",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-649877715",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 649877715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0OTg3NzcxNQ==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-26T00:09:48Z",
    "updated_at": "2020-06-26T00:09:48Z",
    "author_association": "MEMBER",
    "body": "> That's a good point, is HTTP a must? I'm not sure what the alternatives would be but I would say proposal 2 would work best on a direct connection.\r\n\r\nI would *love* to use a direct TLS connection, but unfortunately the client needs to be a browser. I think our options are:\r\n\r\n- HTTP REST\r\n- RPC\r\n  - via HTTP\r\n  - via Websocket\r\n\r\nJSON-RPC is tempting, but all the other APIs are REST so it seems consistent to follow that unfortunately.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649877715/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649879855",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-649879855",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 649879855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0OTg3OTg1NQ==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-26T00:17:59Z",
    "updated_at": "2020-06-26T00:50:51Z",
    "author_association": "MEMBER",
    "body": "With regard to @kirk-baird's [comment](https://github.com/sigp/lighthouse/issues/1269#issuecomment-648759550) about not needing to sign requests, I provide this updated proposal:\r\n\r\n## Proposal (1.1)\r\n\r\n**Setup**: The VC assigns itself a secp256k1 keypair and we call these keys `vc_pk` and `vc_sk`.\r\n\r\nThe proposal goes:\r\n\r\n- The API between the VC and GUI is HTTP/REST.\r\n- Any sensitive endpoints require a `Signature` HTTP header where;\r\n  - requests include an [`Authorization: Basic <vc_pk>`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) header.\r\n  - responses include a [`Signature <sig>`](https://tools.ietf.org/id/draft-cavage-http-signatures-01.html) header, where `sig` is a signature using `vc_sk` across the sha256 of the response headers + body.\r\n\r\n### Authentication\r\n\r\nThis proposal provides authentication such that;\r\n\r\n- The GUI (client) knows that the responses are from the VC (server).\r\n- The VC (server) knows the GUI (client) has been granted access via knowledge of `vc_pk`.\r\n\r\nAs such, `vc_pk` becomes a basic \"access token\" to the VC. As such, we should not present it to users as a \"public key\"; instead more like \"secret access token\".\r\n\r\n### Encryption\r\n\r\nThis proposal does not provide any encryption. Instead, I propose we use transport level security, when required.\r\n\r\nUsers running the GUI and VC on the same machine can communicate via `localhost`, no encryption required.\r\n\r\nUsers running the GUI and VC on separate computers, across an untrusted network can use:\r\n\r\n- SSL/TLS (nginx + letsencrypt, etc)\r\n- If getting a domain is too hard/not applicable, then reverse-SSH can be used to encrypt the traffic.\r\n\r\n### VC Key Generation\r\n\r\nAs mentioned above, the VC assigns itself a secp256k1 keypair. This keypair:\r\n\r\n- Should be stored on-disk (unencrypted) with the configuration files of the VC.\r\n- Generated randomly if it does not already exist.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/649879855/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/650838953",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-650838953",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 650838953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MDgzODk1Mw==",
    "user": {
      "login": "kirk-baird",
      "id": 27878213,
      "node_id": "MDQ6VXNlcjI3ODc4MjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/27878213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirk-baird",
      "html_url": "https://github.com/kirk-baird",
      "followers_url": "https://api.github.com/users/kirk-baird/followers",
      "following_url": "https://api.github.com/users/kirk-baird/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirk-baird/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirk-baird/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirk-baird/subscriptions",
      "organizations_url": "https://api.github.com/users/kirk-baird/orgs",
      "repos_url": "https://api.github.com/users/kirk-baird/repos",
      "events_url": "https://api.github.com/users/kirk-baird/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirk-baird/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-28T23:46:31Z",
    "updated_at": "2020-06-28T23:46:31Z",
    "author_association": "MEMBER",
    "body": "Proposal 1.1 looks good to me :)",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/650838953/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/703005023",
    "html_url": "https://github.com/sigp/lighthouse/issues/1269#issuecomment-703005023",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1269",
    "id": 703005023,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzAwNTAyMw==",
    "user": {
      "login": "paulhauner",
      "id": 6660660,
      "node_id": "MDQ6VXNlcjY2NjA2NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paulhauner",
      "html_url": "https://github.com/paulhauner",
      "followers_url": "https://api.github.com/users/paulhauner/followers",
      "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
      "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
      "organizations_url": "https://api.github.com/users/paulhauner/orgs",
      "repos_url": "https://api.github.com/users/paulhauner/repos",
      "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paulhauner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-02T23:52:40Z",
    "updated_at": "2020-10-02T23:52:40Z",
    "author_association": "MEMBER",
    "body": "Proposal 1.1 was implemented in #1657",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/703005023/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
