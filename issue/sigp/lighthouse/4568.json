{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/4568",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/4568",
  "id": 1837657548,
  "node_id": "I_kwDOCFeAzc5tiG3M",
  "number": 4568,
  "title": "Default `Content-Type` header to `application/json` if omitted",
  "user": {
    "login": "michaelsproul",
    "id": 4452260,
    "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/michaelsproul",
    "html_url": "https://github.com/michaelsproul",
    "followers_url": "https://api.github.com/users/michaelsproul/followers",
    "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
    "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
    "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
    "repos_url": "https://api.github.com/users/michaelsproul/repos",
    "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
    "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 985647284,
      "node_id": "MDU6TGFiZWw5ODU2NDcyODQ=",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/enhancement",
      "name": "enhancement",
      "color": "a2eeef",
      "default": true,
      "description": "New feature or request"
    },
    {
      "id": 2336800343,
      "node_id": "MDU6TGFiZWwyMzM2ODAwMzQz",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/HTTP-API",
      "name": "HTTP-API",
      "color": "5A63A2",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 4,
  "created_at": "2023-08-05T09:00:13Z",
  "updated_at": "2023-08-07T10:37:09Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nIt would make our HTTP API slightly more ergonomic to use via `curl` if it didn't error when the `Content-Type` header is omitted.\r\n\r\nThis seems to be acceptable according to the HTTP spec:\r\n\r\nhttps://stackoverflow.com/questions/15860742/is-content-type-mandatory-in-http-post-request\r\n\r\nI think using `application/json` as the default for most endpoints is OK, as that's usually what one is munging around on the CLI. If the user is sending binary they should be savvy enough to set the header (we could maybe log a warning if the error message doesn't already make it clear enough that Lighthouse attempted to parse JSON data).\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/4568/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1666481172",
    "html_url": "https://github.com/sigp/lighthouse/issues/4568#issuecomment-1666481172",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568",
    "id": 1666481172,
    "node_id": "IC_kwDOCFeAzc5jVHwU",
    "user": {
      "login": "eserilev",
      "id": 7217615,
      "node_id": "MDQ6VXNlcjcyMTc2MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eserilev",
      "html_url": "https://github.com/eserilev",
      "followers_url": "https://api.github.com/users/eserilev/followers",
      "following_url": "https://api.github.com/users/eserilev/following{/other_user}",
      "gists_url": "https://api.github.com/users/eserilev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eserilev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eserilev/subscriptions",
      "organizations_url": "https://api.github.com/users/eserilev/orgs",
      "repos_url": "https://api.github.com/users/eserilev/repos",
      "events_url": "https://api.github.com/users/eserilev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eserilev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-05T11:42:37Z",
    "updated_at": "2023-08-05T11:42:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd like to work on this",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1666481172/reactions",
      "total_count": 5,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667576564",
    "html_url": "https://github.com/sigp/lighthouse/issues/4568#issuecomment-1667576564",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568",
    "id": 1667576564,
    "node_id": "IC_kwDOCFeAzc5jZTL0",
    "user": {
      "login": "eserilev",
      "id": 7217615,
      "node_id": "MDQ6VXNlcjcyMTc2MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eserilev",
      "html_url": "https://github.com/eserilev",
      "followers_url": "https://api.github.com/users/eserilev/followers",
      "following_url": "https://api.github.com/users/eserilev/following{/other_user}",
      "gists_url": "https://api.github.com/users/eserilev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eserilev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eserilev/subscriptions",
      "organizations_url": "https://api.github.com/users/eserilev/orgs",
      "repos_url": "https://api.github.com/users/eserilev/repos",
      "events_url": "https://api.github.com/users/eserilev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eserilev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-07T10:09:44Z",
    "updated_at": "2023-08-07T10:36:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "EDIT\r\nI think a solution for this issue specifically is to go endpoint by endpoint and make sure we arent rejecting when content-type json isn't included\r\n\r\nWhen we include the filter `.and(warp::body::json())` the filter checks for Content-Type json in the header. If the header doesn't exist, it rejects the request. A small tweak to this filter will resolve this issue.\r\n\r\nI put together a big write up on what I had done so far down below, but I think I may have gone down a wrong path here. \r\n\r\n----\r\n\r\nI was under the impression that I'd be able to simply use some warp filter to append a Content-Type header if none existed. However this is not necessarily the case. Firstly, request headers in warp are immutable, so in order to append a new header, I would need to clone the existing headers, append a new header to the cloned list and then replace the existing request headers with the \"new\" headers.\r\n\r\nI tried doing something like this\r\n\r\n``` rust\r\nfn default_content_type(log: Logger)->  impl Filter<Extract = (HeaderMap,), Error = Infallible> + Copy {\r\n    warp::header::headers_cloned()\r\n        .map(|mut headers:HeaderMap| {\r\n            if headers.get(\"Content-Type\").is_none() {\r\n                headers.insert(\"Content-Type\", HeaderValue::from_static(\"application/json\"));\r\n                println!(\"{:?}\", headers);\r\n            }\r\n            headers\r\n        })\r\n}\r\n``` \r\n\r\nand then updating the route filters \r\n\r\n``` rust\r\n let routes = warp::get()\r\n        .and(default_content_type(log.clone))\r\n        .and( the GET route filters)\r\n        ...\r\n        ...\r\n         .uor(\r\n            warp::post().and(default_content_type(log.clone))\r\n            .and(the POST route filters)\r\n```\r\n\r\nhowever the return type of `default_content_type` doesn't play nice with some of the code downstream. Once we start getting into the `with` statements toward the end of the route filters I get the error message\r\n\r\n``` bash\r\nthe trait `Reply` is not implemented for `(HeaderMap, warp::generic::Either<(warp::http::Response<warp::hyper::Body>,), (impl Reply,)>)`\r\n```\r\n\r\nIf I update default_content_type to\r\n\r\n``` rust\r\nfn default_content_type(log: Logger)->  impl Filter<Extract = (), Error = Infallible> + Copy {\r\n    warp::header::headers_cloned()\r\n        .map(|mut headers:HeaderMap| {\r\n            if headers.get(\"Content-Type\").is_none() {\r\n                headers.insert(\"Content-Type\", HeaderValue::from_static(\"application/json\"));\r\n                println!(\"{:?}\", headers);\r\n            }\r\n        })\r\n}\r\n``` \r\n\r\nthings work fine, however the updated header doesn't actually get passed downstream, so this becomes a useless filter. I am beginning to think that warp filters weren't really built to update request headers like this. Theres another option here to completely rebuild the request from scratch and append the missing header, this sounds a lot like a proxy server.\r\n\r\nIf we were to implement some sort of proxy server, I dont think warp filters are the right tool for the job. There is a crate I came across called tower: https://docs.rs/tower/latest/tower/ that seems to be the right tool for this. It is compatible with warp and would allow us to easily build middleware/proxy server. We could use the proxy server to check for the existence of the Content-Type header, if it doesn't exist we can add the Content-Type header and then pass the request along to the beacon api. A proxy server might also offer some additional benefits as an intermediary layer between the external world and the beacon api. This is a relatively big change to the underlying beacon api infra, so the proxy server would probably need to provide more utility than just making curl requests easier for users. Otherwise it seems like a big change for such a small use case.\r\n\r\nI've spent a good amount of time on this. I could be completely missing the boat here, maybe my warp filter is just not set up correctly and a small code change could resolve this entirely. But this is the conclusion I came to based on the work I've done so far.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667576564/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667608045",
    "html_url": "https://github.com/sigp/lighthouse/issues/4568#issuecomment-1667608045",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568",
    "id": 1667608045,
    "node_id": "IC_kwDOCFeAzc5jZa3t",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-07T10:32:31Z",
    "updated_at": "2023-08-07T10:32:31Z",
    "author_association": "MEMBER",
    "body": "> There is potentially another option here to go endpoint by endpoint and alway make sure were defaulting to JSON even if the content-type header isnt included. I think most endpoints already do this?\r\n\r\nYeah I think this might be the most viable approach. First step would be identifying which endpoints don't work without a content-type provided",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667608045/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667614016",
    "html_url": "https://github.com/sigp/lighthouse/issues/4568#issuecomment-1667614016",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/4568",
    "id": 1667614016,
    "node_id": "IC_kwDOCFeAzc5jZcVA",
    "user": {
      "login": "eserilev",
      "id": 7217615,
      "node_id": "MDQ6VXNlcjcyMTc2MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eserilev",
      "html_url": "https://github.com/eserilev",
      "followers_url": "https://api.github.com/users/eserilev/followers",
      "following_url": "https://api.github.com/users/eserilev/following{/other_user}",
      "gists_url": "https://api.github.com/users/eserilev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eserilev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eserilev/subscriptions",
      "organizations_url": "https://api.github.com/users/eserilev/orgs",
      "repos_url": "https://api.github.com/users/eserilev/repos",
      "events_url": "https://api.github.com/users/eserilev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eserilev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2023-08-07T10:37:00Z",
    "updated_at": "2023-08-07T10:37:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Yeah I think this might be the most viable approach. First step would be identifying which endpoints don't work without a content-type provided\r\n\r\nadded some edits to my initial comments, I think I know what to do now\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/1667614016/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
