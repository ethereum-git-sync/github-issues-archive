{
  "url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
  "repository_url": "https://api.github.com/repos/sigp/lighthouse",
  "labels_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883/labels{/name}",
  "comments_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883/comments",
  "events_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883/events",
  "html_url": "https://github.com/sigp/lighthouse/issues/1883",
  "id": 740471436,
  "node_id": "MDU6SXNzdWU3NDA0NzE0MzY=",
  "number": 1883,
  "title": "Fallback eth1 node and beacon node",
  "user": {
    "login": "AgeManning",
    "id": 7454587,
    "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/AgeManning",
    "html_url": "https://github.com/AgeManning",
    "followers_url": "https://api.github.com/users/AgeManning/followers",
    "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
    "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
    "organizations_url": "https://api.github.com/users/AgeManning/orgs",
    "repos_url": "https://api.github.com/users/AgeManning/repos",
    "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
    "received_events_url": "https://api.github.com/users/AgeManning/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 985647284,
      "node_id": "MDU6TGFiZWw5ODU2NDcyODQ=",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/enhancement",
      "name": "enhancement",
      "color": "a2eeef",
      "default": true,
      "description": "New feature or request"
    },
    {
      "id": 2336803064,
      "node_id": "MDU6TGFiZWwyMzM2ODAzMDY0",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/infra-ci",
      "name": "infra-ci",
      "color": "7365BC",
      "default": false,
      "description": ""
    },
    {
      "id": 2490305065,
      "node_id": "MDU6TGFiZWwyNDkwMzA1MDY1",
      "url": "https://api.github.com/repos/sigp/lighthouse/labels/A1",
      "name": "A1",
      "color": "223184",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2020-11-11T05:22:12Z",
  "updated_at": "2020-12-24T00:44:44Z",
  "closed_at": "2020-12-24T00:44:44Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "It would be nice to add CLI flags for a fallback eth1 node and for the VC a fallback BN. \r\n\r\nThe logic would be that if the designated eth1 node doesn't work (i.e a local eth1 node) we attempt to connect to the fallback eth1 node. \r\n\r\nSimilarly for the VC have a backup BN if the http connection fails.\r\n",
  "closed_by": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/1883/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726150495",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-726150495",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 726150495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjE1MDQ5NQ==",
    "user": {
      "login": "blacktemplar",
      "id": 3133334,
      "node_id": "MDQ6VXNlcjMxMzMzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3133334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktemplar",
      "html_url": "https://github.com/blacktemplar",
      "followers_url": "https://api.github.com/users/blacktemplar/followers",
      "following_url": "https://api.github.com/users/blacktemplar/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktemplar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktemplar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktemplar/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktemplar/orgs",
      "repos_url": "https://api.github.com/users/blacktemplar/repos",
      "events_url": "https://api.github.com/users/blacktemplar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktemplar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-12T15:30:01Z",
    "updated_at": "2020-11-12T15:30:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "I am currently working on the fallback eth1 node and there are two approaches we could go with that:\r\n\r\nIn both situations we specify a list of eth1 endpoints (used in the specified order as fallback options).\r\n\r\n1. For all calls to the eth1 node if the call to the first endpoint fails try all the endpoints consecutively until one returns with success or all got tried.\r\n2. We use a dynamic eth1 endpoint, that is first initiated with the first endpoint of the list. When doing regular updates (`do_updates`) we try to access all eth1 endpoints (can be done in parallel) and check if their sync states differ and if they differ for multiple update calls we change the dynamic endpoint to the endpoint that is synced the furthest.\r\n\r\nThe first approach is clearly more \"live\" but could result in slower answers if some of the higher priority endpoints are all down for a longer time. Furthermore, the first approach cannot react on the situation if the first endpoint is online but stuck syncing or something like that.\r\n\r\nOn the other hand the second approach has a slower update function (needs to call all the endpoints) and reacts slower to an endpoint going offline. So in the end the question is how fast we want to switch to the fallback endpoint. I think for eth1 endpoints we have enough reaction time to do approach 2 since it shouldn't matter if the eth1 node is offline for a short time.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726150495/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726270877",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-726270877",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 726270877,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjI3MDg3Nw==",
    "user": {
      "login": "pawanjay176",
      "id": 9890508,
      "node_id": "MDQ6VXNlcjk4OTA1MDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9890508?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pawanjay176",
      "html_url": "https://github.com/pawanjay176",
      "followers_url": "https://api.github.com/users/pawanjay176/followers",
      "following_url": "https://api.github.com/users/pawanjay176/following{/other_user}",
      "gists_url": "https://api.github.com/users/pawanjay176/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pawanjay176/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pawanjay176/subscriptions",
      "organizations_url": "https://api.github.com/users/pawanjay176/orgs",
      "repos_url": "https://api.github.com/users/pawanjay176/repos",
      "events_url": "https://api.github.com/users/pawanjay176/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pawanjay176/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-12T18:52:40Z",
    "updated_at": "2020-11-12T18:52:40Z",
    "author_association": "MEMBER",
    "body": "> first endpoint is online but stuck syncing \r\n\r\nI don't think this is a concern since we immediately return `RemoteNotSynced` error if the eth1 node is not synced upto the `ETH1_FOLLOW_DISTANCE` . So we can instantly move to fallback node if the higher priority node falls out of sync.\r\n\r\nMy vote is for the first approach. It's much simpler imo and more in the lines of the other node(s) being a backup.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726270877/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726428050",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-726428050",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 726428050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjQyODA1MA==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-13T00:34:21Z",
    "updated_at": "2020-11-13T00:34:21Z",
    "author_association": "MEMBER",
    "body": "I agree with @pawanjay176 \r\n\r\nIt sounds like the simpler approach and we don't have to worry about potential race conditions if a backup node gets a block faster than the main node and appears \"more synced\". \r\n\r\nIt sounds like 1. is the simpler and easier solution to implement and intuitively will fit with what a user expects with like a CLI flag named something like `--fallback-eth1-endpoint`. ",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726428050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726573140",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-726573140",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 726573140,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjU3MzE0MA==",
    "user": {
      "login": "blacktemplar",
      "id": 3133334,
      "node_id": "MDQ6VXNlcjMxMzMzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3133334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktemplar",
      "html_url": "https://github.com/blacktemplar",
      "followers_url": "https://api.github.com/users/blacktemplar/followers",
      "following_url": "https://api.github.com/users/blacktemplar/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktemplar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktemplar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktemplar/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktemplar/orgs",
      "repos_url": "https://api.github.com/users/blacktemplar/repos",
      "events_url": "https://api.github.com/users/blacktemplar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktemplar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-13T07:27:13Z",
    "updated_at": "2020-11-13T07:27:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "ok then I will continue with variant 1. I am glad you said that since I basically did already implement it and then came up with variant 2 ;).",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/726573140/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730459027",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-730459027",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 730459027,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMDQ1OTAyNw==",
    "user": {
      "login": "blacktemplar",
      "id": 3133334,
      "node_id": "MDQ6VXNlcjMxMzMzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3133334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktemplar",
      "html_url": "https://github.com/blacktemplar",
      "followers_url": "https://api.github.com/users/blacktemplar/followers",
      "following_url": "https://api.github.com/users/blacktemplar/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktemplar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktemplar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktemplar/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktemplar/orgs",
      "repos_url": "https://api.github.com/users/blacktemplar/repos",
      "events_url": "https://api.github.com/users/blacktemplar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktemplar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-19T15:41:03Z",
    "updated_at": "2020-11-19T15:41:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > first endpoint is online but stuck syncing\r\n> \r\n> I don't think this is a concern since we immediately return `RemoteNotSynced` error if the eth1 node is not synced upto the `ETH1_FOLLOW_DISTANCE` . So we can instantly move to fallback node if the higher priority node falls out of sync.\r\n> \r\n> My vote is for the first approach. It's much simpler imo and more in the lines of the other node(s) being a backup.\r\n\r\nI am currently writing tests for my fallback implementation and I think we cannot detect a node that is stuck without comparing to another node or asserting some chain liveness. The only case when we return a `RemoteNotSynced` error is if a remote went backwards more than `ETH1_FOLLOW_DISTANCE`. So if a remote just stops reporting new blocks we will never detect that and the fallbacks will not be used in this case. The only option to detect that would be to periodically compare with the fallback nodes or by assuming a minimum block issuance rate of the eth1 chain.\r\n\r\nI think additionally to the current solution (basically variant 2 above but with a local cache needed to avoid checking network id and chain id before each single request) it would be quite easy to have some longer-term cache that stores which endpoints are not synced. This cache could then be updated (by comparing the heads of all given eth1 endpoints) in some longer interval like `ETH1_FOLLOW_DISTANCE` * `SECONDS_PER_ETH1_BLOCK` / 2. This should be enough and should not lead to a lot of unnecessary requests...",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730459027/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730714131",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-730714131",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 730714131,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMDcxNDEzMQ==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-20T00:05:15Z",
    "updated_at": "2020-11-20T00:05:15Z",
    "author_association": "MEMBER",
    "body": "Yeah this is a good point. \r\n\r\nWe probably do want to check against the nodes available to see which is the most up to sync. I don't want to over complicate anything, but I would be concerned with the case that one of the fallbacks is faulty (similar to the roughtime issue Prysm had). \r\n\r\nI would imagine a lot of users would set a central node (like Infura) as a fallback rather than running many local nodes. And in the case that a single central node is faulty (claims to have a very high block number) it would be bad that every lh node uses faulty eth1 data because their centralised fallback is faulty.\r\n\r\nDo you think we should be concerned about these kinds of edge cases? ",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730714131/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730882491",
    "html_url": "https://github.com/sigp/lighthouse/issues/1883#issuecomment-730882491",
    "issue_url": "https://api.github.com/repos/sigp/lighthouse/issues/1883",
    "id": 730882491,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMDg4MjQ5MQ==",
    "user": {
      "login": "blacktemplar",
      "id": 3133334,
      "node_id": "MDQ6VXNlcjMxMzMzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3133334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktemplar",
      "html_url": "https://github.com/blacktemplar",
      "followers_url": "https://api.github.com/users/blacktemplar/followers",
      "following_url": "https://api.github.com/users/blacktemplar/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktemplar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktemplar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktemplar/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktemplar/orgs",
      "repos_url": "https://api.github.com/users/blacktemplar/repos",
      "events_url": "https://api.github.com/users/blacktemplar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktemplar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-20T06:28:03Z",
    "updated_at": "2020-11-20T06:28:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "hmmm... thats a good point. Since we need to trust the system time anyways we could do this comparison only if the timestamp of the `latest` block of the first endpoint is in the past more than `ETH1_FOLLOW_DISTANCE * SECONDS_PER_ETH1_BLOCK / 2` or something like that. When this happens I would say the safest would be downloading the `latest` block from each endpoint and comparing `totalDifficulty` and the timestamp of the blocks. Having a faulty `latest` block seems to be impossible except for a malicious actor ... I will prepare a simple solution for that in the PR and then we can discuss details if that is needed.",
    "reactions": {
      "url": "https://api.github.com/repos/sigp/lighthouse/issues/comments/730882491/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
