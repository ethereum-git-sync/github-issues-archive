{
  "url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343",
  "repository_url": "https://api.github.com/repos/NethermindEth/nethermind",
  "labels_url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343/labels{/name}",
  "comments_url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343/comments",
  "events_url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343/events",
  "html_url": "https://github.com/NethermindEth/nethermind/issues/2343",
  "id": 712800491,
  "node_id": "MDU6SXNzdWU3MTI4MDA0OTE=",
  "number": 2343,
  "title": "Signing a message for Optimistic OmniBridge",
  "user": {
    "login": "varasev",
    "id": 33550681,
    "node_id": "MDQ6VXNlcjMzNTUwNjgx",
    "avatar_url": "https://avatars.githubusercontent.com/u/33550681?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/varasev",
    "html_url": "https://github.com/varasev",
    "followers_url": "https://api.github.com/users/varasev/followers",
    "following_url": "https://api.github.com/users/varasev/following{/other_user}",
    "gists_url": "https://api.github.com/users/varasev/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/varasev/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/varasev/subscriptions",
    "organizations_url": "https://api.github.com/users/varasev/orgs",
    "repos_url": "https://api.github.com/users/varasev/repos",
    "events_url": "https://api.github.com/users/varasev/events{/privacy}",
    "received_events_url": "https://api.github.com/users/varasev/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "LukaszRozmej",
    "id": 12445221,
    "node_id": "MDQ6VXNlcjEyNDQ1MjIx",
    "avatar_url": "https://avatars.githubusercontent.com/u/12445221?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/LukaszRozmej",
    "html_url": "https://github.com/LukaszRozmej",
    "followers_url": "https://api.github.com/users/LukaszRozmej/followers",
    "following_url": "https://api.github.com/users/LukaszRozmej/following{/other_user}",
    "gists_url": "https://api.github.com/users/LukaszRozmej/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/LukaszRozmej/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/LukaszRozmej/subscriptions",
    "organizations_url": "https://api.github.com/users/LukaszRozmej/orgs",
    "repos_url": "https://api.github.com/users/LukaszRozmej/repos",
    "events_url": "https://api.github.com/users/LukaszRozmej/events{/privacy}",
    "received_events_url": "https://api.github.com/users/LukaszRozmej/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "LukaszRozmej",
      "id": 12445221,
      "node_id": "MDQ6VXNlcjEyNDQ1MjIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/12445221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LukaszRozmej",
      "html_url": "https://github.com/LukaszRozmej",
      "followers_url": "https://api.github.com/users/LukaszRozmej/followers",
      "following_url": "https://api.github.com/users/LukaszRozmej/following{/other_user}",
      "gists_url": "https://api.github.com/users/LukaszRozmej/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LukaszRozmej/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LukaszRozmej/subscriptions",
      "organizations_url": "https://api.github.com/users/LukaszRozmej/orgs",
      "repos_url": "https://api.github.com/users/LukaszRozmej/repos",
      "events_url": "https://api.github.com/users/LukaszRozmej/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LukaszRozmej/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2020-10-01T12:33:50Z",
  "updated_at": "2020-10-11T15:58:53Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "The concept of the bridge is described here: https://ethresear.ch/t/optimistic-bridge-between-mainnet-and-a-pos-chain/7965 - please, read it first.\r\n\r\n## Introduction\r\n\r\nThe idea of the optimistic omnibridge is to let user withdraw their tokens from the Mainnet bridge contract if the user created a corresponding burning transaction on the xDai side, and challenge the withdraw if they actually didn't burn.\r\n\r\nWithdrawing on the Mainnet side consists of two steps:\r\n1. Claim withdrawal.\r\n2. Withdraw tokens.\r\n\r\nAfter the claim, there are 24 hours during which a user cannot withdraw their tokens. During that time, POSDAO validators check if the claim transaction on the Mainnet side has a corresponding burn transaction on the xDai side. If not, POSDAO validators send their `rejects` to the Mainnet contract. If there are `50%+1` rejects, the claim is rejected and the withdrawal cannot be done.\r\n\r\nThe Mainnet contract should know whether the `reject` sender is a POSDAO validator. For this purpose, the Mainnet contract should always have a Merkle Root of the current POSDAO validator set. When reject, the POSDAO validator sends their Merkle Path to prove that they are from the validator set.\r\n\r\nThe validator set on the POSDAO side is updated every staking epoch (week). The validator set in the Mainnet contract should be synced with the updated validator set on the xDai side.\r\n\r\nIt is assumed that the new validator set (namely its Merkle Root) will be transferred by someone to the Mainnet contract in a single transaction.\r\n\r\nA validator set has its expiration timestamp which equals the timestamp of epoch end. So, if a new staking epoch begins but nobody transfers the new validator set to Mainnet, the previous validator set on the Mainnet side expires, and users cannot withdraw their tokens after the expiration until the new validator set is sent to Mainnet.\r\n\r\n## Verifying the message on Mainnet\r\n\r\nThe message transferred to the Mainnet contract will have the following fields:\r\n\r\n- new_validator_set_merkle_root\r\n- validator_set_change_threshold\r\n- reject_threshold\r\n- expiration_timestamp\r\n\r\nThese fields will be joined together and hashed with keccak256 and the hash will be signed by `50%+1` of the current validators.\r\n\r\nSome user will take the message, signatures, and a list of remaining validators (which are not in those `50%+1` signatures), and transfer this data to the Mainnet contract.\r\n\r\nThe Mainnet contract will receive the transaction with that data, build the Merkle Root of the addresses from the signatures (joining them with the given list of remaining validators) and compare the calculated Merkle Root with the previously stored Merkle Root. If they match and the number of signatures >= the previously-stored `validator_set_change_threshold`, it means that the previous validators signed the message about the new validator set correctly. After the successful verification, the Mainnet contract approves the passed message and updates the Merkle Root, thresholds, and expiration timestamp in its storage.\r\n\r\n## Signing the message on xDai\r\n\r\nPOSDAO has a ValidatorSetAuRa contract which manages a validator set.\r\n\r\nOnce the validator set changes due to some action (new staking epoch starts or due to `reportMalicious` mechanism), the ValidatorSetAuRa contract emits the `InitiateChange` event using the `emitInitiateChange` function.\r\n\r\nCalling this function always means that the current validator set is about to be updated.\r\n\r\nThe `emitInitiateChange` function, in addition to emitting `InitiateChange` event, will also calculate and store (in the contract) a new message with its fields:\r\n- new_validator_set_merkle_root\r\n- validator_set_change_threshold\r\n- reject_threshold\r\n- expiration_timestamp\r\n\r\nThe message must then be signed by `50%+1` (or `2/3+1` if `twoThirdsMajorityTransition`) of the current validators until the `InitiateChange` block is finalized.\r\n\r\nTo guarantee that the message is signed simultaneously with `InitiateChange` block finalization, we need to follow the same AuRa logic as for calling the `finalizeChange` function, i.e. each validator must sign the message on their turn beginning from the `InitiateChange` block (including this block) until the `finalizeChange` block (excluding this block).\r\n\r\nFor storing the sign in the contract, there will be a `signChange` function in the ValidatorSetAuRa contract which will have `require(msg.sender == block.coinbase)` condition, so there will only be one sign allowed per block (the sign from block's author). The `signChange` will be called with zero gas price like `emitInitiateChange`.\r\n\r\nOnce `50%+1`th signature is received, the `signChange` function will emit an event with all message's data needed to be transferred by someone to Mainnet.\r\n\r\nAll this will guarantee that:\r\n- the message is not fully signed (and emitted) by the current validators before the new validator set finalization (because we shouldn't transfer the message about non-finalized validator set to Mainnet)\r\n- the message won't be signed if at least 50% of the current validators turn off their nodes between `InitiateChange` and `finalizeChange` blocks\r\n- the message will be signed and emitted before the old validators turn off their nodes right on the `finalizeChange` block (when the new validator set starts to work)\r\n\r\nI omitted here most of the technical details (and checks) not related to ValidatorSetAuRa's interaction with the Ethereum client. All the Ethereum client will need to do is to read certain getters from the ValidatorSetAuRa contract at the right moment, and send the `signChange` transaction when certain conditions.\r\n\r\nThere will be a public getter `ValidatorSetAuRa.getBridgeMessage(uint256 blockTimestamp) view returns(bytes32)` which will accept an optional `blockTimestamp` parameter and return 32 bytes of the keccak256 result, which will need to be signed by validator's private key.\r\n\r\nThe `blockTimestamp` param will expect a timestamp of the `InitiateChange` block being currently produced if the current validator is producing a block at which `emitInitiateChangeCallable` returns `true`. The `blockTimestamp` param will expect zero for other blocks after the `InitiateChange` block.\r\n\r\nThe function will return `bytes32(0)` if there is no message to sign at the current block.\r\n\r\nThe signing logic would be as follows:\r\n\r\nFirst, check `emitInitiateChangeCallable`: https://github.com/NethermindEth/nethermind/blob/c632039ff2b8997043b303e10ca2e325e0358d3c/src/Nethermind/Nethermind.Consensus.AuRa/Validators/ContractBasedValidator.Posdao.cs#L50\r\n\r\n`1.` If `emitInitChangeCallable == true`,\r\n\r\n`1.1.` call `getBridgeMessage(currentBlockTimestamp)`, where `currentBlockTimestamp` is a timestamp of the current block being produced. We need this timestamp to be passed to the function because the contract doesn't know the exact timestamp of the future (upcoming) block when we call `getBridgeMessage`. The block timestamp is needed for the correct `expiration_timestamp` calculation.\r\n\r\n`1.2.` sign getBridgeMessage's result using validator's private key and push the transaction `emitInitiateChange(bytes32 r, bytes32 s, uint8 v)` to the block (like [here](https://github.com/NethermindEth/nethermind/blob/c632039ff2b8997043b303e10ca2e325e0358d3c/src/Nethermind/Nethermind.Consensus.AuRa/Validators/ContractBasedValidator.Posdao.cs#L54)), where `r,s,v` is ECDSA values of the signature.\r\n\r\n`2.` If `emitInitChangeCallable == false`,\r\n\r\n`2.1.` call `getBridgeMessage(0)`:\r\n\r\n`2.1.1.` if that returned `bytes32(0)`, do nothing.\r\n\r\n`2.1.2.` if that returned non-zero result, sign it using validator's private key and push the transaction `signChange(0, bytes32 r, bytes32 s, uint8 v)` to the block, where `r,s,v` is ECDSA values of the signature.\r\n\r\nNotes:\r\n\r\n- When calling `getBridgeMessage` please pass there validator's address through the `from` field so that the getter in the contract could recognize the validator's address using `msg.sender`.\r\n\r\n- Please add somewhere in Nethermind's code a comment that [this logic](https://github.com/NethermindEth/nethermind/blob/c632039ff2b8997043b303e10ca2e325e0358d3c/src/Nethermind/Nethermind.Consensus.AuRa/Validators/ContractBasedValidator.Posdao.cs#L50) should go before any other transactions at the beginning of the block because other transactions (such as `reportMalicious`) can change a pending validator set in the contract which is predicted by the `ValidatorSetAuRa.getBridgeMessage` getter (see point 1.1 above) and used by the `emitInitiateChange` function.\r\n\r\n- The mentioned functions and getters haven't yet been implemented in the `ValidatorSetAuRa` contract. Currently, it's just an implementation plan.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/NethermindEth/nethermind/issues/2343/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
