{
  "url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
  "repository_url": "https://api.github.com/repos/vyperlang/vyper",
  "labels_url": "https://api.github.com/repos/vyperlang/vyper/issues/297/labels{/name}",
  "comments_url": "https://api.github.com/repos/vyperlang/vyper/issues/297/comments",
  "events_url": "https://api.github.com/repos/vyperlang/vyper/issues/297/events",
  "html_url": "https://github.com/vyperlang/vyper/issues/297",
  "id": 246488392,
  "node_id": "MDU6SXNzdWUyNDY0ODgzOTI=",
  "number": 297,
  "title": "What should the syntax for (i) ABI-formatted logs, and (ii) calls to external contracts be?",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 34,
  "created_at": "2017-07-29T00:52:13Z",
  "updated_at": "2018-01-19T00:54:58Z",
  "closed_at": "2018-01-18T18:55:01Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "For ABI-formatted logs, we'd need to have syntax for both event type declaration and making the actual logs. For event type declaration, one option is for the parser to expect a list of declarations between storage variable declarations and function declarations that look like this:\r\n\r\n```\r\nMyLog: __log__(arg_1: num, arg2: indexed(bytes32), arg3: timestamp, arg4: bytes <= 100)\r\n```\r\nFor the actual logging, I personally highly disagree with Solidity's syntax of making event logs and function calls syntactically the same; it goes against Viper's goals of making it hard to write misleading code.\r\n\r\nOne option is to copy Serpent syntax:\r\n\r\n```\r\nlog(type=MyLog, 5, sha3(\"cow\"), block.timestamp, \"moose\")\r\n```\r\n\r\nAnother is:\r\n\r\n```\r\nlog.MyLog(5, sha3(\"cow\"), block.timestamp, \"moose\")\r\n```\r\n\r\nFor external contract calls, we already have `raw_call`, but it would be good to have something ABI-formatted. We have the ABI formatting call in place already for self-calls, but to extend that to external calls we need a syntax for declaring external contract types.\r\n\r\nOne option is for the parser to expect another list of declarations, like:\r\n\r\n```\r\nclass Foo():\r\n    def bar(arg1: num, arg2: bytes32): pass\r\n    @constant\r\n    def baz(arg1: bytes <= 100, arg2: num256): pass\r\n```\r\n\r\nAnother is to just directly pass in JSON ABI:\r\n\r\n```\r\nFoo = extern([{\"constant\": false, \"type\": \"function\", \"name\": \"bar(int128,bytes32)\", \"outputs\": [], \"inputs\": [{\"type\": \"int128\", \"name\": \"arg1\"}, {\"type\": \"bytes32\", \"name\": \"arg2\"}]}, {\"constant\": true, \"type\": \"function\", \"name\": \"baz(bytes,uint256)\", \"outputs\": [], \"inputs\": [{\"type\": \"bytes\", \"name\": \"arg1\"}, {\"type\": \"uint256\", \"name\": \"arg2\"}]}])\r\n```\r\n\r\nThen, one could declare anything from then on as having type Foo (we'd require contract types to start with a capitalized letter).\r\n\r\nAny other ideas?",
  "closed_by": {
    "login": "DavidKnott",
    "id": 17552858,
    "node_id": "MDQ6VXNlcjE3NTUyODU4",
    "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/DavidKnott",
    "html_url": "https://github.com/DavidKnott",
    "followers_url": "https://api.github.com/users/DavidKnott/followers",
    "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
    "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
    "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
    "repos_url": "https://api.github.com/users/DavidKnott/repos",
    "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
    "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/297/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/vyperlang/vyper/issues/297/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/318831121",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-318831121",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 318831121,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODgzMTEyMQ==",
    "user": {
      "login": "yograterol",
      "id": 3322886,
      "node_id": "MDQ6VXNlcjMzMjI4ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3322886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yograterol",
      "html_url": "https://github.com/yograterol",
      "followers_url": "https://api.github.com/users/yograterol/followers",
      "following_url": "https://api.github.com/users/yograterol/following{/other_user}",
      "gists_url": "https://api.github.com/users/yograterol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yograterol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yograterol/subscriptions",
      "organizations_url": "https://api.github.com/users/yograterol/orgs",
      "repos_url": "https://api.github.com/users/yograterol/repos",
      "events_url": "https://api.github.com/users/yograterol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yograterol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-29T13:27:17Z",
    "updated_at": "2017-07-29T13:33:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "We could create a reservated variable, by example \"Logs\" into it variable we can set a dict with every Event for the smart contract, in one place.\r\n\r\n```python\r\nLogs = {\r\n    Log1: __log__(arg_1: num),\r\n    Log2: __log__(arg_1: num)\r\n}\r\n```\r\n\r\nAnd we call:\r\n\r\n```\r\nLogs.Log1(1)\r\n\r\n# or\r\n\r\nLogs[\"Log1\"](1)\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/318831121/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/318831868",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-318831868",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 318831868,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODgzMTg2OA==",
    "user": {
      "login": "yograterol",
      "id": 3322886,
      "node_id": "MDQ6VXNlcjMzMjI4ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3322886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yograterol",
      "html_url": "https://github.com/yograterol",
      "followers_url": "https://api.github.com/users/yograterol/followers",
      "following_url": "https://api.github.com/users/yograterol/following{/other_user}",
      "gists_url": "https://api.github.com/users/yograterol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yograterol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yograterol/subscriptions",
      "organizations_url": "https://api.github.com/users/yograterol/orgs",
      "repos_url": "https://api.github.com/users/yograterol/repos",
      "events_url": "https://api.github.com/users/yograterol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yograterol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-29T13:43:27Z",
    "updated_at": "2017-07-29T13:43:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "About of external contracts, I vote to ABI JSON directly.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/318831868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/319940182",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-319940182",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 319940182,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTk0MDE4Mg==",
    "user": {
      "login": "0xc1c4da",
      "id": 2714786,
      "node_id": "MDQ6VXNlcjI3MTQ3ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2714786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xc1c4da",
      "html_url": "https://github.com/0xc1c4da",
      "followers_url": "https://api.github.com/users/0xc1c4da/followers",
      "following_url": "https://api.github.com/users/0xc1c4da/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xc1c4da/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xc1c4da/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xc1c4da/subscriptions",
      "organizations_url": "https://api.github.com/users/0xc1c4da/orgs",
      "repos_url": "https://api.github.com/users/0xc1c4da/repos",
      "events_url": "https://api.github.com/users/0xc1c4da/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xc1c4da/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-03T11:13:35Z",
    "updated_at": "2017-08-03T11:13:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "Reading the pythonic ABI class definitions is just, well, it's a pleasure. Having that said - JSON ABI is probably preferred because of interoperability with other developer tools. Still thinking about logs ",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/319940182/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/320029126",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-320029126",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 320029126,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDAyOTEyNg==",
    "user": {
      "login": "yograterol",
      "id": 3322886,
      "node_id": "MDQ6VXNlcjMzMjI4ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3322886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yograterol",
      "html_url": "https://github.com/yograterol",
      "followers_url": "https://api.github.com/users/yograterol/followers",
      "following_url": "https://api.github.com/users/yograterol/following{/other_user}",
      "gists_url": "https://api.github.com/users/yograterol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yograterol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yograterol/subscriptions",
      "organizations_url": "https://api.github.com/users/yograterol/orgs",
      "repos_url": "https://api.github.com/users/yograterol/repos",
      "events_url": "https://api.github.com/users/yograterol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yograterol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-03T16:58:45Z",
    "updated_at": "2017-08-03T16:58:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jarradh You're right ABI Class is better to read, however JSON ABI as Dictionary could be readable too in Python - Viper.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/320029126/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/321380784",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-321380784",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 321380784,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTM4MDc4NA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-09T21:03:40Z",
    "updated_at": "2017-08-09T21:14:59Z",
    "author_association": "MEMBER",
    "body": "I was thinking about external contract calls, and let me know what you think about this:\r\n\r\nAssumptions\r\n1. contracts are addresses, once initialized on the chain\r\n2. you can get the address of a contract\r\n3. you want to use methods of a contract you are referencing as if you were that contract\r\n\r\nIt would work like this:\r\n1. There is a new type called `contract` which is just an `address` with additional properties\r\n2. When you initialize the contract, you specify the contract address, either explicitly or through an arg\r\n3. Part of the additional properties of a `contract` type is that you can call any method from that contract with your own arguments, but `msg.sender` and `msg.value` are the same\r\n4. Another additional property is that it type-checks during contract initialization to ensure the referenced contract has the methods that are called elsewhere in the contract, and are provided with the right types as args via the ABI (not sure if this is possible, but seems feasible to me). This ensures a user doesn't purposely create a contract that has a method which cannot work due to a method it is calling being specified incorrectly or otherwise not existing.\r\n\r\nAn example would look something like this:\r\n\r\nContract A (an owned item):\r\n```python\r\nowner: public(address)\r\n\r\ndef __init__():\r\n    self.owner = msg.sender\r\n\r\ndef transfer_ownership(new_owner: address):\r\n    assert msg.sender == self.owner\r\n    self.owner = new_owner\r\n```\r\n\r\nContract B (sale of an owned item):\r\n```python\r\nbuyer: address\r\nowner: address\r\nitem: contract\r\n\r\n@payable\r\ndef __init__(_item: contract):\r\n    self.item = _item\r\n    # Implicitly type checks all method calls to Contract A from Contract B \r\n    # at this point, e.g. ( \r\n    #      item.get_owner() -> address       [from self.__init__]\r\n    #      item.transfer_ownership(address)  [from self.accept]\r\n    # )\r\n    self.owner = self.item.get_owner()\r\n\r\n# Buyer notifies Seller of intent to buy through external means\r\n# (I wish there was like a messaging scheme to directly notify the owner)\r\n\r\n# Note: seller should verify what self.item points to before \r\n# accepting (or rejecting)\r\ndef accept():\r\n    assert msg.sender == self.owner\r\n    self.item.transfer_ownership(self.buyer)\r\n    selfdestruct(self.owner)\r\n\r\ndef reject():\r\n    assert msg.sender == self.owner\r\n    selfdestruct(self.buyer)\r\n```\r\n\r\nThen someone who wants to buy something \"owned\" can get the contract address for that owned item and provide it to the sale contract as owned item to sell. The point of this example is to demonstrate the process of using this new `contract` type, which I hope you agree is a simpler, more intuitive way. Let me know what you think, I am not totally familiar with all of the underlying concepts of how this might work, more of a top level view\r\n\r\n\r\nThis might work with inheritance too, perhaps with an `inherits` type that is like a `contract` but all the data from the parent contract is actually in the child contract, and the child contract needs to call the initialization method for the parent. After initialization, the child contract is allowed to call any methods of the parent contract and all the effects apply to the data of the child. Additionally, an `@override` decorator would override any method provided by the parent contract (as well as verify the parent contract has that method to begin with), but you could always re-call that method via `self.super.method()` (where `self.super` is the parent contract).",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/321380784/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/321382634",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-321382634",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 321382634,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTM4MjYzNA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-09T21:11:21Z",
    "updated_at": "2017-08-09T21:11:21Z",
    "author_association": "MEMBER",
    "body": "As far as logs, I am not sure why it needs to have it's own log class. Can it be easier to use and just infer the size (in bytes) needed to store the referenced type (assuming it is a base type that is being \"printed\" to the log)? Then you string them however you like e.g.:\r\n```python\r\nlog('MyLog:', 5, sha3(\"cow\"), block.timestamp, \"moose\")\r\n```\r\n\r\nIt seems overkill to me to create a new log type just for a few debug statements.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/321382634/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327602533",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327602533",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327602533,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzYwMjUzMw==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-06T20:24:21Z",
    "updated_at": "2017-09-07T03:36:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "Contract 1:\r\n\r\n    def foo(arg1: num) -> num:\r\n        return arg1\r\n\r\nContract 2:\r\n\r\n    class Foo():\r\n        def foo(arg1: num) -> num: pass\r\n\r\n    def bar(arg1: address, arg2: num) -> num:\r\n        return Foo(arg1).foo(arg2)\r\n\r\n@yograterol @fubuloubu I'm adding in the ability to call other contracts (without `raw_call`), I currently have the above working.   I'd love some feedback on the formatting. ",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327602533/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327668937",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327668937",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327668937,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY2ODkzNw==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T02:54:05Z",
    "updated_at": "2017-09-07T02:59:35Z",
    "author_association": "MEMBER",
    "body": "@DavidKnott are these 2 different options? (\"Inner code\", \"outer code\") I am totally not following what you are intending here. Maybe a more flushed out example would be clearer.\r\n\r\nI believe you are talking about adding inner (worker?) classes in contracts? In my suggestion above, I was thinking that each contract can only be one \"class\" and you can reference another contract as a class and create an instance of it inside your own contract. That sort of keeps things simpler when discussing contract \"inheritance\" because each \"class\" is it's own contract and you can follow the tree of references to understand it by just following the address references. This prevents having too much complexity for the user by allowing inner classes in contract code. Can you give a good use case where I would want an inner class in my contract?\r\n\r\nI also have no idea how `Foo()`, which is defined with no constructor args (as far as I can tell), is called via `Foo(arg1)` in your \"Outer code\" example. Am I missing something, or is there a missing part to your example?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327668937/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327671949",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327671949",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327671949,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY3MTk0OQ==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T03:14:50Z",
    "updated_at": "2017-09-07T03:14:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "@fubuloubu My mistake, I should've been clearer, I'm not talking about inner worker classes.  I'm talking about being able to call functions in other contracts without using `raw_call`.  In the example above I'm using `class Foo():` to declare the contract and then listing the functions I want to call, in this case the `foo` function (from inner code).\r\nTo reiterate `Foo(insert_contract_address_here)` creates a contract object that I can call functions that are listed within the above `class Foo():`\r\nDoes that make sense?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327671949/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327674457",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327674457",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327674457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY3NDQ1Nw==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T03:34:41Z",
    "updated_at": "2017-09-07T03:34:41Z",
    "author_association": "MEMBER",
    "body": "So, `class` is sort of a \"prototype\" for what methods you're looking to call from a contract that you are going to reference? Does that mean \"inner code\" is contract 1, and \"outer code\" is contract 2 in your example?\r\n\r\nFurther, `Foo(arg1: address)` creates a copy of contract 1 (referencing using the given address) inside contract 2, and then calls the method `.foo(arg2: num)` of `Foo`, which is now operating independantly of contract 1 and performs the method using the given data (e.g. returns `arg2`)\r\n\r\nThat's how I'm taking it. I think you need an example where the referenced class has internal (`global`) data it is making use of, so that we can talk about what data is being operated on in the class.\r\n\r\nI'm trying to think of how I would use a class in my \"owned item\" example above, as that is only showing how referencing might work (even though I mused very briefly on how class inheritance might work)",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327674457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327676833",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327676833",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327676833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY3NjgzMw==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T03:53:40Z",
    "updated_at": "2017-09-07T03:54:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, exactly `class` is creating an abstract version of contract 1.  But `class Foo():` doesn't copy contract 1, it stores the `method_id`, `inputs (with types)` and `outputs` (again with types).  This might be a better example:\r\n\r\n    def test_external_contract_calls():\r\n        contract_1 = \"\"\"\r\n    lucky: num\r\n\r\n    def __init__(_lucky: num):\r\n        self.lucky = _lucky\r\n\r\n    def foo() -> num:\r\n        return self.lucky\r\n        \"\"\"\r\n\r\n        lucky_number = 7\r\n        c = get_contract(contract_1, args=[lucky_number])\r\n\r\n        contract_2 = \"\"\"\r\n    class Foo():\r\n        def foo() -> num: pass\r\n\r\n\r\n    def bar(arg1: address) -> num:\r\n        return Foo(arg1).foo()\r\n        \"\"\"\r\n        c2 = get_contract(contract_2)\r\n        \r\n        assert c2.bar(c.address) == lucky_number\r\n        print('Successfully executed an external contract call')\r\n\r\nUsing your above example if you want to call contract 1 from contract 2 it'd be something like:\r\n`Item(insert_address_of_contract_1).transfer_ownership(self.buyer)`\r\nDown the road I'd like to add functionality so that you can do this:\r\n     `self.item = Item(insert_address_of_contract_1)`\r\n     `self.item.transfer_ownership(self.buyer)`",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327676833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327679566",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327679566",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327679566,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY3OTU2Ng==",
    "user": {
      "login": "yograterol",
      "id": 3322886,
      "node_id": "MDQ6VXNlcjMzMjI4ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3322886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yograterol",
      "html_url": "https://github.com/yograterol",
      "followers_url": "https://api.github.com/users/yograterol/followers",
      "following_url": "https://api.github.com/users/yograterol/following{/other_user}",
      "gists_url": "https://api.github.com/users/yograterol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yograterol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yograterol/subscriptions",
      "organizations_url": "https://api.github.com/users/yograterol/orgs",
      "repos_url": "https://api.github.com/users/yograterol/repos",
      "events_url": "https://api.github.com/users/yograterol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yograterol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:16:08Z",
    "updated_at": "2017-09-07T04:16:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "@DavidKnott I like the idea, but It is a bit confuse for me, because if I can use a `class` just to call an external contract why can't I use a `class` to define my main contract?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327679566/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327682775",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327682775",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327682775,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4Mjc3NQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:37:52Z",
    "updated_at": "2017-09-07T04:37:52Z",
    "author_association": "MEMBER",
    "body": "@DavidKnott, okay I think I follow now. I believe my only gripe is that the syntax is a bit awkward, and that you are duplicating some work there (whether that is justified is a different story). My intuition says that if you do a second analysis of types on the usage of that class, you can infer the type signature required without needing to show it explicitly. But if your method makes this feature easier to implement, then I think there's justification for doing it that way, type inferencing doesn't sound fun or scalable.\r\n\r\nSo, it would be a run-time check that the provided address contains the methods you provided underneath the `class` declaration, and those class methods are the only ones allowed to be used in the contract's methods. Is `Foo' then a global with type class and the given type signatures for methods? How about this syntax:\r\n\r\n```python\r\nitem: class {\r\n    foo() -> num, # No in args, returns num\r\n    bar(num), # 1 in arg, no return\r\n    baz(num) -> num # 1 in arg, returns num\r\n}\r\n\r\ndef __init__(_item: address):\r\n    self.item = _item # run-time check that _item contains 'foo()', 'bar()', and 'baz()'\r\n\r\ndef foo() -> num:\r\n    return self.item.foo()\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327682775/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327682800",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327682800",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327682800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4MjgwMA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:38:02Z",
    "updated_at": "2017-09-07T04:38:02Z",
    "author_association": "MEMBER",
    "body": "Additionally, I believe you would need to instantiate the 1st contract in the 2nd with the lucky number e.g. `Foo(arg1: address, arg2: num).foo() -> num` otherwise how would `Foo()` know what `lucky` was set to? `Foo()` is an instance of the contract at the specified address, and therefore shall not reference the value set in the original contract. Does that make sense?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327682800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327683361",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327683361",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327683361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4MzM2MQ==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:42:06Z",
    "updated_at": "2017-09-07T04:42:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "`Foo()` is not an instance but a gateway (used to form function calls) to contract 1.  `Foo()` only needs to know about the functions it's calling which is nice because if you only need to call one function in the `Foo()` contract you only need to declare one function in it.  Does that make sense?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327683361/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684427",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327684427",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327684427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4NDQyNw==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:49:34Z",
    "updated_at": "2017-09-07T04:49:34Z",
    "author_association": "MEMBER",
    "body": "I believe I understand, but that would be talking about referencing not classes. Basically, `Foo(address)` is telling you that you expect the contract referenced by the given address to contain certain methods, which you are allowed to call below the gateway. But, with your example, the values used are from the original contract (hence we are talking about referencing another contract, instead of reusing it with our own data like how a class typically works IMO) e.g. `Foo(address1).foo() == 7`",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684559",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327684559",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327684559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4NDU1OQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:50:29Z",
    "updated_at": "2017-09-07T04:50:29Z",
    "author_association": "MEMBER",
    "body": "The difference is definitely more semantic, can you use the keyword `ref`/`reference` instead of `class`?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684559/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684900",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327684900",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327684900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4NDkwMA==",
    "user": {
      "login": "yograterol",
      "id": 3322886,
      "node_id": "MDQ6VXNlcjMzMjI4ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3322886?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yograterol",
      "html_url": "https://github.com/yograterol",
      "followers_url": "https://api.github.com/users/yograterol/followers",
      "following_url": "https://api.github.com/users/yograterol/following{/other_user}",
      "gists_url": "https://api.github.com/users/yograterol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yograterol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yograterol/subscriptions",
      "organizations_url": "https://api.github.com/users/yograterol/orgs",
      "repos_url": "https://api.github.com/users/yograterol/repos",
      "events_url": "https://api.github.com/users/yograterol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yograterol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:52:48Z",
    "updated_at": "2017-09-07T04:52:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "or `external Foo():`",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684900/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684950",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327684950",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327684950,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4NDk1MA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T04:53:09Z",
    "updated_at": "2017-09-07T04:53:09Z",
    "author_association": "MEMBER",
    "body": ":+1: `external`",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327684950/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327686137",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327686137",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327686137,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY4NjEzNw==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T05:00:58Z",
    "updated_at": "2017-09-07T05:17:42Z",
    "author_association": "MEMBER",
    "body": "I think there should be a rule that these `external` contract assignmentss have to specified on contract creation (`__init__`) in order to avoid a scenario where a contract fails during a runtime assignment and therefore the contract is rendered unusable. To phrase differently, the contract needs to fail when trying to run `__init__` and not after it has been posted to the chain.\r\n\r\nThis makes sense actually since this type of parameter cannot have a default value logically",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327686137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327694190",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327694190",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327694190,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzY5NDE5MA==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T05:50:01Z",
    "updated_at": "2017-09-07T05:50:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "I like `external` but think that contract assignments should be able allowed anywhere.  A common pattern with smart contracts is having contracts that talk back and forth.  One way of getting this to work is by deploying `contract_1` and then `contract_2` and then calling a `setup(contract_2: address)` function in `contract_1`.  This wouldn't work if contract assignments are only allowed in `__init__`.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327694190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327829158",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327829158",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327829158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzgyOTE1OA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T15:08:33Z",
    "updated_at": "2017-09-07T15:08:33Z",
    "author_association": "MEMBER",
    "body": "Well, I guess I shouldn't be so limiting. Here is my scenario, if you can make it work then it has my :+1: :+1: \r\n\r\nI am using your method of contract referencing to add a reference to a contract that must contain a `foo()` method. However, I got the type signature wrong (detected during runtime?) and must re-deploy my contract in order to fix it.\r\n\r\nOn second thought, this means if you did appropriate testing you could probably avoid this scenario. I guess my worry is that there could be a situation that develops where you don't discover there is a problem until after the contract is in general use, and then that means you'd have to go through a more painful process to redeploy a new contract that people were already using. If it failed at init, then that wouldn't be possible. However, given the overall likelihood of that scenario should be pretty low (if you've done adequete testing), you've convinced me.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327829158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327830940",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327830940",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327830940,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzgzMDk0MA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T15:14:39Z",
    "updated_at": "2017-09-07T15:14:39Z",
    "author_association": "MEMBER",
    "body": "Hmm, I guess the other thing is if you haven't initialized the contract reference yet but then go to use a function from it that would be a runtime error that would have to be handled and communicated to the user so that they understand what the problem is. If you always set the reference during contract init (with the option of updating the reference after) then the only runtime error is if the referenced contract does not contain that method, which can be a runtime check when setting the reference so you can avoid never having a scenario where an active contract has a reference that doesn't implement the proper methods.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327830940/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327838754",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327838754",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327838754,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzgzODc1NA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T15:40:01Z",
    "updated_at": "2017-09-07T15:40:01Z",
    "author_association": "MEMBER",
    "body": "One more thought, if you don't require a contract reference be set at initialization then it is much easier to create mutual recursion between contracts because you can reference contracts that have been initialized after yours. Somewhat topical after we were talking about Viper's resistance to call stack attacks.\r\n\r\nIf you make references set on init a requirement, and then allow a reference to be updated after the fact, it is still possible to create mutual recursion but you would have to be much more deliberate to create that mutual recursion because the first contract would need to set it's side of the recursive reference to a bogus contract with the right signature before updating the reference after the 2nd contract is initialized.\r\n\r\nAlso should put in the assertions for setting a reference that the address cannot be the calling contract itself (avoiding single recursion).",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327838754/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327938176",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327938176",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327938176,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzkzODE3Ng==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T21:58:29Z",
    "updated_at": "2017-09-07T21:58:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'll think some more on where / how contract references should be initialized.  Definitely a good idea to make sure contracts cannot call themselves (right now my PR doesn't protect against that).\r\n\r\nI'm also sticking with `class` for now, although it's a bit misleading.  This is because Viper is currently using `ast` (a python module written in c) which only parses valid python.  I thought of doing something like `replace(external, class)` before `ast` is used but that seems a bit hacky.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327938176/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327945631",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-327945631",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 327945631,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzk0NTYzMQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-07T22:37:48Z",
    "updated_at": "2017-09-07T22:42:49Z",
    "author_association": "MEMBER",
    "body": "My original example wayyyy above has syntax that is also valid python and additionally it solves the duplicate work of specifying the desired type signatures manually. However, it requires a method to intrinsically scan the contract code during compilation to determine the proper method type signatures required of the referenced contract and add the proper assertions against that external contract's ABI. A more simplified example using that style:\r\n\r\n```python\r\nitem: contract\r\n\r\ndef __init__(_item: contract):\r\n    self.item = _item\r\n    # add run-time assertions that test contract at address _item\r\n    # contains methods 'foo(bool) -> num', ...\r\n    \r\n    # Perhaps this could be an additional constant method 'check_item() -> bool'\r\n    # so other functions can use it with no gas cost (assert check_item())\r\n\r\ndef change_item(_item: contract):\r\n    self.item = _item # same assertions added as __init__\r\n\r\ndef bar(flag: bool) -> num:\r\n    # assertions passed on the reference setter, \r\n    # so this method exists and returns the right type\r\n    return self.item.foo(flag)\r\n```\r\n\r\nDue to the work required to add that additional scanning step, I can see why this might take a little more time to implement, but I think it is ideal as a lot of errors can be detected during compilation, you can decouple the actions of setting the references from using them, and it becomes more obvious that a method failures because the type signature doesn't match what's required.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/327945631/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328185205",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-328185205",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 328185205,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODE4NTIwNQ==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-08T18:50:28Z",
    "updated_at": "2017-09-08T18:50:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "I definitely agree with having a `contract` data type as I think it'll make it easier to think about as opposed to having to call contracts with `Item(address)` every time. \r\n\r\nI'm a little confused about how the scanning would work in practice, as I'm pretty sure that checking if a contract has specific methods will increase gas costs (and we'll have to look into how to check if a contract has a specific method without calling it).  At this point I believe forcing a contract to have to already be deployed for it to work seems like more trouble then it's worth (I've been struggle to think of other ways to prevent double recursion).  \r\n\r\nMaybe it's just because I'm coming from Solidity where abstract contracts are used frequently but it seems to me that by only scanning a contract to get methods takes away some of the code clarity, because although declaring the external functions at the top is more verbose I like the idea of being able to look at the top of a contract and get an idea of all the external calls that are being made.\r\n\r\n    item: contract {\r\n        foo(bool) -> bool\r\n    }\r\n    def __init__(_item: contract):\r\n        self.item = _item\r\n\r\n    def change_item(_item: contract):\r\n        self.item = _item\r\n\r\nWhat do you think of this format, which uses the contract data type but also declares the methods that will be called at the top.\r\n        ",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328185205/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328198472",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-328198472",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 328198472,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODE5ODQ3Mg==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-08T19:53:28Z",
    "updated_at": "2017-09-08T19:54:11Z",
    "author_association": "MEMBER",
    "body": "Definitely much clearer that way, in my opinion.\r\n\r\nThe only difference between my suggestion (not specifying all the calls) and your proposal (specifying at the top) in practice is that the compiler would do the work of scanning and creating the external call list. You need that list during compilation to decide if the right types are provided to the external call in the code, I think you agree with me there. There is no extra gas cost for that scanning, it's only during the compilation stage to ensure types match up. Explicitly writing them at the top is a clear summary of what you're doing in the code below and also makes it easier for the compiler; but the cost is that the contract writer has to remember to keep that in sync with how they are using it as they're writing. Given the paradigm make it easier for the reader than the writer, I'm leaning towards your way now for clarity's sake.\r\n\r\nNow, the second part of my suggestion is performing that type-checking again during the assignment of the reference. This would be on chain, so there would be increased gas costs here. The point of this check would be to ensure you couldn't set a reference to a contract that couldn't fulfill the desired external calls elsewhere in the contract, basically changing the location of the failure from when the external call is made to when the reference is assigned so it is clear that the reference assignment cannot fulfill something else in the contract. That clarifies run-time errors IMO (assignment and external calls are in separate contexts). Additionally, this would prevent an attack where you had some reference set, and everything was working fine, and then the attacker came along and set the reference to some contract that doesn't have the right calls, preventing others from withdrawing funds or whatever while they had their way with it.\r\n\r\nLast, ensuring a contract must already be deployed to assign the first reference comes from mandating that the reference is set in `__init__()`. This is optional, but then you'd have unset references which would make contract calls fail until the reference is set anyways.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328198472/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328225593",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-328225593",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 328225593,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODIyNTU5Mw==",
    "user": {
      "login": "DavidKnott",
      "id": 17552858,
      "node_id": "MDQ6VXNlcjE3NTUyODU4",
      "avatar_url": "https://avatars.githubusercontent.com/u/17552858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DavidKnott",
      "html_url": "https://github.com/DavidKnott",
      "followers_url": "https://api.github.com/users/DavidKnott/followers",
      "following_url": "https://api.github.com/users/DavidKnott/following{/other_user}",
      "gists_url": "https://api.github.com/users/DavidKnott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DavidKnott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DavidKnott/subscriptions",
      "organizations_url": "https://api.github.com/users/DavidKnott/orgs",
      "repos_url": "https://api.github.com/users/DavidKnott/repos",
      "events_url": "https://api.github.com/users/DavidKnott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DavidKnott/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-08T22:10:42Z",
    "updated_at": "2017-09-08T22:10:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "Glad we agree on the first part.\r\n\r\nFor the second part of things I see the merits of moving the error up to instantiation but am not so sure about it in practice.  I think it needs to be evaluated further and the decision should be made depending how much it increases gas costs and how \"seeing\" another contracts function works (without calling it).\r\n\r\nFor the `__init__` functionality I'm leaning against it for now at least for the first implementation.  Though I'd like to discuss it again after we have something to play around with and test for vulnerabilities.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328225593/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328284841",
    "html_url": "https://github.com/vyperlang/vyper/issues/297#issuecomment-328284841",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/297",
    "id": 328284841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODI4NDg0MQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-09T15:39:33Z",
    "updated_at": "2017-09-09T15:40:01Z",
    "author_association": "MEMBER",
    "body": "Further thoughts. Having this contract type should allow more complex interactions such as lists and maps, as behind the hood the contract type should basically be an address type with extra properties. I was thinking of some use cases, which I'll summarize in the following example:\r\n\r\n```python\r\nfriends: contract {\r\n    receive_message(bytes <= 192)\r\n}[num]\r\nnum_friends: num\r\nmessages: (bytes <= 192)[num]\r\nnum_messages: num\r\n\r\ndef add_friend(_friend: contract):\r\n    self.friends[self.num_friends] = _friend\r\n    self.num_friends += 1\r\n\r\ndef send_message(friend_num: num, message: bytes <= 192):\r\n    self.friends[friend_num].receive_message(message)\r\n\r\ndef receive_message(_message: bytes <= 192):\r\n    self.messages[self.num_messages] = _message\r\n    self.num_messages += 1\r\n```\r\n\r\nIn this example, two (or more) instances of this contract can send each other messages. I could see trying to build out the add-friend functionality to build a secure messaging platform with key signing, etc. but for now I hope you see the point here. I don't think anything about what we've discussed precludes these extensions, although tests will be needed to tell this works of course.\r\n\r\nWhat do you think @DavidKnott?",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/328284841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
