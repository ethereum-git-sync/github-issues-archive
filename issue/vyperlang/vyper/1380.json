{
  "url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
  "repository_url": "https://api.github.com/repos/vyperlang/vyper",
  "labels_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380/labels{/name}",
  "comments_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380/comments",
  "events_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380/events",
  "html_url": "https://github.com/vyperlang/vyper/issues/1380",
  "id": 428621698,
  "node_id": "MDU6SXNzdWU0Mjg2MjE2OTg=",
  "number": 1380,
  "title": "Inefficient use of JUMPI statements",
  "user": {
    "login": "Pet3ris",
    "id": 224585,
    "node_id": "MDQ6VXNlcjIyNDU4NQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/224585?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Pet3ris",
    "html_url": "https://github.com/Pet3ris",
    "followers_url": "https://api.github.com/users/Pet3ris/followers",
    "following_url": "https://api.github.com/users/Pet3ris/following{/other_user}",
    "gists_url": "https://api.github.com/users/Pet3ris/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Pet3ris/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Pet3ris/subscriptions",
    "organizations_url": "https://api.github.com/users/Pet3ris/orgs",
    "repos_url": "https://api.github.com/users/Pet3ris/repos",
    "events_url": "https://api.github.com/users/Pet3ris/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Pet3ris/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 479554964,
      "node_id": "MDU6TGFiZWw0Nzk1NTQ5NjQ=",
      "url": "https://api.github.com/repos/vyperlang/vyper/labels/enhancement",
      "name": "enhancement",
      "color": "84b6eb",
      "default": true,
      "description": null
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-04-03T08:07:03Z",
  "updated_at": "2021-10-06T07:26:17Z",
  "closed_at": "2021-10-06T07:26:17Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "### Version Information\r\n\r\n* vyper Version (output of `vyper --version`): 0.1.0b9\r\n* OS: osx 10.14.3\r\n* Python Version: 3.7.2\r\n* Environment (output of `pip freeze`):\r\n\r\n### What's your issue about?\r\n\r\nWhile working on the following (very slightly) modified Uniswap contract:\r\n\r\n```python\r\n# @title Uniswap Exchange Interface V1\r\n# @notice Source code found at https://github.com/uniswap\r\n# @notice Use at your own risk\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ncontract Factory():\r\n    def getExchange(token_addr: address) -> address: constant\r\n\r\ncontract Exchange():\r\n    def getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei): constant\r\n    def ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256: modifying\r\n    def ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei): modifying\r\n\r\nTokenPurchase: event({buyer: indexed(address), eth_sold: indexed(uint256(wei)), tokens_bought: indexed(uint256)})\r\nEthPurchase: event({buyer: indexed(address), tokens_sold: indexed(uint256), eth_bought: indexed(uint256(wei))})\r\nAddLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nRemoveLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nname: public(bytes32)                             # Uniswap V1\r\nsymbol: public(bytes32)                           # UNI-V1\r\ndecimals: public(uint256)                         # 18\r\ntotalSupply: public(uint256)                      # total number of UNI in existence\r\nbalances: map(address, uint256)                   # UNI balance of an address\r\nallowances: map(address, map(address, uint256))   # UNI allowance of one address on another\r\ntoken: ERC20                                      # address of the ERC20 token traded on this contract\r\nfactory: Factory                                  # interface for the factory that created this contract\r\n\r\n# @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n#      using create_with_code_of(). It is called once by the factory during contract creation.\r\n@public\r\ndef setup(token_addr: address):\r\n    assert (self.factory == ZERO_ADDRESS and self.token == ZERO_ADDRESS) and token_addr != ZERO_ADDRESS\r\n    self.factory = Factory(msg.sender)\r\n    self.token = ERC20(token_addr)\r\n    self.name = 0x556e697377617020563100000000000000000000000000000000000000000000\r\n    self.symbol = 0x554e492d56310000000000000000000000000000000000000000000000000000\r\n    self.decimals = 18\r\n\r\n# @notice Deposit ETH and Tokens (self.token) at current ratio to mint UNI tokens.\r\n# @dev min_liquidity does nothing when total UNI supply is 0.\r\n# @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n# @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of UNI minted.\r\n@public\r\n@payable\r\ndef addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert deadline > block.timestamp and (max_tokens > 0 and msg.value > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    if total_liquidity > 0:\r\n        assert min_liquidity > 0\r\n        eth_reserve: uint256(wei) = self.balance - msg.value\r\n        token_reserve: uint256 = self.token.balanceOf(self)\r\n        token_amount: uint256 = msg.value * token_reserve / eth_reserve + 1\r\n        liquidity_minted: uint256 = msg.value * total_liquidity / eth_reserve\r\n        assert max_tokens >= token_amount and liquidity_minted >= min_liquidity\r\n        self.balances[msg.sender] += liquidity_minted\r\n        self.totalSupply = total_liquidity + liquidity_minted\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, liquidity_minted)\r\n        return liquidity_minted\r\n    else:\r\n        assert (self.factory != ZERO_ADDRESS and self.token != ZERO_ADDRESS) and msg.value >= 1000000000\r\n        assert self.factory.getExchange(self.token) == self\r\n        token_amount: uint256 = max_tokens\r\n        initial_liquidity: uint256 = as_unitless_number(self.balance)\r\n        self.totalSupply = initial_liquidity\r\n        self.balances[msg.sender] = initial_liquidity\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, initial_liquidity)\r\n        return initial_liquidity\r\n\r\n# @dev Burn UNI tokens to withdraw ETH and Tokens at current ratio.\r\n# @param amount Amount of UNI burned.\r\n# @param min_eth Minimum ETH withdrawn.\r\n# @param min_tokens Minimum Tokens withdrawn.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of ETH and Tokens withdrawn.\r\n@public\r\ndef removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -> (uint256(wei), uint256):\r\n    assert (amount > 0 and deadline > block.timestamp) and (min_eth > 0 and min_tokens > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    assert total_liquidity > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_amount: uint256(wei) = amount * self.balance / total_liquidity\r\n    token_amount: uint256 = amount * token_reserve / total_liquidity\r\n    assert eth_amount >= min_eth and token_amount >= min_tokens\r\n    self.balances[msg.sender] -= amount\r\n    self.totalSupply = total_liquidity - amount\r\n    send(msg.sender, eth_amount)\r\n    assert self.token.transfer(msg.sender, token_amount)\r\n    log.RemoveLiquidity(msg.sender, eth_amount, token_amount)\r\n    log.Transfer(msg.sender, ZERO_ADDRESS, amount)\r\n    return eth_amount, token_amount\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param input_amount Amount of ETH or Tokens being sold.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens bought.\r\n@private\r\n@constant\r\ndef getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    input_amount_with_fee: uint256 = input_amount * 997\r\n    numerator: uint256 = input_amount_with_fee * output_reserve\r\n    denominator: uint256 = (input_reserve * 1000) + input_amount_with_fee\r\n    return numerator / denominator\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param output_amount Amount of ETH or Tokens being bought.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens sold.\r\n@private\r\n@constant\r\ndef getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    numerator: uint256 = input_reserve * output_amount * 1000\r\n    denominator: uint256 = (output_reserve - output_amount) * 997\r\n    return numerator / denominator + 1\r\n\r\n@private\r\ndef ethToTokenInput(eth_sold: uint256(wei), min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (eth_sold > 0 and min_tokens > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_bought: uint256 = self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance - eth_sold), token_reserve)\r\n    assert tokens_bought >= min_tokens\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, eth_sold, tokens_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value).\r\n# @dev User cannot specify minimum output or deadline.\r\n@public\r\n@payable\r\ndef __default__():\r\n    self.ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value) and minimum output.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies exact input (msg.value) and minimum output\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef ethToTokenOutput(tokens_bought: uint256, max_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance - max_eth), token_reserve)\r\n    # Throws if eth_sold > max_eth\r\n    eth_refund: uint256(wei) = max_eth - as_wei_value(eth_sold, 'wei')\r\n    if eth_refund > 0:\r\n        send(buyer, eth_refund)\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, as_wei_value(eth_sold, 'wei'), tokens_bought)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenSwapOutput(tokens_bought: uint256, deadline: timestamp) -> uint256(wei):\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_sold > 0 and min_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth\r\n    send(recipient, wei_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return wei_bought\r\n\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthSwapInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp) -> uint256(wei):\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthTransferInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens >= tokens_sold\r\n    send(recipient, eth_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthSwapOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthTransferOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToTokenInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert (deadline >= block.timestamp and tokens_sold > 0) and (min_tokens_bought > 0 and min_eth_bought > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    tokens_bought: uint256 = Exchange(exchange_addr).ethToTokenTransferInput(min_tokens_bought, deadline, recipient, value=wei_bought)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n@private\r\ndef tokenToTokenOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth_sold > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    eth_bought: uint256(wei) = Exchange(exchange_addr).getEthToTokenOutputPrice(tokens_bought)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens_sold >= tokens_sold and max_eth_sold >= eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    eth_sold: uint256(wei) = Exchange(exchange_addr).ethToTokenTransferOutput(tokens_bought, deadline, recipient, value=eth_bought)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact input.\r\n# @param eth_sold Amount of ETH sold.\r\n# @return Amount of Tokens that can be bought with input ETH.\r\n@public\r\n@constant\r\ndef getEthToTokenInputPrice(eth_sold: uint256(wei)) -> uint256:\r\n    assert eth_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance), token_reserve)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact output.\r\n# @param tokens_bought Amount of Tokens bought.\r\n# @return Amount of ETH needed to buy output Tokens.\r\n@public\r\n@constant\r\ndef getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei):\r\n    assert tokens_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance), token_reserve)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact input.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @return Amount of ETH that can be bought with input Tokens.\r\n@public\r\n@constant\r\ndef getTokenToEthInputPrice(tokens_sold: uint256) -> uint256(wei):\r\n    assert tokens_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    return as_wei_value(eth_bought, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact output.\r\n# @param eth_bought Amount of output ETH.\r\n# @return Amount of Tokens needed to buy output ETH.\r\n@public\r\n@constant\r\ndef getTokenToEthOutputPrice(eth_bought: uint256(wei)) -> uint256:\r\n    assert eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n\r\n# @return Address of Token that is sold on this exchange.\r\n@public\r\n@constant\r\ndef tokenAddress() -> address:\r\n    return self.token\r\n\r\n# @return Address of factory that created this exchange.\r\n@public\r\n@constant\r\ndef factoryAddress() -> address(Factory):\r\n    return self.factory\r\n\r\n# ERC20 compatibility for exchange liquidity modified from\r\n# https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy\r\n@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256:\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self.balances[msg.sender] -= _value\r\n    self.balances[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]\r\n```\r\n\r\nThe compiled bytecode has a block at line 2116: `5b6000156109c057` which translates to\r\n\r\n```\r\nJUMPDEST\r\nPUSH1 0x00\r\nISZERO\r\nPUSH2 0x09c0\r\nJUMPI\r\n```\r\n\r\nIt seems like this should have been compiled as\r\n\r\n```\r\nJUMPDEST\r\nPUSH2 0x09c0\r\nJUMP\r\n```\r\n\r\nSaving gas costs of `Schedule(JUMPI - JUMP + PUSH1 + ISZERO)`.\r\n\r\nAnother benefit is less confusion to static analyzers.\r\n\r\n### How can it be fixed?\r\n\r\nI'm not aware of how the compiler is structured right now, but a post-fix would be to trace if the jump condition is fully known from variables in the block, reverting to `JUMP` (or nothing if the jump condition is false) and then dead-code-eliminating the relevant `PUSH/ISZERO` operations.\r\n",
  "closed_by": {
    "login": "charles-cooper",
    "id": 3867501,
    "node_id": "MDQ6VXNlcjM4Njc1MDE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3867501?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/charles-cooper",
    "html_url": "https://github.com/charles-cooper",
    "followers_url": "https://api.github.com/users/charles-cooper/followers",
    "following_url": "https://api.github.com/users/charles-cooper/following{/other_user}",
    "gists_url": "https://api.github.com/users/charles-cooper/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/charles-cooper/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/charles-cooper/subscriptions",
    "organizations_url": "https://api.github.com/users/charles-cooper/orgs",
    "repos_url": "https://api.github.com/users/charles-cooper/repos",
    "events_url": "https://api.github.com/users/charles-cooper/events{/privacy}",
    "received_events_url": "https://api.github.com/users/charles-cooper/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/1380/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479504010",
    "html_url": "https://github.com/vyperlang/vyper/issues/1380#issuecomment-479504010",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
    "id": 479504010,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTUwNDAxMA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-03T14:05:17Z",
    "updated_at": "2019-04-03T14:05:48Z",
    "author_association": "MEMBER",
    "body": "Sounds like a good candidate for an optimization check?\r\n\r\nSide note: `name` and `symbol` can be `string[N]` now (where `N` is the length of the string you want.)",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479504010/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479545002",
    "html_url": "https://github.com/vyperlang/vyper/issues/1380#issuecomment-479545002",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
    "id": 479545002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTU0NTAwMg==",
    "user": {
      "login": "Pet3ris",
      "id": 224585,
      "node_id": "MDQ6VXNlcjIyNDU4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224585?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Pet3ris",
      "html_url": "https://github.com/Pet3ris",
      "followers_url": "https://api.github.com/users/Pet3ris/followers",
      "following_url": "https://api.github.com/users/Pet3ris/following{/other_user}",
      "gists_url": "https://api.github.com/users/Pet3ris/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Pet3ris/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Pet3ris/subscriptions",
      "organizations_url": "https://api.github.com/users/Pet3ris/orgs",
      "repos_url": "https://api.github.com/users/Pet3ris/repos",
      "events_url": "https://api.github.com/users/Pet3ris/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Pet3ris/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-03T15:42:24Z",
    "updated_at": "2019-04-03T15:42:24Z",
    "author_association": "NONE",
    "body": "@fubuloubu - thank you for the tip :)!",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479545002/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479629717",
    "html_url": "https://github.com/vyperlang/vyper/issues/1380#issuecomment-479629717",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
    "id": 479629717,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTYyOTcxNw==",
    "user": {
      "login": "jacqueswww",
      "id": 6917456,
      "node_id": "MDQ6VXNlcjY5MTc0NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6917456?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jacqueswww",
      "html_url": "https://github.com/jacqueswww",
      "followers_url": "https://api.github.com/users/jacqueswww/followers",
      "following_url": "https://api.github.com/users/jacqueswww/following{/other_user}",
      "gists_url": "https://api.github.com/users/jacqueswww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jacqueswww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jacqueswww/subscriptions",
      "organizations_url": "https://api.github.com/users/jacqueswww/orgs",
      "repos_url": "https://api.github.com/users/jacqueswww/repos",
      "events_url": "https://api.github.com/users/jacqueswww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jacqueswww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-03T19:37:52Z",
    "updated_at": "2019-04-03T19:40:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Pet3ris yeah currently I added those as empty `['if', 0, body]` statements to make extra sure there is no we can run into another function. I guess I was being a bit paranoid, because there is always a `STOP` at the end of a function.\r\nThe simplest fix, as mentioned above would be to just use `goto` & `label` to wrap the private function.\r\n\r\nFor the above example - could you isolate it into a smaller example, so the person making the change can digest it easily? :)\r\n\r\nI can also recommend the `vyper -f ir` output to get a good understanding of how the function are created.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/479629717/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/483164353",
    "html_url": "https://github.com/vyperlang/vyper/issues/1380#issuecomment-483164353",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
    "id": 483164353,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MzE2NDM1Mw==",
    "user": {
      "login": "Pet3ris",
      "id": 224585,
      "node_id": "MDQ6VXNlcjIyNDU4NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224585?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Pet3ris",
      "html_url": "https://github.com/Pet3ris",
      "followers_url": "https://api.github.com/users/Pet3ris/followers",
      "following_url": "https://api.github.com/users/Pet3ris/following{/other_user}",
      "gists_url": "https://api.github.com/users/Pet3ris/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Pet3ris/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Pet3ris/subscriptions",
      "organizations_url": "https://api.github.com/users/Pet3ris/orgs",
      "repos_url": "https://api.github.com/users/Pet3ris/repos",
      "events_url": "https://api.github.com/users/Pet3ris/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Pet3ris/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-15T08:48:56Z",
    "updated_at": "2019-04-15T08:48:56Z",
    "author_association": "NONE",
    "body": "@jacqueswww - here is a simpler reproduction:\r\n\r\n```python\r\n@public\r\ndef __init__():\r\n    pass\r\n\r\n@private\r\n@constant\r\ndef g(b: uint256) -> uint256:\r\n    return b + 1\r\n\r\n@public\r\ndef f(a: uint256):\r\n    assert self.g(a) == 2\r\n```\r\n\r\nThe end of the first block has this pattern at the end:\r\n\r\n![image](https://user-images.githubusercontent.com/224585/56119243-a370f200-5f63-11e9-98b7-0b91ec7a1eac.png)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/483164353/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/935646119",
    "html_url": "https://github.com/vyperlang/vyper/issues/1380#issuecomment-935646119",
    "issue_url": "https://api.github.com/repos/vyperlang/vyper/issues/1380",
    "id": 935646119,
    "node_id": "IC_kwDOBGDvrM43xNOn",
    "user": {
      "login": "charles-cooper",
      "id": 3867501,
      "node_id": "MDQ6VXNlcjM4Njc1MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3867501?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/charles-cooper",
      "html_url": "https://github.com/charles-cooper",
      "followers_url": "https://api.github.com/users/charles-cooper/followers",
      "following_url": "https://api.github.com/users/charles-cooper/following{/other_user}",
      "gists_url": "https://api.github.com/users/charles-cooper/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/charles-cooper/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/charles-cooper/subscriptions",
      "organizations_url": "https://api.github.com/users/charles-cooper/orgs",
      "repos_url": "https://api.github.com/users/charles-cooper/repos",
      "events_url": "https://api.github.com/users/charles-cooper/events{/privacy}",
      "received_events_url": "https://api.github.com/users/charles-cooper/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-06T07:26:17Z",
    "updated_at": "2021-10-06T07:26:17Z",
    "author_association": "COLLABORATOR",
    "body": "I think this is no longer an issue as of v0.3. Please reopen if it is.",
    "reactions": {
      "url": "https://api.github.com/repos/vyperlang/vyper/issues/comments/935646119/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
