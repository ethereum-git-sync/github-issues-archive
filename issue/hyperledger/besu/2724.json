{
  "url": "https://api.github.com/repos/hyperledger/besu/issues/2724",
  "repository_url": "https://api.github.com/repos/hyperledger/besu",
  "labels_url": "https://api.github.com/repos/hyperledger/besu/issues/2724/labels{/name}",
  "comments_url": "https://api.github.com/repos/hyperledger/besu/issues/2724/comments",
  "events_url": "https://api.github.com/repos/hyperledger/besu/issues/2724/events",
  "html_url": "https://github.com/hyperledger/besu/issues/2724",
  "id": 989956570,
  "node_id": "MDU6SXNzdWU5ODk5NTY1NzA=",
  "number": 2724,
  "title": "Store the trie nodes of the previous 128 blocks",
  "user": {
    "login": "matkt",
    "id": 26581503,
    "node_id": "MDQ6VXNlcjI2NTgxNTAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/26581503?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/matkt",
    "html_url": "https://github.com/matkt",
    "followers_url": "https://api.github.com/users/matkt/followers",
    "following_url": "https://api.github.com/users/matkt/following{/other_user}",
    "gists_url": "https://api.github.com/users/matkt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/matkt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/matkt/subscriptions",
    "organizations_url": "https://api.github.com/users/matkt/orgs",
    "repos_url": "https://api.github.com/users/matkt/repos",
    "events_url": "https://api.github.com/users/matkt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/matkt/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "matkt",
    "id": 26581503,
    "node_id": "MDQ6VXNlcjI2NTgxNTAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/26581503?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/matkt",
    "html_url": "https://github.com/matkt",
    "followers_url": "https://api.github.com/users/matkt/followers",
    "following_url": "https://api.github.com/users/matkt/following{/other_user}",
    "gists_url": "https://api.github.com/users/matkt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/matkt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/matkt/subscriptions",
    "organizations_url": "https://api.github.com/users/matkt/orgs",
    "repos_url": "https://api.github.com/users/matkt/repos",
    "events_url": "https://api.github.com/users/matkt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/matkt/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "matkt",
      "id": 26581503,
      "node_id": "MDQ6VXNlcjI2NTgxNTAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/26581503?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/matkt",
      "html_url": "https://github.com/matkt",
      "followers_url": "https://api.github.com/users/matkt/followers",
      "following_url": "https://api.github.com/users/matkt/following{/other_user}",
      "gists_url": "https://api.github.com/users/matkt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/matkt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/matkt/subscriptions",
      "organizations_url": "https://api.github.com/users/matkt/orgs",
      "repos_url": "https://api.github.com/users/matkt/repos",
      "events_url": "https://api.github.com/users/matkt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/matkt/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2021-09-07T12:57:27Z",
  "updated_at": "2021-12-13T09:21:05Z",
  "closed_at": "2021-12-13T09:21:05Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "For snapsync it is necessary to store the trie nodes of the last 128 blocks. With Bonsai we do not keep them, so we have to add in database this information.\n\nThis can be handled by adding additional segments in the BonsaiWorldStateKeyValueStorage class\n\n```java\nsnapTrieBranchBucketStorage =\n            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_BRANCH_STORAGE_BUCKET_1);\n```\n\nwith each addition of a trie node we also add it in our temporary bucket by prefixing it by the stateroot hash\n\n```java\n\n private void writeTrieNode(\n          final Optional<BlockHeader> blockHeader, final BonsaiWorldStateKeyValueStorage.Updater stateUpdater, final Bytes location, final Bytes value) {\n    stateUpdater.getTrieBranchStorageTransaction().put(location.toArrayUnsafe(), value.toArrayUnsafe());\n    blockHeader.ifPresent(header -> stateUpdater.getSnapTrieBranchBucketStorageTransaction().put(Bytes.concatenate(header.getStateRoot(), location).toArrayUnsafe(), value.toArrayUnsafe()));\n }\n\n  private void writeStorageTrieNode(\n          final BonsaiWorldStateKeyValueStorage.Updater stateUpdater,\n      final Hash accountHash,\n      final Bytes location,\n      final Bytes32 nodeHash,\n      final Bytes value) {\n    stateUpdater.putAccountStorageTrieNode(accountHash, location, nodeHash, value);\n }\n\n @Override\n  public Optional<Bytes> getAccountStateTrieNode(final Optional<Hash> stateRoot, final Bytes location, final Bytes32 nodeHash) {\n    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n    } else {\n      return stateRoot.map(hash -> snapTrieBranchBucketStorage.get(Bytes.concatenate(hash, location).toArrayUnsafe())\n              .map(Bytes::wrap))\n              .orElseGet(() -> trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap));\n    }\n  }\n```\n\nso when we want to check the proof of a range with link to a specific stateroot we will use this bucket to have the right sorts nodes by passing the stateroot to the getAccountStateTrieNode method\n\n\nit is necessary to manage the clean of this bucket so that it has only the last 128 blocks. One solution would be to have two buckets. `If we use two tables and alternate which ones we insert into we don't need to track what block the trie nodes were in or wether they were in an orphan or not.\nwhen we switch buckets we empty out the old one.  Each bucket would keep some subset of nodes based on block number.  i.e. pick the bucket based on blocknum (int div) 256 (mod) 2 and when we are within 10 blocks or so empty out the other bucket. (proposed by Danno)`\n\n\n\n\n",
  "closed_by": {
    "login": "matkt",
    "id": 26581503,
    "node_id": "MDQ6VXNlcjI2NTgxNTAz",
    "avatar_url": "https://avatars.githubusercontent.com/u/26581503?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/matkt",
    "html_url": "https://github.com/matkt",
    "followers_url": "https://api.github.com/users/matkt/followers",
    "following_url": "https://api.github.com/users/matkt/following{/other_user}",
    "gists_url": "https://api.github.com/users/matkt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/matkt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/matkt/subscriptions",
    "organizations_url": "https://api.github.com/users/matkt/orgs",
    "repos_url": "https://api.github.com/users/matkt/repos",
    "events_url": "https://api.github.com/users/matkt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/matkt/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/hyperledger/besu/issues/2724/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/hyperledger/besu/issues/2724/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[

]
